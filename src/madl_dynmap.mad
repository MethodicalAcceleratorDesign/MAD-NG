--[=[
 o-----------------------------------------------------------------------------o
 |
 | Dynamic 6D maps
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: I. Shreyber, irina.tecker at cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o
  Acknowledgements:

  The physics implemented in this module is for the most part taken from the
  work of E. Forest through his two books and numerous articles and reports on
  the subject, and for some parts, from the translation of his Fortran code
  PTC/FPP. The rest of the physics is taken from various publications. The
  structure of the code, the choice of the integrators and the maps according
  to the configuration of the commands and the elements are my own.

  MAD-NG supports almost direct translation of equations into code that works
  for both, particles (orbit) tracking and optics (damap) tracking at the same
  time, including parametric damaps with knobs. This unique feature facilitates
  the translation of new physics from publications with explicit equations.
 o-----------------------------------------------------------------------------o
  Purpose:

  - Provide a catalog of dynamical 6D maps (i.e. track) with the following
    calling convention: dynmap(elm, map, len_weight), see the sympint module.
  - TODO: list the expected attributes for elm and map
 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- settings
local new_bend_thick = false -- true (take new maps, worst)

--[=[
Notes about directions and quantities:
  element direction   edir: affects curvatures    (edir = seq.dir).
  track direction (s) sdir: affects lengths       (sdir = cmd.dir).
  time direction  (t) tdir: affects angles & nrj  (tdir = edir x sdir).
  beam direction      bdir: affects strengths & V (bdir = edir x sdir x chg).
--]=]

--[=[
Notes about PTC variables vs MAD:
  DIR  : tracking direction        = sdir
  B    : relativistic beta0        = beta
  L    : thick weighted length     = lw*el
  YL   : kick  weighted length     = lw*el
  LD   : thick weighted arc length = lw*(eld or el)
  B0   : curvature = angle/LD      = eh
  BN(1): dip  normal strength      = k0
  AN(1): dip  skew   strength      = k0s
  BN(2): quad normal strength      = k1
  AN(2): quad skew   strength      = k1s
  BN(3): sext normal strength      = k2
  AN(3): sext skew   strength      = k2s
  etc...
--]=]

--[=[
Notes and questions:
  Is (1/beta+pt) in t eq. shouldn't be sqrt((1/beta+pt)^2 - 1/(beta*gamma)^2) ?
  is it a linear approximation?
--]=]

-- locals ---------------------------------------------------------------------o

local _C, vector, matrix, option                                 in MAD
local is_nil, is_number, is_damap                                in MAD.typeid
local minlen, minang, minstr, clight, qelect, pi, twopi, pi_2    in MAD.constant
local printf                                                     in MAD.utility
local pt2beta                                                    in MAD.gphys

local abs, sqrt, invsqrt, exp, log, sin, cos, tan, asin, acos,
      atan, atan2, hypot, sinh, cosh, sinc, sinhc, asinc         in MAD.gmath

local min, max in math
local assert = assert

local    pi_clight =    pi/clight
local twopi_clight = twopi/clight

-- field mutipoles ------------------------------------------------------------o

local function bxby (nmul, knl, ksl, x, y)
  local bx, by, byt = ksl[nmul], knl[nmul]

  for i=nmul-1,1,-1 do
    byt = by*x - bx*y + knl[i]
    bx  = by*y + bx*x + ksl[i]
    by  = byt
  end

  return bx, by
end

local function bxbyh (snm, bfx, bfy, x, y)
  local bx, by, k = 0, 0, 0

  for i = snm,1,-1 do
    local btx, bty = 0, 0

    for j = snm-i,1,-1 do
      k = k+1
      btx = (btx + bfx[k]) * y
      bty = (bty + bfy[k]) * y
    end

    k = k+1
    bx = (bx + btx + bfx[k]) * x
    by = (by + bty + bfy[k]) * x
  end

  local btx, bty = 0, 0
  for i = snm,1,-1 do
    k = k+1
    btx = (btx + bfx[k]) * y
    bty = (bty + bfy[k]) * y
  end
  
  bx = bx + (btx + bfx[k+1])
  by = by + (bty + bfy[k+1])

  return bx, by
end

M.bxby  = bxby
M.bxbyh = bxbyh

-- patches --------------------------------------------------------------------o

-- X-rotation

local function xrotation (elm, m, lw_, dphi_)  -- Rx(ax) [ROT_YZ]            -- checked
  local ax = dphi_ or m.ang
  if abs(ax) < minang then return end

  m.atdebug(elm, m, 'xrotation:0')

  local ax = ax*(lw_ or m.sdir)*m.edir
  local sa, ca, ta = sin(ax), cos(ax), tan(ax)
  local beta = m.beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local   pz = sqrt(1 + 2/beta*pt + pt^2 - px^2 - py^2)
    local  _pz = 1/pz
    local  ptt = 1 - ta*py*_pz
    local _ptt = y/ptt
    local _pzt = ta*_pz*_ptt

    -- eq. 127 in Forest06
    m[i].y  = _ptt/ca
    m[i].py = ca*py + sa*pz
    m[i].x  = x + _pzt*px
    m[i].t  = t - _pzt*(1/beta+pt)
  end

  m.atdebug(elm, m, 'xrotation:1')
end

M.xrotation = xrotation

-- Y-rotation

local function yrotation (elm, m, lw_, dthe_)  -- Ry(ay) [ROT_XZ]            -- checked
  local ay = dthe_ or m.ang
  if abs(ay) < minang then return end

  m.atdebug(elm, m, 'yrotation:0')

  local ay = -ay*(lw_ or m.sdir)*m.edir -- minus sign, eq. 127 is for clockwise yrotation
  local sa, ca, ta = sin(ay), cos(ay), tan(ay)
  local beta = m.beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local   pz = sqrt(1 + 2/beta*pt + pt^2 - px^2 - py^2)
    local  _pz = 1/pz
    local  ptt = 1 - ta*px*_pz
    local _ptt = x/ptt
    local _pzt = ta*_pz*_ptt

    -- eq. 127 in Forest06
    m[i].x  = _ptt/ca
    m[i].px = ca*px + sa*pz
    m[i].y  = y + _pzt*py
    m[i].t  = t - _pzt*(1/beta+pt)
  end

  m.atdebug(elm, m, 'yrotation:1')
end

M.yrotation = yrotation

-- S-rotation

local function srotation (elm, m, lw_, dpsi_)  -- Rz(az) [ROT_XY]            -- checked
  local az = dpsi_ or m.ang
  if abs(az) < minang then return end

  m.atdebug(elm, m, 'srotation:0')

  local az = az*(lw_ or m.sdir)*m.edir
  local sa, ca = sin(az), cos(az)

  for i=1,m.npar do
    local x, px, y, py in m[i]
    local nx  = ca*x  + sa*y
    local npx = ca*px + sa*py

    m[i].y    = ca*y  - sa*x
    m[i].py   = ca*py - sa*px
    m[i].x    = nx
    m[i].px   = npx
  end

  m.atdebug(elm, m, 'srotation:1')
end

M.srotation = srotation

M.tilt = \elm, m, lw_ -> srotation(elm, m, lw_*m.sdir, m.tlt) -- to get opposite angle of the exit when sdir = 1 compared to entry of sdir = -1

-- Translation

local function translate (elm, m, lw_, dx_, dy_, ds_) -- [TRANS]             -- unchecked
  local dx = dx_ or m.dx
  local dy = dy_ or m.dy
  local ds = ds_ or m.ds
  if abs(dx)+abs(dy)+abs(ds) < minlen then return end

  m.atdebug(elm, m, 'translate:0')

  local edir, sdir in m
  local lw = lw_ or sdir
  dx = dx*lw*edir
  dy = dy*lw*edir
  ds = ds*lw

  if abs(ds) < minlen then
    for i=1,m.npar do
      local x, y in m[i]
      m[i].x = x - dx
      m[i].y = y - dy
    end
  else -- ds is treated as a drift without correction for the time of flight
    local beta = m.beam.beta
    for i=1,m.npar do
      local x, px, y, py, t, pt, beam in m[i]
      local beta = beam and beam.beta or beta
      local l_pz = ds*invsqrt(1 + 2/beta*pt + pt^2 - px^2 - py^2)
      m[i].x = x + px*l_pz - dx
      m[i].y = y + py*l_pz - dy
      m[i].t = t - l_pz*(1/beta+pt)
    end
  end

  m.atdebug(elm, m, 'translate:1')
end

M.translate = translate

-- Changeref (generic patch, lw_>0: RT, lw_<0: TR)

function M.changeref (elm, m)                                                 -- unchecked
  local sdir, edir, dx, dy, ds, dthe, dphi, dpsi in m
  local trn = abs(dx  )+abs(dy  )+abs(ds  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return end

  m.atdebug(elm, m, 'changeref:0')

  -- forward : x1' = R*x1+T
  -- backward: x1  = R^-1*(x1'-T)

  -- rotate
  if rot and sdir > 0 then
    yrotation(elm, m,  1,  dthe)
    xrotation(elm, m,  1, -dphi)
    srotation(elm, m,  1,  dpsi)
  end

  -- translate
  if trn then -- translate does everything
    translate(elm, m, m.sdir, dx, dy, ds)
  end

  -- rotate
  if rot and sdir < 0 then
    srotation(elm, m, -1,  dpsi)
    xrotation(elm, m, -1, -dphi)
    yrotation(elm, m, -1,  dthe)
  end

  m.atdebug(elm, m, 'changeref:1')
end

-- Changedir (reverse mflow e-direction)

function M.changedir (elm, m)                                                 -- unchecked
  m.atdebug(elm, m, 'changedir:0')

  m.edir = -m.edir

  m.atdebug(elm, m, 'changedir:1')
end

-- Changenrj (change frame energy)

function M.changenrj (elm, m)                                                 -- unchecked
  local dnrj in m
  if dnrj == 0 then return end

  m.atdebug(elm, m, 'changenrj:0')

  local edir, sdir, beam in m
  local p0c, _b0 = beam.pc, 1/beam.beta
  beam.energy = beam.energy + dnrj*sdir*edir
  local a, beta = p0c/beam.pc, beam.beta

  for i=1,m.npar do
    -- scale momenta of particles attached to the reference beam only
    if not m[i].beam then
      local px, py, pt in m[i]
      local dp2 = a^2*(1 + (2*_b0)*pt + pt^2) -- new (1+dp)^2
      m[i].px = a*px
      m[i].py = a*py
      m[i].pt = sqrt(dp2 + 1/beta^2 - 1) - 1/beta
    end
  end

  m.atdebug(elm, m, 'changenrj:1')
end

-- misalignments --------------------------------------------------------------o

local _T  = vector(3) -- misalignment translation
local _R  = matrix(3) -- misalignment rotation
local _Tb = vector(3) -- misalignment translation at exit (Tbar)
local _Rb = matrix(3) -- misalignment rotation    at exit (Rbar)

local misalignent, misalignexi -- forward declaration

-- Misalign (lw_>0: entry, lw_<0: exit)

function M.misalign (elm, m, lw_)                                            -- unchecked
  if (lw_ or 1) >= 0
  then misalignent(elm, m,  1)
  else misalignexi(elm, m, -1)
  end
end

function misalignent (elm, m, lw)                                            -- unchecked
  m.atdebug(elm, m, 'misalignent:0')

  local sdir, edir, algn, ptcmodel in m
  local dthe, dphi, dpsi, dx, dy, ds, rot, trn in algn

  -- misalignment at entry and local/global frames
  -- forward : x1' = R*x1+T
  -- backward: x1  = R^-1*(x1'-T)

  -- rotate
  if rot and sdir > 0 then -- MADX survey does Ry(theta) o Rx(-phi) o Rz(psi) (X)
    if not ptcmodel then
      yrotation(elm, m,  1,  dthe)
      xrotation(elm, m,  1, -dphi)
      srotation(elm, m,  1,  dpsi)
    else
      xrotation(elm, m,  1, -dphi)
      yrotation(elm, m,  1,  dthe)
      srotation(elm, m,  1,  dpsi)
    end
  end

  -- translate
  if trn then
    if rot then -- rotate T
      _T:fill{edir*dx, edir*dy, ds}
      if not ptcmodel
      then _R:rotzxy(-edir*dphi, edir*dthe, edir*dpsi, true):mul(_T, _T)
      else _R:rotzyx(-edir*dphi, edir*dthe, edir*dpsi, true):mul(_T, _T)
      end
      translate(elm, m, sdir, edir*_T[1], edir*_T[2], _T[3])
    else
      translate(elm, m, sdir, dx, dy, ds)
    end
  end

  -- rotate
  if rot and sdir < 0 then
    srotation(elm, m, -1,  dpsi)
    xrotation(elm, m, -1, -dphi)
    yrotation(elm, m, -1,  dthe)
  end

  m.atdebug(elm, m, 'misalignent:1')
end

function misalignexi (elm, m, lw)                                            -- unchecked
  m.atdebug(elm, m, 'misalignexi:0')

  local el, eld, mang, tlt, sdir, edir, algn, ptcmodel in m
  local dthe, dphi, dpsi, dx, dy, ds, rot, trn in algn

  -- translation
  if trn
  then _T:fill{edir*dx, edir*dy, ds}
  else _T:zeros()
  end

  -- rotation
  if rot then
    if not ptcmodel
    then _R:rotzxy(-edir*dphi, edir*dthe, edir*dpsi)
    else _R:rotzyx(-edir*dphi, edir*dthe, edir*dpsi)
    end
  end

  -- compute Rbar, Tbar
  _C.mad_mat_rtbar(_Rb._dat, _Tb._dat, abs(eld or el), edir*mang, edir*tlt, rot and _R._dat or nil, _T._dat)

  -- misalignment at exit and local/global frames
  -- forward : x2  = Rb^-1*(x2'-Tb)
  -- backward: x2' = Rb*x2+Tb

  -- rotate
  if rot and sdir > 0 then
    if not ptcmodel then
      local ax, ay, az = _Rb:torotzxy()
      srotation(elm, m, -edir, az)
      xrotation(elm, m, -edir, ax)
      yrotation(elm, m, -edir, ay)
    else
      local ax, ay, az = _Rb:torotzyx(true)
      xrotation(elm, m,  edir, ax)
      yrotation(elm, m,  edir, ay)
      srotation(elm, m,  edir, az)
    end
  end

  -- translate
  translate(elm, m, -sdir, edir*_Tb[1], edir*_Tb[2], _Tb[3])

  -- rotate
  if rot and sdir < 0 then
    local ax, ay, az = _Rb:torotzxy()
    yrotation(elm, m, edir, ay)
    xrotation(elm, m, edir, ax)
    srotation(elm, m, edir, az)
  end

  m.atdebug(elm, m, 'misalignexi:1')
end

-- [INTER_STREX, INTER_TEAPOT, H3 adjustment] ---------------------------------o

local function drift_adj (elm, m, l) -- [KICKPATH] drift adjustment          -- checked
  m.atdebug(elm, m, 'drift_adj:0')

  local beta = m.beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local l_pz = l*invsqrt(1 + 2/beta*pt + pt^2 - px^2 - py^2)

    m[i].x = x + px*(l_pz-l)
    m[i].y = y + py*(l_pz-l)
    m[i].t = t - (1/beta+pt)*l_pz + (1-m.T)/beta*l
  end

  m.atdebug(elm, m, 'drift_adj:1')
end

-- DKD [INTER_STREX] ----------------------------------------------------------o

local is_tpsa in MAD.typeid

function M.strex_drift (elm, m, lw, istp) -- [DRIFT]                         -- checked
  if abs(m.el*lw) < minlen then return end

  m.atdebug(elm, m, 'strex_drift:0')

  local el, eld in m
  local l, ld = el*lw, (eld or el)*lw
  local beta = m.beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local l_pz = l*invsqrt(1 + 2/beta*pt + pt^2 - px^2 - py^2)

    m[i].x = x + px*l_pz
    m[i].y = y + py*l_pz
    m[i].t = t - (1/beta+pt)*l_pz + (1-m.T)/beta*ld
  end

  m.atdebug(elm, m, 'strex_drift:1')
end

function M.strex_kick (elm, m, lw, istp, no_k0l) -- [KICKEX]                 -- checked
  if m.nmul == 0 then return end

  m.atdebug(elm, m, 'strex_kick:0')

  local edir, nmul, knl, ksl, beam in m
  local wchg = lw*edir*beam.charge
  local dby  = no_k0l == true and knl[1] or 0

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local  wchg = beam and lw*edir*beam.charge or wchg
    local bx,by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px - wchg*(by-dby)
    m[i].py = py + wchg* bx
  end

  m.atdebug(elm, m, 'strex_kick:1')
end

local function strex_kicks(elm, m, lw, i, wchg, beta, pz)
  local ksi, lrad in m
  if ksi == 0 or lrad == 0 then return end

  local x, px, y, py, pt in m[i]

  local  hss = lw*ksi^2/lrad -- 4 H(s_0)^2/ds
  local _dpp = 1/pz
  local _dp  = _dpp^2
  local  ang = (wchg*0.5*ksi)*_dpp
  local ca, sa = cos(ang), sin(ang)

  local nx  = ca* x + sa* y
  local npx = ca*px + sa*py
  local ny  = ca* y - sa* x
  local npy = ca*py - sa*px
  local nt  = m[i].t - ang*(1/beta+pt)*(y*px - x*py)*_dp

  m[i].x  = nx
  m[i].px = npx - (0.25 *hss)*nx*_dpp
  m[i].y  = ny
  m[i].py = npy - (0.25 *hss)*ny*_dpp
  m[i].t  = nt  - (0.125*hss)*(1/beta+pt)*(nx^2+ny^2)*_dpp^3
end


function M.strex_kickhs (elm, m, lw, istp) -- [KICKT]                        -- checked
  local lrad, nmul, ksi in m
  if nmul == 0 and ksi == 0 then return end

  m.atdebug(elm, m, 'strex_kickhs:0')

  local sdir, edir, knl, ksl, beam in m
  local wchg = lw*edir*beam.charge -- lw is always 1 for multipole only (Needed?)
  local beta = beam.beta

  for i=1,m.npar do
    local x, y, t, pt, beam in m[i]
    local wchg = beam and lw*edir*beam.charge or wchg
    local beta = beam and beam.beta or beta
    local   pz = sqrt(1 + 2/beta*pt + pt^2)

    if sdir == -1 then strex_kicks(elm, m, lw, i, wchg, beta, pz) end

    -- multipole
    if nmul > 0 then
      local bx,by = bxby(nmul, knl, ksl, x, y)

      m[i].px = m[i].px - wchg*by -- With 0 el and ksi ~= 0, we get problems with the multipole
      m[i].py = m[i].py + wchg*bx

      if abs(knl[1]) + abs(ksl[1]) > 0 then
        m[i].px = m[i].px + (wchg*knl[1])*pz
        m[i].py = m[i].py - (wchg*ksl[1])*pz
        m[i].t  = m[i].t  - wchg*(knl[1]*x - ksl[1]*y)*(1/beta+pt)/pz

        -- field curvature
        if lrad ~= 0 then
          m[i].px = m[i].px - lw*(knl[1]^2/lrad)*x
          m[i].py = m[i].py - lw*(ksl[1]^2/lrad)*y
        end
      end
    end

    if sdir == 1 then strex_kicks(elm, m, lw, i, wchg, beta, pz) end

  end

  m.atdebug(elm, m, 'strex_kickhs:1')
end

-- DKD [INTER_TEAPOT] ---------------------------------------------------------o

function M.curex_drift (elm, m, lw, istp) -- [SPROT]                         -- checked
  m.atdebug(elm, m, 'curex_drift:0')

  local el, eh, edir in m
  local ld, ang, rho = el*lw, eh*el*lw*edir, 1/eh*edir -- R=rho, A=ang
  local ca, sa, sa2 = cos(ang), sin(ang), sin(ang/2)
  local beta = m.beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local   pz = sqrt(1 + 2/beta*pt + pt^2 - px^2 - py^2)
    local  _pz = 1/pz
    local  pxt = px*_pz
    local _ptt = 1/(ca - sa*pxt)
    local  pst = (x+rho)*sa*_pz*_ptt

    m[i].x  = (x + rho*(2*sa2^2 + sa*pxt))*_ptt
    m[i].px = ca*px + sa*pz
    m[i].y  = y + pst*py
    m[i].t  = t - pst*(1/beta+pt) + (1-m.T)/beta*ld
  end

  m.atdebug(elm, m, 'curex_drift:1')
end

function M.curex_kick (elm, m, lw, istp, no_k0l) -- [SKICK]                  -- checked
  m.atdebug(elm, m, 'curex_kick:0')

  local el, eh, edir, snm, knl, bfx, bfy, beam in m
  local bdir = lw*edir*beam.charge
  local bx, by = 0, knl[1] -- i.e. nmul == 1 and ksl[1] == 0

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local bdir = beam and lw*edir*beam.charge or bdir
    local r = 1+eh*x*edir

    if snm > 0 then bx, by = bxbyh(snm, bfx, bfy, x, y) end

    m[i].px = px - bdir*by*r
    m[i].py = py + bdir*bx*r
    if no_k0l == true then
      m[i].px = m[i].px + (bdir*knl[1])*r
    end
  end

  m.atdebug(elm, m, 'curex_kick:1')
end

-- TKT [INTER_TEAPOT] ---------------------------------------------------------o

-- version for k0*charge == 0 to avoid NaN

local function curex_drift0 (elm, m, lw, i, ld, ca, sa, sa2, rho)
  m.atdebug(elm, m, 'curex_drift0:0')

  local x, px, y, py, t, pt in m[i]
  local beta = (m[i].beam or m.beam).beta
  local   pz = sqrt(1 + 2/beta*pt + pt^2 - px^2 - py^2)
  local  _pz = 1/pz
  local  pxt = px*_pz
  local  ptt = ca - sa*pxt
  local _ptt = 1/ptt
  local  pst = (x+rho)*sa*_pz*_ptt

  m[i].x  = (x + rho*(2*sa2^2 + sa*pxt))*_ptt
  m[i].px = ca*px + sa*pz
  m[i].y  = y + pst*py
  m[i].t  = t - pst*(1/beta+pt) + (1-m.T)/beta*ld

  m.atdebug(elm, m, 'curex_drift0:1')
end

local function sbend_thick_new (elm, m, lw, istp) -- [SSEC]                  -- checked
  m.atdebug(elm, m, 'sbend_thick:0')

  local el, eh, edir, knl, beam in m
  local ld, ang, rho, k0 = el*lw, eh*el*lw*edir, 1/eh*edir, knl[1]/el*edir
  local beta, k0q = beam.beta, k0*beam.charge
  local ca, sa, sa2, s2a = cos(ang), sin(ang), sin(ang/2), sin(2*ang)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local  k0q = beam and k0*beam.charge or k0q

    if k0q == 0 then
      curex_drift0 (elm, m, lw, i, ld, ca, sa, sa2, rho)
      goto continue
    end

    local  pw2 = 1 + 2/beta*pt + pt^2 - py^2
    local   pz = sqrt(pw2 - px^2)                                       -- PZ
    local   xr = x+rho
    local  pzx = pz - k0q*xr
    local  npx = sa*pzx + ca*px                                         -- XN(2)
    local  dpx = ca*pzx - sa*px                                         -- DPX'
    local  pzs = sqrt(pw2 - npx^2)                                      -- PZS
    local _ptt = invsqrt(pw2)                                           -- 1/PT

    local  xt1 = -k0q*x^2 + 2*(pz*xr - (k0q*rho)*x) - k0q*rho^2
    local   xi =  px*_ptt
    local zeta = npx*_ptt
    local  sxi = sqrt(1-xi^2)
    local    w = (ca*xi + sa*sxi) * sqrt(1-zeta^2)
    local    v = (sa*xi - ca*sxi) * zeta
    local  xt2 = (s2a*px + sa^2*(2*pz - k0q*xr)) * xr*_ptt^2 / (w - v)
    local  dxs = asinc(xt2*k0q)*xt2

    -- Error arises from 1/(w-v) -> ["040000"] = ~1e10 then reduces to ~1e-2
    -- leading to an error of ~1e-8

    -- eq. 126 in Forest06 with modif. from Sagan
    m[i].x  = xt1/(dpx+pzs) - rho                                       -- XN(1)
    m[i].px = npx                                                       -- XN(2)
    m[i].y  = y + dxs*py                                                -- XN(3)
    m[i].t  = t - dxs*(1/beta+pt) + (1-m.T)/beta*ld                     -- XN(6)

    ::continue::
  end

  m.atdebug(elm, m, 'sbend_thick:1')
end

local function sbend_thick_old (elm, m, lw, istp) -- [SSEC]                  -- checked
  m.atdebug(elm, m, 'sbend_thick:0')
  
  local el, eh, edir, knl, beam in m
  local ld, ang, rho, k0 = el*lw, eh*el*lw*edir, 1/eh*edir, knl[1]/el*edir
  local beta, k0q = beam.beta, k0*beam.charge
  local ca, sa, sa2 = cos(ang), sin(ang), sin(ang/2)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local  k0q = beam and k0*beam.charge or k0q

    if k0q == 0 then
      curex_drift0 (elm, m, lw, i, ld, ca, sa, sa2, rho)
      goto continue
    end

    local  pw2 = 1 + 2/beta*pt + pt^2 - py^2
    local   pz = sqrt(pw2 - px^2)                                       -- PZ
    local  pzx = pz - k0q*(rho+x)      -- could be numerically unstable
    local  npx = sa*pzx + ca*px                                         -- XN(2)
    local  dpx = ca*pzx - sa*px                                         -- DPX'
    local  pzs = sqrt(pw2 - npx^2)                                      -- PZS
    local _ptt = invsqrt(pw2)                                           -- PT
    local  dxs = (ang + asin(px*_ptt) - asin(npx*_ptt))/k0q             -- XN(3)

    -- eq. 126 in Forest06
    m[i].x  = (pzs - dpx)/k0q - rho    -- could be numerically unstable -- XN(1)
    m[i].px = npx                                                       -- XN(2)
    m[i].y  = y + dxs*py                                                -- XN(3)
    m[i].t  = t - dxs*(1/beta+pt) + (1-m.T)/beta*ld                     -- XN(6)

    ::continue::
  end

  m.atdebug(elm, m, 'sbend_thick:1')
end

M.sbend_thick = new_bend_thick and sbend_thick_new or sbend_thick_old
M.sbend_kick  = \el,m,lw,istp -> M.curex_kick(el,m,lw,istp,true) ;           -- checked

-- TKT [INTER_STREX] ----------------------------------------------------------o

-- version for k0*charge == 0 to avoid NaN

local function strex_drift0 (elm, m, lw, i, l, ld)                           -- checked
  m.atdebug(elm, m, 'strex_drift0:0')

  local x, px, y, py, t, pt in m[i]
  local beta = (m[i].beam or m.beam).beta
  local l_pz = l*invsqrt(1 + 2/beta*pt + pt^2 - px^2 - py^2)

  m[i].x = x + px*l_pz
  m[i].y = y + py*l_pz
  m[i].t = t - (1/beta+pt)*l_pz + (1-m.T)/beta*ld

  m.atdebug(elm, m, 'strex_drift0:1')
end

local function rbend_thick_new (elm, m, lw, istp) -- [SPAR]                  -- checked
  m.atdebug(elm, m, 'rbend_thick:0')

  local el, eld, edir, knl, beam in m
  local l, ld, k0 = el*lw, (eld or el)*lw, knl[1]/el*edir
  local beta, k0q, k0lq = beam.beta, k0*beam.charge, knl[1]*lw*beam.charge*edir

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local k0q  = beam and k0*beam.charge or k0q

    if k0q == 0 then
      strex_drift0 (elm, m, lw, i, l, ld)
      goto continue
    end

    local k0lq = beam and knl[1]*lw*beam.charge*edir or k0lq
    local  npx = px - k0lq
    local  pw2 = 1 + 2/beta*pt + pt^2 - py^2
    local _ptt = invsqrt(pw2)
    local   pz = sqrt(pw2 - px^2)
    local  pzs = sqrt(pw2 - npx^2)
    local   xi =  px*_ptt
    local zeta = npx*_ptt
    local  xtd = xi*sqrt(1-zeta^2) + zeta*sqrt(1-xi^2)
    local   xt = l*(2*px - k0lq)*_ptt^2 / xtd
    local  dxs = asinc(xt*k0q)*xt

    -- eq. 129 in Forest06 with modif. from Sagan
    m[i].x  = x + l*(2*px - k0lq) / (pz+pzs)
    m[i].px = npx
    m[i].y  = y + dxs*py
    m[i].t  = t - dxs*(1/beta+pt) + (1-m.T)/beta*ld

    ::continue::
  end

  m.atdebug(elm, m, 'rbend_thick:1')
end

local function rbend_thick_old (elm, m, lw, istp) -- [SPAR]                  -- checked
  m.atdebug(elm, m, 'rbend_thick:0')

  local el, eld, edir, knl, beam in m
  local l, ld, k0 = el*lw, (eld or el)*lw, knl[1]/el*edir
  local beta, k0q, k0lq = beam.beta, k0*beam.charge, knl[1]*lw*beam.charge*edir

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local k0q  = beam and k0*beam.charge or k0q

    if k0q == 0 then
      strex_drift0 (elm, m, lw, i, l, ld)
      goto continue
    end

    local k0lq = beam and knl[1]*lw*beam.charge*edir or k0lq
    local  npx = px - k0lq
    local  pw2 = 1 + 2*pt/beta + pt^2 - py^2
    local _ptt = invsqrt(pw2)
    local   pz = sqrt(pw2 - px^2)
    local  pzs = sqrt(pw2 - npx^2)
    local  dxs = (asin(px*_ptt) - asin(npx*_ptt))/k0q

    -- eq. 129 in Forest06
    m[i].x  = x + (pzs-pz)/k0q
    m[i].px = npx
    m[i].y  = y + dxs*py
    m[i].t  = t - dxs*(1/beta+pt) + (1-m.T)/beta*ld

    ::continue::
  end

  m.atdebug(elm, m, 'rbend_thick:1')
end

M.rbend_thick = new_bend_thick and rbend_thick_new or rbend_thick_old
M.rbend_kick  = \el,m,lw,istp -> M.strex_kick(el,m,lw,istp,true)             -- checked

-- TKT [INTER_TKTF] -----------------------------------------------------------o

function M.quad_thick (elm, m, lw, istp) -- [PUSHTKT7]                       -- checked
  m.atdebug(elm, m, 'quad_thick:0')

  local el, sdir, edir, k1, beam in m
  local l = el*lw
  local chg = beam.charge

  -- [GETMAT7] TODO: cache these values as lw is the same over the slices
  local ws = k1*edir < 0 and -1 or 1
  local cx, sx, mx1, mx2
  local cy, sy, my1, my2

  if abs(k1) >= minstr then
    local w = sqrt(abs(k1))*sdir*edir*ws
    cx, sx = cos (w*l), sin (w*l)
    cy, sy = cosh(w*l), sinh(w*l)
    mx1, mx2 = sx/w, -sx*w
    my1, my2 = sy/w,  sy*w
  else
    cx, sx, mx1, mx2 = 1, 0, l, 0
    cy, sy, my1, my2 = 1, 0, l, 0
  end

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local chg = beam and beam.charge or chg

    if ws ~= chg then -- swap x <-> y
      ws, cx, cy, mx1, mx2, my1, my2 =
     -ws, cy, cx, my1, my2, mx1, mx2
    end

    local nx  = x*cx  + px*mx1
    local npx = x*mx2 + px*cx
    local ny  = y*cy  + py*my1
    local npy = y*my2 + py*cy

    m[i].x  = nx
    m[i].px = npx
    m[i].y  = ny
    m[i].py = npy
  end

  m.atdebug(elm, m, 'quad_thick:1')
end

function M.quad_kick_ (elm, m, lw, istp) -- [KICKTKT7]                       -- checked
  local l = m.el*lw
  if istp >= 0 then drift_adj(elm, m, istp == 0 and l/2 or l) end

  m.atdebug(elm, m, 'quad_kick:0')
  if m.nmul > 0 then
    local edir, nmul, knl, ksl, beam in m
    local wchg = lw*edir*beam.charge

    for i=1,m.npar do
      local x, px, y, py, beam in m[i]
      local  wchg = beam and lw*edir*beam.charge or wchg
      local bx,by = bxby(nmul, knl, ksl, x, y)

      m[i].px = px - wchg*(by - knl[2]*x)
      m[i].py = py + wchg*(bx - knl[2]*y)
    end
  end
  m.atdebug(elm, m, 'quad_kick:1')

  if istp <= 0 then drift_adj(elm, m, istp == 0 and l/2 or l) end
end

M.quad_kick = \elm, m, lw, istp -> M.quad_kick_(elm, m, lw, 0)

-- skew (tilted by k1s)

function M.quad_thicks (elm, m, lw, istp) -- [PUSHTKT7]                      -- checked
  m.atdebug(elm, m, 'quad_thicks:0')

  local el, sdir, edir, k1, ca, sa, beam in m
  local l = el*lw
  local chg = beam.charge

  -- [GETMAT7] TODO: cache these values as lw is the same over the slices
  local ws = k1*edir < 0 and -1 or 1
  local w  = sqrt(abs(k1))*sdir*edir*ws
  local cx, sx = cos (w*l), sin (w*l)
  local cy, sy = cosh(w*l), sinh(w*l)
  local mx1, mx2 = sx/w, -sx*w
  local my1, my2 = sy/w,  sy*w

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local chg = beam and beam.charge or chg

    if ws ~= chg then -- swap x <-> y
       ws, cx, cy, mx1, mx2, my1, my2 =
      -ws, cy, cx, my1, my2, mx1, mx2
    end

    -- srotation
    local nx  = ca*x  + sa*y
    local npx = ca*px + sa*py
    local ny  = ca*y  - sa*x
    local npy = ca*py - sa*px

    x  = nx*cx  + npx*mx1
    px = nx*mx2 + npx*cx
    y  = ny*cy  + npy*my1
    py = ny*my2 + npy*cy

    -- srotation^-1
    m[i].x  = ca*x  - sa*y
    m[i].px = ca*px - sa*py
    m[i].y  = ca*y  + sa*x
    m[i].py = ca*py + sa*px
  end

  m.atdebug(elm, m, 'quad_thicks:1')
end

function M.quad_kicks_ (elm, m, lw, istp) -- [KICKTKT7]                      -- checked
  local l = m.el*lw
  if istp >= 0 then drift_adj(elm, m, istp == 0 and l/2 or l) end

  m.atdebug(elm, m, 'quad_kicks:0')
  if m.nmul > 0 then
    local edir, nmul, knl, ksl, beam in m
    local wchg = lw*edir*beam.charge

    for i=1,m.npar do
      local x, px, y, py, beam in m[i]
      local  wchg = beam and lw*edir*beam.charge or wchg
      local bx,by = bxby(nmul, knl, ksl, x, y)

      m[i].px = px - wchg*(by - knl[2]*x + ksl[2]*y)
      m[i].py = py + wchg*(bx - knl[2]*y - ksl[2]*x)
    end
  end
  m.atdebug(elm, m, 'quad_kicks:1')

  if istp <= 0 then drift_adj(elm, m, istp == 0 and l/2 or l) end
end

M.quad_kicks = \elm, m, lw, istp -> M.quad_kicks_(elm, m, lw, 0)

-- curved (eh ~= 0)

function M.quad_thickh_new (elm, m, lw, istp) -- [PUSHTKT7]                  -- unchecked
  m.atdebug(elm, m, 'quad_thickh:0')

  local el, eh, sdir, edir, beam in m
  local    l = el*lw
  local   eh = eh*edir
  local beta = beam.beta
  local  chg = beam.charge

  local kx  = (knl[2]+eh*knl[1])/el --only absolute value used
  local ky  = -knl[2]/el            --only absolute value used
  local wxs = kx*edir < 0 and -1 or 1
  local wys = ky*edir < 0 and -1 or 1
  local mx11, mx12, mx13, mx21, mx22, mx23, mx31, mx32, mx33
  local my11, my12, my13, my21, my22, my23

  local wx, wy = 0, 0
  if abs(kx) >= minstr then
    wx = sqrt(abs(kx))*sdir*edir*wxs
    local cx, sx = cos (wx*l), sin (wx*l)
    local cy, sy = cosh(wx*l), sinh(wx*l)
    mx11, mx12, mx13 =  cx  , sx/w, wxs*eh*(cx-1)/wx^2
    mx21, mx22, mx23 = -sx*w, cx  , mx12
    mx31, mx32, mx33 =  mx23, mx13, wxs*-eh^2*(l-mx12)/wx^2
  else
    mx11, mx12, mx13 =  1, l, eh*l^2/2
    mx21, mx22, mx23 =  0, 1, eh*l
    mx31, mx32, mx33 =  mx23, mx13, mx13*mx23/3
  end

  if abs(ky) >= minstr then
    wy = sqrt(abs(ky))*sdir*edir*wys
    local cx, sx = cos (wy*l), sin (wy*l)
    local cy, sy = cosh(wy*l), sinh(wy*l)
    my11, my12, my13 =  cy  , sy/w, 0
    my21, my22, my23 =  sy*w, cy  , 0
  else
    my11, my12, my13 =  1, l, 0
    my21, my22, my23 =  0, 1, 0
  end

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta   or beta
    local  chg = beam and beam.charge or chg

    if ws ~= chg then -- swap x <-> y
      mx11, mx12, mx13, mx21, mx22, mx23,
      my11, my12, my13, my21, my22, my23,  ws =
      my11, my12, my13, my21, my22, my23,
      mx11, mx12, mx13, mx21, mx22, mx23, -ws
    end

--  mx11 = cx                  ; 1
--  mx12 = sx/w                ; l
--  mx13 = ws*beta*(cx-1)/w^2  ; beta*l^2/2
--  mx21 = ws*w*sx             ; 0
--  mx22 = cx                  ; 1
--  mx23 = beta*mx12           ; beta*l

--  my11 = cy                  ; 1
--  my12 = sy/w                ; l
--  my13 = 0                   ; 0
--  my21 = ws*w*sy             ; 0
--  my22 = cx                  ; 1
--  my23 = 0                   ; 0

    local nx  = x*mx11 + px*mx12 + (mx13/beta)*pt
    local npx = x*mx21 + px*mx22 + (mx23/beta)*pt
    local ny  = y*my11 + py*my12
    local npy = y*my21 + py*my22
    -- TODO: update t...

    m[i].x  = nx
    m[i].px = npx
    m[i].y  = ny
    m[i].py = npy
  end

  m.atdebug(elm, m, 'quad_thickh:1')
end

function M.quad_thickh (elm, m, lw, istp) -- [PUSHTKT7]                      -- unchecked (checked for sdir=1 and eh=0)
  m.atdebug(elm, m, 'quad_thickh:0')

  local el, eh, edir, knl, beam in m
  local l = el*lw
  local eh = eh*edir
  local chg = beam.charge
  local beta = beam.beta

  -- [GETMAT7, w ~= 0]
  local kx  = (knl[2]+eh*knl[1])/el   -- No need to include sign of edir here (see below)
  local ky  = -knl[2]/el              --only absolute value used
  local wxs = kx*edir < 0 and -1 or 1 --w(x/y)s determines sign after sqrt
  local wys = ky*edir < 0 and -1 or 1 
  local wx, cx, sx, wy, cy, sy 
  local mx11, mx12, mx13, mx21, mx22, mx23, mx31, mx32, mx33
  local my11, my12,       my21, my22

  if abs(kx) >= minstr then
    wx = sqrt(abs(kx))*wxs -- only wxs is needed for the sign of kx
  else
    wx = 0
    mx11, mx12, mx13 = 1   , l   , eh*l^2/2
    mx21, mx22, mx23 = 0   , 1   , eh*l
    mx31, mx32, mx33 = mx23, mx13, mx13*mx23/3
  end

  if abs(ky) >= minstr then
    wy = sqrt(abs(ky))*wys -- only wys is needed for the sign of ky
  else
    wy = 0
    my11, my12 = 1, l
    my21, my22 = 0, 1
  end

  -- trig 1st GETMAT7, no need to reverse wxs and wys
  -- Removed reverse of wx and wy as they were just reversed later on

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local chg  = beam and beam.charge or chg
    local beta = beam and beam.beta   or beta

    local cx, sx
    if wx ~= 0 then -- [GETMAT7]
      wx, wxs = wx*chg, -wxs*chg
      if wx > 0
      then cx, sx = cos (wx*l), sin (wx*l)
      else cx, sx = cosh(wx*l), sinh(wx*l)
      end
      mx11, mx12, mx13 = cx       , sx/wx,  eh*    (cx-1)*wxs/wx^2
      mx21, mx22, mx23 = wxs*wx*sx, cx   ,  eh*     mx12
      mx31, mx32, mx33 = mx23     , mx13 , -eh^2*(l-mx12)*wxs/wx^2
    end

    local cy, sy
    if wy ~= 0 then -- [GETMAT7]
      wy, wys = wy*chg, -wys*chg
      if wy > 0
      then cy, sy = cos (wy*l), sin (wy*l)
      else cy, sy = cosh(wy*l), sinh(wy*l)
      end
      my11, my12 = cy       , sy/wy
      my21, my22 = wys*wy*sy, cy
    end

--[[ PTC matrix form
    { cx      , sx/wx          ,  h*(cx-1)/wx2*ws     ,
      sx*wx*ws, cx             ,  h*sx/wx             ,
      h*sx/wx , h*(cx-1)/wx2*ws, -h^2*(l-sx/wx)/wx2*ws }
    { cy      , sy/wy          ,  0                   ,
      sy*wy*ws, cy             ,  0                    }
--]]

    -- print("mx11=", mx11) print("mx12=", mx12) print("mx13=", mx13)
    -- print("mx21=", mx21) print("mx22=", mx22) print("mx23=", mx23)
    -- print("my11=", my11) print("my12=", my12)
    -- print("my21=", my21) print("my22=", my22)
    -- print("mx31=", mx31) print("mx32=", mx32) print("mx33=", mx33)

    local nx  = x*mx11 + px*mx12 + pt*(mx13/beta)
    local npx = x*mx21 + px*mx22 + pt*(mx23/beta)
    local ny  = y*my11 + py*my12
    local npy = y*my21 + py*my22
    local dt  = x*(mx31/beta) + px*(mx32/beta) + pt*mx33

    m[i].x   = nx
    m[i].y   = ny
    m[i].px  = npx
    m[i].py  = npy
    m[i].t   = t - dt
  end

  m.atdebug(elm, m, 'quad_thickh:1')
end

function M.quad_kickh_ (elm, m, lw, istp) -- [KICKTKT7]                      -- unchecked (checked for sdir=1 and eh=0)
  local l = m.el*lw
  if istp >= 0 then drift_adj(elm, m, istp == 0 and l/2 or l) end

  m.atdebug(elm, m, 'quad_kickh:0')
  if m.nmul > 0 then
    local eh, edir, nmul, knl, ksl, beam in m
    local   eh = eh*edir
    local beta = beam.beta
    local wchg = lw*edir*beam.charge

    for i=1,m.npar do
      local x, px, y, py, t, pt, beam in m[i]
      local  beam = beam and beam.beta or beta
      local  wchg = beam and lw*edir*beam.charge or wchg
      local    pz = sqrt(1 + 2/beta*pt + pt^2)
      local bx,by = bxby(nmul, knl, ksl, x, y)

      m[i].px = px - wchg*(by - knl[2]*x) + l*eh*(pz-(1/beta*pt)) -- eh has tdir included
      m[i].py = py + wchg*(bx - knl[2]*y)
      m[i].t  =  t - l*eh*((1/beta+pt)/pz - 1/beta)*x
    end
  end
  m.atdebug(elm, m, 'quad_kickh:1')

  if istp <= 0 then drift_adj(elm, m, istp == 0 and l/2 or l) end
end

M.quad_kickh = \elm, m, lw, istp -> M.quad_kickh_(elm, m, lw, 0)

-- DKD, TKT [INTER_SOL5] ------------------------------------------------------o

function M.solen_thick (elm, m, lw, istp) -- [KICK_SOL]                      -- checked
  m.atdebug(elm, m, 'solen_thick:0')

  local el, ks, beam, edir in m
  local l, wchg = el*lw, 0.5*beam.charge*edir
  local bsol = ks*wchg
  local beta = beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local bsol = beam and ks*wchg or bsol
    local   xp = px + bsol*y
    local   yp = py - bsol*x
    local l_pz = l*invsqrt(1 + 2/beta*pt + pt^2 - xp^2 - yp^2)
    local  ang = l_pz*bsol

    local ca, sa, sc = cos(ang), sin(ang), sinc(ang)

    local lsc = l_pz*sc
    local xt  = ca*x  + lsc*px
    local pxt = ca*px - lsc*x *bsol^2
    local yt  = ca*y  + lsc*py
    local pyt = ca*py - lsc*y *bsol^2

    m[i].x  = ca*xt  + sa*yt
    m[i].px = ca*pxt + sa*pyt
    m[i].y  = ca*yt  - sa*xt
    m[i].py = ca*pyt - sa*pxt
    m[i].t  = t - (1/beta+pt)*l_pz + (1-m.T)/beta*l
  end

  m.atdebug(elm, m, 'solen_thick:1')
end

-- DKD, TKT [SEPTTRACK] -------------------------------------------------------o

function M.esept_thick (elm, m, lw, istp) -- [SEP]                           -- checked
  m.atdebug(elm, m, 'elsep_thick:0')

  local el, ca, sa, volt, edir, beam in m
  local beta = beam.beta
  local  bg2 = beam.betgam2
  local wchg = beam.charge/beam.pc
  local   k1 = edir*volt*wchg
  local    l = el*lw

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local  bg2 = beam and beam.betgam2 or bg2
    local   k1 = beam and k1*beam.charge/(wchg*beam.pc) or k1
    local   e1 = 1/beta+pt

    -- srotation
    local   nx  = ca*x  + sa*y
    local   npx = ca*px + sa*py
    local   ny  = ca*y  - sa*x
    local   npy = ca*py - sa*px

    local    dp = e1 + k1*ny
    local  l_pz = l*invsqrt(dp^2 - 1/bg2 - npx^2 - npy^2)
    local   arg = k1*l_pz
    local   shx = sinhc(arg)*l_pz
    local ch,sh = cosh(arg), sinh(arg)
    local   chm = sinh(0.5*arg)^2*(2/k1) -- was sinhc(0.5*arg)*sinh(0.5*arg)/l_pz
    local    dt = chm*npy + sh *ny  + e1*shx
    local    yt = ch *ny  + shx*npy + e1*chm
    local   pyt = ch *npy + sh*dp

    nx = nx + npx*l_pz
    ny, npy = yt, pyt

    -- srotation^-1
    m[i].x  = ca*nx  - sa*ny
    m[i].px = ca*npx - sa*npy
    m[i].y  = ca*ny  + sa*nx
    m[i].py = ca*npy + sa*npx
    m[i].t  = t - dt + (1-m.T)/beta*l
  end

  m.atdebug(elm, m, 'elsep_thick:1')
end

-- DKD, TKT [INTER_CAV4] ------------------------------------------------------o

function M.rfcav_kick (elm, m, lw, istp) -- [KICKCAV, FEVAL_CAVR?]           -- checked
  if m.volt == 0 then return end
  m.atdebug(elm, m, 'rfcav_kick:0')

  local volt, freq, lag, edir, beam in m
  local omega = freq*twopi_clight
  local phase = lag
  local  wchg = beam.charge/beam.pc
  local    vl = lw*wchg*edir*volt

!  printf('@@ vl=% -.16e, omega=% -.16e, phase=% -.16e, p0c=% -.16e, yl=% -.16e\n',
!          vl, omega, phase, beam.pc, m.el*lw, beam.beta)

  for i=1,m.npar do
    local t, pt, beam in m[i]
    local vl = beam and vl*beam.charge/(beam.pc*wchg) or vl

    -- energy kick
    m[i].pt = pt + vl*sin(phase - omega*t)
  end

  m.atdebug(elm, m, 'rfcav_kick:1')
end

function M.rfcav_kickn (elm, m, lw, istp) -- [KICKCAV, nmul~=0 or nbsl~=0]   -- checked
  m.atdebug(elm, m, 'rfcav_kickn:0')

  local volt, freq, lag, edir, nbsl, nmul, knl, ksl, beam in m
  local omega = freq*twopi_clight
  local phase = lag
  local _pc   = 1/beam.pc
  local chg   = beam.charge
  local bdir  = lw*chg*edir
  local vl    = bdir*volt

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local ph = phase - omega*t
    local sa, ca = sin(ph), cos(ph)
    local _pc, vl, bdir = _pc, vl, bdir
    local f = 1

    if beam then
      _pc, vl, bdir = 1/beam.pc, vl*chg*beam.charge, bdir*chg*beam.charge
    end

    if vl ~= 0 then
      -- bessel modes (single mode ko=1)
      if nbsl > 0 then
        local df, r2 = 0, 1

        for i=1,nbsl do
          r2 = -r2*omega^2/(4*(i+1)^2)
          df =  df + 2*r2*i
          r2 =  r2*(x^2+y^2)
          f  =  f + r2
        end

        local c1 = df*vl*_pc*ca/omega
        px = px + x*c1
        py = py + y*c1
      end

      -- energy kick
      pt = pt + f*vl*_pc*sa
    end

    if nmul > 0 then
      local bx, by, byt = bxby(nmul, knl, ksl, x, y)
      px = px + bdir*_pc*by*ca
      py = py - bdir*_pc*bx*ca

      by = -knl[nmul]/nmul
      bx = -ksl[nmul]/nmul
      for i=nmul-1,1,-1 do
        byt = x*by - y*bx - knl[i]/i
        bx  = y*by + x*bx - ksl[i]/i
        by  = byt
      end
      byt = x*by - y*bx
      bx  = y*by + x*bx
      by  = byt

      pt = pt - bdir*_pc*omega*by*sa
    end

    m[i].px = px
    m[i].py = py
    m[i].pt = pt
  end

  m.atdebug(elm, m, 'rfcav_kickn:1')
end

-- DKD, TKT -------------------------------------------------------------------o

function M.wire_kick (elm, m, lw, istp)                                      -- checked
  m.atdebug(elm, m, 'wire_kick:0')

  local kckorbit in option
  local edir, sdir, beam in m
  local nwire, xma, yma, l_int, l_phy, current, dpx, dpy in m
  local pc, chg = beam.pc, beam.charge*edir*sdir
  local lwa = 1e-16*clight*lw

  for i=1,m.npar do
    if not (kckorbit or is_damap(m[i])) then goto continue end

    local x, px, y, py, beam in m[i]
    local chg = beam and beam.charge*edir*sdir or chg
    local pc  = beam and beam.pc or pc
    local c0  = lwa*chg/pc
    local wpx, wpy = 0, 0

    for j=1,nwire do
      local dx  = x - xma[j]
      local dy  = y - yma[j]
      local r2  = dx^2+dy^2
      local l21 = (l_int[j]+l_phy[j])^2
      local l22 = (l_int[j]-l_phy[j])^2
      local c1  = c0*current[j]*(sqrt(l21+4*r2) - sqrt(l22+4*r2))/r2
      local kx  = c1*dx
      local ky  = c1*dy

      wpx = wpx + kx
      wpy = wpy + ky
    end

    if not kckorbit then -- clear orbit kick
      wpx:clrord(0)
      wpy:clrord(0)
    end

    m[i].px = px - wpx - dpx
    m[i].py = py - wpy - dpy
  ::continue::
  end

  m.atdebug(elm, m, 'wire_kick:1')
end

-- DKD, TKT -------------------------------------------------------------------o

local BB = require 'madl_bbeam' -- beambeam shapes

function M.bbeam_kick (elm, m, lw, istp)                                     -- unchecked
  m.atdebug(elm, m, 'bbeam_kick:0')

  local xma, yma, dpx, dpy, sigx, sigy, sigtol, npart, charge, bbdir, bbeam in elm
  local korb = elm.kckorbit or option.kckorbit
  local sdir, beam in m
  local pc, beta in beam
  local npart = bbeam and bbeam.npart  or npart
  local bbeta = bbeam and bbeam.beta   or beta
  local bbchg = bbeam and bbeam.charge or charge
  local bbkck = -1e-9*qelect*npart*bbchg*bbdir

  for i=1,m.npar do
    if not (korb or is_damap(m[i])) then goto continue end

    local x, px, y, py, pt, beam in m[i]

    if beam then pc, beta = beam.pc, beam.beta end

    local bet = pt2beta(pt, beta)
    local kck = bbkck * (1 + bet*bbeta)/(pc * (bet+bbeta))

    x = x - xma
    y = y - yma

    -- TODO: handle more shapes
    local Ex, Ey = BB.ExEy_GxGy_gauss(x, y, sigx, sigy, sigtol)

    local bpx = kck*Ex
    local bpy = kck*Ey

    if not korb then -- clear orbit kick
      bpx:set0(0)
      bpy:set0(0)
    end

    m[i].px = px + sdir*bpx - dpx
    m[i].py = py + sdir*bpy - dpy

    ::continue::
  end

  m.atdebug(elm, m, 'bbeam_kick:1')
end

function M.bbeam_kick6D (elm, m, lw, istp)                                   -- unchecked
  m.atdebug(elm, m, 'bbeam_kick6D:0')

  error("NYI")

  m.atdebug(elm, m, 'bbeam_kick6D:1')
end

-- DKD, TKT -------------------------------------------------------------------o

function M.nllens_kick (elm, m, lw, istp)                                    -- unchecked
  m.atdebug(elm, m, 'nllens_kick:0')

  local knll, cnll in elm
  local edir, sdir, beam in m
  local chg = beam.charge*edir*sdir

  assert(cnll ~= 0, "invalid cnll (non-zero expected)")
  knll = knll/cnll

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local chg = beam and beam.charge*edir*sdir or chg

    x = x/cnll
    y = y/cnll

    local  xp1 = x+1
    local  xm1 = x-1
    local  xpy = 0.5*sqrt(xp1^2+y^2)
    local  xmy = 0.5*sqrt(xm1^2+y^2)
    local _xpy = 0.25/xpy
    local _xmy = 0.25/xmy

    local    u = xmy + xpy
    local    v = xpy - xmy
    local   u2 = u^2
    local   v2 = v^2
    local _uv2 = 1/(u2-v2)
    local  um1 = sqrt(u2-1)
    local  mv1 = sqrt(1-v2)
    local  lum = log(u+um1)*um1
    local  acv = (acos(v)-pi_2)*mv1
    local  duv = 1 - 2*(u*lum+v*acv)*_uv2
    local   dd = u == 1 and 0 or lum*(u/um1)^2

    local  dUu = (lum+dd            + u*duv)*_uv2
    local  dUv = (acv*(1-(v/mv1)^2) - v*duv)*_uv2

    local  dux = xm1*_xmy + xp1*_xpy
    local  duy =  y *_xmy +  y *_xpy
    local  dvx = xp1*_xpy - xm1*_xmy
    local  dvy =  y *_xpy -  y *_xmy

    m[i].px = px + (chg*knll)*(dUu*dux + dUv*dvx)
    m[i].py = py + (chg*knll)*(dUu*duy + dUv*dvy)
  end

  m.atdebug(elm, m, 'nllens_kick:1')
end

-- DKD, TKT -------------------------------------------------------------------o

function M.linm_thin (elm, m, lw, istp)                                     -- unchecked
  m.atdebug(elm, m, 'linm_thin:0')

  local update = elm:var_get'update'
  if update then update(elm, m, lw, istp) end -- update element

  local bet0, bet1 in elm
  local sdir in m

      if is_nil(bet0) then bet0 = {}
  elseif is_nil(bet1) then bet1 = {} end

  local bx0 =       bet0.beta11 or bet1.beta11  or 1
  local by0 =       bet0.beta22 or bet1.beta22  or 1
  local bx1 =       bet1.beta11 or bet0.beta11  or 1
  local by1 =       bet1.beta22 or bet0.beta22  or 1
  local ax0 = sdir*(bet0.alfa11 or bet1.alfa11) or 0
  local ay0 = sdir*(bet0.alfa22 or bet1.alfa22) or 0
  local ax1 = sdir*(bet1.alfa11 or bet0.alfa11) or 0
  local ay1 = sdir*(bet1.alfa22 or bet0.alfa22) or 0
  local ux0 = sdir*(bet0.mu1    or bet1.mu1)    or 0
  local uy0 = sdir*(bet0.mu2    or bet1.mu2)    or 0
  local ux1 = sdir*(bet1.mu1    or bet0.mu1)    or 0
  local uy1 = sdir*(bet1.mu2    or bet0.mu2)    or 0

  local sx , cx  = sin(twopi*(ux1 - ux0)), cos(twopi*(ux1 - ux0))
  local sy , cy  = sin(twopi*(uy1 - uy0)), cos(twopi*(uy1 - uy0))
  local bxr, byr = sqrt(bx1 / bx0),  sqrt(by1 / by0)
  local bxp, byp = sqrt(bx1 * bx0),  sqrt(by1 * by0)

  -- Wolski, ch4, eq. 4.60
  local mx00 = bxr * (cx+ax0*sx)
  local mx01 = bxp *  sx
  local mx10 = ((ax0-ax1)*cx - (1+ax0*ax1)*sx) / bxp
  local mx11 = (cx-ax1*sx0) / bxr

  local my00 = byr * (cy+ay0*sy)
  local my01 = byp *  sy
  local my10 = ((ay0-ay1)*cy - (1+ay0*ay1)*sy) / byp
  local my11 = (cy-ay1*sy0) / byr

  -- TODO: dispersion

  for i=1,m.npar do
    local x, px, y, py in m[i]

    local nx  = mx00*x + mx01*px
    local npx = mx10*x + mx11*px
    local ny  = my00*y + my01*py
    local npy = my10*y + my11*py

    m[i].x  = nx
    m[i].px = npx
    m[i].y  = ny
    m[i].py = npy
  end

  m.atdebug(elm, m, 'linm_thin:1')
end

-- DKD, TKT -------------------------------------------------------------------o

function M.genm_thick (elm, m, lw, istp)                                     -- unchecked
  m.atdebug(elm, m, 'genm_thick:0')

  local update = elm:var_get'update'
  if update then update(elm, m, lw, istp) end -- update damap

  local damap in elm

  if m.sdir == -1 then damap = damap^-1 end -- backtracking

  for i=1,m.npar do
    local m = m[i]
    if is_damap(m) then
      damap:compose(m, m)
    else
      local v = vector(6):fill{m.x, m.px, m.y, m.py, m.t, m.pt}
      damap:eval(v, v)
      m.x, m.px, m.y, m.py, m.t, m.pt = v[1], v[2], v[3], v[4], v[5], v[6]
    end
  end

  m.atdebug(elm, m, 'genm_thick:1')
end

-- fringes --------------------------------------------------------------------o

local tobit, fbit, fset, fcut, ftst in MAD.gfunc

  -- fringe fields (elements fringe attribute)
M.fringe = {
  none  = tobit(0),
  bend  =  fbit(0),               -- bending    fringe fields
  mult  =  fbit(1),               -- multipolar fringe fields
  qsad  =  fset(fbit(1),fbit(2)), -- multipolar fringe fields with quad SAD
  rfcav =  fbit(3),               -- rfcavity   fringe fields
  solen =  fbit(4),               -- solenoid   fringe fields

  -- sbend+quadrupole
  comb   = fset(fbit(0),fbit(1)),
  combqs = fset(fbit(0),fbit(1),fbit(2)), -- with fsad
}
-- for k,v in pairs(M.fringe) do print(k,v) end

local fringe in M

--[[
Policy in MAD-X PTC:
====================
k%fringe                T/F        ptc_setswitch equivalent to permfringe=1
el%likemad              T/F        special flag for true rbend
el%thin                 T/F        disable fringe for cavity
el%permfringe           0,1,2,3    0:none, 1:mult_fringe, 2:qsad_fringe, 3:1+2
el%bend_fringe          T/F        bend_fringe (and mult_fringe-bend_fringe)
el%highest_fringe       N (N=2)    limit of mult_fringe
el%kill_ent_fringe      T/F        disable fringe on entry
el%kill_exi_fringe      T/F        disable fringe on exit

FRINGE_STRAIGHT: (TRACK_FRINGE)
  EDGE, MULTIPOLE_FRINGE, FRINGE2QUAD

FRINGE_STREX[LIKEMAD=TRUE]:
  ROT_XZ, FACE, FRINGE_DIPOLE, MULTIPOLE_FRINGE, FRINGE2QUAD, WEDGE
FRINGE_STREX:
  EDGE_TRUE_PARALLEL, MULTIPOLE_FRINGE, FRINGE2QUAD

FRINGE_TEAPOT[EDGE/=0]:
  ROT_XZ, FACE, FRINGE_DIPOLE, MULTIPOLE_FRINGE, FRINGE2QUAD, MAD8WEDGE, WEDGE
FRINGE_TEAPOT:
  FACE, FRINGE_DIPOLE, MULTIPOLE_FRINGE, FRINGE2QUAD

FRINGE_DIPOLE[BEND_FRINGE=TRUE]
FRINGE2QUAD[PERMFRINGE=2.or.3]
MULTIPOLE_FRINGE[PERMFRINGE=1.or.3]

NEWFACE[EXACT] / FACE[.not.EXACT]
EDGE
EDGE_TRUE_PARALLEL

FRINGECAV[PERMFRINGE/=0,THIN/=T,NOCAVITY/=T,N_BESSEL/=-1]
--]]

 -- forward declarations
local mad8_wedge, bend_wedge, bend_face
local bend_fringe, mult_fringe, qsad_fringe, sol_fringe, cav_fringe

function M.strex_fringe (elm, m, lw_)  -- [FRINGE_STREX]                     -- checked
  m.atdebug(elm, m, 'strex_fringe:0')

  local lw = lw_ or 1
  local sdir, edir in m

  if lw == 1 and elm.kill_ent_fringe or lw == -1 and elm.kill_exi_fringe
  then m.frng = 0
  else m.frng = fcut(m.fringe, elm.fringe)
  end

  local e1, e2 = (m.e1 or elm.e1), (m.e2 or elm.e2)
  local h1, h2 =          elm.h1 ,          elm.h2 

  if sdir == -1 then e1, e2, h1, h2 = e2, e1, h2, h1 end -- swap

  if sdir*lw == 1 then
! print(lw == 1 and 'forward entry' or 'backward exit')
    yrotation(elm, m, sdir, -e1)
    if m.pdir == lw then                           -- Entering magnet
      for i=1,m.npar do
        m[i].x = m[i].x+m.elc*sin((e2-e1)*edir/2)       -- EDGE_TRUE_PARALLEL
      end
    end
    bend_face(elm, m, 1, h1)
    if m.frng ~= 0 then
      if ftst(m.frng, fringe.bend) then bend_fringe(elm, m, 1) end
      if ftst(m.frng, fringe.mult) then mult_fringe(elm, m, 1) end
      if ftst(m.frng, fringe.qsad) then qsad_fringe(elm, m, 1) end
    end
    if not m.pdir then                    -- ! EDGE_TRUE_PARALLEL
      local a = 0.5*(m.ehd or m.eh)*(m.eld or m.el) - e1
      bend_wedge(elm, m, 1, a)
    end
  else
! print(lw == -1 and 'forward exit' or 'backward entry')
    if not m.pdir then                    -- ! EDGE_TRUE_PARALLEL
      local a = 0.5*(m.ehd or m.eh)*(m.eld or m.el) - e2
      bend_wedge(elm, m, -1, a)
    end
    if m.frng ~= 0 then
      if ftst(m.frng, fringe.qsad) then qsad_fringe(elm, m, -1) end
      if ftst(m.frng, fringe.mult) then mult_fringe(elm, m, -1) end
      if ftst(m.frng, fringe.bend) then bend_fringe(elm, m, -1) end
    end
    bend_face(elm, m, -1, h2)
    if m.pdir == lw then                                -- Exiting magnet
      for i=1,m.npar do
        m[i].x = m[i].x+m.elc*sin((e2-e1)*edir/2)            -- EDGE_TRUE_PARALLEL
      end
    end
    yrotation(elm, m, -sdir, e2)
  end

  m.atdebug(elm, m, 'strex_fringe:1')
end

function M.curex_fringe (elm, m, lw_) -- [FRINGE_TEAPOT]                     -- checked
  m.atdebug(elm, m, 'curex_fringe:0')

  local lw = lw_ or 1
  local sdir, edir in m
  local e, h

  if lw == 1 and elm.kill_ent_fringe or lw == -1 and elm.kill_exi_fringe
  then m.frng = 0
  else m.frng = fcut(m.fringe, elm.fringe)
  end

  if lw == 1
  then e, h = m.e1, elm.h1
  else e, h = m.e2, elm.h2
  end

  if sdir*lw == 1 then
-- print(lw == 1 and 'forward entry' or 'backward exit')
    yrotation (elm, m, sdir, -e)
    bend_face (elm, m, 1   ,  h)
    if m.frng ~= 0 then
      if ftst(m.frng, fringe.bend) then bend_fringe(elm, m, 1) end
      if ftst(m.frng, fringe.mult) then mult_fringe(elm, m, 1) end
      if ftst(m.frng, fringe.qsad) then qsad_fringe(elm, m, 1) end
    end
--    if e ~= 0 then MAD.dbg() end
    mad8_wedge(elm, m, 1,  e)
    bend_wedge(elm, m, 1, -e)
  else
-- print(lw == -1 and 'forward exit' or 'backward entry')
    bend_wedge(elm, m, -1,-e)
    mad8_wedge(elm, m, -1, e)
    if m.frng ~= 0 then
      if ftst(m.frng, fringe.qsad) then qsad_fringe(elm, m, -1) end
      if ftst(m.frng, fringe.mult) then mult_fringe(elm, m, -1) end
      if ftst(m.frng, fringe.bend) then bend_fringe(elm, m, -1) end
    end
    bend_face (elm, m, -1   , h)
    yrotation (elm, m, -sdir, e)
  end

  m.atdebug(elm, m, 'curex_fringe:1')
end

function M.solen_fringe (elm, m, lw_)
  m.atdebug(elm, m, 'solen_fringe:0')

  local lw = lw_ or 1
  if lw == 1 and elm.kill_ent_fringe or lw == -1 and elm.kill_exi_fringe
  then m.frng = 0
  else m.frng = fcut(m.fringe, elm.fringe)
  end

  if ftst(m.frng, fringe.solen) then
-- lw ==  1: 'forward entry' or 'backward exit'
-- lw == -1: 'forward exit'  or 'backward entry'
    sol_fringe(elm, m, sdir*lw)
  end

  m.atdebug(elm, m, 'solen_fringe:1')
end

local function adjust_time (m)
  if abs(m.el) < minlen then return end

  local Tl = (m.T-m.Tbak)*m.el*m.sdir
  local beta = m.beam.beta
  for i=1,m.npar do
    local t, beam in m[i]
    local beta = beam and beam.beta or beta
    m[i].t = t + Tl/beta -- adjust time of flight
  end
end

function M.rfcav_fringe (elm, m, lw_) -- [ADJUST_TIME_CAV4, FRINGECAV]       -- checked
  m.atdebug(elm, m, 'rfcav_fringe:0')

  local lw = lw_ or 1
  local sdir, beam in m

  if lw == 1 and elm.kill_ent_fringe or lw == -1 and elm.kill_exi_fringe
  then m.frng = 0
  else m.frng = fcut(m.fringe, elm.fringe)
  end

  if sdir*lw == 1 then
-- print(lw == 1 and 'forward entry' or 'backward exit', 'T=', m.T, elm.totalpath)
    assert(m.Tbak < 0, "inconsistent totalpath when entering rfcavity")
    if m.Tbak == -1 then
      m.lag = m.lag - m.freq*abs(m.el)*pi_clight/beam.beta -- t=0 => accel=0
      m.Tbak, m.T = m.T, 1
    else
      m.Tbak, m.T = m.T, 0
    end
    if lw == -1 and m.T ~= m.Tbak then adjust_time(m) end
    if ftst(m.frng, fringe.rfcav) then cav_fringe(elm, m,  1) end
  else
-- print(lw == -1 and 'forward exit' or 'backward entry', 'T=', m.T, m.Tbak)
    if ftst(m.frng, fringe.rfcav) then cav_fringe(elm, m, -1) end
    if lw == -1 and m.T ~= m.Tbak then adjust_time(m) end
    m.T, m.Tbak = m.Tbak, -1
  end

  m.atdebug(elm, m, 'rfcav_fringe:1')
end

-- fringes helpers ------------------------------------------------------------o

function bend_face (elm, m, lw, h) -- [NEWFACE]                              -- checked
  if h == 0 then return end
  local el, knl in m
  if abs(el) < minlen or abs(knl[1]) < minstr then return end

  m.atdebug(elm, m, 'bend_face:0')

  local edir, sdir, beam in m
  local  k0h = 0.5*h*knl[1]/el*edir*sdir -- Needs confirmation, but I believe h1, h2 are independent of tdir -> see PTC
  -- PTC eq: X(2)=X(2)+(EL%DIR*EL%CHARGE*BN(1)*H/2.0_dp)*X(1)**2. If h was dependent on tdir, then this equation would not require DIR 
  local  chg = beam.charge
  local beta = beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local chg  = beam and beam.charge or chg
    local k0hq = k0h*chg -- k0hq must be weighted by bdir

    if sdir == 1 then -- to insure reversal symmetry ; horizontal wedge (only sdir) -> PTC uses edir, and if we do this, reversing edir does not give the same result
      px = px + k0hq*x^2
    end

    -- This is still not fully revesible in 4th order, due to dependancy of x on px and vice versa.
    local dpp    = 1 + 2/beta*pt + pt^2
    local y2     = y^2
    local _pt2   = 1/(dpp - px^2)
    local xi     = 2*k0hq*sqrt(dpp)*_pt2
    local dxi_px = 2*px*xi         *_pt2

    if sdir == -1 then 
      local npx = px - xi*y2 
      _pt2   = 1/(dpp - npx^2)
      xi     = 2*k0hq*sqrt(dpp)*_pt2
      dxi_px = 2*npx*xi        *_pt2
    end
    
    local dxi_ddel = -2*xi*(1+pt)*_pt2

    if sdir == 1 then 
      x  = x  / (1-dxi_px*y2)
      px = px - xi*y2
      py = py - 2*xi*x*y
      t  = t  + dxi_ddel*x*y2
    else
      t  = t  + dxi_ddel*x*y2
      py = py - 2*xi*x*y
      x  = x  / (1-dxi_px*y2)
      px = px - xi*y2 + k0hq*x^2
    end

    m[i].x  = x
    m[i].px = px
    m[i].py = py
    m[i].t  = t
  end

  m.atdebug(elm, m, 'bend_face:1')
end

function mad8_wedge (elm, m, lw_, e)     -- [FRINGE_TEAPOT:MAD8_WEDGE]            -- checked
  if e == 0 or abs(m.knl[2]) < minstr then return end
  m.atdebug(elm, m, 'mad8_wedge:0')

  local el, edir, knl, frng, beam in m
  local   wc = frng <= 1 and 0 or 0.25
  local  k1e = e*knl[2]/el
  local   c1 = (1+wc)*k1e
  local   c2 = (1-wc)*k1e
  local  chg = beam.charge

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local chg = beam and beam.charge or chg
    m[i].px = px + (chg*c1  )*x^2 - (chg*c2)*y^2
    m[i].py = py - (chg*c2*2)*x*y
  end

  m.atdebug(elm, m, 'mad8_wedge:1')
end

function bend_wedge (elm, m, lw_, e) -- [WEDGE] see also [sr]bend_thick      -- checked
  if e == 0 then return end
  if abs(m.knl[1]) < minstr then return yrotation(elm,m,m.sdir,-e) end
  m.atdebug(elm, m, 'bend_wedge:0')

  local el, sdir, edir, knl, beam in m
  local   k0 = knl[1]/el*edir
  local   b1 = k0*beam.charge
  local beta = beam.beta
  local  e   = e*sdir*edir
  local sa, ca, s2a = sin(e), cos(e), sin(2*e)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    -- Note: for now, ignore wedge for photons to avoid NaN due to b1=0
    if beam and beam.charge == 0 then goto continue end

    local beta = beam and beam.beta or beta
    local   b1 = beam and k0*beam.charge or b1

    local pzy = 1 + 2/beta*pt + pt^2 - py^2
    local _pt = invsqrt(pzy)
    local  pz = sqrt(pzy - px^2)
    local pzx = pz - b1*x
    local npx = px*ca + pzx*sa
    local pzs = sqrt(pzy - npx^2)
    local dxs = (e + asin(px*_pt) - asin(npx*_pt))/b1

    m[i].x  = x*(ca + (px*s2a + sa^2*(pz+pzx))/(pzs + pz*ca - px*sa))
    m[i].px = npx
    m[i].y  = y + dxs*py
    m[i].t  = t - dxs*(1/beta+pt)

    ::continue::
  end

  m.atdebug(elm, m, 'bend_wedge:1')
end

local function bend_fringe_param (dpp, px, py, c2, b0, tfac, only_ky)
  -- This map could do with some cleaning, use of pz, _pz and _pz2 is inconsistent
  local   pz = sqrt(dpp - px^2 - py^2)
  local  _pz = 1/pz
  local _pz2 = _pz^2

  local xp,  yp  = px/pz, py/pz
  local xyp, yp2 = xp*yp, 1+yp^2
  local xp2,_yp2 = xp^2 , 1/yp2

  local fi0 = atan((xp*_yp2)) - c2*(1 + xp2*(1+yp2))*pz
  local co2 = b0/cos(fi0)^2
  local co1 = co2/(1 + (xp*_yp2)^2)*_yp2
  local co3 = co2*c2

  local fi1 =    co1          - co3*2*xp*(1+yp2)*pz
  local fi2 = -2*co1*xyp*_yp2 - co3*2*xp*xyp    *pz
  local fi3 =                 - co3*(1 + xp2*(1+yp2))

  local ky = fi1*xyp*_pz      + fi2*yp2*_pz      - fi3*yp
  if only_ky then return fi0, nil, ky, nil end -- only ky is needed, speed up calculation

  local kx = fi1*(1+xp2)*_pz  + fi2*xyp*_pz      - fi3*xp
  local kz = fi1*tfac*xp*_pz2 + fi2*tfac*yp*_pz2 - fi3*tfac*_pz
  return fi0, kx, ky, kz
end


function bend_fringe (elm, m, lw) -- [FRINGE_DIPOLE]                         -- checked
  if abs(m.knl[1]) < minang then return end
  m.atdebug(elm, m, 'bend_fringe:0')

  local el, sdir, edir, beam in m
  local   fh = 2*elm.hgap*(sdir*lw == -1 and elm.fintx or elm.fint)
  local fsad = fh ~= 0 and 1/(36*fh) or 0
  local  k0w = m.knl[1]/abs(el)*edir*sdir*lw
  local   b0 = k0w*beam.charge
  local beta = beam.beta

! printf("lw=% d, sdir=% d, el=% -.4f, fh=% -.5e, b0=% -.5e\n",
!         lw, sdir, el, fh, b0)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local   b0 = beam and k0w*beam.charge or b0
    local   c2 = b0*fh

    local  dpp = 1 + 2/beta*pt + pt^2
    local relp = invsqrt(dpp)
    local tfac = -(1/beta + pt)
    local   c3 = b0^2*fsad*relp

    local fi0, kx, ky, kz = bend_fringe_param(dpp, px, py, c2, b0, tfac, sdir==-1) -- this method is not perfect.
    local ny = 2*y / (1 + sqrt(1-2*ky*y))
    if sdir == 1 then
      local ny2 = ny^2

      m[i].x  = x  + 0.5*kx*ny2
      m[i].py = py - (4*c3*ny2 + b0*tan(fi0))*ny
      m[i].t  = t  + (0.5*kz  + c3*ny2*relp^2*tfac)*ny2
      m[i].y  = ny
    else -- need to reverse y-dependence
      -- This is still not fully revesible in 5thand 6th order, due to self dependance of py -> results in max error of 1e-11 and 2e-9 for 5th and 6th order respectively
      local npy = py + (4*c3*ny^2 + b0*tan(fi0))*ny
      fi0, kx, ky, kz = bend_fringe_param(dpp, px, npy, c2, b0, tfac) -- this method is not perfect.
      local y2 = y^2

      m[i].x  = x  - 0.5*kx*y2
      m[i].py = py + (4*c3*y2 + b0*tan(fi0))*y
      m[i].t  = t  - (0.5*kz + c3*y2*relp^2*tfac)*y2
      m[i].y  = y - y2*ky/2
    end
  end

  m.atdebug(elm, m, 'bend_fringe:1')
end

function qsad_fringe (elm, m, lw) -- [FRINGE2QUAD]                           -- unchecked
  if abs(m.knl[2])+abs(m.ksl[2]) < minstr then return end                    -- need SAD f1 & f2
  local f1, f2 in elm
  if abs(f1)+abs(f2) < minstr then return end

  m.atdebug(elm, m, 'qsad_fringe:0')

-- fwd entry, bwd exit : lw= 1
-- fwd exit , bwd entry: lw=-1

  local el, k1, ca, sa, beam in m
  local beta = beam.beta
  local  chg = beam.charge

  local sdir, edir, knl, ksl in m
  local a  = -0.5*atan2(ksl[2], knl[2])
  local b2 = hypot(knl[2],ksl[2])/el*edir
  local ca, sa = cos(a), sin(a)

  f1 = -abs(f1)*f1*b2/24
  f2 =          f2*b2*sdir

  -- Lee-Whiting formula, E. Forest ch 13.2.3, eq 13.33
  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local  chg = beam and beam.charge or chg
    local  _pz = invsqrt(1 + 2/beta*pt + pt^2)
    local   dt = (1/beta+pt)*_pz

    local f1 = (lw*chg*f1)*_pz
    local f2 = (   chg*f2)*_pz

    local nx  = ca*x  + sa*y
    local npx = ca*px + sa*py
    local ny  = ca*y  - sa*x
    local npy = ca*py - sa*px

    m[i].t  = t - dt*((f1*nx + (1+f1/2)*exp(-f1)*f2*npx*_pz)*npx -
                      (f1*ny + (1-f1/2)*exp( f1)*f2*npy*_pz)*npy)*_pz

    x  =  nx*exp( f1) + f2*npx*_pz
    y  =  ny*exp(-f1) - f2*npy*_pz
    px = npx*exp(-f1)
    py = npy*exp( f1)

    m[i].x  = ca*x  - sa*y
    m[i].px = ca*px - sa*py
    m[i].y  = ca*y  + sa*x
    m[i].py = ca*py + sa*px
  end

  m.atdebug(elm, m, 'qsad_fringe:1')
end

function mult_fringe (elm, m, lw) -- [MULTIPOLE_FRINGE]                      -- checked
  local fmax = elm.frngmax or m.frngmax
  if min(m.nmul,fmax) == 0 then return end

  m.atdebug(elm, m, 'mult_fringe:0')

  local el, sdir, edir, nmul, knl, ksl, beam in m
  local  beta = beam.beta
  local  wchg = beam.charge*lw
  local no_k1 = ftst(m.frng, fringe.bend)
  local    _l = el ~= 0 and edir/el or edir

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local wchg = beam and beam.charge*lw or wchg
    local  _pz = invsqrt(1 + 2/beta*pt + pt^2)

    local rx, ix = 1, 0
    local fx, fxx, fxy = 0, 0, 0
    local fy, fyx, fyy = 0, 0, 0

    -- NOTE: this loop is not fully time reversable to numerical precision,
    --       because it depends on x,y and affects x,y (implicit formulation
    --       in backtracking, not a thin lens)
    for j=1,min(nmul,fmax) do
      local drx, dix = rx, ix
      rx = drx*x - dix*y
      ix = drx*y + dix*x

      local nj, nf = -wchg/(4*(j+1)), (j+2)/j
      local kj, ksj = knl[j]*_l, ksl[j]*_l
      local u, v, du, dv

!      printf("lw=% d, sdir=% d, j=%d, nj=% -.5f, nf=% -.5f, rx=% -.16e, ix=% -.16e, \z
!              drx=% -.16e, dix=% -.16e, kj=% -.16e, ksj=% -.16e, ",
!              lw, sdir, j, nj, nf, rx, ix, drx, dix, kj, ksj)

      if j == 1 and no_k1 then
        u  = nj*(       - ksj*ix )
        v  = nj*(       + ksj*rx )
        du = nj*(       - ksj*dix)
        dv = nj*(       + ksj*drx)
      else
        u  = nj*(kj*rx  - ksj*ix )
        v  = nj*(kj*ix  + ksj*rx )
        du = nj*(kj*drx - ksj*dix)
        dv = nj*(kj*dix + ksj*drx)
      end

      local dux, dvx =  j*du, j*dv
      local duy, dvy = -j*dv, j*du

!      printf("u=% -.16e, v=% -.16e, du=% -.16e, dv=% -.16e, ", u, v, du, dv)

      fx  = fx  +   u*x + nf*   v*y
      fy  = fy  +   u*y - nf*   v*x
      fxx = fxx + dux*x + nf* dvx*y + u
      fyy = fyy + duy*y - nf* dvy*x + u
      fxy = fxy + duy*x + nf*(dvy*y + v)
      fyx = fyx + dux*y - nf*(dvx*x + v)

!      printf("fx=% -.16e, fy=% -.16e, fxx=% -.16e, fyy=% -.16e, fxy=% -.16e, fyx=% -.16e\n",
!              fx, fy, fxx, fyy, fxy, fyx)
    end

    local    a = 1 - fxx*_pz
    local    b =   - fyx*_pz
    local    c =   - fxy*_pz
    local    d = 1 - fyy*_pz
    local _det = 1/(a*d - b*c)
    local  npx = (d*px - b*py)*_det
    local  npy = (a*py - c*px)*_det

    m[i].x  = x - fx*_pz
    m[i].y  = y - fy*_pz
    m[i].px = npx
    m[i].py = npy
    m[i].t  = t + (1/beta+pt)*(npx*fx + npy*fy)*_pz^3
  end

  m.atdebug(elm, m, 'mult_fringe:1')
end

function sol_fringe (elm, m, lw)                                             -- unchecked
  -- TODO: shortcut
  m.atdebug(elm, m, 'solent_fringe:0')

  local m1, m2, p0, s0 in elm
  local ksi, beam in m
  local k , k2 = ksi, ksi^2
  local    ekm = exp(0.25*k2*m2)
  local   _ekm = 1/ekm
  local c1, c2 = sqrt(2/3)*_ekm, sqrt(3/8)*_ekm

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]

    local r2 = x^2+y^2
    local  J = x*py - y*px ; if lw == -1 then J = J + 0.5*k*r2 end
    local  q = x*px + y*py
    local J2, kJ, r, phi = J^2, k*J, sqrt(r2), atan2(y,x)
    local  J_r = J/r
    local  ekJ = exp(0.25*kJ)
    local _ekJ = 1/ekJ

    local R, Q, P, R2
    if lw == 1 then
      R = sqrt(J2 / (4+kJ + ekJ*((J_r*ekm)^2-4)))
      Q = (1 - (4-_ekJ*(4+kJ))*r2/J2*_ekm^2)
          *(c1*r*tan((c2*k2*m1)*r) - (0.125*k2)*r2^2*(p0+(3/32*s0)*r2) + q)
      P = phi - Q*(0.125*k-J*(R/J2)^2*(4*(1-ekJ)+kJ*(1+0.125*kJ)))
    else -- lw == -1
      R = ekm * sqrt(J2 / (4 + _ekJ*(J_r^2-4-kJ))) ; R2 = R^2
      Q = q/(1 - (4-_ekJ*(4+kJ))*R2/J2*_ekm^2)
          + c1*R*tan((c2*k2*m1)*R) - (0.125*k2)*R2^2*(p0+(3/32*s0)*R2)
      P = phi + q*(0.125*k-J*(r/J2)^2*(4*(1-ekJ)+kJ*(1+0.125*kJ)))
    end

    local cP, sP = cos(P), sin(P)
    local Q_R, J_R = Q/R, J/R

    if lw == 1 then J_R = J_R - (0.5*k)*R end

    m[i].x  =   R*cP
    m[i].px = Q_R*cP - J_R*sP
    m[i].y  =   R*sP
    m[i].px = Q_R*sP + J_R*cP
  end

  m.atdebug(elm, m, 'solent_fringe:1')
end

function cav_fringe (elm, m, lw) -- [FRINGECAV]                              -- checked
  if abs(m.el) < minlen or m.volt == 0 then return end
  m.atdebug(elm, m, 'cav_fringe:0')

  local el, volt, freq, lag, edir, beam in m
  local    w = freq*twopi_clight
  local wchg = beam.charge/beam.pc
  local   vl = 0.5*lw/el*wchg*edir*volt

!  printf('@@ vl=% -.16e, omega=% -.16e, phase=% -.16e, p0c=% -.16e, yl=% -.16e\n',
!          vl, w, lag, beam.pc, m.el*lw)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local  vl = beam and vl*beam.charge/(beam.pc*wchg) or vl
    local  s1 = sin(lag - w*t)
    local  c1 = cos(lag - w*t)

    m[i].px = px - vl*s1*x
    m[i].py = py - vl*s1*y
    m[i].pt = pt + (0.5*vl*w)*c1*(x^2 + y^2)
  end

  m.atdebug(elm, m, 'cav_fringe:1')
end

-- extra fringe (not used) ----------------------------------------------------o

function M.dipeg_fringe (elm, m, lw_) -- [MADX dipedge]                      -- unchecked
  if abs(m.knl[1]) < minstr then return end -- switched off
  m.atdebug(elm, m, 'dipeg_fringe:0')

  local lw = lw_ or 1
  local el, edir, sdir, edir, knl, beam in m
  local k0 = knl[1]/el*edir
  local corr, e = 0, 0

  if lw == 1 then
    e = m.e1*sdir*edir
    if not elm.kill_ent_fringe then
      corr = 2*k0*elm.hgap*elm.fint
    end
  else
    e = m.e2*sdir*edir
    if not elm.kill_exi_fringe then
      corr = 2*k0*elm.hgap*(elm.fintx or elm.fint)
    end
  end

  if e == 0 and corr == 0 then
  m.atdebug(elm, m, 'dipeg_fringe:1')
  return
  end

  local chg = beam.charge
  local r21 = k0*tan(e)
  local r43 = corr == 0 and -r21 or -k0 * tan(e - corr/cos(e)*(1+sin(e)^2))

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local chg = beam and beam.charge or chg

    m[i].px = px + chg*r21*x
    m[i].py = py + chg*r43*y
  end

  m.atdebug(elm, m, 'dipeg_fringe:1')
end

-- end ------------------------------------------------------------------------o
return { dynmap = M }
