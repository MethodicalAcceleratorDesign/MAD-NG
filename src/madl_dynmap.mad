--[=[
 o-----------------------------------------------------------------------------o
 |
 | Dynamic 6D maps
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: I. Shreyber, irina.tecker at cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a catalog of dynamical 6D maps (i.e. track)
    maps must have the following calling convention:
      dynmap(elm, map, length_weight)
    (see the symplectic integrators)
  - TODO: list the expected fields for elm and map

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- PTC variables:
-- L     thick weighted length
-- LD    thick weighted arc length
-- YL    kick  weighted length
-- B     relativistic beta0
-- B0    curvature = angle/LD
-- BN(1) k0
-- BN(2) k1
-- DIR   tracking direction

-- Note:
-- Is (_beta+pt) in t shouldn't be sqrt((_beta+pt)^2 - (_beta*_gamma)^2) ??
-- is it a 1st order approximation?

-- locals ---------------------------------------------------------------------o

local matrix                                                     in MAD
local is_nil, is_number                                          in MAD.typeid
local minlen, minang, clight, twopi                              in MAD.constant

local fnone                                                      in MAD.gfunc
local abs, sqrt, max, sin, cos, tan, asin, acos, atan, atan2,
      sinh, cosh, sinc, fact                                     in MAD.gmath

local drift = MAD.element.drift {}

-- constants
local volt_c = 1e-3

 -- forward declarations
local sbend_face, sbend_wedge, sbend_fringe, mult_fringe, straight_fringe

-- debug ----------------------------------------------------------------------o

local nodump = true

local function mdump(str, l, m)
  if nodump then return end
  assert(m.npar >= 1)
  print(str, l, m[1].x, m[1].px, m[1].y, m[1].py, m[1].t, m[1].pt)
end

-- field mutipoles ------------------------------------------------------------o

local function bxby (nmul, knl, ksl, x, y)
  local bx, by, byt = 0, 0

  for i=nmul,1,-1 do
    byt = by*x - bx*y + knl[i]
    bx  = by*y + bx*x + ksl[i]
    by  = byt
  end
  return bx, by
end

-- TODO: polar_bxby (nmul, knl, ksl, h, x, y) using TPSA (?)

-- patches (lw_ == 0 disable the patches) -------------------------------------o

-- X-rotation (pitch)

function M.xrotation (elm, m, lw_)  -- Rx(phi) [ROT_YZ]
  if lw_ == 0 then return end

  local phi = is_number(elm) and elm or (elm.phi or 0) + (elm.dphi or 0)
  if abs(phi) < minang then return end

  local tdir, npar in m
  phi = phi*tdir
  local sa, ca, ta = sin(phi), cos(phi), tan(phi)

  for i=1,npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = 1/(beam or m.beam).beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)
    local   _pz = 1/pz
    local   ptt = 1 - ta*py*_pz
    local  _ptt = y/ptt
    local  _pzt = ta*_pz*_ptt

    m[i].y  = _ptt/ca
    m[i].py = ca*py + sa*pz
    m[i].x  = x + _pzt*px
    m[i].t  = t - _pzt*(_beta+pt)
  end
end

-- Y-rotation (yaw)

function M.yrotation (elm, m, lw_)  -- Ry(theta) [ROT_XZ]
  if lw_ == 0 then return end

  local the = is_number(elm) and elm or (elm.theta or 0) + (elm.dtheta or 0)
  if abs(the) < minang then return end

  local tdir, npar in m
  the = the*tdir
  local sa, ca, ta = sin(the), cos(the), tan(the)

  for i=1,npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = 1/(beam or m.beam).beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)
    local   _pz = 1/pz
    local   ptt = 1 - ta*px*_pz
    local  _ptt = x/ptt
    local  _pzt = ta*_pz*_ptt

    -- eq. 127 in Forest06
    m[i].x  = _ptt/ca
    m[i].px = ca*px + sa*pz
    m[i].y  = y + _pzt*py
    m[i].t  = t - _pzt*(_beta+pt)
  end
end

-- S-rotation (roll, tilt)

function M.srotation (elm, m, lw_)  -- Rz(psi) [ROT_XY]
  if lw_ == 0 then return end

  local psi = is_number(elm) and elm or (elm.psi or 0) + (elm.dpsi or 0)
  if abs(psi) < minang then return end

  local tdir, npar in m
  psi = psi*tdir
  local sa, ca = sin(psi), cos(psi)

  for i=1,npar do
    local x, px, y, py in m[i]
    local nx  = ca*x  + sa*y
    local npx = ca*px + sa*py
    m[i].y    = ca*y  - sa*x
    m[i].py   = ca*py - sa*px
    m[i].x    = nx
    m[i].px   = npx
  end
end

-- Translation (dx, dy, dz)

function M.translate (elm, m, lw_) -- [TRANS]
  if lw_ == 0 then return end

  local dx = (elm.dx or 0) + (elm.ddx or 0)
  local dy = (elm.dy or 0) + (elm.ddy or 0)
  local dz = (elm.dz or 0) + (elm.ddz or 0)

  if abs(dx)+abs(dy)+abs(dz) < minlen then return end

  local tdir, npar in m
  dx = dx*tdir

  if abs(dz) < minlen then
    for i=1,npar do
      local x, y in m[i]
      m[i].x = x - dx
      m[i].y = y - dy
    end
    return
  end

  -- dz is treated as a drift without correction for the time of flight
  local T, sdir in m
  dz = dz*sdir

  for i=1,npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = 1/(beam or m.beam).beta
    local l_pz = l/sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)

    m[i].x = x + l_pz*px - dx
    m[i].y = y + l_pz*py - dy
    m[i].t = t - l_pz*(_beta+pt)
  end
end

-- Changeref (generic patch, dir>0: xyzt, dir<0: tzyx)

function M.changeref (elm, m, lw_)
  if lw_ == 0 then return end

  local dir = lw_ or 1

  if dir > 0 then
    M.xrotation(elm, m, lw_)
    M.yrotation(elm, m, lw_)
    M.srotation(elm, m, lw_)
    M.translate(elm, m, lw_)
  else
    M.translate(elm, m, lw_)
    M.srotation(elm, m, lw_)
    M.yrotation(elm, m, lw_)
    M.xrotation(elm, m, lw_)
  end
end

-- Changedir (reverse mflow t-direction)

function M.changedir (elm_, m, lw_)
  if lw_ == 0 then return end

  m.tdir = -m.tdir
end

-- Changenrj (change particles energy)

function M.changenrj (elm, m, lw_)  -- (to review, option to reset pt?)
  if lw_ == 0 then return end

  local dnrj = elm.dnrj
  if dnrj == 0 then return end

  local sdir, npar, beam in m
  beam.energy = beam.energy + dnrj*sdir

  for i=1,npar do
    beam = m[i].beam
    if beam then
      beam.energy = beam.energy + dnrj*sdir
    end
  end
end

-- DKD [INTER_DKD, angle == 0] ------------------------------------------------o

function M.strex_drift (elm, m, lw) -- [DRIFTR]                                 checked
  if abs(m.el) < minlen then return end

  local el, eld, sdir, npar, beam, T in m
  local l, ld = el*sdir*lw, eld*sdir*lw
  local _beta = 1/beam.beta

  mdump('strex_drift-0:', l, m)

  for i=1,npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local  l_pz = l/sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)

    m[i].x = x + px*l_pz
    m[i].y = y + py*l_pz
    m[i].t = t - (_beta+pt)*l_pz + (1-T)*ld*_beta
  end

  mdump('strex_drift-1:', l, m)
end

function M.strex_kick (elm, m, lw, no_k0l) -- [KICKEXR]                         checked
  if m.nmul == 0 then return end

  local tdir, npar, beam, nmul, knl, ksl in m
  local wchg = lw*tdir*beam.charge

  mdump('strex_kick-0:', 0, m)

  for i=1,npar do
    local x, px, y, py, beam in m[i]
    local wchg = beam and lw*tdir*beam.charge or wchg
    local bx,by = bxby(nmul, knl, ksl, x, y)

    if no_k0l then by = by - knl[1] end

    m[i].px = px - wchg*by
    m[i].py = py + wchg*bx
  end

  mdump('strex_kick-1:', 0, m)
end

function M.strex_hkick (elm, m, lw) -- [KICKTR]                                 unchecked
  if m.nmul == 0 then return end

  local el, sdir, tdir, npar, beam, nmul, knl, ksl in m
  local wchg = lw*tdir*beam.charge
  local _beta = 1/beam.beta

  mdump('strex_hkick-0:', el*sdir*lw, m)

  for i=1,npar do
    local x, px, y, py, t, pt, beam in m[i]
    local  wchg = beam and lw*tdir*beam.charge or wchg
    local _beta = beam and 1/beam.beta or _beta
    local bx,by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px - wchg*(by - knl[1])
    m[i].py = py + wchg*(bx - ksl[1])

    -- dipole focusing and delta_p
    local dpp1 = sqrt(1 + (2*_beta)*pt + pt^2)
    if el ~= 0 then
      local dp = dpp1 - 1
      m[i].px = m[i].px - (knl[1]^2/el)*x + (wchg*knl[1])*dp
      m[i].py = m[i].py - (ksl[1]^2/el)*y + (wchg*ksl[1])*dp
    end
      m[i].t  = t - wchg*(knl[1]*x - ksl[1]*y) * (_beta+pt)/dpp1
  end

  mdump('strex_hkick-1:', el*sdir*lw, m)
end

function M.strex_fringe (elm, m, lw) -- [??] re-defined to fnone hereafter
  mdump('strex_fringe-0:', m.eld*m.sdir*lw, m)
  error("NYI")

  local nmul, sdir in m
  if nmul == 0 then return end

  if pos == 'entry' then
    local e, h = elm.e1 or 0, elm.h1 or 0
    if sdir == 1 then
      M.yrotation  (elm, m, e)
      sbend_face   (elm, m, h)
      sbend_fringe (elm, m, 'entry')
    else
      sbend_fringe (elm, m, 'entry')
      sbend_face   (elm, m, h)
      M.yrotation  (elm, m, e)
    end
    mult_fringe    (elm, m, 'entry')
    straight_fringe(elm, m, 'entry')
    return
  end

  if pos == 'exit' then
    local e, h = elm.e2 or 0, elm.h2 or 0
    straight_fringe(elm, m, 'exit')
    mult_fringe    (elm, m, 'exit')
    if sdir == 1 then
      sbend_fringe (elm, m, 'exit')
      sbend_face   (elm, m, h)
      M.yrotation  (elm, m, e)
    else
      M.yrotation  (elm, m, e)
      sbend_face   (elm, m, h)
      sbend_fringe (elm, m, 'exit')
    end
    return
  end

  mdump('strex_fringe-1:', m.eld*m.sdir*lw, m)
end

M.strex_fringe = fnone -- TODO: see above

-- DKD [INTER_TEAPOT, angle ~= 0] ---------------------------------------------o

function M.curex_drift (elm, m, lw) -- [SPROT]
  if abs(m.el) < minlen then return end

  local eld, ang, sdir, tdir, npar, beam, T in m
  local ld, ang = eld*sdir*lw, ang*tdir*lw
  local _beta = 1/beam.beta

  local sa, ca, ta, sa2 = sin(ang), cos(ang), tan(ang), sin(ang/2)
  local rho = ld/ang

  mdump('curex_drift-0:', ld, m)

  for i=1,npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local    pz = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2)
    local   _pz = 1/pz
    local   pxt = px*_pz
    local   ptt = (1 - ta*pxt)*ca
    local  _ptt = 1/ptt
    local   pst = (x+rho)*sa*_pz*_ptt

    m[i].x  = (x + rho*(2*sa2^2 + sa*pxt))*_ptt
    m[i].px = ca*px + sa*pz
    m[i].y  = y + pst*py
    m[i].t  = t - pst*(_beta+pt) + (1-T)*ld*_beta
  end

  mdump('curex_drift-1:', ld, m)
end

function M.curex_kick (elm, m, lw) -- [SKICK]
  if m.nmul == 0 then return end

  local ang, tdir, npar, beam, nmul, knl, ksl in m
  local wchg = lw*tdir*beam.charge
  local ang = ang*tdir*lw
  local h = ang

  mdump('curex_kick-0:', m.eld*m.sdir*lw, m)

  for i=1,npar do
    local x, px, y, py, beam in m[i]
    local wchg = beam and lw*tdir*beam.charge or wchg
    local bx, by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px - (1 + h*x)*wchg*by
    m[i].py = py + (1 + h*x)*wchg*bx
  end

  mdump('curex_kick-1:', m.eld*m.sdir*lw, m)
end

function M.curex_fringe (elm, m, lw) -- [??] re-defined to fnone hereafter
  mdump('curex_fringe-0:', m.eld*m.sdir*lw, m)
  error("NYI")

  if pos == 'entry' and not elm.kill_ent_fringe then
    local e, h = elm.e1 or 0, elm.h1 or 0
    if abs(e) < minang then
      sbend_face  (elm, m,  h)
      sbend_fringe(elm, m, 'entry')
    else
      M.yrotation (elm, m,  e)
      sbend_face  (elm, m,  h)
      sbend_fringe(elm, m, 'entry')
      sbend_wedge (elm, m, -e)
    end
    return
  end

  if pos == 'exit' and not elm.kill_exi_fringe then
    local e, h = elm.e2 or 0, elm.h2 or 0
    if abs(e) < minang then
      sbend_fringe(elm, m, 'exit')
      sbend_face  (elm, m,  h)
    else
      sbend_wedge (elm, m, -e)
      sbend_fringe(elm, m, 'exit')
      sbend_face  (elm, m,  h)
      M.yrotation (elm, m,  e)
    end
    return
  end

  mdump('curex_fringe-1:', m.eld*m.sdir*lw, m)
end

M.curex_fringe = fnone -- TODO: see above

-- TKT [INTER_STREX] ----------------------------------------------------------o

function M.rbend_thick (elm, m, lw) -- [SPARR]
  local el, eld, k0, sdir, tdir, npar, knl, T in m
  local l, ld = el*lw*sdir, eld*lw*sdir

  mdump('rbend_thick-0:', l, m)

  for i=1,npar do
    local x, px, y, py, t, pt in m[i]
    local  beam = m[i].beam or m.beam
    local  bdir = beam.charge*tdir
    local _beta = 1/beam.beta

    local  pw2 = 1 + 2*_beta*pt + pt^2 - py^2
    local   pz = sqrt(pw2 - px^2)
    local  ptt = sqrt(pw2)
    local _ptt = 1/ptt
    local  npx = px - l*knl[1]*bdir
    local  pzs = sqrt(pw2 - npx^2)
    local   nx = x + (pzs-pz)/(knl[1]*bdir)
    local  pzt = (asin(px*_ptt) - asin(npx*_ptt))/(knl[1]*bdir)

    -- eq. 129 in Forest06
    m[i].x  = nx
    m[i].px = npx
    m[i].y  = y + pzt*py
    m[i].t  = t - pzt*(_beta+pt) + (1-T)*ld*_beta
  end

  mdump('rbend_thick-1:', l, m)
end

M.rbend_kick   = \el,m,lw => M.strex_kick(el,m,lw,true) end
M.rbend_fringe = M.strex_fringe

-- TKT [INTER_TEAPOT] ---------------------------------------------------------o

function M.sbend_thick (elm, m, lw) -- [SSECR]
  local el, ang, k0, sdir, tdir, npar, T in m
  el, ang, k0 = el*lw*sdir, ang*lw*tdir, k0*tdir

  local rho = el/ang
  local sa, ca = sin(ang), cos(ang)

  mdump('sbend_thick-0:', m.eld*m.sdir*lw, m)

  for i=1,npar do
    local x, px, y, py, t, pt in m[i]
    local  beam = m[i].beam or m.beam
    local   k0q = k0*beam.charge
    local _beta = 1/beam.beta

    local  pw2 = 1 + 2*_beta*pt + pt^2 - py^2
    local   pz = sqrt(pw2 - px^2)
    local  pzx = pz - (rho+x)*k0q
    local  npx =  ca*px + sa*pzx
    local  dpx = -sa*px + ca*pzx
    local   ps = sqrt(pw2 - npx^2)
    local  ptt = sqrt(pw2)
    local _ptt = 1/ptt
    local  dxs = (ang + asin(px*_ptt) - asin(npx*_ptt))/k0q

    -- eq. 126 in Forest06
    m[i].x  = (ps-dpx)/k0q - rho   -- x + ... ??
    m[i].px = npx
    m[i].y  = y + dxs*py
    m[i].t  = t - dxs*(_beta+pt) + (1-T)*_beta*el
  end

  mdump('sbend_thick-1:', m.eld*m.sdir*lw, m)
end

function M.sbend_kick (elm, m, lw) -- [SKICKR]
  if m.nmul == 0 then return end

  local ang, tdir, npar, beam, nmul, knl, ksl in m
  local wchg = lw*tdir*beam.charge
  local ang = ang*tdir*lw
  local h = ang

  -- [SET_S_B -> S_B_from_V] -- should be done with TPSA
  -- [GETANBNR]
  -- [GETMAGNETICR]

  mdump('sbend_kick-0:', m.eld*m.sdir*lw, m)

  for i=1,npar do
    local x, px, y, py, beam in m[i]
    local wchg = beam and lw*tdir*beam.charge or wchg
    local bx, by = bxby(nmul, knl, ksl, x, y)

    -- TODO...
    m[i].px = px - wchg*by
    m[i].py = py + wchg*bx

--    X(2)=X(2)+YL*DIR*B(1)
--    X(4)=X(4)+YL*DIR*B(2)
--    IF(.NOT.EL%DRIFTKICK) THEN
--       X(2)=X(2)+YL*DIR*EL%BN(1)*(1.0_dp+X(1)*EL%P%B0)
--    ENDIF
  end

  mdump('sbend_kick-1:', m.eld*m.sdir*lw, m)

  error("NYI")
end

M.sbend_kick   = M.curex_kick -- TODO: case angle ~= k0l
M.sbend_fringe = M.curex_fringe

-- TKT [INTER_TKTF] -----------------------------------------------------------o

local function drift_adj (l, m) -- [KICKPATH] drift adjustment                  checked
  local npar, beam, T in m
  local _beta = 1/beam.beta

  mdump('drift_adj-0:', l, m)

  for i=1,npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local l_pz = l/sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)

    m[i].x = x + px*(l_pz-l)
    m[i].y = y + py*(l_pz-l)
    m[i].t = t - (_beta+pt)*l_pz + (1-T)*l*_beta
  end

  mdump('drift_adj-1:', l, m)
end

function M.quad_thick (elm, m, lw) -- [PUSHTKT7]                                checked
  local el, k1, sdir, tdir, npar, beam in m
  local l = el*sdir*lw
  local chg = beam.charge

  -- [GETMAT7R, h == 0]
  local ws = k1*tdir*sdir < 0 and -1 or 1
  local w  = sqrt(abs(k1))*tdir*ws
  local cx, sx = cos (w*l), sin (w*l)
  local cy, sy = cosh(w*l), sinh(w*l)
  local mx1, mx2 = sx/w, -sx*w
  local my1, my2 = sy/w,  sy*w
-- [GETMAT7R]

  mdump('quad_thick-0:', l, m)

  for i=1,npar do
    local x, px, y, py, t, pt, beam in m[i]
    local chg = beam and beam.charge or chg

    if ws ~= chg then -- swap x <-> y
      ws, cx, cy, mx1, mx2, my1, my2 = -ws, cy, cx, my1, my2, mx1, mx2
    end

    local nx  = x*cx  + px*mx1
    local npx = x*mx2 + px*cx
    local ny  = y*cy  + py*my1
    local npy = y*my2 + py*cy

    m[i].x   = nx
    m[i].y   = ny
    m[i].px  = npx
    m[i].py  = npy
  end

  mdump('quad_thick-1:', l, m)
end

function M.quad_kick (elm, m, lw) -- [KICKTKT7]                                 checked
  local el, sdir, tdir, npar, beam, nmul, knl, ksl in m
  local l = el*lw*sdir
  local  bdir = beam.charge*tdir
  local _beta = 1/beam.beta

  drift_adj(l/2, m)

  mdump('quad_kick-0:', l, m)

  for i=1,npar do
    local x, px, y, py, t, pt, beam in m[i]
    local  bdir = beam and beam.charge*tdir or bdir
    local _beta = beam and 1/beam.beta or _beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2) - 1
    local bx,by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px - l*bdir*(by - knl[1] - knl[2]*x)
    m[i].py = py + l*bdir*(bx          - knl[2]*y)
  end

  mdump('quad_kick-1:', l, m)

  drift_adj(l/2, m)
end

M.quad_fringe = M.strex_fringe

-- special case

function M.quad_hthick (elm, m, lw) -- [PUSHTKT7]                               unchecked
  local el, eld, eh, k0, k1, sdir, tdir, npar, beam in m
  local chg, cx, cy, sx, sy, mx12, mx21, mx13, my12, my21, mx33

  local l = el*lw*sdir
  local h = eh*tdir*sdir

  mdump('quad_hthick-0:', l, m)

  for i=1,npar do
    local x, px, y, py, t, pt in m[i]
    local beam = m[i].beam or beam
    local h_b = h/beam.beta

    if chg ~= beam.charge then -- [GETMAT7R]
      chg = beam.charge
      local bdir = tdir*chg
      local kx, ky = k1+h*k0, k1
      local wx = sqrt(abs(kx))*bdir
      local wy = sqrt(abs(ky))*bdir
      local wsx, wsy

      if kx*bdir*sdir < 0
      then cx, sx, wsx = cosh(wx*l), sinh(wx*l), -1
      else cx, sx, wsx = cos (wx*l), sin (wx*l),  1
      end
      if ky*bdir*sdir < 0
      then cy, sy, wsy = cos (wy*l), sin (wy*l), -1
      else cy, sy, wsy = cosh(wy*l), sinh(wy*l),  1
      end

      mx12, mx21, mx13 = sx/wx, -sx*wx*wsx, (1-cx  )/wx^2*wsx
      my12, my21, mx33 = sy/wy,  sy*wy*wsy, (l-mx21)/wx^2*wsx
    end

--[[ MATRIX REPRESENTATION FROM PTC [GETMAT7R]
    { cx            , sx/wx                , h*(1-cx)/wx2*ws*_beta     ,
     -sx*wx*ws      , cx                   , h*sx/wx                   ,
      h*sx/wx*_beta , h*(1-cx)/wx2*ws*_beta, h^2*(l-sx/wx)/wx2*ws*_beta }
    { cy      , sy/wy, 0,
      sy*wy*ws, cy   , 0}
--]]

    local nx  = x*cx       + px*mx12     + pt*mx13*h_b
    local npx = x*mx21     + px*cx       + pt*mx12*h_b
    local ny  = y*cy       + py*my12
    local npy = y*my21     + py*cy
    local nt  = x*mx12*h_b + px*mx13*h_b + pt*mx33*h^2

    m[i].x   = nx
    m[i].y   = ny
    m[i].px  = npx
    m[i].py  = npy
    m[i].t   = t - nt
  end

  mdump('quad_hthick-1:', l, m)
end

function M.quad_hkick (elm, m, lw) -- [KICKTKT7]                                unchecked
  local el, eh, sdir, tdir, npar, nmul, knl, ksl in m
  local l = el*lw*sdir
  local h = eh*tdir*sdir

  drift_adj(l/2, m)

  mdump('quad_hkick-0:', l, m)

  for i=1,npar do
    local x, px, y, py, t, pt in m[i]
    local  beam = m[i].beam or m.beam
    local  bdir = beam.charge*tdir
    local _beta = 1/beam.beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2) - 1
    local bx,by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px + l*bdir*(h*(pz-pt*_beta) - (by - knl[1] - knl[2]*x))
    m[i].py = py + l*bdir*(                  (bx          - knl[2]*y))
    m[i].t  =  t - l*h*((pt+_beta)/(1+pz) - _beta)*x
  end

  mdump('quad_hkick-1:', l, m)

  drift_adj(l/2, m)
end

-- TKT [INTER_TEAPOT] ---------------------------------------------------------o

function M.combi_thick (elm, m, l) -- [??]
  local k0, k1, l, angle in elm
  l, angle = l*lw, angle*lw
  if abs(k0*l-angle) < minang and abs(k1*l) < minang then
    return M.sbend_thick(elm, m, lw)
  end

  local _el   = 1/elm.l
  local _beta = 1/m.beam.beta
  local l_bet2_gam2 = l/(m.beam.gamma^2-1)

  local angle = elm.angle
  local lw    = l*_el
  local h     = lw*angle
  local hbar  = h*_beta

  local knl, bdir in m
  local k0, k1 = bdir*knl[1]*_el, bdir*knl[2]*_el
  local hk0pk1 = h*k0+k1
  local wx2, wy2 = abs(hk0pk1), abs(k1)
  local wx , wy  = sqrt(wx2), sqrt(wy2)

  local cx, sx, cy, sy
  if hk0pk1 < 0
  then cx, sx = cosh(wx*l), sinh(wx*l)/wx -- check wx == 0
  else cx, sx = cos (wx*l), sin (wx*l)/wx -- check wx == 0
  end
  if k1 < 0
  then cy, sy = cosh(wy*l), sinh(wy*l)/wy -- check wy == 0
  else cy, sy = cos (wy*l), sin (wy*l)/wy -- check wy == 0
  end

--  local npos in m
--  M.drift_adj(npos == 'last' and l or l/2, m)

  local x, px, y, py, t, pt in m
  local m16, m56 = (1-cx)/wx2, hbar^2*(l-sx)/wx2

  m.x  =      cx*x + sx*px + hbar*m16*pt + (h-k0)*m16
  m.px = -wx2*sx*x + cx*px + hbar*sx*pt  + (h-k0)*sx
  m.y  =      cy*y + sy*py
  m.py =  wy2*sy*y + cy*py
  m.t  = t - hbar*(sx*x+m16*px) + (l_bet2_gam2-m56)*pt

--  M.drift_adj(npos == 'first' and l or l/2, m)
end

function M.combi_kick (elm, m, l) -- [??]
  error("NYI")
end

M.combi_fringe = fnone

-- TKT [INTER_SOL5] -----------------------------------------------------------o

function M.solen_thick (elm, m, l) -- [??]                                      unchecked
  local el, ksi, sdir, tdir, npar, T in m
  local l = el*sdir*lw
  local ks = 0.5*ksi*tdir/l

  mdump('solen_thick-0:', l, m)

  for i=1,npar do
    local x, px, y, py, t, pt, beam in m[i]
    local  beam = m[i].beam or m.beam
    local  bsol = ks*beam.charge
    local _beta = 1/beam.beta
    local    xp = px + bsol*y
    local    yp = py - bsol*x
    local  l_pz = l/sqrt(1 + 2*_beta*pt + pt^2 - xp^2 - yp^2)
    local   ang = l_pz*bsol

    local ca, sa, sc = cos(ang), sin(ang), sinc(ang)

    local xt  = ca*x  + l_pz*sc*px
    local pxt = ca*px - l_pz*sc*x *bsol^2
    local yt  = ca*y  + l_pz*sc*py
    local pyt = ca*py - l_pz*sc*y *bsol^2

    m[i].x  = ca*xt  + sa*yt
    m[i].px = ca*pxt + sa*pyt
    m[i].y  = ca*yt  - sa*xt
    m[i].py = ca*pyt - sa*pxt
    m[i].t  = t - (_beta+pt)*l_pz + (1-T)*l*_beta
  end

  mdump('solen_thick-1:', l, m)
end

M.solen_kick   = M.strex_kick
M.solen_fringe = fnone -- TODO

-- rfcavity -------------------------------------------------------------------o

M.rfcav_thick = M.strex_drift

function M.rfcav_kick (elm, m, lw) -- [??]
  error("NYI")

-- missing input: tt, phase, phase0, ff, ph, a, r, nbessel, freq, volt, lag

--  local x, px, y, py, t, pt, bdir, nmul, knl, ksl in m
--  local volt, freq, lag, nbessel in elm
--
--  if freq == 0 then
--    error("Frequency number has to be defined for RF Cavity (i.e. harmon NYI) "
--          .. elm.name)
--  end
--
--  local pc = m.beam.pc
--  local omega = twopi*freq / clight
--  local vl    = bdir*l*volt*volt_c/pc
--  local df, f, r2 = 0, 1, 1
--
--  do i=1,nbessel
--    r2  = -r2*(ko*omega)^2/(4*(i+1)^2)
--    dr2 =  r2*i
--    df  =  df + 2*dr2
--    r2  =  r2*(x^2+y^2)
--    f   =  f + r2
--  end
--
--  local ff, ph = elm.f or {}, elm.ph or {}
--  local a , r  = elm.a or  0, elm.r or 0
--  local arg = omega*(t + tt) + phasÐµ + ph + phase0
--
--  if nbessel > 0 then
--    m.px = px-x*ff[ko]* df * vl * cos(arg)/(omega)
--    m.py = py-y*ff[ko]* df * vl * cos(arg)/(omega)
--  end
--
--  m.pt = m.pt -ff*f*vl*sin(arg)
--
--  local lw = elm.l>0 and l/elm.l or 1
--  local bx, by = bxby(nmul, knl, ksl, x, y, lw)
--
--  m.px = m.px - ff[ko]*           bdir*by/pc*(a + r*cos(arg))
--  m.py = m.py + ff[ko]*           bdir*bx/pc*(a + r*cos(arg))
--  m.pt = m.pt + ff[ko]*(ko*omega)*bdir*by/pc*     r*sin(arg)

--[[ useful???
  by = -lw*knl[nmul] / fact(nmul-1) / nmul
  bx = -lw*ksl[nmul] / fact(nmul-1) / nmul

  for i=nmul-1,1,-1 do
    byt = x*by - y*bx - lw*knl[i] / fact(i-1) / i
    bx  = y*by + x*bx - lw*ksl[i] / fact(i-1) / i
    by  = byt
  end

  byt = x*by - y*bx
  bx  = y*by + x*bx
  by  = byt
]]
end

M.rfcav_fringe = fnone -- TODO

-- fringes --------------------------------------------------------------------o

function sbend_face (elm, m, h) -- [??]
  local x, px, y, py, t, pt, bdir in m
  local k0 = elm.k0 or 0
  local _beta = 1/m.beam.beta

  if bdir == 1 then -- to insure reversal symmetry ; horizontal wedge (only dir)
    px = px +(bdir*k0*h/2)*x^2
  end

  local ptt =        sqrt(1 + 2*pt*_beta + pt^2 - px^2)
  local xi  = bdir*sqrt(1 + 2*pt*_beta + pt^2)*k0*h/ptt^2
  local dxi_px   =  2*px*xi/ptt^2
  local dxi_ddel = -2*xi*(1 + pt)/ptt^2

  x  = x / (1-dxi_px*y^2)
  px = px - xi*y^2
  py = py - 2*xi*x*y
  t  = t  - dxi_ddel*x*y^2

  if(bdir == -1) then -- to insure reversal symmetry; horizontal wedge (only dir)
    px = px +(bdir*k0*h/2)*x^2
  end

  m.x  = x
  m.px = px
  m.py = py
  m.t  = t
end

function sbend_wedge (elm, m, e) -- [??]
  local x, px, y, py, t, pt, T, bdir in m
  local k0 = elm.k0 or 0
  local _beta = 1/m.beam.beta
  local b1 = bdir*k0
  local sa, ca, sa2 = sin(e), cos(e), sin(2*e)

  if b1 == 0 then
    yrot_track (elm, m, e) return
  end

  local pz  = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2)
  local ptt = sqrt(1 + 2*_beta*pt + pt^2        - py^2)
  local pxt = px*ca + (pz - b1*x)*sa
  local pzs = sqrt(1 + 2*_beta*pt + pt^2 - py^2 - pxt^2)
  local yt  = (e + asin(px/ptt) - asin(pxt/ptt)) / b1

  m.x  = x*ca + (x*px*sa2 + sa^2*(2*x*pz-b1*x^2)) / (pzs+pz*ca-px*sa)
  m.px = pxt
  m.y  = y + py * yt
  m.t  = t - yt*(_beta + pt)
end

function sbend_fringe (elm, m, pos) -- [??]
--  TODO: FINT and FINTX to have different FINT at entrance /exit
  local x, px, y, py, t, pt, T in m
  local k0   = elm.k0 or 0
  local _beta = 1/m.beam.beta
-- soft edge
  local fint = elm.fint or 0  -- fringe field integral at entrance and exit of the bend
  local hgap = elm.hgap or 0  -- half gap of the magnet
  local fsad = 0

  if fint*hgap ~= 0.0 then  -- soft edge
      fsad = 1/(fint*hgap*2)/36
  end

  local b = m.beam.charge*k0
  if pos == 'exit' then
     b = -b
  end

  local pz = sqrt(1 + 2*_beta*pt + pt^2 - px^2 - py^2)
  local time_fac = _beta + pt
  local rel_p    = sqrt(1 + 2*_beta*pt + pt^2)

  local c3=b^2*fsad/rel_p

  local xp, yp = px/pz or 0, py/pz or 0
  local d = matrix { -- to remove!
    { (1+xp^2) / pz, xp*yp    / pz, -time_fac*xp /pz^2 },
    {  xp*yp   / pz, (1+yp^2) / pz, -time_fac*yp /pz^2 },
    { -xp          ,   -yp        ,  time_fac    /pz   },
  }

  local fi0 = atan((xp/(1 + yp^2)))-2*b*fint*hgap*(1 + xp^2*(2 + yp^2))*pz
  local co2 = b/cos(fi0)^2
  local co1 = co2/(1 + (xp/(1 + yp^2))^2)

  local fi = {0, 0, 0}
  fi[1] =    co1 /       (1 + yp^2) - 2*co2*b*fint*hgap* (2*xp*(2 + yp^2)*pz)
  fi[2] =-2*co1*xp*yp/(1 + yp^2)^2  - 2*co2*b*fint*hgap* (2*xp^2*yp)*pz
  fi[3] =                           - 2*co2*b*fint*hgap* (1 + xp^2*(2 + yp^2))

  fi0=b*tan(fi0)

  b=0
  for i=1,3 do -- y column
    b=fi[i]*d:get(i,2) + b
  end
  m.y  = 2*m.y/(1 + sqrt(1 - 2*b*m.y))
  m.py = py - fi0*m.y

  b=0
  for i=1,3 do -- x column
    b=fi[i]*d:get(i,1) + b
  end
  m.x = m.x+0.5*b*m.y^2

  b=0
  for i=1,3 do -- z column
    b=fi[i]*d:get(i,3) + b
  end
  m.t = t + 0.5*b*m.y^2

  -- soft edge
  m.py = m.py - 4*c3*m.y^3
  m.t  = m.t  +   c3*m.y^4/rel_p^2*time_fac
end

function mult_fringe (elm, m) -- [??]
  local x, px, y, py, bdir, nmul, knl, ksl in m
  local _beta = 1/m.beam.beta
  local _l = 1/elm.l

  local rx, ix, fx, fy, fxx, fxy, fyx, fyy = 1, 0, 0, 0, 0, 0, 0, 0

	for i=1, nmul do
	  local drx, dix = rx, ix
    rx  = drx*x - dix*y
    ix  = drx*y + dix*x

    local ni, nf = -bdir/(4*(i+1)), i+2/i
    local lkn, lks = knl[i]*_l, ksl[i]*_l

    local u   =  ni*(lkn*rx  - lks*ix )
    local v   =  ni*(lkn*ix  + lks*rx )
    local du  =  ni*(lkn*drx - lks*dix)
    local dv  =  ni*(lkn*dix + lks*drx)
	  local dux =   i*du
    local dvx =   i*dv
    local duy =  -i*dv
    local dvy =   i*du

    fx  = fx  +   u*x + nf*       v*y
    fy  = fy  +   u*y - nf*       v*x
    fxx = fxx + dux*x + nf*     dvx*y + u
    fyy = fyy + duy*y - nf*     dvy*x + u
    fxy = fxy + duy*x + nf*(v + dvy*y)
    fyx = fyx + dux*y - nf*(v - dvx*x)
	end

  local _pz = 1/sqrt(1 + 2*pt*_beta + pt^2)
  local a = 1 - fxx*_pz
  local d = 1 - fyy*_pz
  local b =   - fyx*_pz
  local c =   - fxy*_pz
  local _det = 1/(a*d - b*c)

  m.x  = x - fx*_pz
  m.y  = y - fy*_pz
  m.px = (d*px - b*py)*_det
  m.py = (a*py - c*px)*_det
  m.t  = t + (_beta+pt)*(m.px*fx + m.py*fy)*_pz^3
end

function straight_fringe (elm, m) -- [??]
-- Lee-Whiting formula, E. Forest ch 13.2.3, eq 13.33
	local x, px, y, py, t, pt, T, bdir in m
  local k0   = elm.k0 or 0
  local _beta = 1/m.beam.beta
-- soft edge
  local fint = elm.fint or 0  -- fringe field integral at entrance and exit of the bend
  local hgap = elm.hgap or 0  -- half gap of the magnet

  local _pz  = 1/sqrt(1 + 2*_beta*pt + pt^2 )
  local time_fac = (_beta + pt)*_pz

  local a2, b2 = elm.ksl[2]/elm.l or 0, elm.knl[2]/elm.l or 0
  local b  = sqrt(b2^2 + a2^2)

  local f1 = -bdir*fint*abs(fint)*b*_pz/24.0
  local f2 =  hgap*b*_pz

  local ang=-atan2(a2,b2)/2

  tilt(-ang or 0, m)

  m.t = t - time_fac*(f1*x + f2*(1+f1/2)*px*_pz*exp(-f1))*px*_pz
          + time_fac*(f1*y + f2*(1-f1/2)*py*_pz*exp( f1))*py*_pz

  m.x = x*exp( f1) + px*f2*_pz
  m.y = y*exp(-f1) - py*f2*_pz

  m.px = px*exp(-f1)
  m.py = py*exp( f1)

  tilt(-ang or 0, m)
end

-- TODO: extra maps for SABAC integrators -------------------------------------o

function M.drift_sabac (elm, m, lw)
  local el, sdir, npar, beam, T in m
  local l = el*lw*sdir

  mdump('drift_sabac-0:', l, m)

  for i=1,npar do
    local x, px, y, py, t, pt in m[i]
    local _beta = 1/(m[i].beam or beam).beta
    local l_dp = l/(1 + (2*_beta)*pt + pt^2)

    m[i].x = x + px*l_dp
    m[i].y = y + py*l_dp
    m[i].t = t - 0.5*(px^2+py^2)*l_dp^2/l
  end

  mdump('drift_sabac-1:', l, m)
end

function M.quad_corr_sabac (elm, m, lw, w)
  local el, sdir, tdir, npar, k1 in m
  local l, k1w2 = el*lw*sdir, k1^2*tdir*w

  mdump('quad_corr_sabac-0:', l, m)

  for i=1,npar do
    local x, px, y, py, t, pt in m[i]
    local  beam = m[i].beam or m.beam
    local  bdir = tdir*beam.charge
    local _beta = 1/beam.beta
    local  l_dp = l/(1 + (2*_beta)*pt + pt^2)

    m[i].px = px + l^2*k1w2*x*l_dp
    m[i].py = py + l^2*k1w2*y*l_dp
    m[i].t  = t  + l  *k1w2*0.5*(x^2+y^2)*l_dp^2
  end

  mdump('quad_corr_sabac-1:', l, m)
end

-- end ------------------------------------------------------------------------o
return { dynmap = M }
