--[=[
 o-----------------------------------------------------------------------------o
 |
 | Dynamic 6D maps
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: I. Shreyber, irina.tecker at cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o
  Acknowledgements:

  The physics implemented in this module is for the most part taken from the
  work of E. Forest through his two books and numerous articles and reports on
  the subject, and for some parts, from the translation of his Fortran code
  PTC/FPP. The rest of the physics is taken from various publications. The
  structure of the code, the choice of the integrators and the maps according
  to the configuration of the commands and the elements are my own.

  MAD-NG supports almost direct translation of equations into code that works
  for both, particles (orbit) tracking and optics (damap) tracking at the same
  time, including parametric damaps with knobs. This unique feature facilitates
  the translation of new physics from publications with explicit equations.
 o-----------------------------------------------------------------------------o
  Purpose:

  - Provide a catalog of dynamical 6D maps (i.e. track) with the following
    calling convention: dynmap(elm, map, len_weight), see the sympint module.
  - TODO: list the expected attributes for elm and map
 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- settings
local new_bend_thick = false -- true (take new maps, worst)

--[=[
Notes about directions and quantities:
  element direction   edir: affects curvatures    (edir = seq.dir).
  track direction (s) sdir: affects lengths       (sdir = cmd.dir).
  time direction  (t) tdir: affects angles & nrj  (tdir = edir x sdir).
  beam direction      bdir: affects strengths & V (bdir = edir x sdir x chg).
--]=]

--[=[
Notes about PTC variables vs MAD:
  DIR  : tracking direction        = sdir
  B    : relativistic beta0        = beta
  L    : thick weighted length     = lw*el
  YL   : kick  weighted length     = lw*el
  LD   : thick weighted arc length = lw*(eld or el)
  B0   : curvature = angle/LD      = eh
  BN(1): dip  normal strength      = k0
  AN(1): dip  skew   strength      = k0s
  BN(2): quad normal strength      = k1
  AN(2): quad skew   strength      = k1s
  BN(3): sext normal strength      = k2
  AN(3): sext skew   strength      = k2s
  etc...
--]=]

--[=[
Notes and questions:
  Is (_beta+pt) in t eq. shouldn't be sqrt((_beta+pt)^2 - (_beta*_gamma)^2) ??
  is it a linear order approximation?
--]=]

-- locals ---------------------------------------------------------------------o

local _C, vector, matrix                                         in MAD
local is_nil, is_number, is_damap                                in MAD.typeid
local minlen, minang, minstr, clight, qelect, pi, twopi, pi_2    in MAD.constant
local printf                                                     in MAD.utility
local pt2beta                                                    in MAD.gphys

local abs, sqrt, invsqrt, exp, log, sin, cos, tan, asin, acos,
      atan, atan2, hypot, sinh, cosh, sinc, sinhc, asinc         in MAD.gmath

local min, max in math
local assert = assert

local    pi_clight =    pi/clight
local twopi_clight = twopi/clight

-- field mutipoles ------------------------------------------------------------o

local function bxby (nmul, knl, ksl, x, y)
  local bx, by, byt = ksl[nmul], knl[nmul]

  for i=nmul-1,1,-1 do
    byt = by*x - bx*y + knl[i]
    bx  = by*y + bx*x + ksl[i]
    by  = byt
  end

  return bx, by
end

local function bxbyh (snm, bfx, bfy, x, y)
  local bx, by, k = 0, 0, 0

  for i = snm,1,-1 do
    local btx, bty = 0, 0

    for j = snm-i,1,-1 do
      k = k+1
      btx = (btx + bfx[k]) * y
      bty = (bty + bfy[k]) * y
    end

    k = k+1
    bx = (bx + btx + bfx[k]) * x
    by = (by + bty + bfy[k]) * x
  end

  local btx, bty = 0, 0
  for i = snm,1,-1 do
    k = k+1
    btx = (btx + bfx[k]) * y
    bty = (bty + bfy[k]) * y
  end
  
  bx = bx + btx + bfx[k+1]
  by = by + bty + bfy[k+1]

  return bx, by
end

-- patches --------------------------------------------------------------------o

-- X-rotation

local function xrotation (elm, m, lw_, dphi_)  -- Rx(ax) [ROT_YZ]            -- checked
  local ax = dphi_ or elm.angle*m.tdir
  if abs(ax) < minang then return end

  m.atdebug(elm, m, lw_, 'xrotation:0')

  local ax = ax*(lw_ or 1)
  local sa, ca, ta = sin(ax), cos(ax), tan(ax)
  local _beta = 1/m.beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)
    local   _pz = 1/pz
    local   ptt = 1 - ta*py*_pz
    local  _ptt = y/ptt
    local  _pzt = ta*_pz*_ptt

    -- eq. 127 in Forest06
    m[i].y  = _ptt/ca
    m[i].py = ca*py + sa*pz
    m[i].x  = x + _pzt*px
    m[i].t  = t - _pzt*(_beta+pt)
  end

  m.atdebug(elm, m, lw_, 'xrotation:1')
end

M.xrotation = xrotation

-- Y-rotation

local function yrotation (elm, m, lw_, dthe_)  -- Ry(ay) [ROT_XZ]            -- checked
  local ay = dthe_ or elm.angle*m.tdir
  if abs(ay) < minang then return end

  m.atdebug(elm, m, lw_, 'yrotation:0')

  local ay = -ay*(lw_ or 1) -- minus sign, eq. 127 is for clockwise yrotation
  local sa, ca, ta = sin(ay), cos(ay), tan(ay)
  local _beta = 1/m.beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)
    local   _pz = 1/pz
    local   ptt = 1 - ta*px*_pz
    local  _ptt = x/ptt
    local  _pzt = ta*_pz*_ptt

    -- eq. 127 in Forest06
    m[i].x  = _ptt/ca
    m[i].px = ca*px + sa*pz
    m[i].y  = y + _pzt*py
    m[i].t  = t - _pzt*(_beta+pt)
  end

  m.atdebug(elm, m, lw_, 'yrotation:1')
end

M.yrotation = yrotation

-- S-rotation

local function srotation (elm, m, lw_, dpsi_)  -- Rz(az) [ROT_XY]            -- checked
  local az = dpsi_ or elm.angle*m.tdir
  if abs(az) < minang then return end

  m.atdebug(elm, m, lw_, 'srotation:0')

  local az = az*(lw_ or 1)
  local sa, ca = sin(az), cos(az)

  for i=1,m.npar do
    local x, px, y, py in m[i]
    local nx  = ca*x  + sa*y
    local npx = ca*px + sa*py

    m[i].y    = ca*y  - sa*x
    m[i].py   = ca*py - sa*px
    m[i].x    = nx
    m[i].px   = npx
  end

  m.atdebug(elm, m, lw_, 'srotation:1')
end

M.srotation = srotation

-- Translation

local function translate (elm, m, lw_, dx_, dy_, ds_) -- [TRANS]             -- unchecked
  local dx = dx_ or elm.dx
  local dy = dy_ or elm.dy
  local ds = ds_ or elm.ds
  if abs(dx)+abs(dy)+abs(ds) < minlen then return end

  m.atdebug(elm, m, lw_, 'translate:0')

  local tdir in m
  local lw = lw_ or 1
  dx = dx*lw*tdir
  dy = dy*lw*tdir
  ds = ds*lw*sdir

  if abs(ds) < minlen then
    for i=1,m.npar do
      local x, y in m[i]
      m[i].x = x - dx
      m[i].y = y - dy
    end
  else -- ds is treated as a drift without correction for the time of flight
    local _beta = 1/m.beam.beta
    for i=1,m.npar do
      local x, px, y, py, t, pt, beam in m[i]
      local _beta = beam and 1/beam.beta or _beta
      local  l_pz = ds/sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)
      m[i].x = x + px*l_pz - dx
      m[i].y = y + py*l_pz - dy
      m[i].t = t - l_pz*(_beta+pt)
    end
  end

  m.atdebug(elm, m, lw_, 'translate:1')
end

M.translate = translate

-- Changeref (generic patch, lw_>0: RT, lw_<0: TR)

function M.changeref (elm, m, lw_)                                           -- unchecked
  local sdir, edir in m 
  local lw = (lw_ or 1)*sdir -- for trackone, sdir is not placed into lw
  local dx, dy, ds, dphi, dpsi in elm
  local dthe = elm.dtheta
  local trn = abs(dx  )+abs(dy  )+abs(ds  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return end

  m.atdebug(elm, m, lw_, 'changeref:0')

  -- forward : x1' = R*x1+T
  -- backward: x1  = R^-1*(x1'-T)

  -- rotate
  if rot and lw > 0 then
    yrotation(elm, m,  edir,  dthe)
    xrotation(elm, m,  edir, -dphi)
    srotation(elm, m,  edir,  dpsi)
  end

  -- translate
  if trn then -- translate does everything
    translate(elm, m, 1, dx, dy, ds)
  end

  -- rotate
  if rot and lw < 0 then
    srotation(elm, m, -edir,  dpsi)
    xrotation(elm, m, -edir, -dphi)
    yrotation(elm, m, -edir,  dthe)
  end

  m.atdebug(elm, m, lw_, 'changeref:1')
end

-- Changedir (reverse mflow e-direction)

function M.changedir (elm_, m, lw_)                                          -- unchecked
  m.atdebug(elm, m, lw_, 'changedir:0')

  m.edir = -m.edir
  m.tdir = -m.tdir

  m.atdebug(elm, m, lw_, 'changedir:1')
end

-- Changenrj (change frame energy)

function M.changenrj (elm, m, lw_)                                           -- unchecked
  local dnrj in elm
  if dnrj == 0 then return end

  m.atdebug(elm, m, lw_, 'changenrj:0')

  local tdir, beam in m
  local p0c, _b0 = beam.pc, 1/beam.beta
  beam.energy = beam.energy + dnrj*tdir
  local a, _beta = p0c/beam.pc, 1/beam.beta

  for i=1,m.npar do
    -- scale momenta of particles attached to the reference beam only
    if not m[i].beam then
      local px, py, pt in m[i]
      local dp2 = a^2*(1 + (2*_b0)*pt + pt^2) -- new (1+dp)^2
      m[i].px = a*px
      m[i].py = a*py
      m[i].pt = sqrt(dp2 + _beta^2 - 1) - _beta
    end
  end

  m.atdebug(elm, m, lw_, 'changenrj:1')
end

-- misalignments --------------------------------------------------------------o

local _T  = vector(3) -- misalignment translation
local _R  = matrix(3) -- misalignment rotation
local _Tb = vector(3) -- misalignment translation at exit (Tbar)
local _Rb = matrix(3) -- misalignment rotation    at exit (Rbar)

local misalignent, misalignexi -- forward declaration

-- Misalign (lw_>0: entry, lw_<0: exit)

function M.misalign (elm, m, lw_)                                            -- unchecked
  if (lw_ or 1) >= 0
  then misalignent(elm, m,  1)
  else misalignexi(elm, m, -1)
  end
end

function misalignent (elm, m, lw)                                            -- unchecked
  m.atdebug(elm, m, lw, 'misalignent:0')

  local sdir, edir, tdir, algn in m

  -- misalignment at entry and local/global frames
  -- forward : x1' = R*x1+T
  -- backward: x1  = R^-1*(x1'-T)

  -- rotate
  if algn.rot and sdir > 0 then
    yrotation(elm, m,  edir,  algn.dthe)
    xrotation(elm, m,  edir, -algn.dphi)
    srotation(elm, m,  edir,  algn.dpsi)
  end

  -- translate
  if algn.trn then
    translate(elm, m, sdir, algn.dx, algn.dy, algn.ds)
  end

  -- rotate
  if algn.rot and sdir < 0 then
    srotation(elm, m, -edir,  algn.dpsi)
    xrotation(elm, m, -edir, -algn.dphi)
    yrotation(elm, m, -edir,  algn.dthe)
  end

  m.atdebug(elm, m, lw, 'misalignent:1')
end

function misalignexi (elm, m, lw)                                            -- unchecked
  m.atdebug(elm, m, lw, 'misalignexi:0')

  local el, ang, tlt, sdir, edir, tdir, algn in m
  local mang = m.mang or ang

  -- translation
  if algn.trn then _T:fill{algn.dx, algn.dy, algn.ds} else _T:zeros() end

  -- rotation
  if algn.rot then _R:rotzxy(-algn.dphi, algn.dthe, algn.dpsi) end

  -- compute Rbar, Tbar
  _C.mad_mat_rtbar(_Rb._dat, _Tb._dat, abs(el), mang, tlt, algn.rot and _R._dat or nil, _T._dat)

  -- misalignment at exit and local/global frames
  -- forward : x2  = Rb^-1*(x2'-Tb)
  -- backward: x2' = Rb*x2+Tb

  -- _T:print("T")
  -- _R:print("R")
  -- _Tb:print("Tb")
  -- _Rb:print("Rb")

  -- rotate
  if algn.rot and sdir > 0 then
    local ax, ay, az = _Rb:torotzxy()
    srotation(elm, m, -edir, az)
    xrotation(elm, m, -edir, ax)
    yrotation(elm, m, -edir, ay)
  end

  -- translate
  if algn.trn then
    translate(elm, m, -sdir, _Tb[1], _Tb[2], _Tb[3])
  end

  -- rotate
  if algn.rot and sdir < 0 then
    local ax, ay, az = _Rb:torotzxy()
    yrotation(elm, m,  edir, ay)
    xrotation(elm, m,  edir, ax)
    srotation(elm, m,  edir, az)
  end

  m.atdebug(elm, m, lw, 'misalignexi:1')
end

-- [INTER_STREX, INTER_TEAPOT, H3 adjustment] ---------------------------------o

local function drift_adj (elm, m, l) -- [KICKPATH] drift adjustment          -- checked
  m.atdebug(elm, m, l, 'drift_adj:0')

  local T in m
  local _beta = 1/m.beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local  l_pz = l/sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)

    m[i].x = x + px*(l_pz-l)
    m[i].y = y + py*(l_pz-l)
    m[i].t = t - l_pz*(_beta+pt) + (1-T)*(l*_beta)
  end

  m.atdebug(elm, m, l, 'drift_adj:1')
end

-- DKD [INTER_STREX] ----------------------------------------------------------o

local is_tpsa in MAD.typeid

function M.strex_drift (elm, m, lw, istp) -- [DRIFT]                         -- checked
  if abs(m.el*lw) < minlen then return end

  m.atdebug(elm, m, lw, 'strex_drift:0')

  local el, eld, T in m
  local l, ld = el*lw, (eld or el)*lw
  local _beta = 1/m.beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local  l_pz = l/sqrt(1 + (2*_beta)*pt + pt^2 - px^2 - py^2)

    m[i].x = x + px*l_pz
    m[i].y = y + py*l_pz
    m[i].t = t - l_pz*(_beta+pt) + (1-T)*(ld*_beta)
  end

  m.atdebug(elm, m, lw, 'strex_drift:1')
end

function M.strex_kick (elm, m, lw, istp, no_k0l) -- [KICKEX]                 -- checked
  if m.nmul == 0 then return end

  m.atdebug(elm, m, lw, 'strex_kick:0', no_k0l)

  local tdir, nmul, knl, ksl, beam in m
  local wchg = lw*tdir*beam.charge
  local dby  = no_k0l == true and knl[1] or 0

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local  wchg = beam and lw*tdir*beam.charge or wchg
    local bx,by = bxby(nmul, knl, ksl, x, y)

    m[i].px = px - wchg*(by-dby)
    m[i].py = py + wchg* bx
  end

  m.atdebug(elm, m, lw, 'strex_kick:1', no_k0l)
end

local function strex_kicks(elm, m, lw, i, wchg, _beta, pz)
  local ksi, lrad in m
  if ksi == 0 or lrad == 0 then return end

  local x, px, y, py, pt in m[i]

  local  hss = lw*ksi^2/lrad -- 4 H(s_0)^2/ds
  local _dpp = 1/pz
  local _dp  = _dpp^2
  local  ang = (wchg*0.5*ksi)*_dpp
  local ca, sa = cos(ang), sin(ang)

  local nx  = ca* x + sa* y
  local npx = ca*px + sa*py
  local ny  = ca* y - sa* x
  local npy = ca*py - sa*px
  local nt  = m[i].t - ang*(_beta+pt)*(y*px - x*py)*_dp

  m[i].x  = nx
  m[i].px = npx - (0.25 *hss)*nx*_dpp
  m[i].y  = ny
  m[i].py = npy - (0.25 *hss)*ny*_dpp
  m[i].t  = nt  - (0.125*hss)*(_beta+pt)*(nx^2+ny^2)*_dpp^3
end


function M.strex_kickhs (elm, m, lw, istp) -- [KICKT]                        -- checked
  local lrad, nmul, ksi in m
  if nmul == 0 and ksi == 0 then return end

  m.atdebug(elm, m, lw, 'strex_kickhs:0')

  local sdir, tdir, knl, ksl, beam in m
  local  wchg = lw*tdir*beam.charge -- lw is always 1 for multipole only (Needed?)
  local _beta = 1/beam.beta

  for i=1,m.npar do
    local x, y, t, pt, beam in m[i]
    local  wchg = beam and lw*tdir*beam.charge or wchg
    local _beta = beam and 1/beam.beta or _beta
    local    pz = sqrt(1 + (2*_beta)*pt + pt^2)

    if sdir == -1 then strex_kicks(elm, m, lw, i, wchg, _beta, pz) end

    -- multipole
    if nmul > 0 then
      local bx,by = bxby(nmul, knl, ksl, x, y)

      m[i].px = m[i].px - wchg*by -- With 0 el and ksi ~= 0, we get problems with the multipole
      m[i].py = m[i].py + wchg*bx

      if abs(knl[1]) + abs(ksl[1]) > 0 then
        m[i].px = m[i].px + (wchg*knl[1])*pz
        m[i].py = m[i].py - (wchg*ksl[1])*pz
        m[i].t  = m[i].t  - wchg*(knl[1]*x - ksl[1]*y)*(_beta+pt)/pz

        -- field curvature
        if lrad ~= 0 then
          m[i].px = m[i].px - lw*(knl[1]^2/lrad)*x
          m[i].py = m[i].py - lw*(ksl[1]^2/lrad)*y
        end
      end
    end

    if sdir == 1 then strex_kicks(elm, m, lw, i, wchg, _beta, pz) end

  end

  m.atdebug(elm, m, lw, 'strex_kickhs:1')
end

-- DKD [INTER_TEAPOT] ---------------------------------------------------------o

function M.curex_drift (elm, m, lw, istp) -- [SPROT]                         -- checked
  m.atdebug(elm, m, lw, 'curex_drift:0')

  local el, eld, eh, T in m
  local ld, ang, rho = (eld or el)*lw, eh*el*lw, 1/eh -- R=rho, A=ang
  local ca, sa, sa2 = cos(ang), sin(ang), sin(ang/2)
  local beta = m.beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local   pz = sqrt(1 + (2/beta)*pt + pt^2 - px^2 - py^2)
    local  _pz = 1/pz
    local  pxt = px*_pz
    local  ptt = ca - sa*pxt
    local _ptt = 1/ptt
    local  pst = (x+rho)*sa*_pz*_ptt

    m[i].x  = (x + rho*(2*sa2^2 + sa*pxt))*_ptt
    m[i].px = ca*px + sa*pz
    m[i].y  = y + pst*py
    m[i].t  = t - pst*(1/beta+pt) + (1-T)*(ld/beta)
  end

  m.atdebug(elm, m, lw, 'curex_drift:1')
end

function M.curex_kick (elm, m, lw, istp, no_k0l) -- [SKICK]                  -- checked
  m.atdebug(elm, m, lw, 'curex_kick:0', no_k0l)

  local el, eh, tdir, snm, knl, bfx, bfy, beam in m
  local bdir = tdir*beam.charge
  local bx, by = 0, knl[1] -- i.e. nmul == 1 and ksl[1] == 0

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local bdir = beam and tdir*beam.charge or bdir
    local r = 1+eh*x

    if snm > 0 then bx, by = bxbyh(snm, bfx, bfy, x, y) end

    m[i].px = px - (lw*bdir)*by*r
    m[i].py = py + (lw*bdir)*bx*r
    if no_k0l == true then
      m[i].px = m[i].px + (lw*bdir*knl[1])*r
    end
  end

  m.atdebug(elm, m, lw, 'curex_kick:1', no_k0l)
end

-- TKT [INTER_TEAPOT] ---------------------------------------------------------o

-- version for k0*charge == 0 to avoid NaN

local function curex_drift0 (elm, m, lw, i, ld, ca, sa, sa2, rho)
  m.atdebug(elm, m, lw, 'curex_drift0:0')

  local x, px, y, py, t, pt in m[i]
  local beta = (m[i].beam or m.beam).beta
  local   pz = sqrt(1 + (2/beta)*pt + pt^2 - px^2 - py^2)
  local  _pz = 1/pz
  local  pxt = px*_pz
  local  ptt = ca - sa*pxt
  local _ptt = 1/ptt
  local  pst = (x+rho)*sa*_pz*_ptt

  m[i].x  = (x + rho*(2*sa2^2 + sa*pxt))*_ptt
  m[i].px = ca*px + sa*pz
  m[i].y  = y + pst*py
  m[i].t  = t - pst*(1/beta+pt) + (1-m.T)*(ld/beta)

  m.atdebug(elm, m, lw, 'curex_drift0:1')
end

local function sbend_thick_new (elm, m, lw, istp) -- [SSEC]                  -- checked
  m.atdebug(elm, m, lw, 'sbend_thick:0')

  local el, eld, eh, tdir, knl, beam, T in m
  local ld, ang, rho, k0 = (eld or el)*lw, eh*el*lw, 1/eh, knl[1]/el*tdir
  local beta, k0q = beam.beta, k0*beam.charge
  local ca, sa, sa2, s2a = cos(ang), sin(ang), sin(ang/2), sin(2*ang)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local  k0q = beam and k0*beam.charge or k0q

    if k0q == 0 then
      curex_drift0 (elm, m, lw, i, ld, ca, sa, sa2, rho)
      goto continue
    end

    local  pw2 = 1 + 2*pt/beta + pt^2 - py^2
    local   pz = sqrt(pw2 - px^2)                                      -- PZ
    local   xr = x+rho
    local  pzx = pz - k0q*xr
    local  npx = sa*pzx + ca*px                                        -- XN(2)
    local  dpx = ca*pzx - sa*px                                        -- DPX'
    local  pzs = sqrt(pw2 - npx^2)                                     -- PZS
    local _ptt = invsqrt(pw2)                                          -- 1/PT

    local  xt1 = -k0q*x^2 + 2*(pz*xr - (k0q*rho)*x) - k0q*rho^2
    local   xi =  px*_ptt
    local zeta = npx*_ptt
    local  sxi = sqrt(1-xi^2)
    local    w = (ca*xi + sa*sxi) * sqrt(1-zeta^2)
    local    v = (sa*xi - ca*sxi) * zeta
    local  xt2 = (s2a*px + sa^2*(2*pz - k0q*xr)) * xr*_ptt^2 / (w - v)
    local  dxs = asinc(xt2*k0q)*xt2

    -- Error arises from 1/(w-v) -> ["040000"] = ~1e10 then reduces to ~1e-2
    -- leading to an error of ~1e-8

    -- eq. 126 in Forest06 with modif. from Sagan
    m[i].x  = xt1/(dpx+pzs) - rho                                       -- XN(1)
    m[i].px = npx                                                       -- XN(2)
    m[i].y  = y + dxs*py                                                -- XN(3)
    m[i].t  = t - dxs*(1/beta+pt) + (1-T)*(ld/beta)                     -- XN(6)

    ::continue::
  end

  m.atdebug(elm, m, lw, 'sbend_thick:1')
end

local function sbend_thick_old (elm, m, lw, istp) -- [SSEC]                  -- checked
  m.atdebug(elm, m, lw, 'sbend_thick:0')
  
  local el, eld, eh, tdir, knl, beam, T in m
  local ld, ang, rho, k0 = (eld or el)*lw, eh*el*lw, 1/eh, knl[1]/el*tdir
  local beta, k0q = beam.beta, k0*beam.charge
  local ca, sa, sa2 = cos(ang), sin(ang), sin(ang/2)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local  k0q = beam and k0*beam.charge or k0q

    if k0q == 0 then
      curex_drift0 (elm, m, lw, i, ld, ca, sa, sa2, rho)
      goto continue
    end

    local  pw2 = 1 + 2*pt/beta + pt^2 - py^2
    local   pz = sqrt(pw2 - px^2)                                      -- PZ
    local  pzx = pz - k0q*(rho+x)      -- could be numerically unstable
    local  npx = sa*pzx + ca*px                                        -- XN(2)
    local  dpx = ca*pzx - sa*px                                        -- DPX'
    local  pzs = sqrt(pw2 - npx^2)                                     -- PZS
    local _ptt = invsqrt(pw2)                                          -- PT
    local  dxs = (ang + asin(px*_ptt) - asin(npx*_ptt))/k0q            -- XN(3)

    -- eq. 126 in Forest06
    m[i].x  = (pzs - dpx)/k0q - rho    -- could be numerically unstable -- XN(1)
    m[i].px = npx                                                       -- XN(2)
    m[i].y  = y + dxs*py                                                -- XN(3)
    m[i].t  = t - dxs*(1/beta+pt) + (1-T)*(ld/beta)                     -- XN(6)

    ::continue::
  end

  m.atdebug(elm, m, lw, 'sbend_thick:1')
end

M.sbend_thick = new_bend_thick and sbend_thick_new or sbend_thick_old
M.sbend_kick  = \el,m,lw,istp -> M.curex_kick(el,m,lw,istp,true) ;           -- checked

-- TKT [INTER_STREX] ----------------------------------------------------------o

-- version for k0*charge == 0 to avoid NaN

local function strex_drift0 (elm, m, lw, i, l, ld)                           -- checked
  m.atdebug(elm, m, lw, 'strex_drift0:0')

  local x, px, y, py, t, pt in m[i]
  local beta = (m[i].beam or m.beam).beta
  local l_pz = l/sqrt(1 + (2/beta)*pt + pt^2 - px^2 - py^2)

  m[i].x = x + px*l_pz
  m[i].y = y + py*l_pz
  m[i].t = t - l_pz*(1/beta+pt) + (1-m.T)*(ld/beta)

  m.atdebug(elm, m, lw, 'strex_drift0:1')
end

local function rbend_thick_new (elm, m, lw, istp) -- [SPAR]                  -- checked
  m.atdebug(elm, m, lw, 'rbend_thick:0')

  local el, eld, tdir, knl, beam, T in m
  local l, ld, k0 = el*lw, (eld or el)*lw, knl[1]/el*tdir
  local beta, k0q, k0lq = beam.beta, k0*beam.charge, knl[1]*lw*beam.charge*tdir

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local k0q  = beam and k0*beam.charge or k0q

    if k0q == 0 then
      strex_drift0 (elm, m, lw, i, l, ld)
      goto continue
    end

    local k0lq = beam and knl[1]*lw*beam.charge*tdir or k0lq
    local  npx = px - k0lq
    local  pw2 = 1 + 2*pt/beta + pt^2 - py^2
    local _ptt = invsqrt(pw2)
    local   pz = sqrt(pw2 - px^2)
    local  pzs = sqrt(pw2 - npx^2)
    local   xi =  px*_ptt
    local zeta = npx*_ptt
    local  xtd = xi*sqrt(1-zeta^2) + zeta*sqrt(1-xi^2)
    local   xt = l*(2*px - k0lq)*_ptt^2 / xtd
    local  dxs = asinc(xt*k0q)*xt

    -- eq. 129 in Forest06 with modif. from Sagan
    m[i].x  = x + l*(2*px - k0lq) / (pz+pzs)
    m[i].px = npx
    m[i].y  = y + dxs*py
    m[i].t  = t - dxs*(1/beta+pt) + (1-T)*ld/beta

    ::continue::
  end

  m.atdebug(elm, m, lw, 'rbend_thick:1')
end

local function rbend_thick_old (elm, m, lw, istp) -- [SPAR]                  -- checked
  m.atdebug(elm, m, lw, 'rbend_thick:0')

  local el, eld, tdir, knl, beam, T in m
  local l, ld, k0 = el*lw, (eld or el)*lw, knl[1]/el*tdir
  local beta, k0q, k0lq = beam.beta, k0*beam.charge, knl[1]*lw*beam.charge*tdir

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local beta = beam and beam.beta or beta
    local k0q  = beam and k0*beam.charge or k0q

    if k0q == 0 then
      strex_drift0 (elm, m, lw, i, l, ld)
      goto continue
    end

    local k0lq = beam and knl[1]*lw*beam.charge*tdir or k0lq
    local  npx = px - k0lq
    local  pw2 = 1 + 2*pt/beta + pt^2 - py^2
    local _ptt = invsqrt(pw2)
    local   pz = sqrt(pw2 - px^2)
    local  pzs = sqrt(pw2 - npx^2)
    local  dxs = (asin(px*_ptt) - asin(npx*_ptt))/k0q

    -- eq. 129 in Forest06
    m[i].x  = x + (pzs-pz)/k0q
    m[i].px = npx
    m[i].y  = y + dxs*py
    m[i].t  = t - dxs*(1/beta+pt) + (1-T)*ld/beta

    ::continue::
  end

  m.atdebug(elm, m, lw, 'rbend_thick:1')
end

M.rbend_thick = new_bend_thick and rbend_thick_new or rbend_thick_old
M.rbend_kick  = \el,m,lw,istp -> M.strex_kick(el,m,lw,istp,true)             -- checked

-- TKT [INTER_TKTF] -----------------------------------------------------------o

function M.quad_thick (elm, m, lw, istp) -- [PUSHTKT7]                       -- checked
  m.atdebug(elm, m, lw, 'quad_thick:0')

  local el, sdir, tdir, k1, beam in m
  local l = el*lw
  local chg = beam.charge

  -- [GETMAT7] TODO: cache these values as lw is the same over the slices
  local ws = k1*sdir < 0 and -1 or 1
  local cx, sx, mx1, mx2
  local cy, sy, my1, my2

  if abs(k1) >= minstr then
    local w = sqrt(abs(k1))*tdir*ws
    cx, sx = cos (w*l), sin (w*l)
    cy, sy = cosh(w*l), sinh(w*l)
    mx1, mx2 = sx/w, -sx*w
    my1, my2 = sy/w,  sy*w
  else
    cx, sx, mx1, mx2 = 1, 0, l, 0
    cy, sy, my1, my2 = 1, 0, l, 0
  end

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local chg = beam and beam.charge or chg

    if ws ~= chg then -- swap x <-> y
      ws, cx, cy, mx1, mx2, my1, my2 =
     -ws, cy, cx, my1, my2, mx1, mx2
    end

    local nx  = x*cx  + px*mx1
    local npx = x*mx2 + px*cx
    local ny  = y*cy  + py*my1
    local npy = y*my2 + py*cy

    m[i].x  = nx
    m[i].px = npx
    m[i].y  = ny
    m[i].py = npy
  end

  m.atdebug(elm, m, lw, 'quad_thick:1')
end

function M.quad_kick_ (elm, m, lw, istp) -- [KICKTKT7]                       -- checked
  local l = m.el*lw
  if istp >= 0 then drift_adj(elm, m, istp == 0 and l/2 or l) end

  if m.nmul > 0 then
    m.atdebug(elm, m, lw, 'quad_kick:0')

    local tdir, nmul, knl, ksl, beam in m
    local wchg = lw*tdir*beam.charge

    for i=1,m.npar do
      local x, px, y, py, beam in m[i]
      local  wchg = beam and lw*tdir*beam.charge or wchg
      local bx,by = bxby(nmul, knl, ksl, x, y)

      m[i].px = px - wchg*(by - knl[2]*x)
      m[i].py = py + wchg*(bx - knl[2]*y)
    end

    m.atdebug(elm, m, lw, 'quad_kick:1')
  end

  if istp <= 0 then drift_adj(elm, m, istp == 0 and l/2 or l) end
end

M.quad_kick = \elm, m, lw, istp -> M.quad_kick_(elm, m, lw, 0)

-- skew (tilted by k1s)

function M.quad_thicks (elm, m, lw, istp) -- [PUSHTKT7]                      -- checked
  m.atdebug(elm, m, lw, 'quad_thicks:0')

  local el, sdir, tdir, k1, ca, sa, beam in m
  local l = el*lw
  local chg = beam.charge

  -- [GETMAT7] TODO: cache these values as lw is the same over the slices
  local ws = k1*sdir < 0 and -1 or 1
  local w  = sqrt(abs(k1))*tdir*ws
  local cx, sx = cos (w*l), sin (w*l)
  local cy, sy = cosh(w*l), sinh(w*l)
  local mx1, mx2 = sx/w, -sx*w
  local my1, my2 = sy/w,  sy*w

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local chg = beam and beam.charge or chg

    if ws ~= chg then -- swap x <-> y
       ws, cx, cy, mx1, mx2, my1, my2 =
      -ws, cy, cx, my1, my2, mx1, mx2
    end

    -- srotation
    local nx  = ca*x  + sa*y
    local npx = ca*px + sa*py
    local ny  = ca*y  - sa*x
    local npy = ca*py - sa*px

    x  = nx*cx  + npx*mx1
    px = nx*mx2 + npx*cx
    y  = ny*cy  + npy*my1
    py = ny*my2 + npy*cy

    -- srotation^-1
    m[i].x  = ca*x  - sa*y
    m[i].px = ca*px - sa*py
    m[i].y  = ca*y  + sa*x
    m[i].py = ca*py + sa*px
  end

  m.atdebug(elm, m, lw, 'quad_thicks:1')
end

function M.quad_kicks_ (elm, m, lw, istp) -- [KICKTKT7]                      -- checked
  local l = m.el*lw
  if istp >= 0 then drift_adj(elm, m, istp == 0 and l/2 or l) end

  if m.nmul > 0 then
    m.atdebug(elm, m, lw, 'quad_kicks:0')

    local tdir, nmul, knl, ksl, beam in m
    local wchg = lw*tdir*beam.charge

    for i=1,m.npar do
      local x, px, y, py, beam in m[i]
      local  wchg = beam and lw*tdir*beam.charge or wchg
      local bx,by = bxby(nmul, knl, ksl, x, y)

      m[i].px = px - wchg*(by - knl[2]*x + ksl[2]*y)
      m[i].py = py + wchg*(bx - knl[2]*y - ksl[2]*x)
    end

    m.atdebug(elm, m, lw, 'quad_kicks:1')
  end

  if istp <= 0 then drift_adj(elm, m, istp == 0 and l/2 or l) end
end

M.quad_kicks = \elm, m, lw, istp -> M.quad_kicks_(elm, m, lw, 0)

-- curved (eh ~= 0)

function M.quad_thickh_new (elm, m, lw, istp) -- [PUSHTKT7]                  -- unchecked
  m.atdebug(elm, m, lw, 'quad_thickh:0')

  local el, eh, sdir, edir, tdir, beam in m
  local     l = el*lw
  local _beta = 1/beam.beta
  local   chg = beam.charge

  -- [GETMAT7] TODO: cache these values as lw is the same over the slices!

  local kx  = (knl[2]+eh*knl[1])/el*edir
  local ky  = -knl[2]/el*edir
  local wxs = kx*sdir < 0 and -1 or 1
  local wys = ky*sdir < 0 and -1 or 1
  local mx11, mx12, mx13, mx21, mx22, mx23, mx31, mx32, mx33
  local my11, my12, my13, my21, my22, my23

  local wx, wy = 0, 0
  if abs(kx) >= minstr then
    wx = sqrt(abs(kx))*tdir*wxs
    local cx, sx = cos (wx*l), sin (wx*l)
    local cy, sy = cosh(wx*l), sinh(wx*l)
    mx11, mx12, mx13 =  cx  , sx/w, wxs*eh*(cx-1)/wx^2
    mx21, mx22, mx23 = -sx*w, cx  , mx12
    mx31, mx32, mx33 =  mx23, mx13, wxs*-eh^2*(l-mx12)/wx^2
  else
    mx11, mx12, mx13 =  1, l, eh*l^2/2
    mx21, mx22, mx23 =  0, 1, eh*l
    mx31, mx32, mx33 =  mx23, mx13, mx13*mx23/3
  end

  if abs(ky) >= minstr then
    wy = sqrt(abs(ky))*tdir*wys
    local cx, sx = cos (wy*l), sin (wy*l)
    local cy, sy = cosh(wy*l), sinh(wy*l)
    my11, my12, my13 =  cy  , sy/w, 0
    my21, my22, my23 =  sy*w, cy  , 0
  else
    my11, my12, my13 =  1, l, 0
    my21, my22, my23 =  0, 1, 0
  end

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local   chg = beam and beam.charge or chg

    if ws ~= chg then -- swap x <-> y
      mx11, mx12, mx13, mx21, mx22, mx23,
      my11, my12, my13, my21, my22, my23,  ws =
      my11, my12, my13, my21, my22, my23,
      mx11, mx12, mx13, mx21, mx22, mx23, -ws
    end

--  mx11 = cx                  ; 1
--  mx12 = sx/w                ; l
--  mx13 = ws*beta*(cx-1)/w^2  ; beta*l^2/2
--  mx21 = ws*w*sx             ; 0
--  mx22 = cx                  ; 1
--  mx23 = beta*mx12           ; beta*l

--  my11 = cy                  ; 1
--  my12 = sy/w                ; l
--  my13 = 0                   ; 0
--  my21 = ws*w*sy             ; 0
--  my22 = cx                  ; 1
--  my23 = 0                   ; 0

    local nx  = x*mx11 + px*mx12 + (mx13*_beta)*pt
    local npx = x*mx21 + px*mx22 + (mx23*_beta)*pt
    local ny  = y*my11 + py*my12
    local npy = y*my21 + py*my22
    -- TODO: update t...

    m[i].x  = nx
    m[i].px = npx
    m[i].y  = ny
    m[i].py = npy
  end

  m.atdebug(elm, m, lw, 'quad_thickh:1')
end

function M.quad_thickh (elm, m, lw, istp) -- [PUSHTKT7]                      -- unchecked (checked for sdir=1 and eh=0)
  m.atdebug(elm, m, lw, 'quad_thickh:0')

  local el, eh, sdir, edir, tdir, knl, beam in m
  local l = el*lw
  local chg = beam.charge
  local _beta = 1/beam.beta           -- Should be _beta not beta

  -- [GETMAT7, w ~= 0]
  local kx  = (knl[2]+eh*knl[1])/el   -- No need to include sign of edir here (see below)
  local ky  = -knl[2]/el
  local wxs = kx*tdir < 0 and -1 or 1 --w(x/y)s determines sign after sqrt
  local wys = ky*tdir < 0 and -1 or 1 
  local wx, cx, sx, wy, cy, sy 
  local mx11, mx12, mx13, mx21, mx22, mx23, mx31, mx32, mx33
  local my11, my12,       my21, my22

  if abs(kx) >= minstr then
    wx = sqrt(abs(kx))*wxs -- only wxs is needed for the sign of kx
  else
    wx = 0
    mx11, mx12, mx13 = 1   , l   , eh*l^2/2
    mx21, mx22, mx23 = 0   , 1   , eh*l
    mx31, mx32, mx33 = mx23, mx13, mx13*mx23/3
  end

  if abs(ky) >= minstr then
    wy = sqrt(abs(ky))*wys -- only wys is needed for the sign of ky
  else
    wy = 0
    my11, my12 = 1, l
    my21, my22 = 0, 1
  end

  -- trig 1st GETMAT7, no need to reverse wxs and wys
  -- Removed reverse of wx and wy as they were just reversed later on

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local  chg = beam and beam.charge or chg
    local _beta = beam and 1/beam.beta or _beta

    local cx, sx
    if wx ~= 0 then -- [GETMAT7]
      wx, wxs = wx*chg, -wxs*chg
      if wx > 0
      then cx, sx = cos (wx*l), sin (wx*l)
      else cx, sx = cosh(wx*l), sinh(wx*l)
      end
      mx11, mx12, mx13 = cx       , sx/wx,  eh*    (cx-1)*wxs/wx^2
      mx21, mx22, mx23 = wxs*wx*sx, cx   ,  eh*     mx12
      mx31, mx32, mx33 = mx23     , mx13 , -eh^2*(l-mx12)*wxs/wx^2
    end

    local cy, sy
    if wy ~= 0 then -- [GETMAT7]
      wy, wys = wy*chg, -wys*chg
      if wy > 0
      then cy, sy = cos (wy*l), sin (wy*l)
      else cy, sy = cosh(wy*l), sinh(wy*l)
      end
      my11, my12 = cy       , sy/wy
      my21, my22 = wys*wy*sy, cy
    end

--[[ PTC matrix form
    { cx      , sx/wx          ,  h*(cx-1)/wx2*ws     ,
      sx*wx*ws, cx             ,  h*sx/wx             ,
      h*sx/wx , h*(cx-1)/wx2*ws, -h^2*(l-sx/wx)/wx2*ws }
    { cy      , sy/wy          ,  0                   ,
      sy*wy*ws, cy             ,  0                    }
--]]

    -- print("mx11=", mx11) print("mx12=", mx12) print("mx13=", mx13)
    -- print("mx21=", mx21) print("mx22=", mx22) print("mx23=", mx23)
    -- print("my11=", my11) print("my12=", my12)
    -- print("my21=", my21) print("my22=", my22)
    -- print("mx31=", mx31) print("mx32=", mx32) print("mx33=", mx33)

    local nx  = x*mx11 + px*mx12 + pt*(mx13*_beta)
    local npx = x*mx21 + px*mx22 + pt*(mx23*_beta)
    local ny  = y*my11 + py*my12
    local npy = y*my21 + py*my22
    local dt  = x*(mx31*_beta) + px*(mx32*_beta) + pt*mx33

    m[i].x   = nx
    m[i].y   = ny
    m[i].px  = npx
    m[i].py  = npy
    m[i].t   = t - dt
  end

  m.atdebug(elm, m, lw, 'quad_thickh:1')
end

function M.quad_kickh_ (elm, m, lw, istp) -- [KICKTKT7]                      -- unchecked (checked for sdir=1 and eh=0)
  local l = m.el*lw
  if istp >= 0 then drift_adj(elm, m, istp == 0 and l/2 or l) end

  if m.nmul > 0 then
    m.atdebug(elm, m, lw, 'quad_kickh:0')

    local eh, tdir, nmul, knl, ksl, beam in m
    local _beta = 1/beam.beta
    local  wchg = lw*tdir*beam.charge

    for i=1,m.npar do
      local x, px, y, py, t, pt, beam in m[i]
      local _beam = beam and 1/beam.beta or _beta
      local  wchg = beam and lw*tdir*beam.charge or wchg
      local    pz = sqrt(1 + (2*_beta)*pt + pt^2)
      local bx,by = bxby(nmul, knl, ksl, x, y)

      m[i].px = px - wchg*(by - knl[2]*x) + l*eh*(pz-(_beta*pt)) -- eh has tdir included
      m[i].py = py + wchg*(bx - knl[2]*y)
      m[i].t  =  t - (l*eh)*((_beta+pt)/pz - _beta)*x
    end

    m.atdebug(elm, m, lw, 'quad_kickh:1')
  end

  if istp <= 0 then drift_adj(elm, m, istp == 0 and l/2 or l) end
end

M.quad_kickh = \elm, m, lw, istp -> M.quad_kickh_(elm, m, lw, 0)

-- DKD, TKT [INTER_SOL5] ------------------------------------------------------o

function M.solen_thick (elm, m, lw, istp) -- [KICK_SOL]                      -- checked
  m.atdebug(elm, m, lw, 'solen_thick:0')

  local el, ks, beam, T in m
  local l = el*lw
  local bsol = 0.5*ks*beam.charge
  local _beta = 1/beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local  bsol = beam and 0.5*ks*beam.charge or bsol
    local    xp = px + bsol*y
    local    yp = py - bsol*x
    local  l_pz = l/sqrt(1 + (2*_beta)*pt + pt^2 - xp^2 - yp^2)
    local   ang = l_pz*bsol

    local ca, sa, sc = cos(ang), sin(ang), sinc(ang)

    local lsc = l_pz*sc
    local xt  = ca*x  + lsc*px
    local pxt = ca*px - lsc*x *bsol^2
    local yt  = ca*y  + lsc*py
    local pyt = ca*py - lsc*y *bsol^2

    m[i].x  = ca*xt  + sa*yt
    m[i].px = ca*pxt + sa*pyt
    m[i].y  = ca*yt  - sa*xt
    m[i].py = ca*pyt - sa*pxt
    m[i].t  = t - l_pz*(_beta+pt) + (1-T)*l*_beta
  end

  m.atdebug(elm, m, lw, 'solen_thick:1')
end

-- DKD, TKT [SEPTTRACK] -------------------------------------------------------o

function M.esept_thick (elm, m, lw, istp) -- [SEP]                           -- checked
  m.atdebug(elm, m, lw, 'elsep_thick:0')

  local el, ca, sa, volt, sdir, beam, T in m
  local _beta = 1/beam.beta
  local  _bg2 = 1/beam.betgam2
  local  wchg = beam.charge/beam.pc
  local    k1 = sdir*volt*wchg
  local     l = el*lw

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local  _bg2 = beam and 1/beam.betgam2 or _bg2
    local    k1 = beam and k1*beam.charge/(wchg*beam.pc) or k1
    local    e1 = _beta+pt

    -- srotation
    local   nx  = ca*x  + sa*y
    local   npx = ca*px + sa*py
    local   ny  = ca*y  - sa*x
    local   npy = ca*py - sa*px

    local    dp = e1 + k1*ny
    local  l_pz = l/sqrt(dp^2 - _bg2 - npx^2 - npy^2)
    local   arg = k1*l_pz
    local   shx = sinhc(arg)*l_pz
    local ch,sh = cosh(arg), sinh(arg)
    local   chm = sinh(0.5*arg)^2*(2/k1) -- was sinhc(0.5*arg)*sinh(0.5*arg)/l_pz
    local    dt = chm*npy + sh *ny  + e1*shx
    local    yt = ch *ny  + shx*npy + e1*chm
    local   pyt = ch *npy + sh*dp

    nx = nx + npx*l_pz
    ny, npy = yt, pyt

    -- srotation^-1
    m[i].x  = ca*nx  - sa*ny
    m[i].px = ca*npx - sa*npy
    m[i].y  = ca*ny  + sa*nx
    m[i].py = ca*npy + sa*npx
    m[i].t  = t - dt + (1-T)*(l*_beta)
  end

  m.atdebug(elm, m, lw, 'elsep_thick:1')
end

-- DKD, TKT [INTER_CAV4] ------------------------------------------------------o

function M.rfcav_kick (elm, m, lw, istp) -- [KICKCAV, FEVAL_CAVR?]           -- checked
  m.atdebug(elm, m, lw, 'rfcav_kick:0')

  local volt, freq, lag, tdir, beam in m
  local omega = freq*twopi_clight
  local phase = lag
  local  wchg = beam.charge/beam.pc
  local    vl = lw*wchg*tdir*volt

!  printf('@@ vl=% -.16e, omega=% -.16e, phase=% -.16e, p0c=% -.16e, yl=% -.16e\n',
!          vl, omega, phase, beam.pc, m.el*lw, beam.beta)

  for i=1,m.npar do
    local t, pt, beam in m[i]
    local vl = beam and vl*beam.charge/(beam.pc*wchg) or vl

    -- energy kick
    m[i].pt = pt + vl*sin(phase - omega*t)
  end

  m.atdebug(elm, m, lw, 'rfcav_kick:1')
end

function M.rfcav_kickn (elm, m, lw, istp) -- [KICKCAV, nmul~=0 or nbsl~=0]   -- checked
  m.atdebug(elm, m, lw, 'rfcav_kickn:0')

  local volt, freq, lag, tdir, nbsl, nmul, knl, ksl, beam in m
  local omega = freq*twopi_clight
  local phase = lag
  local _pc   = 1/beam.pc
  local chg   = beam.charge
  local bdir  = lw*chg*tdir
  local vl    = bdir*volt

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local ph = phase - omega*t
    local sa, ca = sin(ph), cos(ph)
    local _pc, vl, bdir = _pc, vl, bdir
    local f = 1

    if beam then
      _pc, vl, bdir = 1/beam.pc, vl*chg*beam.charge, bdir*chg*beam.charge
    end

    -- bessel modes (single mode ko=1)
    if nbsl > 0 then
      local df, r2 = 0, 1

      for i=1,nbsl do
        r2 = -r2*omega^2/(4*(i+1)^2)
        df =  df + 2*r2*i
        r2 =  r2*(x^2+y^2)
        f  =  f + r2
      end

      local c1 = df*vl*_pc*ca/omega
      px = px + x*c1
      py = py + y*c1
    end

    -- energy kick
    pt = pt + f*vl*_pc*sa

    if nmul > 0 then
      local bx, by, byt = bxby(nmul, knl, ksl, x, y)
      px = px + (bdir*_pc)*by*ca
      py = py - (bdir*_pc)*bx*ca

      by = -knl[nmul]/nmul
      bx = -ksl[nmul]/nmul
      for i=nmul-1,1,-1 do
        byt = x*by - y*bx - knl[i]/i
        bx  = y*by + x*bx - ksl[i]/i
        by  = byt
      end
      byt = x*by - y*bx -- extra terms?
      bx  = y*by + x*bx
      by  = byt

      pt = pt - (bdir*_pc)*omega*by*sa
    end

    m[i].px = px
    m[i].py = py
    m[i].pt = pt
  end

  m.atdebug(elm, m, lw, 'rfcav_kickn:1')
end

-- DKD, TKT -------------------------------------------------------------------o

local BB = require 'madl_bbeam' -- beambeam physics

function M.bbeam_kick (elm, m, lw, istp)                                     -- unchecked
  m.atdebug(elm, m, lw, 'bbeam_kick:0')

  local xma, yma, dpx, dpy, sigx, sigy, sigtol, bdir, bbeam in elm
  local tdir, beam in m
  local          p0c =  beam.p0c
  local  beta,   chg =   beam.beta,  beam.charge*tdir
  local bbeta, bbchg =  bbeam.beta, bbeam.charge*bdir
  local         bchg = chg*bbchg

  for i=1,m.npar do
    local x, px, y, py, pt, beam in m[i]
    local bchg = beam and beam.charge*tdir*bbchg or bchg
    local beta = beam and beam.beta or beta
    local p0c  = beam and beam.p0c  or p0c

    x = x - xma
    y = y - yma

    -- TODO: handle more shapes
    local Ex, Ey = BB.ExEy_GxGy_gauss(x, y, sigx, sigy, sigtol, true)

    local bet = pt2beta(pt, beta)
    local kck = (qelect*bchg)*(1 + bet*bbeta)/(p0c * (bet+bbeta))

    m[i].px = px-dpx + kck*Ex
    m[i].py = py-dpy + kck*Ey
  end

  m.atdebug(elm, m, lw, 'bbeam_kick:1')
end

function M.bbeam_kick6D (elm, m, lw, istp)                                   -- unchecked
  m.atdebug(elm, m, lw, 'bbeam_kick6D:0')

  error("NYI")

  m.atdebug(elm, m, lw, 'bbeam_kick6D:1')
end

-- DKD, TKT -------------------------------------------------------------------o

function M.nllens_kick (elm, m, lw, istp)                                    -- unchecked
  m.atdebug(elm, m, lw, 'nllens_kick:0')

  local knll, cnll in elm
  local tdir, beam in m
  local chg = beam.charge*tdir

  assert(cnll ~= 0, "invalid cnll (non-zero expected)")
  knll = knll/cnll

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local chg = beam and beam.charge*tdir or chg

    x = x/cnll
    y = y/cnll

    local  xp1 = x+1
    local  xm1 = x-1
    local  xpy = 0.5*sqrt(xp1^2+y^2)
    local  xmy = 0.5*sqrt(xm1^2+y^2)
    local _xpy = 0.25/xpy
    local _xmy = 0.25/xmy

    local    u = xmy + xpy
    local    v = xpy - xmy
    local   u2 = u^2
    local   v2 = v^2
    local _uv2 = 1/(u2-v2)
    local  um1 = sqrt(u2-1)
    local  mv1 = sqrt(1-v2)
    local  lum = log(u+um1)*um1
    local  acv = (acos(v)-pi_2)*mv1
    local  duv = 1 - 2*(u*lum+v*acv)*_uv2
    local   dd = u == 1 and 0 or lum*(u/um1)^2

    local  dUu = (lum+dd            + u*duv)*_uv2
    local  dUv = (acv*(1-(v/mv1)^2) - v*duv)*_uv2

    local  dux = xm1*_xmy + xp1*_xpy
    local  duy =  y *_xmy +  y *_xpy
    local  dvx = xp1*_xpy - xm1*_xmy
    local  dvy =  y *_xpy -  y *_xmy

    m[i].px = px + (chg*knll)*(dUu*dux + dUv*dvx)
    m[i].py = py + (chg*knll)*(dUu*duy + dUv*dvy)
  end

  m.atdebug(elm, m, lw, 'nllens_kick:1')
end

-- DKD, TKT -------------------------------------------------------------------o

local V6 = vector(6)

function M.genm_thick (elm, m, lw, istp)                                     -- unchecked
  m.atdebug(elm, m, lw, 'genm_thick:0')

  local update = elm:var_get'update'
  if update then update(elm, m, lw) end -- update damap

  local damap in elm
  for i=1,m.npar do
    local m = m[i]
    if is_damap(m) then
      damap:compose(m, m)
    else
      local v = V6:fill{m.x, m.px, m.y, m.py, m.t, m.pt}
      damap:eval(v, v)
      m.x, m.px, m.y, m.py, m.t, m.pt = v[1], v[2], v[3], v[4], v[5], v[6]
    end
  end

  m.atdebug(elm, m, lw, 'genm_thick:1')
end

-- fringes --------------------------------------------------------------------o

local tobit, fbit, fset, fcut, ftst in MAD.gfunc

  -- fringe fields (elements fringe attribute)
M.fringe = {
  none  = tobit(0),
  bend  =  fbit(0),               -- bending    fringe fields
  mult  =  fbit(1),               -- multipolar fringe fields
  qsad  =  fset(fbit(1),fbit(2)), -- multipolar fringe fields with quad SAD
  solen =  fbit(3),               -- solenoid   fringe fields
  rfcav =  fbit(4),               -- rfcavity   fringe fields

  -- sbend+quadrupole
  comb   = fset(fbit(0),fbit(1)),
  combqs = fset(fbit(0),fbit(1),fbit(2)), -- with fsad
}
-- for k,v in pairs(M.fringe) do print(k,v) end

local fringe in M

--[[
Policy in MAD-X PTC:
====================
k%fringe                T/F        ptc_setswitch equivalent to permfringe=1
el%likemad              T/F        special flag for true rbend
el%thin                 T/F        disable fringe for cavity
el%permfringe           0,1,2,3    0:none, 1:mult_fringe, 2:qsad_fringe, 3:1+2
el%bend_fringe          T/F        bend_fringe (and mult_fringe-bend_fringe)
el%highest_fringe       N (N=2)    limit of mult_fringe
el%kill_ent_fringe      T/F        disable fringe on entry
el%kill_exi_fringe      T/F        disable fringe on exit

FRINGE_STRAIGHT: (TRACK_FRINGE)
  EDGE, MULTIPOLE_FRINGE, FRINGE2QUAD

FRINGE_STREX[LIKEMAD=TRUE]:
  ROT_XZ, FACE, FRINGE_DIPOLE, MULTIPOLE_FRINGE, FRINGE2QUAD, WEDGE
FRINGE_STREX:
  EDGE_TRUE_PARALLEL, MULTIPOLE_FRINGE, FRINGE2QUAD

FRINGE_TEAPOT[EDGE/=0]:
  ROT_XZ, FACE, FRINGE_DIPOLE, MULTIPOLE_FRINGE, FRINGE2QUAD, MAD8WEDGE, WEDGE
FRINGE_TEAPOT:
  FACE, FRINGE_DIPOLE, MULTIPOLE_FRINGE, FRINGE2QUAD

FRINGE_DIPOLE[BEND_FRINGE=TRUE]
FRINGE2QUAD[PERMFRINGE=2.or.3]
MULTIPOLE_FRINGE[PERMFRINGE=1.or.3]

NEWFACE[EXACT] / FACE[.not.EXACT]
EDGE
EDGE_TRUE_PARALLEL

FRINGECAV[PERMFRINGE/=0,THIN/=T,NOCAVITY/=T,N_BESSEL/=-1]
--]]

 -- forward declarations
local mad8_wedge, bend_wedge, bend_face
local bend_fringe, mult_fringe, qsad_fringe, sol_fringe, cav_fringe

function M.strex_fringe (elm, m, lw_)  -- [FRINGE_STREX]                     -- checked
  m.atdebug(elm, m, lw_, 'strex_fringe:0')

  local lw = lw_ or 1
  local sdir, tdir in m

  if lw == 1 and elm.kill_ent_fringe or lw == -1 and elm.kill_exi_fringe
  then m.frng = 0
  else m.frng = fcut(m.fringe, elm.fringe)
  end

  local e1, e2 = (m.e1 or elm.e1)*tdir, (m.e2 or elm.e2)*tdir
  local h1, h2 =          elm.h1 *tdir,          elm.h2 *tdir

  if sdir == -1 then e1, e2, h1, h2 = e2, e1, h2, h1 end -- swap

  if sdir*lw == 1 then
! print(lw == 1 and 'forward entry' or 'backward exit')
    yrotation(elm, m, 1, -e1)
    if m.pdir == lw then                           -- Entering magnet
      for i=1,m.npar do
        m[i].x = m[i].x+m.elc*sin((e2-e1)/2)       -- EDGE_TRUE_PARALLEL
      end
    end
    bend_face(elm, m, 1, h1)
    if m.frng ~= 0 then
      if ftst(m.frng, fringe.bend) then bend_fringe(elm, m, 1) end
      if ftst(m.frng, fringe.mult) then mult_fringe(elm, m, 1) end
      if ftst(m.frng, fringe.qsad) then qsad_fringe(elm, m, 1) end
    end
    if not m.pdir then                    -- ! EDGE_TRUE_PARALLEL
      local a = 0.5*m.eh*(m.eld or m.el) - e1
      bend_wedge(elm, m, 1, a)
    end
  else
! print(lw == -1 and 'forward exit' or 'backward entry')
    if not m.pdir then                    -- ! EDGE_TRUE_PARALLEL
      local a = 0.5*m.eh*(m.eld or m.el) - e2
      bend_wedge(elm, m, -1, a)
    end
    if m.frng ~= 0 then
      if ftst(m.frng, fringe.qsad) then qsad_fringe(elm, m, -1) end
      if ftst(m.frng, fringe.mult) then mult_fringe(elm, m, -1) end
      if ftst(m.frng, fringe.bend) then bend_fringe(elm, m, -1) end
    end
    bend_face(elm, m, -1, h2)
    if m.pdir == lw then                                -- Exiting magnet
      for i=1,m.npar do
        m[i].x = m[i].x+m.elc*sin((e2-e1)/2)            -- EDGE_TRUE_PARALLEL
      end
    end
    yrotation(elm, m, -1, e2)
  end

  m.atdebug(elm, m, lw_, 'strex_fringe:1')
end

function M.curex_fringe (elm, m, lw_) -- [FRINGE_TEAPOT]                     -- checked
  m.atdebug(elm, m, lw_, 'curex_fringe:0')

  local lw = lw_ or 1
  local sdir, tdir in m
  local e, h

  if lw == 1 and elm.kill_ent_fringe or lw == -1 and elm.kill_exi_fringe
  then m.frng = 0
  else m.frng = fcut(m.fringe, elm.fringe)
  end

  if lw == 1
  then e, h = m.e1*tdir, elm.h1*tdir
  else e, h = m.e2*tdir, elm.h2*tdir
  end

  if sdir*lw == 1 then
-- print(lw == 1 and 'forward entry' or 'backward exit')
    yrotation (elm, m, 1, -e)
    bend_face (elm, m, 1,  h)
    if m.frng ~= 0 then
      if ftst(m.frng, fringe.bend) then bend_fringe(elm, m, 1) end
      if ftst(m.frng, fringe.mult) then mult_fringe(elm, m, 1) end
      if ftst(m.frng, fringe.qsad) then qsad_fringe(elm, m, 1) end
    end
--    if e ~= 0 then MAD.dbg() end
    mad8_wedge(elm, m, 1,  e)
    bend_wedge(elm, m, 1, -e)
  else
-- print(lw == -1 and 'forward exit' or 'backward entry')
    bend_wedge(elm, m, -1,-e)
    mad8_wedge(elm, m, -1, e)
    if m.frng ~= 0 then
      if ftst(m.frng, fringe.qsad) then qsad_fringe(elm, m, -1) end
      if ftst(m.frng, fringe.mult) then mult_fringe(elm, m, -1) end
      if ftst(m.frng, fringe.bend) then bend_fringe(elm, m, -1) end
    end
    bend_face (elm, m, -1, h)
    yrotation (elm, m, -1, e)
  end

  m.atdebug(elm, m, lw_, 'curex_fringe:1')
end

function M.solen_fringe (elm, m, lw_)
  m.atdebug(elm, m, lw_, 'solen_fringe:0')

  local lw = lw_ or 1
  if lw == 1 and elm.kill_ent_fringe or lw == -1 and elm.kill_exi_fringe
  then m.frng = 0
  else m.frng = fcut(m.fringe, elm.fringe)
  end

  if ftst(m.frng, fringe.solen) then
-- lw ==  1: 'forward entry' or 'backward exit'
-- lw == -1: 'forward exit'  or 'backward entry'
    sol_fringe(elm, m, sdir*lw)
  end

  m.atdebug(elm, m, lw_, 'solen_fringe:1')
end

local function adjust_time (m)
  if abs(m.el) < minlen then return end

  local Tl = (m.T-m.Tbak)*m.el
  local beta = m.beam.beta
  for i=1,m.npar do
    local t, beam in m[i]
    local beta = beam and beam.beta or beta
    m[i].t = t + Tl/beta -- adjust time of flight
  end
end

function M.rfcav_fringe (elm, m, lw_) -- [ADJUST_TIME_CAV4, FRINGECAV]       -- checked
  m.atdebug(elm, m, lw_, 'rfcav_fringe:0')

  local lw = lw_ or 1
  local sdir, beam in m

  if lw == 1 and elm.kill_ent_fringe or lw == -1 and elm.kill_exi_fringe
  then m.frng = 0
  else m.frng = fcut(m.fringe, elm.fringe)
  end

  if sdir*lw == 1 then
-- print(lw == 1 and 'forward entry' or 'backward exit', 'T=', m.T, elm.totalpath)
    assert(m.Tbak == nil, "inconsistent totalpath when entering rfcavity")
    m.Tbak, m.T = m.T, 0
    if not elm.no_cavity_totalpath then
      m.T, m.lag = 1, m.lag - m.freq*abs(m.el)*pi_clight/beam.beta -- t=0 => accel=0
    end
    if lw == -1 and m.T ~= m.Tbak then adjust_time(m) end
    if ftst(m.frng, fringe.rfcav) then cav_fringe(elm, m,  1) end
  else
-- print(lw == -1 and 'forward exit' or 'backward entry', 'T=', m.T, m.Tbak)
    if ftst(m.frng, fringe.rfcav) then cav_fringe(elm, m, -1) end
    if lw == -1 and m.T ~= m.Tbak then adjust_time(m) end
    m.T, m.Tbak = m.Tbak, nil
  end

  m.atdebug(elm, m, lw_, 'rfcav_fringe:1')
end

-- fringes helpers ------------------------------------------------------------o

function bend_face (elm, m, lw, h) -- [NEWFACE]                              -- checked
  if h == 0 then return end
  local el, eld, knl in m
  if abs(el) < minlen or abs(knl[1]) < minstr then return end

  m.atdebug(elm, m, lw, 'bend_face:0')

  local edir, sdir, tdir, beam in m
  ! h is weighted by tdir, el is weighted by sdir, so to get tdir back, we need to multiply by sdir
  local   k0h = 0.5*h * knl[1]/el * sdir
  local   chg = beam.charge
  local _beta = 1/beam.beta

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local chg   = beam and beam.charge or chg
    local k0hq  = k0h*chg -- k0hq must be weighted by bdir

    if tdir == 1 then -- to insure reversal symmetry ; horizontal wedge (only tdir)
      px = px + k0hq*x^2
    end

    local dpp      =  1 + 2*pt*_beta + pt^2
    local _pt2     =  1/(dpp - px^2)
    local xi       =  2*k0hq*sqrt(dpp)*_pt2
    local dxi_px   =  2*px*xi         *_pt2
    local dxi_ddel = -2   *xi*(1+pt)  *_pt2
    local y2       = y^2

    x  = x / (1-dxi_px*y2)
    px = px - xi*y2
    py = py - 2*xi*x*y
    t  = t  + dxi_ddel*x*y2

    if tdir == -1 then -- to insure reversal symmetry; horizontal wedge (only tdir)
      px = px + k0hq*x^2
    end

    m[i].x  = x
    m[i].px = px
    m[i].py = py
    m[i].t  = t
  end

  m.atdebug(elm, m, lw, 'bend_face:1')
end

function mad8_wedge (elm, m, lw_, e)     -- [FRINGE_TEAPOT:MAD8_WEDGE]            -- checked
  if e == 0 or abs(m.knl[2]) < minstr then return end
  m.atdebug(elm, m, lw_, 'mad8_wedge:0')

  local el, eld, edir, knl, frng, beam in m
  local   wc = frng == 0 and 0 or 0.25
  local  k1e = e*knl[2]/el*edir
  local   c1 = (1+wc)*k1e
  local   c2 = (1-wc)*k1e
  local  chg = beam.charge

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local chg = beam and beam.charge or chg
    m[i].px = px + (chg*c1  )*x^2 - (chg*c2)*y^2
    m[i].py = py - (chg*c2*2)*x*y
  end

  m.atdebug(elm, m, lw_, 'mad8_wedge:1')
end

function bend_wedge (elm, m, lw_, e) -- [WEDGE] see also [sr]bend_thick      -- checked
  if e == 0 then return end
  if abs(m.knl[1]) < minstr then return yrotation(-e,m,1) end
  m.atdebug(elm, m, lw_, 'bend_wedge:0')

  local el, eld, tdir, knl, beam in m
  local    k0 = knl[1]/el*tdir
  local    b1 = k0*beam.charge
  local _beta = 1/beam.beta
  local sa, ca, s2a = sin(e), cos(e), sin(2*e)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    -- Note: for now, ignore wedge for photons to avoid NaN due to b1=0
    if beam and beam.charge == 0 then goto continue end

    local _beta = beam and 1/beam.beta or _beta
    local    b1 = beam and k0*beam.charge or b1

    local pzy = 1 + (2*_beta)*pt + pt^2 - py^2
    local _pt = 1/sqrt(pzy)
    local  pz = sqrt(pzy - px^2)
    local pzx = pz - b1*x
    local npx = px*ca + pzx*sa
    local pzs = sqrt(pzy - npx^2)
    local dxs = (e + asin(px*_pt) - asin(npx*_pt))/b1

    m[i].x  = x*(ca + (px*s2a + sa^2*(pz+pzx))/(pzs + pz*ca - px*sa))
    m[i].px = npx
    m[i].y  = y + dxs*py
    m[i].t  = t - dxs*(_beta+pt)

    ::continue::
  end

  m.atdebug(elm, m, lw_, 'bend_wedge:1')
end

function bend_fringe (elm, m, lw) -- [FRINGE_DIPOLE]                         -- checked
  if abs(m.knl[1]) < minang then return end
  m.atdebug(elm, m, lw, 'bend_fringe:0')

  local el, eld, sdir, tdir, beam in m
  local    fh = elm.hgap*(sdir*lw == -1 and elm.fintx or elm.fint)
  local  fsad = fh ~= 0 and 1/(72*fh) or 0
  local   k0w = m.knl[1]/abs(el)*tdir*lw
  local    b0 = k0w*beam.charge
  local _beta = 1/beam.beta

! printf("lw=% d, sdir=% d, el=% -.4f, fh=% -.5e, b0=% -.5e\n",
!         lw, sdir, el, fh, b0)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local    b0 = beam and k0w*beam.charge or b0
    local    c2 = b0*fh*2

    local   dpp = 1 + 2*_beta*pt + pt^2
    local    pz = sqrt(dpp - px^2 - py^2)
    local   _pz = 1/pz
    local  _pz2 = _pz^2
    local  relp = 1/sqrt(dpp)
    local  tfac = -(_beta + pt)
    local    c3 = b0^2*fsad*relp

    local xp,  yp  = px/pz, py/pz
    local xyp, yp2 = xp*yp, 1+yp^2
    local xp2,_yp2 = xp^2 , 1/yp2

    local fi0 = atan((xp*_yp2)) - c2*(1 + xp2*(1+yp2))*pz
    local co2 = b0/cos(fi0)^2
    local co1 = co2/(1 + (xp*_yp2)^2)*_yp2
    local co3 = co2*c2

    local fi1 =    co1          - co3*2*xp*(1+yp2)*pz
    local fi2 = -2*co1*xyp*_yp2 - co3*2*xp*xyp    *pz
    local fi3 =                 - co3*(1 + xp2*(1+yp2))

    local kx = fi1*(1+xp2)*_pz  + fi2*xyp*_pz      - fi3*xp
    local ky = fi1*xyp*_pz      + fi2*yp2*_pz      - fi3*yp
    local kz = fi1*tfac*xp*_pz2 + fi2*tfac*yp*_pz2 - fi3*tfac*_pz

    if sdir == 1 then
      y  = 2*y / (1 + sqrt(1-2*ky*y))
      local y2 = y^2

      m[i].x  = x  + 0.5*kx*y2
      m[i].py = py - (4*c3*y2 + b0*tan(fi0))*y
      m[i].t  = t  + (0.5*kz  + c3*y2*relp^2*tfac)*y2
      m[i].y  = y
    else -- need to reverse y-dependence
      local y2 = y^2

      m[i].x  = x  - 0.5*kx*y2
      m[i].py = py + (4*c3*y2 + b0*tan(fi0))*y
      m[i].t  = t  - (0.5*kz + c3*y2*relp^2*tfac)*y2
      m[i].y  = 0.5*y * (1 + sqrt(1-2*ky*y))
    end
  end

  m.atdebug(elm, m, lw, 'bend_fringe:1')
end

function qsad_fringe (elm, m, lw) -- [FRINGE2QUAD]                           -- unchecked
  if abs(m.knl[2])+abs(m.ksl[2]) < minstr then return end                    -- need SAD f1 & f2
  local f1, f2 in elm
  if abs(f1)+abs(f2) < minstr then return end

  m.atdebug(elm, m, lw, 'qsad_fringe:0')

-- fwd entry, bwd exit : lw= 1
-- fwd exit , bwd entry: lw=-1

  local el, eld, tdir, k1, ca, sa, beam in m
  local _beta = 1/beam.beta
  local  wchg = beam.charge*lw

  local edir, knl, ksl in m
  local a  = -0.5*atan2(ksl[2], knl[2])
  local b2 = sqrt(knl[2]^2 + ksl[2]^2)/el*edir
  local ca, sa = cos(a), sin(a)

  f1 = -abs(f1)*f1*b2/24
  f2 =          f2*b2

  -- Lee-Whiting formula, E. Forest ch 13.2.3, eq 13.33
  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local  wchg = beam and beam.charge*lw or wchg
    local   _pz = 1/sqrt(1 + (2*_beta)*pt + pt^2)
    local    dt = (_beta+pt)*_pz

    local f1 = (wchg*f1)*_pz
    local f2 =       f2 *_pz

    local nx  = ca*x  + sa*y
    local npx = ca*px + sa*py
    local ny  = ca*y  - sa*x
    local npy = ca*py - sa*px

    m[i].t  = t - dt*((f1*nx + (1+f1/2)*exp(-f1)*f2*npx*_pz)*npx -
                      (f1*ny + (1-f1/2)*exp( f1)*f2*npy*_pz)*npy)*_pz

    x  =  nx*exp( f1) + f2*npx*_pz
    y  =  ny*exp(-f1) - f2*npy*_pz
    px = npx*exp(-f1)
    py = npy*exp( f1)

    m[i].x  = ca*x  - sa*y
    m[i].px = ca*px - sa*py
    m[i].y  = ca*y  + sa*x
    m[i].py = ca*py + sa*px
  end

  m.atdebug(elm, m, lw, 'qsad_fringe:1')
end

function mult_fringe (elm, m, lw) -- [MULTIPOLE_FRINGE]                      -- checked
  local fmax = elm.frngmax or m.frngmax
  if min(m.nmul,fmax) == 0 then return end

  m.atdebug(elm, m, lw, 'mult_fringe:0')

  local el, eld, edir, sdir, tdir, nmul, knl, ksl, beam in m
  local _beta = 1/beam.beta
  local    _l = el ~= 0 and tdir/el or edir
  local  wchg = beam.charge*lw

  local no_k1 = ftst(m.frng, fringe.bend)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local _beta = beam and 1/beam.beta or _beta
    local  wchg = beam and beam.charge*lw or wchg
    local   _pz = 1/sqrt(1 + (2*_beta)*pt + pt^2)

    local rx, ix = 1, 0
    local fx, fxx, fxy = 0, 0, 0
    local fy, fyx, fyy = 0, 0, 0

    -- NOTE: this loop is not fully time reversable to numerical precision,
    --       because it depends on x,y and affects x,y (not a thin lens)
    for j=1,min(nmul,fmax) do
      local drx, dix = rx, ix
      rx = drx*x - dix*y
      ix = drx*y + dix*x

      local nj, nf = -wchg/(4*(j+1)), (j+2)/j
      local kj, ksj = knl[j]*_l, ksl[j]*_l
      local u, v, du, dv

!      printf("lw=% d, sdir=% d, j=%d, nj=% -.5f, nf=% -.5f, rx=% -.16e, ix=% -.16e, \z
!              drx=% -.16e, dix=% -.16e, kj=% -.16e, ksj=% -.16e, ",
!              lw, sdir, j, nj, nf, rx, ix, drx, dix, kj, ksj)

      if j == 1 and no_k1 then
        u  = nj*(       - ksj*ix )
        v  = nj*(       + ksj*rx )
        du = nj*(       - ksj*dix)
        dv = nj*(       + ksj*drx)
      else
        u  = nj*(kj*rx  - ksj*ix )
        v  = nj*(kj*ix  + ksj*rx )
        du = nj*(kj*drx - ksj*dix)
        dv = nj*(kj*dix + ksj*drx)
      end

      local dux, dvx =  j*du, j*dv
      local duy, dvy = -j*dv, j*du

!      printf("u=% -.16e, v=% -.16e, du=% -.16e, dv=% -.16e, ", u, v, du, dv)

      fx  = fx  +   u*x + nf*   v*y
      fy  = fy  +   u*y - nf*   v*x
      fxx = fxx + dux*x + nf* dvx*y + u
      fyy = fyy + duy*y - nf* dvy*x + u
      fxy = fxy + duy*x + nf*(dvy*y + v)
      fyx = fyx + dux*y - nf*(dvx*x + v)

!      printf("fx=% -.16e, fy=% -.16e, fxx=% -.16e, fyy=% -.16e, fxy=% -.16e, fyx=% -.16e\n",
!              fx, fy, fxx, fyy, fxy, fyx)
    end

    local    a = 1 - fxx*_pz
    local    b =   - fyx*_pz
    local    c =   - fxy*_pz
    local    d = 1 - fyy*_pz
    local _det = 1/(a*d - b*c)
    local  npx = (d*px - b*py)*_det
    local  npy = (a*py - c*px)*_det

    m[i].x  = x - fx*_pz
    m[i].y  = y - fy*_pz
    m[i].px = npx
    m[i].py = npy
    m[i].t  = t + (_beta+pt)*(npx*fx + npy*fy)*_pz^3
  end

  m.atdebug(elm, m, lw, 'mult_fringe:1')
end

function sol_fringe (elm, m, lw)                                             -- unchecked
  -- TODO: shortcut
  m.atdebug(elm, m, lw, 'solent_fringe:0')

  local m1, m2, p0, s0 in elm
  local tdir, ksi, beam in m
  local k , k2 = ksi, ksi^2
  local    ekm = exp(0.25*k2*m2)
  local   _ekm = 1/ekm
  local c1, c2 = sqrt(2/3)*_ekm, sqrt(3/8)*_ekm

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]

    local r2 = x^2+y^2
    local  J = x*py - y*px ; if lw == -1 then J = J + 0.5*k*r2 end
    local  q = x*px + y*py
    local J2, kJ, r, phi = J^2, k*J, sqrt(r2), atan2(y,x)
    local  J_r = J/r
    local  ekJ = exp(0.25*kJ)
    local _ekJ = 1/ekJ

    local R, Q, P, R2
    if lw == 1 then
      R = sqrt(J2 / (4+kJ + ekJ*((J_r*ekm)^2-4)))
      Q = (1 - (4-_ekJ*(4+kJ))*r2/J2*_ekm^2)
          *(c1*r*tan((c2*k2*m1)*r) - (0.125*k2)*r2^2*(p0+(3/32*s0)*r2) + q)
      P = phi - Q*(0.125*k-J*(R/J2)^2*(4*(1-ekJ)+kJ*(1+0.125*kJ)))
    else -- lw == -1
      R = ekm * sqrt(J2 / (4 + _ekJ*(J_r^2-4-kJ))) ; R2 = R^2
      Q = q/(1 - (4-_ekJ*(4+kJ))*R2/J2*_ekm^2)
          + c1*R*tan((c2*k2*m1)*R) - (0.125*k2)*R2^2*(p0+(3/32*s0)*R2)
      P = phi + q*(0.125*k-J*(r/J2)^2*(4*(1-ekJ)+kJ*(1+0.125*kJ)))
    end

    local cP, sP = cos(P), sin(P)
    local Q_R, J_R = Q/R, J/R

    if lw == 1 then J_R = J_R - (0.5*k)*R end

    m[i].x  =   R*cP
    m[i].px = Q_R*cP - J_R*sP
    m[i].y  =   R*sP
    m[i].px = Q_R*sP + J_R*cP
  end

  m.atdebug(elm, m, lw, 'solent_fringe:1')
end

function cav_fringe (elm, m, lw) -- [FRINGECAV]                              -- checked
  if abs(m.el) < minlen then return end
  m.atdebug(elm, m, lw, 'cav_fringe:0')

  local el, volt, freq, lag, tdir, beam in m
  local    w = freq*twopi_clight
  local wchg = beam.charge/beam.pc
  local   vl = 0.5*lw/el*wchg*tdir*volt

!  printf('@@ vl=% -.16e, omega=% -.16e, phase=% -.16e, p0c=% -.16e, yl=% -.16e\n',
!          vl, w, lag, beam.pc, m.el*lw)

  for i=1,m.npar do
    local x, px, y, py, t, pt, beam in m[i]
    local  vl = beam and vl*beam.charge/(beam.pc*wchg) or vl
    local  s1 = sin(lag - w*t)
    local  c1 = cos(lag - w*t)

    m[i].px = px - vl*s1*x
    m[i].py = py - vl*s1*y
    m[i].pt = pt + (0.5*vl*w)*c1*(x^2 + y^2)
  end

  m.atdebug(elm, m, lw, 'cav_fringe:1')
end

-- extra fringe (not used) ----------------------------------------------------o

function M.dipeg_fringe (elm, m, lw_) -- [MADX dipedge]                      -- unchecked
  if abs(m.knl[1]) < minstr then return end -- switched off
  m.atdebug(elm, m, lw_, 'dipeg_fringe:0')

  local lw = lw_ or 1
  local el, eld, edir, sdir, tdir, knl, beam in m
  local k0 = knl[1]/el*tdir
  local corr, e = 0, 0

  if lw == 1 then
    e = m.e1*tdir
    if not elm.kill_ent_fringe then
      corr = 2*k0*elm.hgap*elm.fint
    end
  else
    e = m.e2*tdir
    if not elm.kill_exi_fringe then
      corr = 2*k0*elm.hgap*(elm.fintx or elm.fint)
    end
  end

  if e == 0 and corr == 0 then
    m.atdebug(elm, m, lw_, 'dipeg_fringe:1')
    return
  end

  local chg = beam.charge
  local r21 = k0*tan(e)
  local r43 = corr == 0 and -r21 or -k0 * tan(e - corr/cos(e)*(1+sin(e)^2))

  for i=1,m.npar do
    local x, px, y, py, beam in m[i]
    local chg = beam and beam.charge or chg

    m[i].px = px + chg*r21*x
    m[i].py = py + chg*r43*y
  end

  m.atdebug(elm, m, lw_, 'dipeg_fringe:1')
end

-- end ------------------------------------------------------------------------o
return { dynmap = M }
