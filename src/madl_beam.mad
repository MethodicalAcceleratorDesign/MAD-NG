--[=[
 o-----------------------------------------------------------------------------o
 |
 | Beam module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide beam command

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local abs, sqrt                                                  in math
local object, tostring                                           in MAD
local setkeys, countkeys, fprintf                                in MAD.utility
local is_object, is_nil, is_boolean, is_string, is_table,
      is_function, is_positive, is_integer, is_mappable          in MAD.typeid
local clight, qelect, emass, pmass, mumass, deumass              in MAD.constant

local GeV_c = 1e9/clight
local krad_GeV = 1e-16*qelect*clight^2 -- 1e-9/(4pi.epsilon0) qelect

local update_skip = setkeys {
  '__id', 'particle', 'mass', 'charge', 'spin',
}

local show_order = setkeys {
  'name', 'kind',
  'particle', 'mass', 'charge', 'spin', 'emrad',
  'energy', 'pc', 'beta', 'gamma', 'betgam', 'brho',
  'ex', 'ey', 'et', 'exn', 'eyn', 'etn',
  'nbunch', 'npart', 'sigx', 'sigy', 'sigt', 'sige',
  'radiate',
}

-- identity -------------------------------------------------------------------o

local _id = {} -- identity

local function is_beam (a)
  local mt = getmetatable(a)
  return mt ~= nil and mt.__beam == _id
end

-- particles database ---------------------------------------------------------o

local particledb = {}

local function newparticle (particle, mass, charge, spin)
  spin = spin or 1/2
  assert(is_nil(particledb[particle]), "particle already in database")
  assert(is_string(particle), "invalid particle (string expected)")
  assert(is_positive(mass)  , "invalid mass (positive number expected)")
  assert(is_integer(charge) , "invalid charge (integer expected)")
  assert(is_integer(2*spin) and spin >= 0,
                              "invalid spin (positive half integer expected)")
  particledb[#particledb+1] = particle
  particledb[particle] = { mass=mass, charge=charge, spin=spin }
end

local function new_particle (self, tbl)
  if not is_beam(self) and is_nil(tbl) then
    assert(is_table(self) , "invalid argument #1 (table expected)")
    tbl, self = self, nil -- right shift
  else
    assert(is_beam(self), "invalid argument #1 (beam expected)")
    assert(is_table(tbl), "invalid argument #2 (table expected)")
  end
  newparticle(tbl.particle, tbl.mass, tbl.charge, tbl.spin)
  return self
end

local function showdb (self, file)
  if not is_beam(self) and is_nil(file) then
    file, self = self, nil -- right shift
  end
  file = file or io.stdout
  for _,k in ipairs(particledb) do
    local mass, charge, spin in particledb[k]
    fprintf(file,"%-12s: mass = %-17s [GeV], charge = % -4d, spin = % -.1g\n",
                      k,         mass,               charge,          spin)
  end
  return self
end

-- populate particle database
new_particle{ particle = 'electron'  , mass = emass  , charge = -1, spin = 1/2 }
new_particle{ particle = 'positron'  , mass = emass  , charge =  1, spin = 1/2 }
new_particle{ particle = 'proton'    , mass = pmass  , charge =  1, spin = 1/2 }
new_particle{ particle = 'antiproton', mass = pmass  , charge = -1, spin = 1/2 }
new_particle{ particle = 'muon'      , mass = mumass , charge = -1, spin = 1/2 }
new_particle{ particle = 'antimuon'  , mass = mumass , charge =  1, spin = 1/2 }
new_particle{ particle = 'deuteron'  , mass = deumass, charge =  1, spin = 1   }

-- implementation -------------------------------------------------------------o

local beam = object 'beam' { kind = 'beam',
  -- particle
  particle  = 'positron',                              --                   [RW]
  mass      = particledb.positron.mass,                -- GeV (m.c^2)       [RO]
  charge    = particledb.positron.charge,              -- ±n qelect         [RO]
  spin      = particledb.positron.spin,                -- ±n/2              [RO]
  emrad     = \s -> krad_GeV * s.charge^2/s.mass,      -- m                 [RO]
  -- energy
  energy    = 1,                                       -- GeV               [RW]
  pc        = \s -> sqrt(s.energy^2 - s.mass^2),       -- GeV               [RU]
  beta      = \s -> sqrt(1 - (s.mass/s.energy)^2),     --                   [RU]
  gamma     = \s -> s.energy/s.mass,                   --                   [RU]
  betgam    = \s -> sqrt(s.gamma^2-1),                 --                   [RU]
  brho      = \s -> GeV_c * s.pc/abs(s.charge),        -- T.m               [RU]
  -- emittance
  ex        = 1,                                       -- rad.m             [RW]
  ey        = 1,                                       -- rad.m             [RW]
  et        = 1e-3,                                    -- rad.m             [RW]
  exn       = \s -> sqrt(s.gamma^2 - 1)*s.ex,          -- rad.m             [RU]
  eyn       = \s -> sqrt(s.gamma^2 - 1)*s.ey,          -- rad.m             [RU]
  etn       = \s -> sqrt(s.gamma^2 - 1)*s.et,          -- rad.m             [RU]
  -- bunch
  nbunch    = 0,                                       --                   [RW]
  npart     = 0,                                       -- per bunch         [RW]
  sigx      = 1,                                       -- m                 [RW]
  sigy      = 1,                                       -- m                 [RW]
  sigt      = 1,                                       -- m                 [RW]
  sige      = 1e-3,                                    -- GeV               [RW]
  -- flags
  radiate   = false,                                   --                   [RW]
}

local newidx = getmetatable(beam).__newindex         -- forward to parent
local eval   = \s,v -> is_function(v) and v(s) or v  -- for proper evaluation

local update = setmetatable({
  -- particle
  particle = \s,_,v => v = eval(s,v)
                       assert(particledb[v],"unknown particle")
                       newidx(s,'particle',v)
                       newidx(s,'mass'    ,particledb[eval(s,v)].mass  )
                       newidx(s,'charge'  ,particledb[eval(s,v)].charge)
                       newidx(s,'spin'    ,particledb[eval(s,v)].spin  ) end,
  mass   := error(  "mass is readonly, define a new particle"),
  charge := error("charge is readonly, define a new particle"),
  spin   := error(  "spin is readonly, define a new particle"),
  emrad  := error( "emrad is readonly, define a new particle"),
  -- energy
  energy = \s,_,v => v = eval(s,v)
                     assert(v > s.mass, "invalid energy (mass < energy expected)")
                     newidx(s, 'energy', v) end,
  pc     = \s,_,v => v = eval(s,v)
                     assert(is_positive(v), "invalid pc (pc >0 expected)")
                     newidx(s, 'energy', sqrt(v^2 + s.mass^2)) end,
  beta   = \s,_,v => v = eval(s,v)
                     assert(is_positive(v) and v<0.9, "invalid beta (0< beta <0.9 expected)")
                     newidx(s, 'energy', sqrt(s.mass^2 / (1-v^2))) end,
  gamma  = \s,_,v => v = eval(s,v)
                     assert(is_positive(v) and v>1, "invalid gamma (gamma >1 expected)")
                     newidx(s, 'energy', v * s.mass) end,
  betgam = \s,_,v => v = eval(s,v)
                     assert(is_positive(v) and v>0.1, "invalid betgam (betgam >0.1 expected)")
                     newidx(s, 'energy', sqrt((v^2+1) * s.mass^2)) end,
  brho   = \s,_,v => v = eval(s,v)
                     assert(is_positive(v), "invalid Brho (Brho >0 expected)")
                     newidx(s, 'energy', sqrt((v*abs(s.charge)/GeV_c)^2 + s.mass^2)) end,
  -- emittance
  ex     = \s,_,v => v=eval(s,v) assert(is_positive(v),"invalid ex <= 0" ) newidx(s,'ex',v) end,
  ey     = \s,_,v => v=eval(s,v) assert(is_positive(v),"invalid ey <= 0" ) newidx(s,'ey',v) end,
  et     = \s,_,v => v=eval(s,v) assert(is_positive(v),"invalid et <= 0" ) newidx(s,'et',v) end,
  exn    = \s,_,v => v=eval(s,v) assert(is_positive(v),"invalid exn <= 0") newidx(s,'ex',v/sqrt(s.gamma^2-1)) end,
  eyn    = \s,_,v => v=eval(s,v) assert(is_positive(v),"invalid eyn <= 0") newidx(s,'ey',v/sqrt(s.gamma^2-1)) end,
  etn    = \s,_,v => v=eval(s,v) assert(is_positive(v),"invalid etn <= 0") newidx(s,'et',v/sqrt(s.gamma^2-1)) end,
  -- bunch
  nbunch = \s,k,v => v=eval(s,v) assert(is_positive(v),"invalid nbunch <= 0") newidx(s,k,v) end,
  npart  = \s,k,v => v=eval(s,v) assert(is_positive(v),"invalid npart <= 0" ) newidx(s,k,v) end,
  sigx   = \s,k,v => v=eval(s,v) assert(is_positive(v),"invalid sigx <= 0"  ) newidx(s,k,v) end,
  sigy   = \s,k,v => v=eval(s,v) assert(is_positive(v),"invalid sigy <= 0"  ) newidx(s,k,v) end,
  sigt   = \s,k,v => v=eval(s,v) assert(is_positive(v),"invalid sigt <= 0"  ) newidx(s,k,v) end,
  sige   = \s,k,v => v=eval(s,v) assert(is_positive(v),"invalid sige <= 0"  ) newidx(s,k,v) end,
  -- flags
 radiate = \s,k,v => assert(is_boolean(v),"invalid radiate (boolean expected)")
                     newidx(s,k,v) end,
},-- default update (no check)
{ __index := newidx })

local function newindex (self, key, val)
  update[key](self,key,val)
end

local function init (self)
  local particle, mass, charge =
        self:raw_get'particle', self:raw_get'mass', self:raw_get'charge'
  if mass or charge then -- include new particle definition
    newparticle(particle, mass, charge, self:raw_get'spin')
  end
  if particle then newindex(self, 'particle', particle) end
  for k,v in pairs(self) do
    if is_nil(update_skip[k]) then newindex(self, k, v) end
  end
  return self
end

local function setv (self, tbl)
  assert(is_beam(self)   , "invalid argument #1 (beam expected)")
  assert(is_mappable(tbl), "invalid argument #2 (mappable expected)")
  local particle, mass, charge in tbl
  if mass or charge then -- include new particle definition
    newparticle(particle, mass, charge, tbl.spin)
  end
  if particle then newindex(self, 'particle', particle) end
  for k,v in pairs(tbl) do
    if is_nil(update_skip[k]) then newindex(self, k, v) end
  end
  return self
end

local function show (self, file)
  assert(is_beam(self), "invalid argument #1 (beam expected)")
  file = file or io.stdout
  for i,k in ipairs(show_order) do
    fprintf(file, "%-25s  %-25s\n", k, tostring(self[k]))
  end
  for _,k in ipairs(self:get_varkeys()) do
    if is_nil(show_order[k]) then
      fprintf(file, "%-25s  %-25s\n", k, tostring(self[k]))
    end
  end
  return self
end

do -- sanity checks (beam:26, update:24, show_order:26)
  local bn, un, sn = countkeys(beam), countkeys(update), #show_order
--  print(bn, un, sn)
  assert(bn == un+2, "inconsistency detected in beam module")
  assert(bn == sn  , "inconsistency detected in beam module")
end

-- members --------------------------------------------------------------------o

beam :set_methods {
  new_particle  = new_particle,
  show          = show,
  showdb        = showdb,

  -- overridden
  setv          = setv,
  set_variables = setv,

} :set_metamethods ({
  __beam     = _id,
  __init     = init,
  __newindex = newindex,

}, true) :set_readonly()

-- env ------------------------------------------------------------------------o

MAD.typeid.is_beam = is_beam

-- end ------------------------------------------------------------------------o
return { beam = beam }
