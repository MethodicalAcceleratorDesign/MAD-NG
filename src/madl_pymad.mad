--[=[
 o-----------------------------------------------------------------------------o
 |
 | Pymad module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: J. Gray, joshua.mark.gray at cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide MAD minimal feature to communicate with parent Python process

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local ffi = require "ffi"
local _C, complex, matrix, cmatrix, imatrix, range, logrange,
          monomial, tpsa, ctpsa                                    in MAD
local is_natural, is_int32, get_metatable                          in MAD.typeid

local type, assert, ipairs, tonumber,    metatable, table =
      type, assert, ipairs, tonumber, getmetatable, table

ffi.cdef [[
FILE*   fdopen (int fd, str_t mode); // wrap py_fd into a FILE*

size_t  fwrite (ptr_t buf, size_t sz, size_t n, FILE*);
size_t  fread  (void* buf, size_t sz, size_t n, FILE*);

void    setbuf (FILE*, char* buf);   // make _pyfp unbuffered
]]

-- data transfer --------------------------------------------------------------o

-- data

local function send_dat (self, dat, sz)
  if self._dbgf then io.write("***pymad.send: data "..sz.." bytes\n") end
  assert(_C.fwrite(dat, 1, sz, self._pyfp) == sz, "couldn't send data")
  return self
end

local function recv_dat (self, dat, sz)
  if self._dbgf then io.write("***pymad.recv: data "..sz.." bytes\n") end
  assert(_C.fread(dat, 1, sz, io.stdin) == sz, "couldn't receive data")
  return dat
end

-- nil

local send_nil = \s -> s
local recv_nil = \_ -> nil

-- boolean

local log    = ffi.new 'log_t[1]'
local log_sz = ffi.new 'log_t'

local function send_bool (self, b)
  log[0] = b
  return send_dat(self, log, log_sz)
end

local recv_bool = \s -> recv_dat(s, log, log_sz)[0]

-- int32

local int    = ffi.new    'int32_t[3]' -- used to hold mat dims and irange
local int_sz = ffi.sizeof 'int32_t'

local function send_int (self, n)
  int[0] = n
  return send_dat(self, int, int_sz)
end

local recv_int = \s -> recv_dat(s, int, int_sz)[0]

-- string

local function send_str (self, s)
  local n = #s
  return send_dat(send_int(self, n), s, n)
end

local function recv_str (self)
  local n = recv_int(self)
  return assert(io.read(n), "couldn't receive string")
end

-- number

local num    = ffi.new 'num_t[3]' -- used to hold complex, range and logrange
local num_sz = ffi.new 'num_t'

local function send_num (self, x)
  num[0] = x
  return send_dat(self, num, num_sz)
end

local recv_num = \s -> recv_dat(s, num, num_sz)[0]

-- complex

local function send_cnum (self, x)
  num[0], num[1] = x:reim()
  return send_dat(self, num, 2*num_sz)
end

local function recv_cnum (self)
  recv_dat(self, num, 2*num_sz)
  return complex(num[0], num[1])
end

-- range

local function send_grng (self, r)
  num[0], num[1], num[2] = r:start(), r:stop(), r:step()
  return send_dat(self, num, 3*num_sz)
end

local function recv_grng (self, ctor)
  recv_dat(self, num, 3*num_sz)
  return ctor(num[0], num[1], num[2])
end

local recv_rng  = \s -> recv_grng(s,    range)
local recv_lrng = \s -> recv_grng(s, logrange)

-- irange

local function is_irange (r)
  return is_int32(r.start) and is_int32(r.stop) and is_int32(r.step)
end

local function send_irng (self, r)
  int[0], int[1], int[2] = r.start, r.stop, r.step
  return send_dat(self, int, 3*int_sz)
end

local function recv_irng (self)
  recv_dat(self, int, 3*int_sz)
  return int[0]..int[1]..int[2]
end

-- matrix

local function send_gmat (self, m)
  int[0], int[1] = m.nrow, m.ncol
  send_dat(self, int, 2*int_sz)
  return sent_dat(self, m._dat, m:bytesize())
end

local function recv_gmat (self, ctor)
  recv_dat(self, int, 2*int_sz)
  local m = ctor(int[0], int[1])
  recv_dat(self, m._dat, m:bytesize())
  return m
end

local recv_mat  = \s -> recv_gmat(s,  matrix)
local recv_cmat = \s -> recv_gmat(s, cmatrix)
local recv_imat = \s -> recv_gmat(s, imatrix)

-- mono

local send_mono = \s,m -> send_str(s, m:tostring())
local recv_mono = \s   -> monomial(recv_str(s))

-- tpsa

local function send_gtpsa (self, x, send)
  local t = x:totable(true)
  local n = #t
  send_int(self, n)
  for i=1,n do send(send_str(self, t[i]), t[t[i]]) end
  return self
end

local send_tpsa = \s,x -> send_gtpsa(s, x, send_num )
local send_ctpa = \s,x -> send_gtpsa(s, x, send_cnum)

local recv_tpsa = \_ -> error("unsupported data type received: tpsa")
local recv_ctpa = \_ -> error("unsupported data type received: ctpsa")

-- table

local function send_tbl (self, t)
  local n = #t
  send_int(self, n)
  for i=1,n do self:send(t[i]) end -- deep copy
  return self
end

local function recv_tbl (self)
  local n = recv_int(self)
  local t = table.new(n,0)
  for i=1,n do t[i] = self:recv() end -- deep copy
  return t
end

-- object (table with metatable are treated as pure reference)

local send_obj = \s -> s
local recv_obj = \_ -> error("unsupported data type received: object")

-- dispatch tables ------------------------------------------------------------o

local type_fun = {
  nil_ = { send = send_nil , recv = recv_nil  },
  bool = { send = send_bool, recv = recv_bool },
  str_ = { send = send_str , recv = recv_str  },
  tbl_ = { send = send_tbl , recv = recv_tbl  },
  obj_ = { send = send_obj , recv = recv_obj  },
  int_ = { send = send_int , recv = recv_int  },
  num_ = { send = send_num , recv = recv_num  },
  cnum = { send = send_cnum, recv = recv_cnum },
  mat_ = { send = send_gmat, recv = recv_mat  },
  cmat = { send = send_gmat, recv = recv_cmat },
  imat = { send = send_gmat, recv = recv_imat },
  rng_ = { send = send_grng, recv = recv_rng  },
  lrng = { send = send_grng, recv = recv_lrng },
  irng = { send = send_irng, recv = recv_irng },
  mono = { send = send_mono, recv = recv_mono },
  tpsa = { send = send_tpsa, recv = recv_tpsa },
  ctpa = { send = send_ctpa, recv = recv_ctpa },
}

local type_str = {
  ['nil'    ]                  = \_ -> 'nil_',
  ['boolean']                  = \_ -> 'bool',
  ['string' ]                  = \_ -> 'str_',
  ['table'  ]                  = \a -> metatable(a) and 'obj_' or 'tbl_',
  ['number' ]                  = \a -> is_int32 (a) and 'int_' or 'num_',
--['cdata'  ]                  = must not be in this list!
  [get_metatable(complex (1))] = \_ -> 'cnum',
  [get_metatable( matrix (1))] = \_ -> 'mat_',
  [get_metatable(cmatrix (1))] = \_ -> 'cmat',
  [get_metatable(imatrix (1))] = \_ -> 'imat',
  [get_metatable(range   (1))] = \a -> is_irange(a) and 'irng' or 'rng_',
  [get_metatable(logrange(1))] = \_ -> 'lrng',
  [get_metatable(monomial(1))] = \_ -> 'mono',
  [get_metatable(tpsa    (1))] = \_ -> 'tpsa',
  [get_metatable(ctpsa   (1))] = \_ -> 'ctpa',
}

-- pymad ----------------------------------------------------------------------o

local pymad = MAD.object 'pymad' { _dbgf = false }

local function catch_err(err)
  io.write("***pymad.run: ", err, "\n", debug.traceback())
end

local function open_pipe (self, py_fd)
  self._pyfp = assert(_C.fdopen(py_fd, "wb"), "unable to wrap py_fd with FILE")
  _C.setbuf(self._pyfp, nil)
  return self
end

local function open_env (self)
  self._env = {}
  setmetatable(self._env, {__index = _G})
  self._env[self.name] = self
  return self
end

local function run (self)
  while true do
    local str = self:recv()
    local fun, err = load(str, nil, nil, self._env)
    if fun then xpcall(fun, catch_err) -- Catch runtime error
    else        catch_err(err)         -- Catch load error
    end
  end
end

-- methods --

local function start(self, py_fd)
  assert(is_natural(py_fd), "invalid argument #2 (file descritor expected)")
  open_pipe(self, py_fd)
  open_env (self)
  run      (self)
end

local function send (self, a)
  local typ = assert(type_str[type(a)] or type_str[get_metatable(a)],
                     "unsupported data type")(a)
  return type_fun[typ].send(send_dat(self, typ, 4), a)
end

local function recv (self)
  local typ = io.read(4)
  return assert(type_fun[typ].recv, "unsupported data type")(self)
end

pymad:set_methods {
  start = start,
  send  = send,
  recv  = recv,
} :set_readonly()

-- end ------------------------------------------------------------------------o
return { pymad = pymad }
