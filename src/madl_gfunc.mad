--[=[
 o-----------------------------------------------------------------------------o
 |
 | Generic functional module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a set of generic functions for functional programming.

 o-----------------------------------------------------------------------------o
]=]

local M = { __help = {} }

-- help -----------------------------------------------------------------------o

M.__help.self = [=[
NAME
  gfunc -- provide generic functions for functional programming

SYNOPSIS
  ident, first, second, swap, repeater, compose, compose_bottom,
  foreach, map, map2, map3, foldl, foldr, filter.

DESCRIPTION
  The gfunc module provides useful utility functions:
  - ident is the identity function.
  - first, second and swap return arguments #1, #2 and #2 #1 respectively
    (i.e. #1 #2 swapped).
  - gen TODO
  - rep returns a sequence holding the same element n-times (or inf).
  - compose composes two callable objects.
  - compose_bottom allows to compose (right to left) callable objects using ^.
  - TODO

RETURN VALUES
  These utility functions.

ERRORS
  None.

SEE ALSO
  None.
]=]

-- locals ---------------------------------------------------------------------o

local is_callable in MAD.concept

-- notes ----------------------------------------------------------------------o

--[[                                    return
-- iterators
  range, enum
  iter, keys, values

-- one to one
  foreach, (side effect)                nil (loop)
  map, (on copy)                        iter
  transform, (in place)                 ?
  scan, accumulate, (memory)

-- two to one
  zip, map2,                            iter

-- partition
  span, split, partition,               2 iters

-- many to one
  foldl, foldr, (reduce)                value
  join, (concat)

-- one to many

-- many1 to many2
  filter,       -- return elements where pred == true
  take,         -- take first n elements
  skip,         -- skip first n elements (alias drop)
  head,         -- return first element i.e. take(1)
  tail,         -- return elements but first, i.e. skip(1)
  last,         -- return last element, i.e. skip(-1)
  count,        -- count elements where pred == true

  random,
]]

--[[
iter(T->I): T
fill, set (I->T): I, T

foreach: fn
map, map2, map3: fn
foldl, foldr: fn, u0
scanl, scanr: fn, u0
filter: fn

find: fn
take: n or fn
drop: n or fn
span: fn
repeat: n or fn

special fold:
and, or, any, all, sum, product, max, min,
]]

-- implementation -------------------------------------------------------------o

local ident   = \... -> ...
local compose = \f,g\... -> f(g(...))

M.gfunc = {

  -- helper

  ident   = ident,
  forget  = \    -> (),
  first   = \a   -> (a),
  second  = \a,b -> (b),
  swap    = \a,b -> (b,a),

  -- functional composition

  compose = compose,
  compose_bottom = setmetatable({ident}, {
    __call = \g,... g[1](...),
    __pow  = \f,g setmetatable(
      { compose(assert(is_callable(f) and f), g[1]) }, getmetatable(g))
  }),

}

--[[
-- not used: tmp for index identity TODO

local sid = setmetatable({ n=0 }, {
  __len       = \s   -> s.n,
  __call      = \s,n => s.n=n return s end,
  __index     = \_,i -> i,
  __newindex := error("invalid write access"),
})
]]

-- end ------------------------------------------------------------------------o
return MAD.utility.defhelp(M)  -- todo: per function help -> 'gfunc'
