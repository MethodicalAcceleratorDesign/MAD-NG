--[=[
 o-----------------------------------------------------------------------------o
 |
 | Plot module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: F.R. Leiro
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides ploting

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- help -----------------------------------------------------------------------o

local __help = {}

-- locals ---------------------------------------------------------------------o
local dat = require 'madl_plotdat'
local range, nrange, vector, element in MAD
local min, max              in MAD.gmath

local GP = {
  gp_output     = 'test.eps'      ,
  plot_data     = "datatoplot.dat",
  layout_data   = "datalayout.dat",
  script        = "plotter.gp"    ,
  terminal_type = "postscript eps",
  font_type     = "Times-Roman"   ,
  font_size     = 22 ,
  xsize         = 27 ,
  ysize         = 17 ,
  l_margin      = 0.1,
  r_margin      = 0.9,
}
--plot default values
local PD = {
  min_x   = 0  ,
  max_x   = 10 ,
  min_y   = 0  ,
  max_y   = 10 ,
  label_x = "x",
  label_y = "y",
  gtitle  = "no-title",
}

-- implementation -------------------------------------------------------------o

local function mkkeys(inp_k, out_k)
  local keys = {}
  for i,k in ipairs(inp_k) do keys[i] = k          end
  for i,k in ipairs(out_k) do keys[i + #inp_k] = k end
  return keys
end

local function plotter_gen(data_src, output, keys)
  for i=1,#data_src[keys[1]] do
    for j,k in ipairs(keys) do
      output:write(data_src[k][i]," ")
    end
    output:write("\n")
  end
    output:close()
end

-- PD
local function scale_axis(data_src, keys)
  local s = #keys
  local vmin, vmax = vector(s), vector(s)
  for i,key in ipairs(keys) do
    local min = data_src[key]:min()
    local max = data_src[key]:max()
    vmin:seti(i, min)
    vmax:seti(i, max)
  end
  return vmin:min(), vmax:max()
end

local function scale_src(data_src, keys, rng)
  local s = data_src[keys[1]]:size()
  local start, stop = 1, s
  if rng and rng:size() <= s then start, stop = rng.start, rng.stop end
  for j,k in ipairs(keys) do data_src[k]:getv(start..stop, 'in'   ) end
  return data_src
end

local function axis_titles(inp_k, out_k)
  local label_x ,label_y = "",""
  for _,key in pairs(inp_k) do label_x = label_x..key.." " end
  for _,key in pairs(out_k) do label_y = label_y..key.." " end
  return label_x ,label_y
end

-- template operations
local function temp_fill(temp, src)
  for key,v in pairs(src) do
    local key = tostring(key)
    for i,tline in ipairs(temp) do -- regular loop might be better
      if tline:find(key)then
        temp[i] = tline:gsub( key, src[key] )
      end
    end
  end
  --return temp
end

local function temp_multiplot(temp, keys)
  local s, lnr = #keys
  for i,tline in ipairs(temp) do
    if tline:find('count') then lnr = i end
  end
  if lnr then
    for i=0,s-1 do temp[lnr+i]=temp[lnr] end
    for i=0,s-1 do temp[lnr+i]=temp[lnr+i]:gsub('count' ,tostring(i+2)) end
    for i=0,s-1 do temp[lnr+i]=temp[lnr+i]:gsub('ytitle',keys[i+1]    ) end
  end
end

local function shallowcopy(orig)
  local orig_type = type(orig)
  local copy
  if orig_type == 'table' then
    copy = {}
    for orig_key, orig_value in pairs(orig) do
      copy[orig_key] = orig_value
    end
  else -- number, string, boolean, etc
    copy = orig
  end
  return copy
end

local function temp_print(temp, printer)
  for i =1,#temp do printer:write(temp[i]) end
  printer:close()
end

local template = {
    -- general settings
    "reset\n"                    ,
    "set terminal terminal_type size xsize cm, ysize cm color font 'font_type, font_size'\n",
    "set output 'gp_output'\n"   ,
    -- plot data setting
    "set grid \n"                ,
    "set lmargin at screen l_margin \n",
    "set rmargin at screen r_margin \n",
    "set title 'gtitle' \n"      ,
    "set xlabel 'label_x' \n"    ,
    "set ylabel 'label_y' \n"    ,
    "set xrange [min_x:max_x] \n",
    "set yrange [min_y:max_y] \n",
    -- plot data
    "plot ",
    "'plot_data' using 1:count every 1::0 w lines lc count title 'ytitle',\\\n"
}

local template_kind = {
    -- general settings
    "reset\n"                     ,
    "set terminal terminal_type size xsize cm, ysize cm color font 'font_type, font_size'\n",
    "set output 'gp_output'\n"    ,
    -- plot data setting
    "set multiplot \n"            ,
    "set grid \n"                 ,
    "set lmargin at screen l_margin \n",
    "set rmargin at screen r_margin \n",
    "set size 1,0.85 \n"          ,

    "set title 'gtitle' \n"       ,
    "set xlabel 'label_x' \n"     ,
    "set ylabel 'label_y' \n"     ,
    "set xrange [min_x:max_x] \n" ,
    "set yrange [min_y:max_y] \n" ,
    -- plot data
    "plot ",
    "'plot_data' using 1:count every 1::0 w lines lc count title 'ytitle',\\\n",

    "\n",
    "unset tmargin \n",
    "unset bmargin \n",
    "unset title  \n",
    "unset arrow \n",
    "unset ylabel \n",
    "unset xlabel \n",
    "unset xtics \n",
    "unset ytics \n",
    "unset y2tics \n",
    "unset y2label \n",
    "unset key \n",
    "set xzeroaxis \n",
    "set border 0 \n",
    "set size 1,0.15 \n",
    "set origin 0,0.85 \n",
    "set yrange [-1:1] \n",
    "plot 'layout_data' u 1:2 w lines ls 1 lc rgb 'black' \n",
}

-- plotting funtion -----------------------------------------------------------o

--layout
local function layout_find(data_src, str)
  local kind = {}
  for i=1,#data_src do
    kind[i] = data_src[i]
  end
  for i,line in ipairs(kind) do
    if line:find(str)then
      kind[i] = 1
    else
      kind[i] = 0
    end
  end
  return kind
end

local function layout_table(x_src, lay_src, keys, size)
  local layout = { x=vector(size) }
  for j=1,size do (layout.x):seti(j, x_src[j]) end
  for i,k in ipairs(keys) do
    layout[k] = vector(size)
    local temp = layout_find(lay_src, tostring(k))
    for j=1,size do
      layout[k]:seti(j, temp [j])
    end
  end
  return layout
end

local function remove_dupl(lay_src)
  local hash = {}
  local res = {}
  for _,v in ipairs(lay_src) do
    if not hash[v] then
      res[#res+1] = v
      hash[v] = true
    end
  end
  return res
end

function M.plot(data_src, inp_k, out_k, rng, layout)
  local gp_script   = io.open(GP.script     , "w")
  local plot_data   = io.open(GP.plot_data  , "w")
  local layout_data = io.open(GP.layout_data, "w")
  local temp

  local keys_plot = mkkeys(inp_k, out_k)
  local d_src = scale_src(data_src, keys_plot, rng)

  --local keys = {'marker'} -- for testing after scale
  local keys = remove_dupl(d_src.kind)

  local keys_lay = mkkeys({'x'}, keys)

  local s = d_src[inp_k[1]]:size()
  local l = layout_table(d_src[inp_k[1]], d_src.kind, keys, s)

  print(l.x         , "\n")
  print(l.marker    , "\n")
  print(l.quadrupole, "\n")

  --print("ploting file: "..GP.gp_output.."\n")
  PD.min_x  , PD.max_x   = scale_axis ( d_src, inp_k )
  PD.min_y  , PD.max_y   = scale_axis ( d_src, out_k )
  PD.label_x, PD.label_y = axis_titles( inp_k, out_k )

  if layout then
    temp = shallowcopy(template_kind)
    plotter_gen   ( l, layout_data, keys_lay ) -- not d_src, other table
  else
    temp = shallowcopy(template)
  end

  plotter_gen   ( d_src, plot_data, keys_plot )
  temp_fill     ( temp , GP        )
  temp_fill     ( temp , PD        )
  temp_multiplot( temp , out_k     )
  temp_print    ( temp , gp_script )

  os.execute("gnuplot "..GP.script)
end

-- end ------------------------------------------------------------------------o
return M