--[=[
 o-----------------------------------------------------------------------------o
 |
 | Plot module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: F.R. Leiro
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides ploting

 o-----------------------------------------------------------------------------o
]=]

-- help -----------------------------------------------------------------------o

local __help = {}
__help.plot = [[
NAME
  plot -- Plot

SYNOPSIS
  TODO

DESCRIPTION
  The module plot provides...

RETURN VALUES
  The plot command

SEE ALSO
  element, sequence, track
]]

-- locals ---------------------------------------------------------------------o

local dat = require 'madl_plotdat'
local isa_matrix, is_range, is_table, is_vector, is_nil, is_string in MAD.typeid
local range, nrange, vector, element, totable in MAD
local min, max  in MAD.gmath

-- implementation -------------------------------------------------------------o

local function table(src)
  if is_string(src) then return totable(src) else return src end
end

local function mk_tbl(t1, t2)
  local tbl = {}
  for i,k in ipairs(t1) do tbl[i]     = k end
  for i,k in ipairs(t2) do tbl[i+#t1] = k end
  return tbl
end

local function rm_dupl(src)
  local hash, res = {}, {}
  for _,v in ipairs(src) do
    if not hash[v] then
      res [#res+1] = v
      hash[v]      = true
    end
  end
  return res
end

local function plotter(src, output, keys) -- REDO
  for i=1,#src[keys[1]] do
    if is_vector(src[keys[1]][i]) then
      for ii=1,#src[keys[1]][i] do
        for j,k in ipairs(keys) do
          output:write(src[k][i][ii]," ")
        end
        output:write("\n")
      end
    else
      for j,k in ipairs(keys) do
        output:write(src[k][i]," ")
      end
    end
    output:write("\n")
  end
  output:close()
end

-- PD
local function chksize(rng, start, stop)
  if rng:size() <= stop then start, stop = rng.start, rng.stop end
  return start, stop
end

local function scale_range(src, rng)
  if     is_range(rng) then return rng
  elseif is_table(rng) then
    local start , stop  = 1, #src
    local rstart, rstop = rng[1], rng[2]
    local vmin, vmax, c = {}, {}
    c=1; src:mapij(\x,i,j => if x>rstart then vmin[c]=i; c=c+1 end end, {})
    c=1; src:mapij(\x,i,j => if x>rstop  then vmax[c]=i; c=c+1 end end, {})
    start, stop = vmin[1], vmax[1]-1
    if rng[2] == -1 then stop = #src end
    return start..stop
  end
end

local function scale_tbl(tbl, start, stop)
  local r = {}
  for j=1,stop-start do r[j] = tbl[start+j] end
  return r
end

local function scale_dat(src, keys, rng)
  local d_src = {}
  local start, stop = 1, #src[keys[1]]
  start, stop = chksize(rng, start, stop)
  for j,k in ipairs(keys) do
    if isa_matrix(src[k]) then d_src[k]=src[k]:getv(start..stop )
                          else d_src[k]=scale_tbl(src[k],start,stop) end
  end
  return d_src
end

-- axis
local function scale_axis(src, keys)
  local vmin, vmax = vector(#keys), vector(#keys)
  for i,key in ipairs(keys) do
    local min = src[key]:min()
    local max = src[key]:max()
    vmin:seti(i, min)
    vmax:seti(i, max)
  end
  return vmin:min(), vmax:max()
end

local function axis_title(src)
  local label = ""
  for _,key in pairs(src) do label = label..key.." " end
  return label
end

--layout
local function sh_get(sh)
  local x_sh, y_sh = {}, {}
  local cx  , cy   = 1 , 1
  for i=1,#sh,2 do x_sh[cx] = sh[i]; cx=cx+1 end
  for i=2,#sh,2 do y_sh[cy] = sh[i]; cy=cy+1 end
  return vector(x_sh), vector(y_sh)
end

local xadjst = \x,l,s -> (x * l + s - l)
local yadjst = \y,h   -> (y * h        )

local function sh_vec(x_sh, y_sh, l, s, h)
  local size = x_sh:size()
  local x1, y1 = vector(size), vector(size)
  for i=1,size do
    x1:seti( i, xadjst(x_sh:geti(i), l, s) )
    y1:seti( i, yadjst(y_sh:geti(i), h   ) )
  end
  return x1, y1
end

local function layout(seq, keys, tbl, inp, rng )
  local xl, yl, c = {}, {}, 1
  for i,k in ipairs( keys ) do
    local s    = seq[k].at
    local l    = seq[k].l
    local kind = seq[k].kind
    local lim  = tbl[inp[1]][rng.stop]
    if s and l and s<lim then
      local h = seq[k][dat[kind].str_k]
      local x, y = sh_get(dat[kind].shape)
      if h then
        xl[c], yl[c] = sh_vec(x, y, l, s, h)
      else
        xl[c], yl[c] = sh_vec(x, y, l, s, 1)
      end
      c=c+1
    end
  end
  return {x=xl, y=yl}
end

local function keys(seq)
  local kinds, c = {}, 1
  local vkeys = seq:get_varkey()
  for _,k in ipairs(vkeys) do
    if is_table(seq[k]) then
      kinds[c] = k:lower(); c=c+1
    end
  end
  return kinds
end

-- template
local function temp_fill(temp, src)
  local templ = {}
  for i,line in ipairs(temp) do
    templ[i], n = string.gsub( line, "%$(%w+)", src )
  end
  return templ
end

local function temp_multiplot(temp, keys)
  local s, lnr = #keys
  for i,line in ipairs(temp) do if line:find('count') then lnr = i end end
  if lnr then
    for i=#temp,lnr,-1 do temp[i+s-1]=temp[i] end
    for i=0,s-1 do temp[lnr+i]=temp[lnr]      end
    for i=0,s-1 do temp[lnr+i]=temp[lnr+i]:gsub('count' , tostring(i+2))
                   temp[lnr+i]=temp[lnr+i]:gsub('ytitle', keys[i+1]    ) end
  end
end

local function temp_print(temp, printer) -- maybe connect to plotter
  for i =1,#temp do printer:write(temp[i]) end
  printer:close()
end

local template = {
    -- general settings
    "reset\n"                          ,
    "set terminal $terminaltype size $xsize cm, $ysize cm color font '$fonttype, $fontsize'\n",
    "set output '$filename'\n"         ,
    -- plot data
    "set multiplot \n"                 ,
    "set grid \n"                      ,
    --"set ytics \n"                   ,
    --"set y2tics \n"                  ,
    --"set y2label '$ylabel' \n"       ,
    "set lmargin at screen $lmargin \n",
    "set rmargin at screen $rmargin \n",
    "set size 1,$sizeplot \n"          ,
    "set title '$title, MAD, $date $time'  \n",
    "set xlabel '$xlabel' \n"          ,
    "set ylabel '$ylabel' \n"          ,
    "set xrange [$xmin:$xmax] \n"      ,
    "set yrange [$ymin:$ymax] \n"      ,
    --"set y2range [$ymax:$ymin] \n"      ,
    "plot ",
    "'$plotdata' using 1:count every 1::0 $interpolate lc count  title 'ytitle',\\\n",
}

local temp_lay = {
    "\nunset tmargin \n"  ,
    "unset bmargin \n"    ,
    "unset title  \n"     ,
    "unset arrow \n"      ,
    "unset ylabel \n"     ,
    "unset xlabel \n"     ,
    "unset xtics \n"      ,
    "unset ytics \n"      ,
    "unset y2tics \n"     ,
    "unset y2label \n"    ,
    "unset key \n"        ,
    "set xzeroaxis \n"    ,
    "set border 0 \n"     ,
    "set size 1,0.15 \n"  ,
    "set origin 0,0.85 \n",
    "set yrange [-1:1] \n",
    "plot '$layoutdata' u 1:2 w lines ls 1 lc rgb 'black' \n",
}
-- plotting command -----------------------------------------------------------o

local mtable, Command in MAD

function exec(self)
  -- file openers
  local gp_script = io.open(self.script    , "w")
  local plot_data = io.open(self.plotdata  , "w")
  local lay_data  = io.open(self.layoutdata, "w")
  local temp

  if self.sequence then
    local keys = rm_dupl( keys(self.sequence) )
    local L    = layout ( self.sequence, keys, self.table, self.inp, self.rng )
    plotter( L, lay_data, {'x','y'} )

    self.sizeplot = 0.85
    temp = mk_tbl(template, temp_lay)
  else
    temp = template
  end

  local keys_plot = mk_tbl   (self.inp  , self.out)
  local d_src     = scale_dat(self.table, keys_plot, self.rng)
  plotter( d_src, plot_data, keys_plot )

  -- template operations
  temp = temp_fill( temp, self      )
  temp_multiplot  ( temp, self.out  )
  temp_print      ( temp, gp_script )
  os.execute("gnuplot "..self.script)
end

local plot = Command 'plot' {
  table    = nil,
  data     = nil,
  sequence = nil,
  HAXIS = 'x',
  VAXIS = 'y',
  inp   = \s table(s.HAXIS),
  out   = \s table(s.VAXIS),
  range = \s 1..#s.table[s.inp[1]],
  rng   = \s scale_range(s.table[s.inp[1]], s.range),

  filename     = "test.eps"      ,
  plotdata     = "dataplot.dat"  ,
  layoutdata   = "datalayout.dat",
  script       = "plotter.gp"    ,
  terminaltype = "postscript eps", --"pdf"
  fonttype     = "Times-Roman"   ,
  fontsize     = 22 ,
  xsize        = 27 ,
  ysize        = 17 ,
  lmargin      = 0.1,
  rmargin      = 0.9,
  sizeplot     = 1  ,

  hlimit = \s { scale_axis( s.table, s.inp ) },
  vlimit = \s { scale_axis( s.table, s.out ) },
  xmin   = \s s.hlimit[1],  xmax = \s s.hlimit[2],
  ymin   = \s s.vlimit[1],  ymax = \s s.vlimit[2],

  xlabel = \s axis_title( s.inp ),
  ylabel = \s axis_title( s.out ),
  title  = \s s.table.title,
  date   = \s s.table.date ,
  time   = \s s.table.time ,

  interpolate = "",
  exec = exec,
} :set_readonly()

-- end ------------------------------------------------------------------------o
return {
  plot = plot,
  __help = __help,
}
