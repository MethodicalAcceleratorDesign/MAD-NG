--[=[
 o-----------------------------------------------------------------------------o
 |
 | MAD C environment (sandbox)
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Load in order all the C modules of the MAD application.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local cdef, C in require 'ffi'

-- implementation -------------------------------------------------------------o

-- common types for MAD (mad_def.h)

cdef [[
typedef const char*       str_t;
typedef bool              log_t;
typedef int32_t           idx_t;
typedef int32_t           ssz_t;
typedef uint32_t          u32_t;
typedef uint64_t          u64_t;
typedef double            num_t;
typedef double _Complex  cnum_t;

typedef struct _IO_FILE    FILE; // stdio.h
]]

-- constants for math and physics (mad_cst.h)

cdef [[
extern const num_t mad_cst_EPS;
extern const num_t mad_cst_TINY;
extern const num_t mad_cst_HUGE;
extern const num_t mad_cst_INF;
extern const num_t mad_cst_NAN;

extern const num_t mad_cst_E;
extern const num_t mad_cst_LOG2E;
extern const num_t mad_cst_LOG10E;
extern const num_t mad_cst_LN2;
extern const num_t mad_cst_LN10;
extern const num_t mad_cst_LNPI;
extern const num_t mad_cst_PI;
extern const num_t mad_cst_2PI;
extern const num_t mad_cst_PI_2;
extern const num_t mad_cst_PI_4;
extern const num_t mad_cst_1_PI;
extern const num_t mad_cst_2_PI;
extern const num_t mad_cst_SQRT2;
extern const num_t mad_cst_SQRT3;
extern const num_t mad_cst_SQRTPI;
extern const num_t mad_cst_SQRT1_2;
extern const num_t mad_cst_SQRT1_3;
extern const num_t mad_cst_1_SQRTPI;
extern const num_t mad_cst_2_SQRTPI;

extern const num_t mad_cst_DEGRAD;
extern const num_t mad_cst_RADDEG;

extern const num_t mad_cst_MINLEN;
extern const num_t mad_cst_MINANG;
extern const num_t mad_cst_MINSTR;

extern const num_t mad_cst_CLIGHT;
extern const num_t mad_cst_MU0;
extern const num_t mad_cst_EPSILON0;
extern const num_t mad_cst_QELECT;
extern const num_t mad_cst_HBAR;
extern const num_t mad_cst_AMASS;
extern const num_t mad_cst_EMASS;
extern const num_t mad_cst_NMASS;
extern const num_t mad_cst_PMASS;
extern const num_t mad_cst_MUMASS;
extern const num_t mad_cst_DEUMASS;
extern const num_t mad_cst_ERADIUS;
extern const num_t mad_cst_ALPHAEM;
]]

-- variables for environment (mad_log.h)

cdef [[
extern const int mad_warn_count;
extern const int mad_stdin_is_tty;
extern const int mad_is_interactive;

extern       int mad_trace_level;
extern       int mad_trace_location;
extern       int mad_trace_fortid;
]]

-- functions for memory management (mad_mem.h)

cdef [[
void*  mad_malloc   (size_t size_);
void*  mad_calloc   (size_t count, size_t size );
void*  mad_realloc  (void  *ptr_ , size_t size_);
void   mad_free     (void  *ptr_);

size_t mad_mcached  (void);
void   mad_mcollect (void);
void   mad_mdump    (FILE*);

// threshold between C and Lua allocator in 8 bytes units
static const ssz_t mad_alloc_threshold = 256;
]]

-- functions for fast string manipulation (mad_str.h)

cdef [[
str_t mad_str_trim    (str_t str, ssz_t arg[2]);
str_t mad_str_num     (str_t str, ssz_t arg[5]);
str_t mad_str_ident   (str_t str, ssz_t arg[4]);
str_t mad_str_quote   (str_t str, ssz_t arg[5]);
str_t mad_str_bracket (str_t str, ssz_t arg[6]);
str_t mad_str_split   (str_t str, ssz_t arg[4], str_t sep);
]]

-- functions for real and complex numbers (mad_num.h)

cdef [[
// C99 math.h
num_t round  (num_t x);
num_t asinh  (num_t x);
num_t acosh  (num_t x);
num_t atanh  (num_t x);
num_t tgamma (num_t x);
num_t lgamma (num_t x);
num_t hypot  (num_t x, num_t y);

// real functions
int    mad_num_sign    (num_t x); // -1, 0, 1
int    mad_num_sign1   (num_t x); // -1, 1: works for ±0, ±inf and ±NaN!

num_t  mad_num_fact    (int n);   // n in Z -> n!
num_t  mad_num_invfact (int n);   // n in Z -> 1/n!

num_t  mad_num_sinc    (num_t x);
num_t  mad_num_sinhc   (num_t x);
num_t  mad_num_asinc   (num_t x);
num_t  mad_num_asinhc  (num_t x);
num_t  mad_num_powi    (num_t x, int n); // x^n, n in Z

// complex to real wrappers
num_t mad_cnum_abs_r   (num_t x_re, num_t x_im);
num_t mad_cnum_arg_r   (num_t x_re, num_t x_im);

void  mad_cnum_sqrt_r  (num_t x_re, num_t x_im, cnum_t *r);
void  mad_cnum_exp_r   (num_t x_re, num_t x_im, cnum_t *r);
void  mad_cnum_log_r   (num_t x_re, num_t x_im, cnum_t *r);
void  mad_cnum_log10_r (num_t x_re, num_t x_im, cnum_t *r);

void  mad_cnum_sin_r   (num_t x_re, num_t x_im, cnum_t *r);
void  mad_cnum_cos_r   (num_t x_re, num_t x_im, cnum_t *r);
void  mad_cnum_tan_r   (num_t x_re, num_t x_im, cnum_t *r);
void  mad_cnum_sinh_r  (num_t x_re, num_t x_im, cnum_t *r);
void  mad_cnum_cosh_r  (num_t x_re, num_t x_im, cnum_t *r);
void  mad_cnum_tanh_r  (num_t x_re, num_t x_im, cnum_t *r);

void  mad_cnum_asin_r  (num_t x_re, num_t x_im, cnum_t *r);
void  mad_cnum_acos_r  (num_t x_re, num_t x_im, cnum_t *r);
void  mad_cnum_atan_r  (num_t x_re, num_t x_im, cnum_t *r);
void  mad_cnum_asinh_r (num_t x_re, num_t x_im, cnum_t *r);
void  mad_cnum_acosh_r (num_t x_re, num_t x_im, cnum_t *r);
void  mad_cnum_atanh_r (num_t x_re, num_t x_im, cnum_t *r);

void  mad_cnum_sinc_r  (num_t x_re, num_t x_im, cnum_t *r);
void  mad_cnum_sinhc_r (num_t x_re, num_t x_im, cnum_t *r);
void  mad_cnum_asinc_r (num_t x_re, num_t x_im, cnum_t *r);
void  mad_cnum_asinhc_r(num_t x_re, num_t x_im, cnum_t *r);

void  mad_cnum_unit_r  (num_t x_re, num_t x_im, cnum_t *r);
void  mad_cnum_proj_r  (num_t x_re, num_t x_im, cnum_t *r);
void  mad_cnum_rect_r  (num_t  rho, num_t  ang, cnum_t *r);
void  mad_cnum_polar_r (num_t x_re, num_t x_im, cnum_t *r);

void  mad_cnum_inv_r   (num_t x_re, num_t x_im, cnum_t *r);
void  mad_cnum_div_r   (num_t x_re, num_t x_im, num_t y_re, num_t y_im, cnum_t *r);
void  mad_cnum_mod_r   (num_t x_re, num_t x_im, num_t y_re, num_t y_im, cnum_t *r);
void  mad_cnum_pow_r   (num_t x_re, num_t x_im, num_t y_re, num_t y_im, cnum_t *r);
void  mad_cnum_powi_r  (num_t x_re, num_t x_im, int   n,                cnum_t *r);

// Faddeeva based functions
num_t mad_num_wf       (num_t x);
num_t mad_num_erf      (num_t x);
num_t mad_num_erfc     (num_t x);
num_t mad_num_erfi     (num_t x);
num_t mad_num_erfcx    (num_t x);
num_t mad_num_dawson   (num_t x);

void  mad_cnum_wf_r    (num_t x_re, num_t x_im, num_t relerr, cnum_t *r);
void  mad_cnum_erf_r   (num_t x_re, num_t x_im, num_t relerr, cnum_t *r);
void  mad_cnum_erfc_r  (num_t x_re, num_t x_im, num_t relerr, cnum_t *r);
void  mad_cnum_erfi_r  (num_t x_re, num_t x_im, num_t relerr, cnum_t *r);
void  mad_cnum_erfcx_r (num_t x_re, num_t x_im, num_t relerr, cnum_t *r);
void  mad_cnum_dawson_r(num_t x_re, num_t x_im, num_t relerr, cnum_t *r);

// MAD random number generator
typedef struct prng_state prng_state_t; // mad_num.[hc]

num_t mad_num_rand     (prng_state_t*);             // [0.,1.)
u64_t mad_num_randi    (prng_state_t*);             // [0,ULLONG_MAX]
void  mad_num_randjump (prng_state_t*);
void  mad_num_randseed (prng_state_t*, num_t seed);

// MADX random number generator
typedef struct xrng_state xrng_state_t; // mad_num.[hc]

num_t mad_num_xrand     (xrng_state_t*);           // [0.,1.)
u32_t mad_num_xrandi    (xrng_state_t*);           // [0,UINT_MAX]
void  mad_num_xrandseed (xrng_state_t*, u32_t seed);

// dummy function for testing reduction with OpenMP by running
// time ./mad -q -e 'io.write("s=",MAD._C.mad_num_suminv(1e11),"\n")'
// => s=25.905651687759, real 0m15.601s, user 1m59.351s
num_t mad_num_suminv(u64_t n);
]]

-- functions for vector-vector, scalar-vector and vector-scalar operations (mad_vec.h)

cdef [[
void   mad_vec_zero   (                                           num_t  r[], ssz_t n, ssz_t d); //  0   -> vec
void   mad_vec_seq    (                         num_t x        ,  num_t  r[], ssz_t n, ssz_t d); //  seq -> vec
void   mad_vec_fill   (                         num_t x        ,  num_t  r[], ssz_t n, ssz_t d); //  num -> vec
void   mad_vec_shift  (       num_t x[],                                      ssz_t n, ssz_t d, int nshft);
void   mad_vec_roll   (       num_t x[],                                      ssz_t n, ssz_t d, int nroll);
void   mad_vec_copy   (const  num_t x[],                          num_t  r[], ssz_t n, ssz_t d); //  vec -> vec
void   mad_vec_copyv  (const  num_t x[],                         cnum_t  r[], ssz_t n, ssz_t d); //  vec ->cvec
void   mad_vec_cvec   (const  num_t x[], const  num_t y[],       cnum_t  r[], ssz_t n, ssz_t d); // vr,vi->cvec
void   mad_vec_minmax (const  num_t x[],       log_t abs       ,  idx_t  r[], ssz_t n, ssz_t d); // MinMax(vec)
void   mad_vec_center (const  num_t x[],                          num_t  r[], ssz_t n, ssz_t d); // vec -> vec-<vec>
num_t  mad_vec_abs    (const  num_t x[],                          num_t  r[], ssz_t n, ssz_t d); // Sum and |vec_i|
num_t  mad_vec_eval   (const  num_t x[],        num_t x0,                     ssz_t n, ssz_t d); // Horner scheme
num_t  mad_vec_sum    (const  num_t x[],                                      ssz_t n, ssz_t d); // Sum(vec)
num_t  mad_vec_ksum   (const  num_t x[],                                      ssz_t n, ssz_t d); // Sum(vec) (Kahan)
num_t  mad_vec_mean   (const  num_t x[],                                      ssz_t n, ssz_t d); // Mean(vec)
num_t  mad_vec_var    (const  num_t x[],                                      ssz_t n, ssz_t d); // Var(vec)
num_t  mad_vec_norm   (const  num_t x[]                                     , ssz_t n, ssz_t d); // |vec|
num_t  mad_vec_knorm  (const  num_t x[]                                     , ssz_t n, ssz_t d); // |vec| (Kahan)
num_t  mad_vec_dist   (const  num_t x[], const  num_t y[]                   , ssz_t n, ssz_t d); // |vec -  vec|
num_t  mad_vec_distv  (const  num_t x[], const cnum_t y[]                   , ssz_t n, ssz_t d); // |vec - cvec|
num_t  mad_vec_dot    (const  num_t x[], const  num_t y[]                   , ssz_t n, ssz_t d); // <vec ,  vec>
num_t  mad_vec_kdot   (const  num_t x[], const  num_t y[]                   , ssz_t n, ssz_t d); // <vec ,  vec> (Kahan)
cnum_t mad_vec_dotv   (const  num_t x[], const cnum_t y[]                   , ssz_t n, ssz_t d); // <vec , cvec>
void   mad_vec_dotv_r (const  num_t x[], const cnum_t y[]      , cnum_t *r  , ssz_t n, ssz_t d); // <vec , cvec>
void   mad_vec_add    (const  num_t x[], const  num_t y[]      ,  num_t  r[], ssz_t n, ssz_t d); //  vec +  vec
void   mad_vec_addn   (const  num_t x[],        num_t y        ,  num_t  r[], ssz_t n, ssz_t d); //  vec +  num
void   mad_vec_addc   (const  num_t x[],       cnum_t y        , cnum_t  r[], ssz_t n, ssz_t d); //  vec +  cpx
void   mad_vec_addc_r (const  num_t x[], num_t y_re, num_t y_im, cnum_t  r[], ssz_t n, ssz_t d); //  vec +  cpx
void   mad_vec_kadd   (int k, const num_t a[], const num_t *x[],  num_t  r[], ssz_t n, ssz_t d); //  sum_k ax
void   mad_vec_sub    (const  num_t x[], const  num_t y[]      ,  num_t  r[], ssz_t n, ssz_t d); //  vec -  vec
void   mad_vec_subv   (const  num_t x[], const cnum_t y[]      , cnum_t  r[], ssz_t n, ssz_t d); //  vec - cvec
void   mad_vec_subn   (const  num_t y[],        num_t x        ,  num_t  r[], ssz_t n, ssz_t d); //  num -  vec
void   mad_vec_subc   (const  num_t y[],       cnum_t x        , cnum_t  r[], ssz_t n, ssz_t d); //  cpx -  vec
void   mad_vec_subc_r (const  num_t y[], num_t x_re, num_t x_im, cnum_t  r[], ssz_t n, ssz_t d); //  cpx -  vec
void   mad_vec_mul    (const  num_t x[], const  num_t y[]      ,  num_t  r[], ssz_t n, ssz_t d); //  vec *  vec
void   mad_vec_muln   (const  num_t x[],        num_t y        ,  num_t  r[], ssz_t n, ssz_t d); //  vec *  num
void   mad_vec_mulc   (const  num_t x[],       cnum_t y        , cnum_t  r[], ssz_t n, ssz_t d); //  vec *  cpx
void   mad_vec_mulc_r (const  num_t x[], num_t y_re, num_t y_im, cnum_t  r[], ssz_t n, ssz_t d); //  vec *  cpx
void   mad_vec_div    (const  num_t x[], const  num_t y[]      ,  num_t  r[], ssz_t n, ssz_t d); //  vec /  vec
void   mad_vec_divv   (const  num_t x[], const cnum_t y[]      , cnum_t  r[], ssz_t n, ssz_t d); //  vec / cvec
void   mad_vec_divn   (const  num_t y[],        num_t x        ,  num_t  r[], ssz_t n, ssz_t d); //  num /  vec
void   mad_vec_divc   (const  num_t y[],       cnum_t x        , cnum_t  r[], ssz_t n, ssz_t d); //  cpx /  vec
void   mad_vec_divc_r (const  num_t y[], num_t x_re, num_t x_im, cnum_t  r[], ssz_t n, ssz_t d); //  cpx /  vec
void   mad_vec_fft    (const  num_t x[],                         cnum_t  r[], ssz_t n);          //  vec ->cvec
void   mad_vec_rfft   (const  num_t x[],                         cnum_t  r[], ssz_t n);          //  vec ->cvec
void   mad_vec_nfft   (const  num_t x[], const num_t x_node[]  , cnum_t  r[], ssz_t n, ssz_t nr);

void   mad_cvec_zero  (                                          cnum_t  r[], ssz_t n, ssz_t d); //  0    ->cvec
void   mad_cvec_seq   (                        cnum_t x        , cnum_t  r[], ssz_t n, ssz_t d); //  cnum ->cvec
void   mad_cvec_seq_r (                  num_t x_re, num_t x_im, cnum_t  r[], ssz_t n, ssz_t d); //  seq  ->cvec
void   mad_cvec_fill  (                        cnum_t x        , cnum_t  r[], ssz_t n, ssz_t d); //  cnum ->cvec
void   mad_cvec_fill_r(                  num_t x_re, num_t x_im, cnum_t  r[], ssz_t n, ssz_t d); //  cnum ->cvec
void   mad_cvec_shift (      cnum_t x[],                                      ssz_t n, ssz_t d, int nshft);
void   mad_cvec_roll  (      cnum_t x[],                                      ssz_t n, ssz_t d, int nroll);
void   mad_cvec_minmax(const cnum_t x[],                          idx_t  r[], ssz_t n, ssz_t d); // MinMax(vec)
void   mad_cvec_center(const cnum_t x[],                         cnum_t  r[], ssz_t n, ssz_t d); //  cvec ->cvec-<cvec>
void   mad_cvec_copy  (const cnum_t x[],                         cnum_t  r[], ssz_t n, ssz_t d); //  cvec ->cvec
void   mad_cvec_vec   (const cnum_t x[],             num_t re[], num_t  ri[], ssz_t n, ssz_t d); //  cvec->vr,vi
void   mad_cvec_conj  (const cnum_t x[],                         cnum_t  r[], ssz_t n, ssz_t d); //  cvec ->cvec*
num_t  mad_cvec_abs   (const cnum_t x[],                          num_t  r[], ssz_t n, ssz_t d); // Sum and |cvec_i|
cnum_t mad_cvec_eval  (const cnum_t x[],       cnum_t x0,                     ssz_t n, ssz_t d); // Horner scheme
void   mad_cvec_eval_r(const cnum_t x[],num_t x0_re,num_t x0_im, cnum_t *r  , ssz_t n, ssz_t d);
cnum_t mad_cvec_sum   (const cnum_t x[],                                      ssz_t n, ssz_t d); // Sum(vec)
void   mad_cvec_sum_r (const cnum_t x[],                         cnum_t *r  , ssz_t n, ssz_t d); // Sum(vec)
cnum_t mad_cvec_mean  (const cnum_t x[],                                      ssz_t n, ssz_t d); // Mean(vec)
void   mad_cvec_mean_r(const cnum_t x[],                         cnum_t *r  , ssz_t n, ssz_t d); // Mean(vec)
cnum_t mad_cvec_var   (const cnum_t x[],                                      ssz_t n, ssz_t d); // Var(vec)
void   mad_cvec_var_r (const cnum_t x[],                         cnum_t *r  , ssz_t n, ssz_t d); // Var(vec)
num_t  mad_cvec_norm  (const cnum_t x[]                                     , ssz_t n, ssz_t d); // |cvec|
num_t  mad_cvec_dist  (const cnum_t x[], const cnum_t y[]                   , ssz_t n, ssz_t d); // |cvec - cvec|
num_t  mad_cvec_distv (const cnum_t x[], const  num_t y[]                   , ssz_t n, ssz_t d); // |cvec -  vec|
cnum_t mad_cvec_dot   (const cnum_t x[], const cnum_t y[]                   , ssz_t n, ssz_t d); // <cvec , cvec>
cnum_t mad_cvec_dotv  (const cnum_t x[], const  num_t y[]                   , ssz_t n, ssz_t d); // <cvec ,  vec>
void   mad_cvec_dot_r (const cnum_t x[], const cnum_t y[]      , cnum_t *r  , ssz_t n, ssz_t d); // <cvec , cvec>
void   mad_cvec_dotv_r(const cnum_t x[], const  num_t y[]      , cnum_t *r  , ssz_t n, ssz_t d); // <cvec ,  vec>
void   mad_cvec_add   (const cnum_t x[], const cnum_t y[]      , cnum_t  r[], ssz_t n, ssz_t d); //  cvec + cvec
void   mad_cvec_addv  (const cnum_t x[], const  num_t y[]      , cnum_t  r[], ssz_t n, ssz_t d); //  cvec +  vec
void   mad_cvec_addn  (const cnum_t x[],        num_t y        , cnum_t  r[], ssz_t n, ssz_t d); //  cvec +  num
void   mad_cvec_addc  (const cnum_t x[],       cnum_t y        , cnum_t  r[], ssz_t n, ssz_t d); //  cvec +  cpx
void   mad_cvec_addc_r(const cnum_t x[], num_t y_re, num_t y_im, cnum_t  r[], ssz_t n, ssz_t d); //  cvec +  cpx
void   mad_cvec_kadd  (int k, const cnum_t a[],const cnum_t *x[],cnum_t  r[], ssz_t n, ssz_t d); //  sum_k ax
void   mad_cvec_sub   (const cnum_t x[], const cnum_t y[]      , cnum_t  r[], ssz_t n, ssz_t d); //  cvec - cvec
void   mad_cvec_subv  (const cnum_t x[], const  num_t y[]      , cnum_t  r[], ssz_t n, ssz_t d); //  cvec -  vec
void   mad_cvec_subn  (const cnum_t y[],        num_t x        , cnum_t  r[], ssz_t n, ssz_t d); //  num  - cvec
void   mad_cvec_subc  (const cnum_t y[],       cnum_t x        , cnum_t  r[], ssz_t n, ssz_t d); //  cpx  - cvec
void   mad_cvec_subc_r(const cnum_t y[], num_t x_re, num_t x_im, cnum_t  r[], ssz_t n, ssz_t d); //  cpx  - cvec
void   mad_cvec_mul   (const cnum_t x[], const cnum_t y[]      , cnum_t  r[], ssz_t n, ssz_t d); //  cvec * cvec
void   mad_cvec_mulv  (const cnum_t x[], const  num_t y[]      , cnum_t  r[], ssz_t n, ssz_t d); //  cvec *  vec
void   mad_cvec_muln  (const cnum_t x[],        num_t y        , cnum_t  r[], ssz_t n, ssz_t d); //  cvec *  num
void   mad_cvec_mulc  (const cnum_t x[],       cnum_t y        , cnum_t  r[], ssz_t n, ssz_t d); //  cvec *  cpx
void   mad_cvec_mulc_r(const cnum_t x[], num_t y_re, num_t y_im, cnum_t  r[], ssz_t n, ssz_t d); //  cvec *  cpx
void   mad_cvec_div   (const cnum_t x[], const cnum_t y[]      , cnum_t  r[], ssz_t n, ssz_t d); //  cvec / cvec
void   mad_cvec_divv  (const cnum_t x[], const  num_t y[]      , cnum_t  r[], ssz_t n, ssz_t d); //  cvec /  vec
void   mad_cvec_divn  (const cnum_t y[],        num_t x        , cnum_t  r[], ssz_t n, ssz_t d); //  num  / cvec
void   mad_cvec_divc  (const cnum_t y[],       cnum_t x        , cnum_t  r[], ssz_t n, ssz_t d); //  cpx  / cvec
void   mad_cvec_divc_r(const cnum_t y[], num_t x_re, num_t x_im, cnum_t  r[], ssz_t n, ssz_t d); //  cpx  / cvec
void   mad_cvec_fft   (const cnum_t x[],                         cnum_t  r[], ssz_t n);          //  cvec ->cvec
void   mad_cvec_nfft  (const cnum_t x[], const num_t x_node[]  , cnum_t  r[], ssz_t n, ssz_t nr);
void   mad_cvec_ifft  (const cnum_t x[],                         cnum_t  r[], ssz_t n);          //  cvec ->cvec
void   mad_cvec_irfft (const cnum_t x[],                          num_t  r[], ssz_t n);          //  cvec -> vec
void   mad_cvec_infft (const cnum_t x[], const num_t r_node[]  , cnum_t  r[], ssz_t n, ssz_t nx);

void   mad_ivec_zero  (                                           idx_t  r[], ssz_t n, ssz_t d); //  0   -> ivec
void   mad_ivec_seq   (                         idx_t x        ,  idx_t  r[], ssz_t n, ssz_t d); //  seq  ->ivec
void   mad_ivec_fill  (                         idx_t x        ,  idx_t  r[], ssz_t n, ssz_t d); //  idx -> ivec
void   mad_ivec_shift (       idx_t x[],                                      ssz_t n, ssz_t d, int nshft);
void   mad_ivec_roll  (       idx_t x[],                                      ssz_t n, ssz_t d, int nroll);
void   mad_ivec_copy  (const  idx_t x[],                          idx_t  r[], ssz_t n, ssz_t d); // ivec ->ivec
void   mad_ivec_copyv (const  idx_t x[],                          num_t  r[], ssz_t n, ssz_t d); // ivec -> vec
void   mad_ivec_minmax(const  idx_t x[],       log_t abs       ,  idx_t  r[], ssz_t n, ssz_t d); // MinMax(ivec)
void   mad_ivec_add   (const  idx_t x[], const  idx_t y[]      ,  idx_t  r[], ssz_t n, ssz_t d); // ivec + ivec
void   mad_ivec_addn  (const  idx_t x[],        idx_t y        ,  idx_t  r[], ssz_t n, ssz_t d); // ivec +  idx
void   mad_ivec_sub   (const  idx_t x[], const  idx_t y[]      ,  idx_t  r[], ssz_t n, ssz_t d); // ivec - ivec
void   mad_ivec_subn  (const  idx_t y[],        idx_t x        ,  idx_t  r[], ssz_t n, ssz_t d); //  idx - ivec
void   mad_ivec_muln  (const  idx_t x[],        idx_t y        ,  idx_t  r[], ssz_t n, ssz_t d); // ivec *  idx
void   mad_ivec_divn  (const  idx_t x[],        idx_t y        ,  idx_t  r[], ssz_t n, ssz_t d); // ivec /  idx
void   mad_ivec_modn  (const  idx_t x[],        idx_t y        ,  idx_t  r[], ssz_t n, ssz_t d); // ivec %  idx

// global fft cleanup
void   mad_fft_cleanup (void);

// unsafe functions, assume that matrices have been reshaped to smaller sizes.
void   mad_vec_append   (struct matrix  *x,     num_t y);
void   mad_cvec_append  (struct cmatrix *x,    cnum_t y);
void   mad_cvec_append_r(struct cmatrix *x, num_t y_re, num_t y_im);
void   mad_ivec_append  (struct imatrix *x,     idx_t y);
]]

-- functions for matrix-matrix, vector-matrix and matrix-vector operations (mad_mat.h)
-- note: matrices can be treated as vectors for elements-wise operations

cdef [[
void   mad_mat_eye      (                         num_t x  ,        num_t  r[], ssz_t m, ssz_t n,            ssz_t ldr); //  eye -> mat
void   mad_mat_seq      (                         num_t x  ,        num_t  r[], ssz_t m, ssz_t n,            ssz_t ldr); //  seq -> mat
void   mad_mat_fill     (                         num_t x  ,        num_t  r[], ssz_t m, ssz_t n,            ssz_t ldr); //  num -> mat
void   mad_mat_roll     (       num_t x[],                                      ssz_t m, ssz_t n, int mroll, int nroll); //  mat -> mat
void   mad_mat_copy     (const  num_t x[],                          num_t  r[], ssz_t m, ssz_t n, ssz_t ldx, ssz_t ldr); //  mat -> mat
void   mad_mat_copym    (const  num_t x[],                         cnum_t  r[], ssz_t m, ssz_t n, ssz_t ldx, ssz_t ldr); //  mat ->cmat
void   mad_mat_trans    (const  num_t x[],                          num_t  r[], ssz_t m, ssz_t n);                       //  mat.t()
void   mad_mat_dot      (const  num_t x[], const  num_t y[],        num_t  r[], ssz_t m, ssz_t n);                       // <mat ,  mat>
void   mad_mat_dotm     (const  num_t x[], const cnum_t y[],       cnum_t  r[], ssz_t m, ssz_t n);                       // <mat , cmat>
void   mad_mat_mul      (const  num_t x[], const  num_t y[],        num_t  r[], ssz_t m, ssz_t n, ssz_t p);              //  mat *  mat
void   mad_mat_mulm     (const  num_t x[], const cnum_t y[],       cnum_t  r[], ssz_t m, ssz_t n, ssz_t p);              //  mat * cmat
void   mad_mat_tmul     (const  num_t x[], const  num_t y[],        num_t  r[], ssz_t m, ssz_t n, ssz_t p);              //  mat'*  mat
void   mad_mat_tmulm    (const  num_t x[], const cnum_t y[],       cnum_t  r[], ssz_t m, ssz_t n, ssz_t p);              //  mat'* cmat
void   mad_mat_mult     (const  num_t x[], const  num_t y[],        num_t  r[], ssz_t m, ssz_t n, ssz_t p);              //  mat'*  mat
void   mad_mat_multm    (const  num_t x[], const cnum_t y[],       cnum_t  r[], ssz_t m, ssz_t n, ssz_t p);              //  mat'* cmat
int    mad_mat_det      (const  num_t x[],                          num_t *r  ,          ssz_t n);                       //  det(mat)
int    mad_mat_invn     (const  num_t y[],        num_t x  ,        num_t  r[], ssz_t m, ssz_t n,          num_t rcond); //  num /  mat
int    mad_mat_invc_r   (const  num_t y[], num_t x_re, num_t x_im, cnum_t  r[], ssz_t m, ssz_t n,          num_t rcond); // cnum /  mat
int    mad_mat_div      (const  num_t x[], const  num_t y[],        num_t  r[], ssz_t m, ssz_t n, ssz_t p, num_t rcond); //  mat /  mat
int    mad_mat_divm     (const  num_t x[], const cnum_t y[],       cnum_t  r[], ssz_t m, ssz_t n, ssz_t p, num_t rcond); //  mat / cmat
int    mad_mat_solve    (const  num_t a[], const  num_t b[],        num_t  x[], ssz_t m, ssz_t n, ssz_t p, num_t rcond); //  min|b-ax| (QR)
int    mad_mat_nsolve   (const  num_t a[], const  num_t b[],        num_t  x[], ssz_t m, ssz_t n, ssz_t N, num_t rcond, num_t r_[]); // min|b-ax| (MICADO)
int    mad_mat_ssolve   (const  num_t a[], const  num_t b[],        num_t  x[], ssz_t m, ssz_t n, ssz_t p, num_t rcond, num_t s_[]); // min|b-ax| (SVD)
int    mad_mat_gsolve   (const  num_t a[], const  num_t b[], const  num_t  c[], const num_t d[],
                                                                    num_t  x[], ssz_t m, ssz_t n, ssz_t p, num_t *nrm_);
int    mad_mat_gmsolve  (const  num_t a[], const  num_t b[], const  num_t  d[],
                                                  num_t x[],        num_t  y[], ssz_t m, ssz_t n, ssz_t p);
int    mad_mat_pcacnd   (const  num_t a[],        idx_t c[],                    ssz_t m, ssz_t n, ssz_t N, num_t cut, num_t s_[]);
int    mad_mat_svdcnd   (const  num_t a[],        idx_t c[],                    ssz_t m, ssz_t n, ssz_t N, num_t cut, num_t s_[], num_t tol);
int    mad_mat_svd      (const  num_t x[], num_t u[], num_t s[],    num_t  v[], ssz_t m, ssz_t n);                       //  u * s * v.t
int    mad_mat_eigen    (const  num_t x[], cnum_t w[], num_t vl[],  num_t vr[],          ssz_t n);                       //  w, vl, vr
void   mad_mat_fft      (const  num_t x[],                         cnum_t  r[], ssz_t m, ssz_t n);                       //  mat ->cmat
void   mad_mat_rfft     (const  num_t x[],                         cnum_t  r[], ssz_t m, ssz_t n);                       //  mat ->cmat
void   mad_mat_nfft     (const  num_t x[], const num_t x_node[]  , cnum_t  r[], ssz_t m, ssz_t n, ssz_t nr);
void   mad_mat_center   (const  num_t x[],                          num_t  r[], ssz_t m, ssz_t n, int d);                //  mat -> mat-<mat>_r
void   mad_mat_sympconj (const  num_t x[],                          num_t  r[],          ssz_t n);                       //  -J M' J
num_t  mad_mat_symperr  (const  num_t x[],                          num_t  r[],          ssz_t n);                       //  M' J M - J
num_t  mad_mat_vdot     (const  num_t x[], idx_t xs, const  num_t y[], idx_t ys,         ssz_t n);                       // <mat[i], mat[j]>

void   mad_cmat_eye_r   (                  num_t x_re, num_t x_im, cnum_t  r[], ssz_t m, ssz_t n,            ssz_t ldr); //  eye  ->cmat
void   mad_cmat_seq_r   (                  num_t x_re, num_t x_im, cnum_t  r[], ssz_t m, ssz_t n,            ssz_t ldr); //  seq  ->cmat
void   mad_cmat_fill_r  (                  num_t x_re, num_t x_im, cnum_t  r[], ssz_t m, ssz_t n,            ssz_t ldr); //  cnum ->cmat
void   mad_cmat_roll    (      cnum_t x[],                                      ssz_t m, ssz_t n, int mroll, int nroll); //  cmat ->cmat
void   mad_cmat_copy    (const cnum_t x[],                         cnum_t  r[], ssz_t m, ssz_t n, ssz_t ldx, ssz_t ldr); //  cmat ->cmat
void   mad_cmat_trans   (const cnum_t x[],                         cnum_t  r[], ssz_t m, ssz_t n);                       //  cmat.t()
void   mad_cmat_ctrans  (const cnum_t x[],                         cnum_t  r[], ssz_t m, ssz_t n);                       //  cmat.ct()
void   mad_cmat_dot     (const cnum_t x[], const cnum_t y[],       cnum_t  r[], ssz_t m, ssz_t n);                       // <cmat , cmat>
void   mad_cmat_dotm    (const cnum_t x[], const  num_t y[],       cnum_t  r[], ssz_t m, ssz_t n);                       // <cmat ,  mat>
void   mad_cmat_mul     (const cnum_t x[], const cnum_t y[],       cnum_t  r[], ssz_t m, ssz_t n, ssz_t p);              //  cmat * cmat
void   mad_cmat_mulm    (const cnum_t x[], const  num_t y[],       cnum_t  r[], ssz_t m, ssz_t n, ssz_t p);              //  cmat *  mat
void   mad_cmat_tmul    (const cnum_t x[], const cnum_t y[],       cnum_t  r[], ssz_t m, ssz_t n, ssz_t p);              //  cmat'* cmat
void   mad_cmat_tmulm   (const cnum_t x[], const  num_t y[],       cnum_t  r[], ssz_t m, ssz_t n, ssz_t p);              //  cmat'*  mat
void   mad_cmat_mult    (const cnum_t x[], const cnum_t y[],       cnum_t  r[], ssz_t m, ssz_t n, ssz_t p);              //  cmat'* cmat
void   mad_cmat_multm   (const cnum_t x[], const  num_t y[],       cnum_t  r[], ssz_t m, ssz_t n, ssz_t p);              //  cmat'*  mat
int    mad_cmat_det     (const cnum_t x[],                         cnum_t *r  ,          ssz_t n);                       //  det(cmat)
int    mad_cmat_invn    (const cnum_t y[],        num_t x  ,       cnum_t  r[], ssz_t m, ssz_t n,          num_t rcond); //   num / cmat
int    mad_cmat_invc_r  (const cnum_t y[], num_t x_re, num_t x_im, cnum_t  r[], ssz_t m, ssz_t n,          num_t rcond); //  cnum / cmat
int    mad_cmat_div     (const cnum_t x[], const cnum_t y[],       cnum_t  r[], ssz_t m, ssz_t n, ssz_t p, num_t rcond); //  cmat / cmat
int    mad_cmat_divm    (const cnum_t x[], const  num_t y[],       cnum_t  r[], ssz_t m, ssz_t n, ssz_t p, num_t rcond); //  cmat /  mat
int    mad_cmat_solve   (const cnum_t a[], const cnum_t b[],       cnum_t  x[], ssz_t m, ssz_t n, ssz_t p, num_t rcond); //  min|b-ax| (QR)
int    mad_cmat_ssolve  (const cnum_t a[], const cnum_t b[],       cnum_t  x[], ssz_t m, ssz_t n, ssz_t p, num_t rcond, num_t s_[]); // min|b-ax| (SVD)
int    mad_cmat_gsolve  (const cnum_t a[], const cnum_t b[], const cnum_t  c[], const cnum_t d[],
                                                                   cnum_t  x[], ssz_t m, ssz_t n, ssz_t p, num_t *nrm_);
int    mad_cmat_gmsolve (const cnum_t a[], const cnum_t b[], const cnum_t  d[],
                                                 cnum_t x[],       cnum_t  y[], ssz_t m, ssz_t n, ssz_t p);
int    mad_cmat_pcacnd  (const cnum_t a[],        idx_t c[],                    ssz_t m, ssz_t n, ssz_t N, num_t cut, num_t s_[]);
int    mad_cmat_svd     (const cnum_t x[], cnum_t u[], num_t s[],  cnum_t  v[], ssz_t m, ssz_t n);                       //  u * s * v.t
int    mad_cmat_eigen   (const cnum_t x[], cnum_t w[], cnum_t vl[],cnum_t vr[],          ssz_t n);                       //  w, vl, vr
void   mad_cmat_fft     (const cnum_t x[],                         cnum_t  r[], ssz_t m, ssz_t n);                       //  cmat ->cmat
void   mad_cmat_nfft    (const cnum_t x[], const num_t x_node[]   ,cnum_t  r[], ssz_t m, ssz_t n, ssz_t nr);
void   mad_cmat_ifft    (const cnum_t x[],                         cnum_t  r[], ssz_t m, ssz_t n);                       //  cmat ->cmat
void   mad_cmat_irfft   (const cnum_t x[],                          num_t  r[], ssz_t m, ssz_t n);                       //  cmat -> mat
void   mad_cmat_infft   (const cnum_t x[], const num_t r_node[]   ,cnum_t  r[], ssz_t m, ssz_t n, ssz_t nx);
void   mad_cmat_center  (const cnum_t x[],                         cnum_t  r[], ssz_t m, ssz_t n, int d);                //  cmat ->cmat-<cmat>_r
void   mad_cmat_sympconj(const cnum_t x[],                         cnum_t  r[],          ssz_t n);                       //  -J M' J
num_t  mad_cmat_symperr (const cnum_t x[],                         cnum_t  r[],          ssz_t n);                       //  M' J M - J
cnum_t mad_cmat_vdot    (const cnum_t x[], idx_t xs, const cnum_t y[], idx_t ys,         ssz_t n);                       // <cmat[i], cmat[j]>
cnum_t mad_cmat_vdotm   (const cnum_t x[], idx_t xs, const  num_t y[], idx_t ys,         ssz_t n);                       // <cmat[i],  mat[j]>
void   mad_cmat_vdot_r  (const cnum_t x[], idx_t xs, const cnum_t y[], idx_t ys, cnum_t *r, ssz_t n);
void   mad_cmat_vdotm_r (const cnum_t x[], idx_t xs, const  num_t y[], idx_t ys, cnum_t *r, ssz_t n);

void   mad_imat_eye     (       idx_t x  ,                           idx_t r[], ssz_t m, ssz_t n,            ssz_t ldr); //  eye  ->imat
void   mad_imat_seq     (       idx_t x  ,                           idx_t r[], ssz_t m, ssz_t n,            ssz_t ldr); //  seq  ->imat
void   mad_imat_fill    (       idx_t x  ,                           idx_t r[], ssz_t m, ssz_t n,            ssz_t ldr); //  idx  ->imat
void   mad_imat_roll    (       idx_t x[],                                      ssz_t m, ssz_t n, int mroll, int nroll); //  imat ->imat
void   mad_imat_copy    (const  idx_t x[],                           idx_t r[], ssz_t m, ssz_t n, ssz_t ldx, ssz_t ldr); //  imat ->imat
void   mad_imat_copym   (const  idx_t x[],                           num_t r[], ssz_t m, ssz_t n, ssz_t ldx, ssz_t ldr); //  imat -> mat
void   mad_imat_trans   (const  idx_t x[],                           idx_t r[], ssz_t m, ssz_t n);                       //  imat ->imat

// global fft cleanup
void   mad_fft_cleanup  (void);

// 3D geometry --

// rotations
void   mad_mat_rot      (      num_t x[], num_t a);  // R
void   mad_mat_rotx     (      num_t x[], num_t ax); // Rx
void   mad_mat_roty     (      num_t x[], num_t ay); // Ry
void   mad_mat_rotz     (      num_t x[], num_t az); // Rz
void   mad_mat_rotxy    (      num_t x[], num_t ax, num_t ay, log_t inv); // Ry.Rx
void   mad_mat_rotxz    (      num_t x[], num_t ax, num_t az, log_t inv); // Rz.Rx
void   mad_mat_rotyz    (      num_t x[], num_t ay, num_t az, log_t inv); // Rz.Ry
void   mad_mat_rotxyz   (      num_t x[], num_t ax, num_t ay, num_t az, log_t inv); // Rz.Ry.Rx
void   mad_mat_rotxzy   (      num_t x[], num_t ax, num_t ay, num_t az, log_t inv); // Ry.Rz.Rx
void   mad_mat_rotyxz   (      num_t x[], num_t ax, num_t ay, num_t az, log_t inv); // Rz.Rx.Ry
void   mad_mat_rotv     (      num_t x[], num_t v[],          num_t av, log_t inv); // Rv
void   mad_mat_torotxyz (const num_t x[], num_t r[]                   , log_t inv); // ax, ay, az from rotxyz
void   mad_mat_torotxzy (const num_t x[], num_t r[]                   , log_t inv); // ax, ay, az from rotxzy
void   mad_mat_torotyxz (const num_t x[], num_t r[]                   , log_t inv); // ax, ay, az from rotyxz
num_t  mad_mat_torotv   (const num_t x[], num_t v_[]                  , log_t inv); // av from rotv

// quaternion
void   mad_mat_rotq     (      num_t x[], num_t q[], log_t inv);
void   mad_mat_torotq   (const num_t x[], num_t q[], log_t inv);

// misalignments
void   mad_mat_rtbar    (      num_t Rb[],       num_t Tb[], num_t el, num_t ang, num_t tlt,
                         const num_t R_[], const num_t T []);

// special flag
extern int mad_use_madx_micado;
extern int mad_use_madx_svdcnd;

// unsafe functions, assume that matrices reshaped sizes are valid (no check!).
void   mad_mat_reshape  (struct matrix  *x, ssz_t m, ssz_t n);
void   mad_cmat_reshape (struct cmatrix *x, ssz_t m, ssz_t n);
void   mad_imat_reshape (struct imatrix *x, ssz_t m, ssz_t n);
]]

-- functions for polygons (mad_poly.h)

cdef [[
// polygon contains a point? (winding number algo)
log_t mad_pol_inside (num_t px, num_t py, const num_t *vx, const num_t *vy, ssz_t n);
]]

-- functions for monomials (mad_mono.h)

cdef [[
typedef unsigned char ord_t; // mad_mono.h

ssz_t mad_mono_str   (ssz_t n,       ord_t a[], str_t s);  // from string
str_t mad_mono_prt   (ssz_t n, const ord_t a[], char s[]); // to   string

void  mad_mono_fill  (ssz_t n,       ord_t a[], ord_t v);
void  mad_mono_copy  (ssz_t n, const ord_t a[], ord_t r[]);
void  mad_mono_rcopy (ssz_t n, const ord_t a[], ord_t r[]);

ord_t mad_mono_min   (ssz_t n, const ord_t a[]);
ord_t mad_mono_max   (ssz_t n, const ord_t a[]);
int   mad_mono_ord   (ssz_t n, const ord_t a[]);
num_t mad_mono_ordp  (ssz_t n, const ord_t a[], idx_t stp);
num_t mad_mono_ordpf (ssz_t n, const ord_t a[], idx_t stp);

log_t mad_mono_eq    (ssz_t n, const ord_t a[], const ord_t b[]);
log_t mad_mono_lt    (ssz_t n, const ord_t a[], const ord_t b[]);
log_t mad_mono_gt    (ssz_t n, const ord_t a[], const ord_t b[]);
log_t mad_mono_le    (ssz_t n, const ord_t a[], const ord_t b[]);
log_t mad_mono_ge    (ssz_t n, const ord_t a[], const ord_t b[]);

int   mad_mono_cmp   (ssz_t n, const ord_t a[], const ord_t b[]);
int   mad_mono_rcmp  (ssz_t n, const ord_t a[], const ord_t b[]);

void  mad_mono_add   (ssz_t n, const ord_t a[], const ord_t b[], ord_t r[]);
void  mad_mono_sub   (ssz_t n, const ord_t a[], const ord_t b[], ord_t r[]);
void  mad_mono_cat   (ssz_t n, const ord_t a[], ssz_t m, const ord_t b[], ord_t r[]);

void  mad_mono_sort  (ssz_t n, const ord_t a[], idx_t idxs[]);

void  mad_mono_print (ssz_t n, const ord_t a[], FILE *fp_);
]]

-- functions for GTPSA descriptors (mad_desc.h)

cdef [[
// types
typedef struct desc desc_t;  // mad_desc.h, mad_[c]tpsa.h, mad_mono.h

// globals
extern const ord_t   mad_tpsa_default;
extern const ord_t   mad_tpsa_same;
extern const desc_t *mad_desc_curr;

// ctors
const desc_t* mad_desc_newv  (int nv, ord_t mo_);
const desc_t* mad_desc_newvp (int nv, int np, ord_t mo_, ord_t po_);
const desc_t* mad_desc_newvpo(int nv, int np, const ord_t no[], ord_t po_);

// dtor
void  mad_desc_del    (const desc_t *d);

// introspection
int   mad_desc_getnv  (const desc_t *d, ord_t *mo_, int *np_, ord_t *po_); // return nv
ord_t mad_desc_getno  (const desc_t *d, int nn, ord_t no_[]); // return mo
ord_t mad_desc_maxord (const desc_t *d); // return mo
ssz_t mad_desc_maxlen (const desc_t *d); // ordlen(maxord) == maxlen
ssz_t mad_desc_ordlen (const desc_t *d, ord_t mo);
ord_t mad_desc_gtrunc (const desc_t *d, ord_t to);
void  mad_desc_info   (const desc_t *d, FILE *fp_);

// -- indexes / monomials
log_t mad_desc_isvalids  (const desc_t *d, ssz_t n,       str_t s   );
log_t mad_desc_isvalidm  (const desc_t *d, ssz_t n, const ord_t m []);
log_t mad_desc_isvalidsm (const desc_t *d, ssz_t n, const idx_t m []);
idx_t mad_desc_idxs      (const desc_t *d, ssz_t n,       str_t s   );
idx_t mad_desc_idxm      (const desc_t *d, ssz_t n, const ord_t m []);
idx_t mad_desc_idxsm     (const desc_t *d, ssz_t n, const idx_t m []);
idx_t mad_desc_nxtbyvar  (const desc_t *d, ssz_t n,       ord_t m []);
idx_t mad_desc_nxtbyord  (const desc_t *d, ssz_t n,       ord_t m []);
ord_t mad_desc_mono      (const desc_t *d, ssz_t n,       ord_t m_[], idx_t i);

// global cleanup (warning: no GTSPA must still be in use!)
void  mad_desc_cleanup(void);
]]

-- functions for GTPSAs real (mad_tpsa.h)

cdef [[
// types
typedef struct tpsa tpsa_t;  // mad_tpsa.h, mad_desc.h, mad_mono.h, mad_bit.h

// ctors, dtor
tpsa_t* mad_tpsa_newd  (const desc_t *d, ord_t mo); // if mo > d_mo, mo = d_mo
tpsa_t* mad_tpsa_new   (const tpsa_t *t, ord_t mo);
void    mad_tpsa_del   (const tpsa_t *t);

// introspection
const
desc_t* mad_tpsa_desc  (const tpsa_t *t);
int32_t mad_tpsa_uid   (      tpsa_t *t, int32_t uid_); // set uid if != 0
ssz_t   mad_tpsa_len   (const tpsa_t *t);
str_t   mad_tpsa_nam   (const tpsa_t *t);
ord_t   mad_tpsa_ord   (const tpsa_t *t);
ord_t   mad_tpsa_ordv  (const tpsa_t *t, ...);       // max order of all
ord_t   mad_tpsa_ordn  (ssz_t n, const tpsa_t *t[]); // max order of all

// initialization
void  mad_tpsa_copy    (const tpsa_t *t, tpsa_t *r);
void  mad_tpsa_sclord  (const tpsa_t *t, tpsa_t *r, log_t inv); // t[i]*o[i]
void  mad_tpsa_getord  (const tpsa_t *t, tpsa_t *r, ord_t ord);
void  mad_tpsa_cutord  (const tpsa_t *t, tpsa_t *r, int   ord); // ord..mo = 0 or 0..-ord=0
void  mad_tpsa_convert (const tpsa_t *t, tpsa_t *r, ssz_t n, idx_t t2r_[], int pb);
void  mad_tpsa_setvar  (      tpsa_t *t, num_t v, idx_t iv_, num_t scl_);
void  mad_tpsa_setnam  (      tpsa_t *t, str_t nam);
void  mad_tpsa_clear   (      tpsa_t *t);
log_t mad_tpsa_isnul   (const tpsa_t *t);

// indexing / monomials
ord_t mad_tpsa_mono    (const tpsa_t *t, ssz_t n,       ord_t m_[], idx_t i);
idx_t mad_tpsa_idxs    (const tpsa_t *t, ssz_t n,       str_t s   ); // string mono "[0-9]*"
idx_t mad_tpsa_idxm    (const tpsa_t *t, ssz_t n, const ord_t m []);
idx_t mad_tpsa_idxsm   (const tpsa_t *t, ssz_t n, const idx_t m []); // sparse mono [(i,o)]
idx_t mad_tpsa_cycle   (const tpsa_t *t, ssz_t n,       ord_t m_[], idx_t i, num_t *v_);

// accessors
num_t mad_tpsa_get0    (const tpsa_t *t);
num_t mad_tpsa_geti    (const tpsa_t *t, idx_t i);
num_t mad_tpsa_gets    (const tpsa_t *t, ssz_t n,       str_t s  ); // string mono "[0-9]*"
num_t mad_tpsa_getm    (const tpsa_t *t, ssz_t n, const ord_t m[]);
num_t mad_tpsa_getsm   (const tpsa_t *t, ssz_t n, const int   m[]); // sparse mono [(i,o)]
void  mad_tpsa_set0    (      tpsa_t *t, /* i = 0 */               num_t a, num_t b);
void  mad_tpsa_seti    (      tpsa_t *t, idx_t i,                  num_t a, num_t b);
void  mad_tpsa_sets    (      tpsa_t *t, ssz_t n,       str_t s  , num_t a, num_t b);
void  mad_tpsa_setm    (      tpsa_t *t, ssz_t n, const ord_t m[], num_t a, num_t b);
void  mad_tpsa_setsm   (      tpsa_t *t, ssz_t n, const int   m[], num_t a, num_t b);

// accessors vector based
void  mad_tpsa_getv    (const tpsa_t *t, idx_t i, ssz_t n,         num_t v[]);
void  mad_tpsa_setv    (      tpsa_t *t, idx_t i, ssz_t n,   const num_t v[]);

// operators
log_t mad_tpsa_equ     (const tpsa_t *a, const tpsa_t *b, num_t tol_);
void  mad_tpsa_dif     (const tpsa_t *a, const tpsa_t *b, tpsa_t *c); // (a_i-b_i)/max(|a_i|,1)
void  mad_tpsa_add     (const tpsa_t *a, const tpsa_t *b, tpsa_t *c);
void  mad_tpsa_sub     (const tpsa_t *a, const tpsa_t *b, tpsa_t *c);
void  mad_tpsa_mul     (const tpsa_t *a, const tpsa_t *b, tpsa_t *c);
void  mad_tpsa_div     (const tpsa_t *a, const tpsa_t *b, tpsa_t *c);
void  mad_tpsa_pow     (const tpsa_t *a, const tpsa_t *b, tpsa_t *c);
void  mad_tpsa_powi    (const tpsa_t *a, int           n, tpsa_t *c);
void  mad_tpsa_pown    (const tpsa_t *a, num_t         v, tpsa_t *c);

// functions
num_t mad_tpsa_nrm     (const tpsa_t *a);
void  mad_tpsa_abs     (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_sqrt    (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_exp     (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_log     (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_sincos  (const tpsa_t *a, tpsa_t *s, tpsa_t *c);
void  mad_tpsa_sin     (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_cos     (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_tan     (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_cot     (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_sinc    (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_sincosh (const tpsa_t *a, tpsa_t *s, tpsa_t *c);
void  mad_tpsa_sinh    (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_cosh    (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_tanh    (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_coth    (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_sinhc   (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_asin    (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_acos    (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_atan    (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_acot    (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_asinc   (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_asinh   (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_acosh   (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_atanh   (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_acoth   (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_asinhc  (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_erf     (const tpsa_t *a, tpsa_t *c);
void  mad_tpsa_erfc    (const tpsa_t *a, tpsa_t *c);

void  mad_tpsa_acc     (const tpsa_t *a, num_t v, tpsa_t *c);  // c += v*a, aliasing OK
void  mad_tpsa_scl     (const tpsa_t *a, num_t v, tpsa_t *c);  // c  = v*a
void  mad_tpsa_inv     (const tpsa_t *a, num_t v, tpsa_t *c);  // c  = v/a
void  mad_tpsa_invsqrt (const tpsa_t *a, num_t v, tpsa_t *c);  // c  = v/sqrt(a)

void  mad_tpsa_unit    (const tpsa_t *x, tpsa_t *r);
void  mad_tpsa_atan2   (const tpsa_t *y, const tpsa_t *x, tpsa_t *r);
void  mad_tpsa_hypot   (const tpsa_t *x, const tpsa_t *y, tpsa_t *r);
void  mad_tpsa_hypot3  (const tpsa_t *x, const tpsa_t *y, const tpsa_t *z, tpsa_t *r);

void  mad_tpsa_integ   (const tpsa_t *a, tpsa_t *c, int iv);
void  mad_tpsa_deriv   (const tpsa_t *a, tpsa_t *c, int iv);
void  mad_tpsa_derivm  (const tpsa_t *a, tpsa_t *c, ssz_t n, const ord_t m[]);
void  mad_tpsa_poisbra (const tpsa_t *a, const tpsa_t *b, tpsa_t *c, int nv);
void  mad_tpsa_taylor  (const tpsa_t *a, ssz_t n, const num_t coef[], tpsa_t *c);

// high level functions (aliasing OK)
void  mad_tpsa_axpb       (num_t a, const tpsa_t *x,
                           num_t b, tpsa_t *r);
void  mad_tpsa_axpbypc    (num_t a, const tpsa_t *x,
                           num_t b, const tpsa_t *y,
                           num_t c, tpsa_t *r);
void  mad_tpsa_axypb      (num_t a, const tpsa_t *x, const tpsa_t *y,
                           num_t b, tpsa_t *r);
void  mad_tpsa_axypbzpc   (num_t a, const tpsa_t *x, const tpsa_t *y,
                           num_t b, const tpsa_t *z,
                           num_t c, tpsa_t *r);
void  mad_tpsa_axypbvwpc  (num_t a, const tpsa_t *x, const tpsa_t *y,
                           num_t b, const tpsa_t *v, const tpsa_t *w,
                           num_t c, tpsa_t *r);
void  mad_tpsa_ax2pby2pcz2(num_t a, const tpsa_t *x,
                           num_t b, const tpsa_t *y,
                           num_t c, const tpsa_t *z, tpsa_t *r);
void  mad_tpsa_axpsqrtbpcx2   (const tpsa_t *x, num_t a, num_t b, num_t c, tpsa_t *r);
void  mad_tpsa_logaxpsqrtbpcx2(const tpsa_t *x, num_t a, num_t b, num_t c, tpsa_t *r);
void  mad_tpsa_logxdy         (const tpsa_t *x, const tpsa_t *y, tpsa_t *r);

// to check for non-homogeneous maps & parameters
void  mad_tpsa_vec2fld  (ssz_t na, const tpsa_t *a   ,                     tpsa_t *mc[]); // F . grad
void  mad_tpsa_fld2vec  (ssz_t na, const tpsa_t *ma[],                     tpsa_t *c   );
void  mad_tpsa_fgrad    (ssz_t na, const tpsa_t *ma[], const tpsa_t * b  , tpsa_t *c   );
void  mad_tpsa_liebra   (ssz_t na, const tpsa_t *ma[], const tpsa_t *mb[], tpsa_t *mc[]);
void  mad_tpsa_exppb    (ssz_t na, const tpsa_t *ma[], const tpsa_t *mb[], tpsa_t *mc[]); // exp(:F:) K
void  mad_tpsa_logpb    (ssz_t na, const tpsa_t *ma[], const tpsa_t *mb[], tpsa_t *mc[]); // exp(log(:F:)) K

num_t mad_tpsa_mnrm     (ssz_t na, const tpsa_t *ma[]);
void  mad_tpsa_minv     (ssz_t na, const tpsa_t *ma[],                               tpsa_t *mc[]);
void  mad_tpsa_pminv    (ssz_t na, const tpsa_t *ma[],                               tpsa_t *mc[], idx_t select[]);
void  mad_tpsa_compose  (ssz_t na, const tpsa_t *ma[], ssz_t nb, const tpsa_t *mb[], tpsa_t *mc[]);
void  mad_tpsa_translate(ssz_t na, const tpsa_t *ma[], ssz_t nb, const num_t   tb[], tpsa_t *mc[]);
void  mad_tpsa_eval     (ssz_t na, const tpsa_t *ma[], ssz_t nb, const num_t   tb[], num_t   tc[]);
void  mad_tpsa_mconv    (ssz_t na, const tpsa_t *ma[], ssz_t nc,                     tpsa_t *mc[], ssz_t n, idx_t t2r_[], int pb);

// I/O
void    mad_tpsa_print    (const tpsa_t *t, str_t name_, num_t eps_, int nohdr_, FILE *stream_);
tpsa_t* mad_tpsa_scan     (                                                      FILE *stream_);
const
desc_t* mad_tpsa_scan_hdr (     int *kind_, char  name_[],                       FILE *stream_);
void    mad_tpsa_scan_coef(      tpsa_t *t,                                      FILE *stream_);
void    mad_tpsa_debug    (const tpsa_t *t, str_t name_, str_t fnam_, int line_, FILE *stream_);
log_t   mad_tpsa_isvalid  (const tpsa_t *t);

// unsafe operation (mo vs allocated!!)
tpsa_t* mad_tpsa_init (tpsa_t *t, const desc_t *d, ord_t mo);
]]

-- functions for GTPSAs complex (mad_ctpsa.h)

cdef [[
// types
typedef struct ctpsa ctpsa_t; // mad_ctpsa.h, mad_desc.h, mad_mono.h, mad_bit.h

// ctors, dtor
ctpsa_t* mad_ctpsa_newd (const  desc_t *d, ord_t mo); // if mo > d_mo, mo = d_mo
ctpsa_t* mad_ctpsa_new  (const ctpsa_t *t, ord_t mo);
void     mad_ctpsa_del  (const ctpsa_t *t);

// introspection
const
desc_t* mad_ctpsa_desc  (const ctpsa_t *t);
int32_t mad_ctpsa_uid   (      ctpsa_t *t, int32_t uid_); // set uid if != 0
ssz_t   mad_ctpsa_len   (const ctpsa_t *t);
str_t   mad_ctpsa_nam   (const ctpsa_t *t);
ord_t   mad_ctpsa_ord   (const ctpsa_t *t);
ord_t   mad_ctpsa_ordv  (const ctpsa_t *t, ...);       // max order of all
ord_t   mad_ctpsa_ordn  (ssz_t n, const ctpsa_t *t[]); // max order of all

// initialization
void  mad_ctpsa_copy    (const ctpsa_t *t, ctpsa_t *r);
void  mad_ctpsa_sclord  (const ctpsa_t *t, ctpsa_t *r, log_t inv); // t[i]*o[i]
void  mad_ctpsa_getord  (const ctpsa_t *t, ctpsa_t *r, ord_t ord);
void  mad_ctpsa_cutord  (const ctpsa_t *t, ctpsa_t *r, int   ord); // ord..mo = 0 or 0..-ord=0
void  mad_ctpsa_convert (const ctpsa_t *t, ctpsa_t *r, ssz_t n, idx_t t2r_[], int pb);
void  mad_ctpsa_setvar_r(      ctpsa_t *t, num_t v_re, num_t v_im, idx_t iv_, num_t scl_re_, num_t scl_im_);
void  mad_ctpsa_setnam  (      ctpsa_t *t, str_t nam);
void  mad_ctpsa_clear   (      ctpsa_t *t);
log_t mad_ctpsa_isnul   (const ctpsa_t *t);

// real, imaginary, norm, phase, conversion
void  mad_ctpsa_cplx    (const  tpsa_t *re_, const tpsa_t *im_, ctpsa_t *r);
void  mad_ctpsa_real    (const ctpsa_t *t,  tpsa_t *r);
void  mad_ctpsa_imag    (const ctpsa_t *t,  tpsa_t *r);
void  mad_ctpsa_cabs    (const ctpsa_t *t,  tpsa_t *r);
void  mad_ctpsa_carg    (const ctpsa_t *t,  tpsa_t *r);
void  mad_ctpsa_unit    (const ctpsa_t *t, ctpsa_t *r);
void  mad_ctpsa_rect    (const ctpsa_t *t, ctpsa_t *r);
void  mad_ctpsa_polar   (const ctpsa_t *t, ctpsa_t *r);

// indexing / monomials
ord_t mad_ctpsa_mono    (const ctpsa_t *t, ssz_t n,       ord_t m_[], idx_t i);
idx_t mad_ctpsa_idxs    (const ctpsa_t *t, ssz_t n,       str_t s   ); // string mono "[0-9]*"
idx_t mad_ctpsa_idxm    (const ctpsa_t *t, ssz_t n, const ord_t m []);
idx_t mad_ctpsa_idxsm   (const ctpsa_t *t, ssz_t n, const int   m []); // sparse mono [(i,o)]
idx_t mad_ctpsa_cycle   (const ctpsa_t *t, ssz_t n,       ord_t m_[], idx_t i, cnum_t *v_);

// accessors without complex-by-value
void  mad_ctpsa_get0_r  (const ctpsa_t *t, cnum_t *r);
void  mad_ctpsa_geti_r  (const ctpsa_t *t, idx_t i, cnum_t *r);
void  mad_ctpsa_gets_r  (const ctpsa_t *t, ssz_t n,       str_t s  , cnum_t *r); // string w orders in '0'-'9'
void  mad_ctpsa_getm_r  (const ctpsa_t *t, ssz_t n, const ord_t m[], cnum_t *r);
void  mad_ctpsa_getsm_r (const ctpsa_t *t, ssz_t n, const int   m[], cnum_t *r); // sparse mono [(i,o)]
void  mad_ctpsa_set0_r  (      ctpsa_t *t, /* i = 0 */               num_t a_re, num_t a_im, num_t b_re, num_t b_im); // a*x[0]+b
void  mad_ctpsa_seti_r  (      ctpsa_t *t, idx_t i,                  num_t a_re, num_t a_im, num_t b_re, num_t b_im); // a*x[i]+b
void  mad_ctpsa_sets_r  (      ctpsa_t *t, ssz_t n,       str_t s  , num_t a_re, num_t a_im, num_t b_re, num_t b_im); // a*x[m]+b
void  mad_ctpsa_setm_r  (      ctpsa_t *t, ssz_t n, const ord_t m[], num_t a_re, num_t a_im, num_t b_re, num_t b_im); // a*x[m]+b
void  mad_ctpsa_setsm_r (      ctpsa_t *t, ssz_t n, const int   m[], num_t a_re, num_t a_im, num_t b_re, num_t b_im); // a*x[m]+b

// accessors vector based
void  mad_ctpsa_getv    (const ctpsa_t *t, idx_t i, ssz_t n,       cnum_t v[]);
void  mad_ctpsa_setv    (      ctpsa_t *t, idx_t i, ssz_t n, const cnum_t v[]);

// operators (without complex-by-value arguments)
log_t mad_ctpsa_equ     (const ctpsa_t *a, const ctpsa_t *b,       num_t tol_);
void  mad_ctpsa_dif     (const ctpsa_t *a, const ctpsa_t *b,       ctpsa_t *c); // (a_i-b_i)/max(|a_i|,1)
void  mad_ctpsa_add     (const ctpsa_t *a, const ctpsa_t *b,       ctpsa_t *c);
void  mad_ctpsa_sub     (const ctpsa_t *a, const ctpsa_t *b,       ctpsa_t *c);
void  mad_ctpsa_mul     (const ctpsa_t *a, const ctpsa_t *b,       ctpsa_t *c);
void  mad_ctpsa_div     (const ctpsa_t *a, const ctpsa_t *b,       ctpsa_t *c);
void  mad_ctpsa_pow     (const ctpsa_t *a, const ctpsa_t *b,       ctpsa_t *c);
void  mad_ctpsa_powi    (const ctpsa_t *a, int            n,       ctpsa_t *c);
void  mad_ctpsa_pown_r  (const ctpsa_t *a, num_t v_re, num_t v_im, ctpsa_t *c);

// operators with internal real-to-complex conversion
log_t mad_ctpsa_equt    (const ctpsa_t *a, const  tpsa_t *b, num_t tol_);
void  mad_ctpsa_dift    (const ctpsa_t *a, const  tpsa_t *b, ctpsa_t *c);
void  mad_ctpsa_tdif    (const  tpsa_t *a, const ctpsa_t *b, ctpsa_t *c);
void  mad_ctpsa_addt    (const ctpsa_t *a, const  tpsa_t *b, ctpsa_t *c);
void  mad_ctpsa_subt    (const ctpsa_t *a, const  tpsa_t *b, ctpsa_t *c);
void  mad_ctpsa_tsub    (const  tpsa_t *a, const ctpsa_t *b, ctpsa_t *c);
void  mad_ctpsa_mult    (const ctpsa_t *a, const  tpsa_t *b, ctpsa_t *c);
void  mad_ctpsa_divt    (const ctpsa_t *a, const  tpsa_t *b, ctpsa_t *c);
void  mad_ctpsa_tdiv    (const  tpsa_t *a, const ctpsa_t *b, ctpsa_t *c);
void  mad_ctpsa_powt    (const ctpsa_t *a, const  tpsa_t *b, ctpsa_t *c);
void  mad_ctpsa_tpow    (const  tpsa_t *a, const ctpsa_t *b, ctpsa_t *c);

// functions
num_t mad_ctpsa_nrm     (const ctpsa_t *a);
void  mad_ctpsa_conj    (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_sqrt    (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_exp     (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_log     (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_sincos  (const ctpsa_t *a, ctpsa_t *s, ctpsa_t *c);
void  mad_ctpsa_sin     (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_cos     (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_tan     (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_cot     (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_sinc    (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_sincosh (const ctpsa_t *a, ctpsa_t *s, ctpsa_t *c);
void  mad_ctpsa_sinh    (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_cosh    (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_tanh    (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_coth    (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_sinhc   (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_asin    (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_acos    (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_atan    (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_acot    (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_asinc   (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_asinh   (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_acosh   (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_atanh   (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_acoth   (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_asinhc  (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_erf     (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_erfc    (const ctpsa_t *a, ctpsa_t *c);

void  mad_ctpsa_hypot   (const ctpsa_t *x, const ctpsa_t *y, ctpsa_t *r);
void  mad_ctpsa_hypot3  (const ctpsa_t *x, const ctpsa_t *y, const ctpsa_t *z, ctpsa_t *r);

void  mad_ctpsa_integ   (const ctpsa_t *a, ctpsa_t *c, int iv);
void  mad_ctpsa_deriv   (const ctpsa_t *a, ctpsa_t *c, int iv);
void  mad_ctpsa_derivm  (const ctpsa_t *a, ctpsa_t *c, ssz_t n, const ord_t m[]);
void  mad_ctpsa_poisbra (const ctpsa_t *a, const ctpsa_t *b, ctpsa_t *c, int nv);
void  mad_ctpsa_taylor  (const ctpsa_t *a, ssz_t n, const cnum_t coef[], ctpsa_t *c);

// functions with internal real-to-complex conversion
void  mad_ctpsa_poisbrat(const ctpsa_t *a, const  tpsa_t *b, ctpsa_t *c, int nv);
void  mad_ctpsa_tpoisbra(const  tpsa_t *a, const ctpsa_t *b, ctpsa_t *c, int nv);

// functions (without complex-by-value arguments)
void  mad_ctpsa_acc_r    (const ctpsa_t *a, num_t v_re, num_t v_im, ctpsa_t *c);
void  mad_ctpsa_scl_r    (const ctpsa_t *a, num_t v_re, num_t v_im, ctpsa_t *c);
void  mad_ctpsa_inv_r    (const ctpsa_t *a, num_t v_re, num_t v_im, ctpsa_t *c);
void  mad_ctpsa_invsqrt_r(const ctpsa_t *a, num_t v_re, num_t v_im, ctpsa_t *c);

// high level functions without complex-by-value
void mad_ctpsa_axpb_r        (num_t a_re, num_t a_im, const ctpsa_t *x,
                              num_t b_re, num_t b_im, ctpsa_t *r);
void mad_ctpsa_axpbypc_r     (num_t a_re, num_t a_im, const ctpsa_t *x,
                              num_t b_re, num_t b_im, const ctpsa_t *y,
                              num_t c_re, num_t c_im, ctpsa_t *r);
void mad_ctpsa_axypb_r       (num_t a_re, num_t a_im, const ctpsa_t *x, const ctpsa_t *y,
                              num_t b_re, num_t b_im, ctpsa_t *r);
void mad_ctpsa_axypbzpc_r    (num_t a_re, num_t a_im, const ctpsa_t *x, const ctpsa_t *y,
                              num_t b_re, num_t b_im, const ctpsa_t *z,
                              num_t c_re, num_t c_im, ctpsa_t *r);
void mad_ctpsa_axypbvwpc_r   (num_t a_re, num_t a_im, const ctpsa_t *x, const ctpsa_t *y,
                              num_t b_re, num_t b_im, const ctpsa_t *v, const ctpsa_t *w,
                              num_t c_re, num_t c_im, ctpsa_t *r);
void mad_ctpsa_ax2pby2pcz2_r (num_t a_re, num_t a_im, const ctpsa_t *x,
                              num_t b_re, num_t b_im, const ctpsa_t *y,
                              num_t c_re, num_t c_im, const ctpsa_t *z, ctpsa_t *r);
void mad_ctpsa_axpsqrtbpcx2_r(const ctpsa_t *x, num_t a_re, num_t a_im, num_t b_re, num_t b_im,
                                                num_t c_re, num_t c_im, ctpsa_t *r);
void mad_ctpsa_logaxpsqrtbpcx2_r(const ctpsa_t *x, num_t a_re, num_t a_im, num_t b_re, num_t b_im,
                                                   num_t c_re, num_t c_im, ctpsa_t *r);
void mad_ctpsa_logxdy         (const ctpsa_t *x, const ctpsa_t *y, ctpsa_t *r);

// to check for non-homogeneous maps & parameters
void     mad_ctpsa_vec2fld  (ssz_t na, const ctpsa_t *a   ,                      ctpsa_t *mc[]); // F . grad
void     mad_ctpsa_fld2vec  (ssz_t na, const ctpsa_t *ma[],                      ctpsa_t *c   );
void     mad_ctpsa_fgrad    (ssz_t na, const ctpsa_t *ma[], const ctpsa_t * b  , ctpsa_t *c   );
void     mad_ctpsa_liebra   (ssz_t na, const ctpsa_t *ma[], const ctpsa_t *mb[], ctpsa_t *mc[]);
void     mad_ctpsa_exppb    (ssz_t na, const ctpsa_t *ma[], const ctpsa_t *mb[], ctpsa_t *mc[]); // exp(:F:) K
void     mad_ctpsa_logpb    (ssz_t na, const ctpsa_t *ma[], const ctpsa_t *mb[], ctpsa_t *mc[]); // exp(log(:F:)) K

num_t    mad_ctpsa_mnrm     (ssz_t na, const ctpsa_t *ma[]);
void     mad_ctpsa_minv     (ssz_t na, const ctpsa_t *ma[],                                ctpsa_t *mc[]);
void     mad_ctpsa_pminv    (ssz_t na, const ctpsa_t *ma[],                                ctpsa_t *mc[], idx_t select[]);
void     mad_ctpsa_compose  (ssz_t na, const ctpsa_t *ma[], ssz_t nb, const ctpsa_t *mb[], ctpsa_t *mc[]);
void     mad_ctpsa_translate(ssz_t na, const ctpsa_t *ma[], ssz_t nb, const cnum_t   tb[], ctpsa_t *mc[]);
void     mad_ctpsa_eval     (ssz_t na, const ctpsa_t *ma[], ssz_t nb, const cnum_t   tb[], cnum_t   tc[]);
void     mad_ctpsa_mconv    (ssz_t na, const ctpsa_t *ma[], ssz_t nc,                      ctpsa_t *mc[], ssz_t n, idx_t t2r_[], int pb);

// I/O
void     mad_ctpsa_print    (const ctpsa_t *t, str_t name_, num_t eps_, int nohdr_, FILE *stream_);
ctpsa_t* mad_ctpsa_scan     (                                                       FILE *stream_);
const
desc_t*  mad_ctpsa_scan_hdr (      int *kind_, char  name_[],                       FILE *stream_);
void     mad_ctpsa_scan_coef(      ctpsa_t *t,                                      FILE *stream_);
void     mad_ctpsa_debug    (const ctpsa_t *t, str_t name_, str_t fnam_, int line_, FILE *stream_);
log_t    mad_ctpsa_is_valid (const ctpsa_t *t);

// unsafe operation (mo vs allocated!!)
ctpsa_t* mad_ctpsa_init (ctpsa_t *t, const desc_t *d, ord_t mo);
]]

-- functions for synchrotron radiation (mad_rad.h)

cdef [[
num_t mad_rad_InvSynFracInt (num_t x); // HBU 2007
]]

-- end ------------------------------------------------------------------------o
return C
