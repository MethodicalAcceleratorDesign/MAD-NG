--[=[
 o-----------------------------------------------------------------------------o
 |
 | MAD C environment (sandbox)
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Load in order all the C modules of the MAD application.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local cdef, C in require 'ffi'

-- implementation -------------------------------------------------------------o

-- common types for MAD (mad_def.h)

cdef [[
typedef bool             log_t;
typedef int32_t          idx_t;
typedef int32_t          ssz_t;
typedef uint32_t         u32_t;
typedef uint64_t         u64_t;
typedef double           num_t;
typedef double _Complex  cpx_t;
typedef const char*      str_t;
typedef const void*      ptr_t;

typedef struct _IO_FILE  FILE; // stdio.h
]]

-- constants for math and physics (mad_cst.h)

cdef [[
extern const num_t mad_cst_EPS;
extern const num_t mad_cst_TINY;
extern const num_t mad_cst_HUGE;
extern const num_t mad_cst_INF;
extern const num_t mad_cst_NAN;

extern const num_t mad_cst_E;
extern const num_t mad_cst_LOG2E;
extern const num_t mad_cst_LOG10E;
extern const num_t mad_cst_LN2;
extern const num_t mad_cst_LN10;
extern const num_t mad_cst_LNPI;
extern const num_t mad_cst_PI;
extern const num_t mad_cst_2PI;
extern const num_t mad_cst_PI_2;
extern const num_t mad_cst_PI_4;
extern const num_t mad_cst_1_PI;
extern const num_t mad_cst_2_PI;
extern const num_t mad_cst_SQRT2;
extern const num_t mad_cst_SQRT3;
extern const num_t mad_cst_SQRTPI;
extern const num_t mad_cst_SQRT1_2;
extern const num_t mad_cst_SQRT1_3;
extern const num_t mad_cst_1_SQRTPI;
extern const num_t mad_cst_2_SQRTPI;

extern const num_t mad_cst_DEG2RAD;
extern const num_t mad_cst_RAD2DEG;

extern const num_t mad_cst_MINLEN;
extern const num_t mad_cst_MINANG;
extern const num_t mad_cst_MINSTR;

extern const num_t mad_cst_CLIGHT;
extern const num_t mad_cst_MU0;
extern const num_t mad_cst_EPSILON0;
extern const num_t mad_cst_QELECT;
extern const num_t mad_cst_HBAR;
extern const num_t mad_cst_AMASS;
extern const num_t mad_cst_EMASS;
extern const num_t mad_cst_NMASS;
extern const num_t mad_cst_PMASS;
extern const num_t mad_cst_MUMASS;
extern const num_t mad_cst_DEUMASS;
extern const num_t mad_cst_ERADIUS;
extern const num_t mad_cst_ALPHAEM;
]]

-- variables for environment (mad_log.h)

cdef [[
extern const int mad_warn_count;
extern const int mad_stdin_is_tty;
extern const int mad_is_interactive;

extern       int mad_trace_level;
extern       int mad_trace_location;
extern       int mad_trace_fortid;
]]

-- functions for memory management (mad_mem.h)

cdef [[
void*  mad_malloc   (size_t size_);
void*  mad_calloc   (size_t count, size_t size );
void*  mad_realloc  (void  *ptr_ , size_t size_);
void   mad_free     (void  *ptr_);

size_t mad_mcached  (void);
void   mad_mcollect (void);
void   mad_mdump    (FILE*);

// threshold between C and Lua allocator in 8 bytes units
static const ssz_t mad_alloc_threshold = 256;
]]

-- functions for fast string manipulation (mad_str.h)

cdef [[
str_t mad_str_trim    (str_t str, ssz_t arg[2]);
str_t mad_str_num     (str_t str, ssz_t arg[5]);
str_t mad_str_ident   (str_t str, ssz_t arg[4]);
str_t mad_str_quote   (str_t str, ssz_t arg[5]);
str_t mad_str_bracket (str_t str, ssz_t arg[6]);
str_t mad_str_split   (str_t str, ssz_t arg[4], str_t sep);
]]

-- functions for real and complex numbers (mad_num.h)

cdef [[
// C99 math.h
num_t round  (num_t x);
num_t asinh  (num_t x);
num_t acosh  (num_t x);
num_t atanh  (num_t x);
num_t tgamma (num_t x);
num_t lgamma (num_t x);
num_t hypot  (num_t x, num_t y);

// real functions
int    mad_num_sign    (num_t x); // -1, 0, 1
int    mad_num_sign1   (num_t x); // -1, 1: works for ±0, ±inf and ±NaN!

num_t  mad_num_fact    (int n);   // n in Z -> n!

num_t  mad_num_sinc    (num_t x);
num_t  mad_num_sinhc   (num_t x);
num_t  mad_num_asinc   (num_t x);
num_t  mad_num_asinhc  (num_t x);
num_t  mad_num_powi    (num_t x, int n); // x^n, n in Z

// complex to real wrappers
num_t mad_cpx_abs_r    (num_t x_re, num_t x_im);
num_t mad_cpx_arg_r    (num_t x_re, num_t x_im);

void  mad_cpx_sqrt_r   (num_t x_re, num_t x_im, cpx_t *r);
void  mad_cpx_exp_r    (num_t x_re, num_t x_im, cpx_t *r);
void  mad_cpx_log_r    (num_t x_re, num_t x_im, cpx_t *r);
void  mad_cpx_log10_r  (num_t x_re, num_t x_im, cpx_t *r);

void  mad_cpx_sin_r    (num_t x_re, num_t x_im, cpx_t *r);
void  mad_cpx_cos_r    (num_t x_re, num_t x_im, cpx_t *r);
void  mad_cpx_tan_r    (num_t x_re, num_t x_im, cpx_t *r);
void  mad_cpx_sinh_r   (num_t x_re, num_t x_im, cpx_t *r);
void  mad_cpx_cosh_r   (num_t x_re, num_t x_im, cpx_t *r);
void  mad_cpx_tanh_r   (num_t x_re, num_t x_im, cpx_t *r);

void  mad_cpx_asin_r   (num_t x_re, num_t x_im, cpx_t *r);
void  mad_cpx_acos_r   (num_t x_re, num_t x_im, cpx_t *r);
void  mad_cpx_atan_r   (num_t x_re, num_t x_im, cpx_t *r);
void  mad_cpx_asinh_r  (num_t x_re, num_t x_im, cpx_t *r);
void  mad_cpx_acosh_r  (num_t x_re, num_t x_im, cpx_t *r);
void  mad_cpx_atanh_r  (num_t x_re, num_t x_im, cpx_t *r);

void  mad_cpx_sinc_r   (num_t x_re, num_t x_im, cpx_t *r);
void  mad_cpx_sinhc_r  (num_t x_re, num_t x_im, cpx_t *r);
void  mad_cpx_asinc_r  (num_t x_re, num_t x_im, cpx_t *r);
void  mad_cpx_asinhc_r (num_t x_re, num_t x_im, cpx_t *r);

void  mad_cpx_unit_r   (num_t x_re, num_t x_im, cpx_t *r);
void  mad_cpx_proj_r   (num_t x_re, num_t x_im, cpx_t *r);
void  mad_cpx_rect_r   (num_t  rho, num_t  ang, cpx_t *r);
void  mad_cpx_polar_r  (num_t x_re, num_t x_im, cpx_t *r);

void  mad_cpx_invsqrt_r(num_t x_re, num_t x_im, cpx_t *r);
void  mad_cpx_inv_r    (num_t x_re, num_t x_im, cpx_t *r);
void  mad_cpx_div_r    (num_t x_re, num_t x_im, num_t y_re, num_t y_im, cpx_t *r);
void  mad_cpx_mod_r    (num_t x_re, num_t x_im, num_t y_re, num_t y_im, cpx_t *r);
void  mad_cpx_pow_r    (num_t x_re, num_t x_im, num_t y_re, num_t y_im, cpx_t *r);
void  mad_cpx_powi_r   (num_t x_re, num_t x_im, int   n,                cpx_t *r);

// Faddeeva based functions
num_t mad_num_wf       (num_t x);
num_t mad_num_erf      (num_t x);
num_t mad_num_erfc     (num_t x);
num_t mad_num_erfi     (num_t x);
num_t mad_num_erfcx    (num_t x);
num_t mad_num_dawson   (num_t x);

void  mad_cpx_wf_r     (num_t x_re, num_t x_im, num_t relerr, cpx_t *r);
void  mad_cpx_erf_r    (num_t x_re, num_t x_im, num_t relerr, cpx_t *r);
void  mad_cpx_erfc_r   (num_t x_re, num_t x_im, num_t relerr, cpx_t *r);
void  mad_cpx_erfi_r   (num_t x_re, num_t x_im, num_t relerr, cpx_t *r);
void  mad_cpx_erfcx_r  (num_t x_re, num_t x_im, num_t relerr, cpx_t *r);
void  mad_cpx_dawson_r (num_t x_re, num_t x_im, num_t relerr, cpx_t *r);

// MAD random number generator
typedef struct prng_state_ prng_state_t; // mad_num.[hc]

num_t mad_num_rand      (prng_state_t*);             // [0.,1.)
u64_t mad_num_randi     (prng_state_t*);             // [0,ULLONG_MAX]
void  mad_num_randjump  (prng_state_t*);
void  mad_num_randseed  (prng_state_t*, num_t seed);

// MADX random number generator
typedef struct xrng_state_ xrng_state_t; // mad_num.[hc]

num_t mad_num_xrand     (xrng_state_t*);           // [0.,1.)
u32_t mad_num_xrandi    (xrng_state_t*);           // [0,UINT_MAX]
void  mad_num_xrandseed (xrng_state_t*, u32_t seed);

// dummy function for testing reduction with OpenMP by running
// time ./mad -q -e 'io.write("s=",MAD._C.mad_num_suminv(1e11),"\n")'
// => s=25.905651687759, real 0m15.601s, user 1m59.351s
num_t mad_num_suminv (u64_t n);
]]

-- functions for vector-vector, scalar-vector and vector-scalar operations (mad_vec.h)

cdef [[
void  mad_vec_fill   (      num_t x  ,                         num_t r[], ssz_t n); // num -> vec
void  mad_vec_roll   (      num_t x[],                                    ssz_t n, int nroll);
void  mad_vec_sort   (      num_t x[],                         idx_t r[], ssz_t n); // shell sort
log_t mad_vec_isnul  (const num_t x[],                                    ssz_t n); // vec == 0
log_t mad_vec_isval  (const num_t x[],       num_t v,                     ssz_t n); // vec == v
void  mad_vec_copy   (const num_t x[],                         num_t r[], ssz_t n); // vec -> vec
void  mad_vec_copyv  (const num_t x[],                         cpx_t r[], ssz_t n); // vec ->cvec
void  mad_vec_minmax (const num_t x[],       log_t absf,       idx_t r[], ssz_t n); // MinMax(vec)
num_t mad_vec_eval   (const num_t x[],       num_t x0,                    ssz_t n); // Horner scheme
num_t mad_vec_sum    (const num_t x[],                                    ssz_t n); // Sum(vec)
num_t mad_vec_ksum   (const num_t x[],                                    ssz_t n); // Sum(vec) (Kahan)
num_t mad_vec_mean   (const num_t x[],                                    ssz_t n); // Mean(vec)
num_t mad_vec_var    (const num_t x[],                                    ssz_t n); // Var(vec)
void  mad_vec_center (const num_t x[],                         num_t r[], ssz_t n); // vec -> vec-<vec>
num_t mad_vec_norm   (const num_t x[],                                    ssz_t n); // |vec|
num_t mad_vec_dist   (const num_t x[], const num_t y[],                   ssz_t n); // |vec -  vec|
num_t mad_vec_distv  (const num_t x[], const cpx_t y[],                   ssz_t n); // |vec - cvec|
num_t mad_vec_dot    (const num_t x[], const num_t y[],                   ssz_t n); // <vec ,  vec>
num_t mad_vec_kdot   (const num_t x[], const num_t y[],                   ssz_t n); // <vec ,  vec> (Kahan)
void  mad_vec_cplx   (const num_t x[], const num_t y[],        cpx_t r[], ssz_t n); // vr,vi->cvec
num_t mad_vec_abs    (const num_t x[],                         num_t r[], ssz_t n); // Sum and |vec_i|
void  mad_vec_add    (const num_t x[], const num_t y[],        num_t r[], ssz_t n); // vec +  vec
void  mad_vec_addn   (const num_t x[],       num_t y  ,        num_t r[], ssz_t n); // vec +  num
void  mad_vec_addc_r (const num_t x[], num_t y_re, num_t y_im, cpx_t r[], ssz_t n); // vec +  cpx
void  mad_vec_sub    (const num_t x[], const num_t y[],        num_t r[], ssz_t n); // vec -  vec
void  mad_vec_subv   (const num_t x[], const cpx_t y[],        cpx_t r[], ssz_t n); // vec - cvec
void  mad_vec_subn   (const num_t y[],       num_t x  ,        num_t r[], ssz_t n); // num -  vec
void  mad_vec_subc_r (const num_t y[], num_t x_re, num_t x_im, cpx_t r[], ssz_t n); // cpx -  vec
void  mad_vec_mul    (const num_t x[], const num_t y[],        num_t r[], ssz_t n); // vec *  vec
void  mad_vec_muln   (const num_t x[],       num_t y  ,        num_t r[], ssz_t n); // vec *  num
void  mad_vec_mulc_r (const num_t x[], num_t y_re, num_t y_im, cpx_t r[], ssz_t n); // vec *  cpx
void  mad_vec_div    (const num_t x[], const num_t y[],        num_t r[], ssz_t n); // vec /  vec
void  mad_vec_divv   (const num_t x[], const cpx_t y[],        cpx_t r[], ssz_t n); // vec / cvec
void  mad_vec_divn   (const num_t y[],       num_t x  ,        num_t r[], ssz_t n); // num /  vec
void  mad_vec_divc_r (const num_t y[], num_t x_re, num_t x_im, cpx_t r[], ssz_t n); // cpx /  vec
void  mad_vec_dif    (const num_t x[], const num_t y[],        num_t r[], ssz_t n); // dif(vec,vec)
void  mad_vec_difv   (const num_t x[], const cpx_t y[],        cpx_t r[], ssz_t n); // dif(vec,cvec)
void  mad_vec_fft    (const num_t x[],                         cpx_t r[], ssz_t n); // vec ->cvec
void  mad_vec_rfft   (const num_t x[],                         cpx_t r[], ssz_t n); // vec ->cvec
void  mad_vec_nfft   (const num_t x[], const num_t x_node[]  , cpx_t r[], ssz_t n, ssz_t nr);
void  mad_vec_kadd   (int k,const num_t a[], const num_t *x[], num_t r[], ssz_t n); // sum_k ax

void  mad_cvec_fill_r(      num_t x_re,            num_t x_im, cpx_t r[], ssz_t n); // cpx ->cvec
void  mad_cvec_roll  (      cpx_t x[],                                    ssz_t n, int nroll);
log_t mad_cvec_isnul (const cpx_t x[],                                    ssz_t n); // cvec == 0
log_t mad_cvec_isval_r(const cpx_t x[],num_t v_re, num_t v_im,            ssz_t n); // cvec == v
void  mad_cvec_copy  (const cpx_t x[],                         cpx_t r[], ssz_t n); // cvec ->cvec
void  mad_cvec_minmax(const cpx_t x[],                         idx_t r[], ssz_t n); // MinMax(vec)
void  mad_cvec_eval_r(const cpx_t x[],num_t x0_re,num_t x0_im, cpx_t *r , ssz_t n);
void  mad_cvec_sum_r (const cpx_t x[],                         cpx_t *r , ssz_t n); // Sum(vec)
void  mad_cvec_ksum_r(const cpx_t x[],                         cpx_t *r , ssz_t n); // Sum(vec)
void  mad_cvec_mean_r(const cpx_t x[],                         cpx_t *r , ssz_t n); // Mean(vec)
void  mad_cvec_var_r (const cpx_t x[],                         cpx_t *r , ssz_t n); // Var(vec)
void  mad_cvec_center(const cpx_t x[],                         cpx_t r[], ssz_t n); //  cvec ->cvec-<cvec>
num_t mad_cvec_norm  (const cpx_t x[],                                    ssz_t n); // |cvec|
num_t mad_cvec_dist  (const cpx_t x[], const cpx_t y[],                   ssz_t n); // |cvec - cvec|
num_t mad_cvec_distv (const cpx_t x[], const num_t y[],                   ssz_t n); // |cvec -  vec|
void  mad_cvec_dot_r (const cpx_t x[], const cpx_t y[],        cpx_t *r , ssz_t n); // <cvec , cvec>
void  mad_cvec_dotv_r(const cpx_t x[], const num_t y[],        cpx_t *r , ssz_t n); // <cvec ,  vec>
void  mad_cvec_kdot_r(const cpx_t x[], const cpx_t y[],        cpx_t *r , ssz_t n); // <cvec , cvec>
void  mad_cvec_kdotv_r(const cpx_t x[],const num_t y[],        cpx_t *r , ssz_t n); // <cvec ,  vec>
void  mad_cvec_reim  (const cpx_t x[], num_t re[], num_t ri[],            ssz_t n); // cvec->vr,vi
void  mad_cvec_conj  (const cpx_t x[],                         cpx_t r[], ssz_t n); // cvec->cvec*
num_t mad_cvec_abs   (const cpx_t x[],                         num_t r[], ssz_t n); // um and |cvec_i|
void  mad_cvec_add   (const cpx_t x[], const cpx_t y[]       , cpx_t r[], ssz_t n); // cvec + cvec
void  mad_cvec_addv  (const cpx_t x[], const num_t y[]       , cpx_t r[], ssz_t n); // cvec +  vec
void  mad_cvec_addn  (const cpx_t x[],       num_t y         , cpx_t r[], ssz_t n); // cvec +  num
void  mad_cvec_addc_r(const cpx_t x[], num_t y_re, num_t y_im, cpx_t r[], ssz_t n); // cvec +  cpx
void  mad_cvec_sub   (const cpx_t x[], const cpx_t y[]       , cpx_t r[], ssz_t n); // cvec - cvec
void  mad_cvec_subv  (const cpx_t x[], const num_t y[]       , cpx_t r[], ssz_t n); // cvec -  vec
void  mad_cvec_subn  (const cpx_t y[],       num_t x         , cpx_t r[], ssz_t n); // num  - cvec
void  mad_cvec_subc_r(const cpx_t y[], num_t x_re, num_t x_im, cpx_t r[], ssz_t n); // cpx  - cvec
void  mad_cvec_mul   (const cpx_t x[], const cpx_t y[]       , cpx_t r[], ssz_t n); // cvec * cvec
void  mad_cvec_mulv  (const cpx_t x[], const num_t y[]       , cpx_t r[], ssz_t n); // cvec *  vec
void  mad_cvec_muln  (const cpx_t x[],       num_t y         , cpx_t r[], ssz_t n); // cvec *  num
void  mad_cvec_mulc_r(const cpx_t x[], num_t y_re, num_t y_im, cpx_t r[], ssz_t n); // cvec *  cpx
void  mad_cvec_div   (const cpx_t x[], const cpx_t y[]       , cpx_t r[], ssz_t n); // cvec / cvec
void  mad_cvec_divv  (const cpx_t x[], const num_t y[]       , cpx_t r[], ssz_t n); // cvec /  vec
void  mad_cvec_divn  (const cpx_t y[],       num_t x         , cpx_t r[], ssz_t n); // num  / cvec
void  mad_cvec_divc_r(const cpx_t y[], num_t x_re, num_t x_im, cpx_t r[], ssz_t n); // cpx  / cvec
void  mad_cvec_dif   (const cpx_t x[], const cpx_t y[],        cpx_t r[], ssz_t n); // dif(cvec,cvec)
void  mad_cvec_difv  (const cpx_t x[], const num_t y[],        cpx_t r[], ssz_t n); // dif(cvec,vec)
void  mad_cvec_fft   (const cpx_t x[],                         cpx_t r[], ssz_t n); // cvec ->cvec
void  mad_cvec_nfft  (const cpx_t x[], const num_t x_node[]  , cpx_t r[], ssz_t n, ssz_t nr);
void  mad_cvec_ifft  (const cpx_t x[],                         cpx_t r[], ssz_t n); // cvec ->cvec
void  mad_cvec_irfft (const cpx_t x[],                         num_t r[], ssz_t n); // cvec -> vec
void  mad_cvec_infft (const cpx_t x[], const num_t r_node[]  , cpx_t r[], ssz_t n, ssz_t nx);
void  mad_cvec_kadd  (int k,const cpx_t a[], const cpx_t *x[], cpx_t r[], ssz_t n); // sum_k ax

void  mad_ivec_fill  (      idx_t x  ,                         idx_t  r[], ssz_t n); // idx ->ivec
void  mad_ivec_roll  (      idx_t x[],                                     ssz_t n, int nroll);
ssz_t mad_ivec_sort  (      idx_t x[],                                     ssz_t n, log_t rmdup); // shell sort
log_t mad_ivec_isnul (const idx_t x[],                                     ssz_t n); // ivec == 0
log_t mad_ivec_isval (const idx_t x[],       idx_t v,                      ssz_t n); // ivec == v
void  mad_ivec_copy  (const idx_t x[],                         idx_t  r[], ssz_t n); // ivec ->ivec
void  mad_ivec_minmax(const idx_t x[],       log_t absf,       idx_t  r[], ssz_t n); // MinMax(ivec)
void  mad_ivec_add   (const idx_t x[], const idx_t y[],        idx_t  r[], ssz_t n); // ivec + ivec
void  mad_ivec_addn  (const idx_t x[],       idx_t y  ,        idx_t  r[], ssz_t n); // ivec +  idx
void  mad_ivec_sub   (const idx_t x[], const idx_t y[],        idx_t  r[], ssz_t n); // ivec - ivec
void  mad_ivec_subn  (const idx_t y[],       idx_t x  ,        idx_t  r[], ssz_t n); //  idx - ivec
void  mad_ivec_mul   (const idx_t x[], const idx_t y[],        idx_t  r[], ssz_t n); // ivec * ivec
void  mad_ivec_muln  (const idx_t x[],       idx_t y  ,        idx_t  r[], ssz_t n); // ivec *  idx
void  mad_ivec_divn  (const idx_t x[],       idx_t y  ,        idx_t  r[], ssz_t n); // ivec /  idx
void  mad_ivec_modn  (const idx_t x[],       idx_t y  ,        idx_t  r[], ssz_t n); // ivec %  idx

// global fft cleanup
void  mad_fft_cleanup (void);
]]

-- functions for matrix-matrix, vector-matrix and matrix-vector operations (mad_mat.h)
-- note: matrices can be treated as vectors for elements-wise operations

cdef [[
void  mad_mat_rev      (      num_t x[],                                   ssz_t m, ssz_t n, int d);                // mat -> rev(mat)
void  mad_mat_center   (      num_t x[],                                   ssz_t m, ssz_t n, int d);                // mat -> mat-<mat>
void  mad_mat_roll     (      num_t x[],                                   ssz_t m, ssz_t n, int mroll, int nroll); // mat -> mat
void  mad_mat_eye      (      num_t x[],                        num_t v  , ssz_t m, ssz_t n, ssz_t ldx);            // mat -> mat
void  mad_mat_copy     (const num_t x[],                        num_t r[], ssz_t m, ssz_t n, ssz_t ldx, ssz_t ldr); // mat -> mat
void  mad_mat_copym    (const num_t x[],                        cpx_t r[], ssz_t m, ssz_t n, ssz_t ldx, ssz_t ldr); // mat ->cmat
void  mad_mat_trans    (const num_t x[],                        num_t r[], ssz_t m, ssz_t n);                       // mat.t()
void  mad_mat_mul      (const num_t x[], const num_t y[],       num_t r[], ssz_t m, ssz_t n, ssz_t p);              // mat *  mat
void  mad_mat_mulm     (const num_t x[], const cpx_t y[],       cpx_t r[], ssz_t m, ssz_t n, ssz_t p);              // mat * cmat
void  mad_mat_tmul     (const num_t x[], const num_t y[],       num_t r[], ssz_t m, ssz_t n, ssz_t p);              // mat'*  mat
void  mad_mat_tmulm    (const num_t x[], const cpx_t y[],       cpx_t r[], ssz_t m, ssz_t n, ssz_t p);              // mat'* cmat
void  mad_mat_mult     (const num_t x[], const num_t y[],       num_t r[], ssz_t m, ssz_t n, ssz_t p);              // mat *  mat'
void  mad_mat_multm    (const num_t x[], const cpx_t y[],       cpx_t r[], ssz_t m, ssz_t n, ssz_t p);              // mat * cmat'
void  mad_mat_dmul     (const num_t x[], const num_t y[],       num_t r[], ssz_t m, ssz_t n, ssz_t p);              // diag(mat) *  mat
void  mad_mat_dmulm    (const num_t x[], const cpx_t y[],       cpx_t r[], ssz_t m, ssz_t n, ssz_t p);              // diag(mat) * cmat
void  mad_mat_muld     (const num_t x[], const num_t y[],       num_t r[], ssz_t m, ssz_t n, ssz_t p);              // mat * diag( mat)
void  mad_mat_muldm    (const num_t x[], const cpx_t y[],       cpx_t r[], ssz_t m, ssz_t n, ssz_t p);              // mat * diag(cmat)
int   mad_mat_det      (const num_t x[],                        num_t *r  ,          ssz_t n);                       // det(mat)
int   mad_mat_invn     (const num_t y[],       num_t x  ,       num_t r[], ssz_t m, ssz_t n,          num_t rcond); // num /  mat
int   mad_mat_invc_r   (const num_t y[], num_t x_re,num_t x_im, cpx_t r[], ssz_t m, ssz_t n,          num_t rcond); // cpx /  mat
int   mad_mat_pinvn    (const num_t y[],       num_t x,         num_t r[], ssz_t m, ssz_t n,          num_t rcond, int ncond); //  num /  mat (pseudo-inverse)
int   mad_mat_pinvc_r  (const num_t y[], num_t x_re,num_t x_im, cpx_t r[], ssz_t m, ssz_t n,          num_t rcond, int ncond); //  cpx /  mat
int   mad_mat_div      (const num_t x[], const num_t y[],       num_t r[], ssz_t m, ssz_t n, ssz_t p, num_t rcond); // mat /  mat
int   mad_mat_divm     (const num_t x[], const cpx_t y[],       cpx_t r[], ssz_t m, ssz_t n, ssz_t p, num_t rcond); // mat / cmat
int   mad_mat_solve    (const num_t a[], const num_t b[],       num_t x[], ssz_t m, ssz_t n, ssz_t p, num_t rcond); // min|b-ax| (QR)
int   mad_mat_nsolve   (const num_t a[], const num_t b[],       num_t x[], ssz_t m, ssz_t n, ssz_t N, num_t rcond, num_t r_[]); // min|b-ax| (MICADO)
int   mad_mat_ssolve   (const num_t a[], const num_t b[],       num_t x[], ssz_t m, ssz_t n, ssz_t p, num_t rcond, int ncond, num_t s_[]); // min|b-ax| (SVD)
int   mad_mat_gsolve   (const num_t a[], const num_t b[], const num_t c[], const num_t d[],
                                                                num_t x[], ssz_t m, ssz_t n, ssz_t p, num_t *nrm_);
int   mad_mat_gmsolve  (const num_t a[], const num_t b[], const num_t d[],
                                               num_t x[],       num_t y[], ssz_t m, ssz_t n, ssz_t p);
int   mad_mat_pcacnd   (const num_t a[],       idx_t c[],                  ssz_t m, ssz_t n, ssz_t N, num_t cut, num_t s_[]);
int   mad_mat_svdcnd   (const num_t a[],       idx_t c[],                  ssz_t m, ssz_t n, ssz_t N, num_t cut, num_t s_[], num_t tol);
int   mad_mat_svd      (const num_t x[], num_t u[], num_t s[],  num_t v[], ssz_t m, ssz_t n);                       // u * s * v.t
int   mad_mat_eigen    (const num_t x[], cpx_t w[], num_t vl[], num_t vr[],         ssz_t n);                       // w, vl, vr
void  mad_mat_fft      (const num_t x[],                        cpx_t r[], ssz_t m, ssz_t n);                       // mat ->cmat
void  mad_mat_rfft     (const num_t x[],                        cpx_t r[], ssz_t m, ssz_t n);                       // mat ->cmat
void  mad_mat_nfft     (const num_t x[], const num_t x_node[],  cpx_t r[], ssz_t m, ssz_t n, ssz_t nr);
void  mad_mat_sympconj (const num_t x[],                        num_t r[],          ssz_t n);                       // -J M' J
num_t mad_mat_symperr  (const num_t x[],                        num_t r[],          ssz_t n, num_t *tol_);          // M' J M - J

void  mad_cmat_rev     (      cpx_t x[],                                   ssz_t m, ssz_t n, int d);                // cmat->rev(cmat)
void  mad_cmat_center  (      cpx_t x[],                                   ssz_t m, ssz_t n, int d);                // cmat->cmat-<cmat>_r
void  mad_cmat_roll    (      cpx_t x[],                                   ssz_t m, ssz_t n, int mroll, int nroll); // cmat->cmat
void  mad_cmat_eye     (      cpx_t x[],                        cpx_t v  , ssz_t m, ssz_t n, ssz_t ldx);            // cmat->cmat
void  mad_cmat_eye_r   (      cpx_t x[], num_t v_re,num_t v_im,            ssz_t m, ssz_t n, ssz_t ldx);            // cmat->cmat
void  mad_cmat_copy    (const cpx_t x[],                        cpx_t r[], ssz_t m, ssz_t n, ssz_t ldx, ssz_t ldr); // cmat->cmat
void  mad_cmat_trans   (const cpx_t x[],                        cpx_t r[], ssz_t m, ssz_t n);                       // cmat.t()
void  mad_cmat_ctrans  (const cpx_t x[],                        cpx_t r[], ssz_t m, ssz_t n);                       // cmat.ct()
void  mad_cmat_mul     (const cpx_t x[], const cpx_t y[],       cpx_t r[], ssz_t m, ssz_t n, ssz_t p);              // cmat * cmat
void  mad_cmat_mulm    (const cpx_t x[], const num_t y[],       cpx_t r[], ssz_t m, ssz_t n, ssz_t p);              // cmat *  mat
void  mad_cmat_tmul    (const cpx_t x[], const cpx_t y[],       cpx_t r[], ssz_t m, ssz_t n, ssz_t p);              // cmat'* cmat
void  mad_cmat_tmulm   (const cpx_t x[], const num_t y[],       cpx_t r[], ssz_t m, ssz_t n, ssz_t p);              // cmat'*  mat
void  mad_cmat_mult    (const cpx_t x[], const cpx_t y[],       cpx_t r[], ssz_t m, ssz_t n, ssz_t p);              // cmat * cmat'
void  mad_cmat_multm   (const cpx_t x[], const num_t y[],       cpx_t r[], ssz_t m, ssz_t n, ssz_t p);              // cmat *  mat'
void  mad_cmat_dmul    (const cpx_t x[], const cpx_t y[],       cpx_t r[], ssz_t m, ssz_t n, ssz_t p);              // diag(cmat) * cmat
void  mad_cmat_dmulm   (const cpx_t x[], const num_t y[],       cpx_t r[], ssz_t m, ssz_t n, ssz_t p);              // diag(cmat) *  mat
void  mad_cmat_muld    (const cpx_t x[], const cpx_t y[],       cpx_t r[], ssz_t m, ssz_t n, ssz_t p);              // cmat * diag(cmat)
void  mad_cmat_muldm   (const cpx_t x[], const num_t y[],       cpx_t r[], ssz_t m, ssz_t n, ssz_t p);              // cmat * diag( mat)
int   mad_cmat_det     (const cpx_t x[],                        cpx_t *r ,          ssz_t n);                       // det(cmat)
int   mad_cmat_invn    (const cpx_t y[],       num_t x  ,       cpx_t r[], ssz_t m, ssz_t n,          num_t rcond); // num  / cmat
int   mad_cmat_invc_r  (const cpx_t y[], num_t x_re,num_t x_im, cpx_t r[], ssz_t m, ssz_t n,          num_t rcond); // cpx  / cmat
int   mad_cmat_pinvn   (const cpx_t y[],       num_t x  ,       cpx_t r[], ssz_t m, ssz_t n,          num_t rcond, int ncond); //  num  / cmat (pseudo-inverse)
int   mad_cmat_pinvc_r (const cpx_t y[], num_t x_re,num_t x_im, cpx_t r[], ssz_t m, ssz_t n,          num_t rcond, int ncond); //  cpx  / cmat
int   mad_cmat_div     (const cpx_t x[], const cpx_t y[],       cpx_t r[], ssz_t m, ssz_t n, ssz_t p, num_t rcond); // cmat / cmat
int   mad_cmat_divm    (const cpx_t x[], const num_t y[],       cpx_t r[], ssz_t m, ssz_t n, ssz_t p, num_t rcond); // cmat /  mat
int   mad_cmat_solve   (const cpx_t a[], const cpx_t b[],       cpx_t x[], ssz_t m, ssz_t n, ssz_t p, num_t rcond); // min|b-ax| (QR)
int   mad_cmat_ssolve  (const cpx_t a[], const cpx_t b[],       cpx_t x[], ssz_t m, ssz_t n, ssz_t p, num_t rcond, int ncond, num_t s_[]); // min|b-ax| (SVD)
int   mad_cmat_gsolve  (const cpx_t a[], const cpx_t b[], const cpx_t c[], const  cpx_t d[],
                                                                cpx_t x[], ssz_t m, ssz_t n, ssz_t p, num_t *nrm_);
int   mad_cmat_gmsolve (const cpx_t a[], const cpx_t b[], const cpx_t d[],
                                               cpx_t x[],       cpx_t y[], ssz_t m, ssz_t n, ssz_t p);
int   mad_cmat_pcacnd  (const cpx_t a[],       idx_t c[],                  ssz_t m, ssz_t n, ssz_t N, num_t cut, num_t s_[]);
int   mad_cmat_svdcnd  (const cpx_t a[],       idx_t c[],                  ssz_t m, ssz_t n, ssz_t N, num_t cut, num_t s_[], num_t tol);
int   mad_cmat_svd     (const cpx_t x[], cpx_t u[], num_t s[],  cpx_t v[], ssz_t m, ssz_t n);                       // u * s * v.t
int   mad_cmat_eigen   (const cpx_t x[], cpx_t w[], cpx_t vl[], cpx_t vr[],         ssz_t n);                       // w, vl, vr
void  mad_cmat_fft     (const cpx_t x[],                        cpx_t r[], ssz_t m, ssz_t n);                       // cmat ->cmat
void  mad_cmat_nfft    (const cpx_t x[], const num_t x_node[],  cpx_t r[], ssz_t m, ssz_t n, ssz_t nr);
void  mad_cmat_ifft    (const cpx_t x[],                        cpx_t r[], ssz_t m, ssz_t n);                       // cmat ->cmat
void  mad_cmat_irfft   (const cpx_t x[],                        num_t r[], ssz_t m, ssz_t n);                       // cmat -> mat
void  mad_cmat_infft   (const cpx_t x[], const num_t r_node[],  cpx_t r[], ssz_t m, ssz_t n, ssz_t nx);
void  mad_cmat_sympconj(const cpx_t x[],                        cpx_t r[],          ssz_t n);                       // -J M' J
num_t mad_cmat_symperr (const cpx_t x[],                        cpx_t r[],          ssz_t n, num_t *tol_);          // M' J M - J

void  mad_imat_rev     (      idx_t x[],                                   ssz_t m, ssz_t n, int d);                // imat->rev(imat)
void  mad_imat_roll    (      idx_t x[],                                   ssz_t m, ssz_t n, int mroll, int nroll); // imat->imat
void  mad_imat_eye     (      idx_t x[],                        idx_t v  , ssz_t m, ssz_t n, ssz_t ldx);            // imat->imat
void  mad_imat_copy    (const idx_t x[],                        idx_t r[], ssz_t m, ssz_t n, ssz_t ldx, ssz_t ldr); // imat->imat
void  mad_imat_copym   (const idx_t x[],                        num_t r[], ssz_t m, ssz_t n, ssz_t ldx, ssz_t ldr); // imat-> mat
void  mad_imat_trans   (const idx_t x[],                        idx_t r[], ssz_t m, ssz_t n);                       // imat->imat

// global fft cleanup
void  mad_fft_cleanup  (void);

// 3D geometry --

// rotations
void  mad_mat_rot      (      num_t x[], num_t a);  // R
void  mad_mat_rotx     (      num_t x[], num_t ax); // Rx
void  mad_mat_roty     (      num_t x[], num_t ay); // Ry
void  mad_mat_rotz     (      num_t x[], num_t az); // Rz
void  mad_mat_rotxy    (      num_t x[], num_t ax, num_t ay, log_t inv); // Ry.Rx
void  mad_mat_rotxz    (      num_t x[], num_t ax, num_t az, log_t inv); // Rz.Rx
void  mad_mat_rotyz    (      num_t x[], num_t ay, num_t az, log_t inv); // Rz.Ry
void  mad_mat_rotxyz   (      num_t x[], num_t ax, num_t ay, num_t az, log_t inv); // Rz.Ry.Rx
void  mad_mat_rotxzy   (      num_t x[], num_t ax, num_t ay, num_t az, log_t inv); // Ry.Rz.Rx
void  mad_mat_rotyxz   (      num_t x[], num_t ax, num_t ay, num_t az, log_t inv); // Rz.Rx.Ry
void  mad_mat_torotxyz (const num_t x[], num_t r[]                   , log_t inv); // ax, ay, az from rotxyz
void  mad_mat_torotxzy (const num_t x[], num_t r[]                   , log_t inv); // ax, ay, az from rotxzy
void  mad_mat_torotyxz (const num_t x[], num_t r[]                   , log_t inv); // ax, ay, az from rotyxz

// vector
void  mad_mat_rotv     (      num_t x[], const num_t v [], num_t a, log_t inv); // Rv
num_t mad_mat_torotv   (const num_t x[],       num_t v_[]         , log_t inv); // av from rotv

// quaternion
void  mad_mat_rotq     (      num_t x[], const num_t q[], log_t inv);
void  mad_mat_torotq   (const num_t x[],       num_t q[], log_t inv);

// misalignments
void  mad_mat_rtbar    (      num_t Rb[],       num_t Tb[], num_t el, num_t ang, num_t tlt,
                        const num_t R_[], const num_t T []);

// unsafe functions, assume that matrices reshaped sizes are valid (no check!).
void  mad_mat_reshape  (struct  matrix_ *x, ssz_t m, ssz_t n);
void  mad_cmat_reshape (struct cmatrix_ *x, ssz_t m, ssz_t n);
void  mad_imat_reshape (struct imatrix_ *x, ssz_t m, ssz_t n);

// special flag
extern int mad_use_madx_micado;
extern int mad_use_madx_svdcnd;
]]

-- functions for polygons (mad_poly.h)

cdef [[
// polygon contains a point? (winding number algo)
log_t mad_pol_inside(num_t px, num_t py, ssz_t n, const num_t vx[], const num_t vy[]);
]]

-- functions for monomials (mad_mono.h)

cdef [[
typedef unsigned char ord_t; // mad_mono.h

ssz_t mad_mono_str  (ssz_t n,       ord_t a[], str_t s);  // from string
str_t mad_mono_prt  (ssz_t n, const ord_t a[], char s[]); // to   string

void  mad_mono_fill (ssz_t n,       ord_t a[], ord_t v);
void  mad_mono_copy (ssz_t n, const ord_t a[], ord_t r[]);

ord_t mad_mono_min  (ssz_t n, const ord_t a[]);
ord_t mad_mono_max  (ssz_t n, const ord_t a[]);
int   mad_mono_ord  (ssz_t n, const ord_t a[]);
num_t mad_mono_ordp (ssz_t n, const ord_t a[], idx_t stp);
num_t mad_mono_ordpf(ssz_t n, const ord_t a[], idx_t stp);

log_t mad_mono_eq   (ssz_t n, const ord_t a[], const ord_t b[]);
log_t mad_mono_lt   (ssz_t n, const ord_t a[], const ord_t b[]);
log_t mad_mono_le   (ssz_t n, const ord_t a[], const ord_t b[]);

int   mad_mono_cmp  (ssz_t n, const ord_t a[], const ord_t b[]);
int   mad_mono_rcmp (ssz_t n, const ord_t a[], const ord_t b[]);

void  mad_mono_add  (ssz_t n, const ord_t a[], const ord_t b[], ord_t r[]);
void  mad_mono_sub  (ssz_t n, const ord_t a[], const ord_t b[], ord_t r[]);
void  mad_mono_cat  (ssz_t n, const ord_t a[], ssz_t m, const ord_t b[], ord_t r[]);
void  mad_mono_rev  (ssz_t n, const ord_t a[], ord_t r[]);

void  mad_mono_print(ssz_t n, const ord_t a[], FILE *fp_);
]]

-- functions for GTPSA descriptors (mad_desc.h)

cdef [[
// types
typedef struct desc_ desc_t;  // mad_desc.h, mad_[c]tpsa.h, mad_mono.h

// globals
extern const ord_t   mad_tpsa_dflt;
extern const ord_t   mad_tpsa_same;
extern       num_t   mad_tpsa_eps;  // consider coef < eps as zero for dflt eps
extern       int     mad_tpsa_dbgf; // effective only with TPSA_DEBUG > 0
extern       int     mad_tpsa_dbga; // effective only with TPSA_DEBUG > 0
extern const desc_t *mad_desc_curr;

// ctors (warning: unique descriptor per structure/input)
const desc_t* mad_desc_newv  (int nv, ord_t mo);
const desc_t* mad_desc_newvp (int nv, ord_t mo, int np_, ord_t po_);
const desc_t* mad_desc_newvpo(int nv, ord_t mo, int np_, ord_t po_, const ord_t no_[]);

// dtor (warning: no GTSPA must still be in use!)
void  mad_desc_del (const desc_t *d_); // delete all registered desc if d_=null

// introspection
int   mad_desc_getnv  (const desc_t *d, ord_t *mo_, int *np_, ord_t *po_); // return nv
ord_t mad_desc_maxord (const desc_t *d, int nn, ord_t no_[]); // return mo
ssz_t mad_desc_maxlen (const desc_t *d, ord_t mo);

// -- indexes / monomials
log_t mad_desc_isvalids  (const desc_t *d,          ssz_t n,       str_t s   );
log_t mad_desc_isvalidm  (const desc_t *d,          ssz_t n, const ord_t m []);
log_t mad_desc_isvalidsm (const desc_t *d,          ssz_t n, const idx_t m []);
idx_t mad_desc_idxs      (const desc_t *d,          ssz_t n,       str_t s   );
idx_t mad_desc_idxm      (const desc_t *d,          ssz_t n, const ord_t m []);
idx_t mad_desc_idxsm     (const desc_t *d,          ssz_t n, const idx_t m []);
idx_t mad_desc_nxtbyvar  (const desc_t *d,          ssz_t n,       ord_t m []);
idx_t mad_desc_nxtbyord  (const desc_t *d,          ssz_t n,       ord_t m []);
ord_t mad_desc_mono      (const desc_t *d, idx_t i, ssz_t n,       ord_t m_[], ord_t *p_);

// debug
void  mad_desc_info      (const desc_t *d, FILE *fp_);
]]

-- functions for GTPSAs real (mad_tpsa.h)

cdef [[
// types
typedef struct tpsa_ tpsa_t;  // mad_tpsa.h, mad_desc.h, mad_mono.h, mad_bit.h

// ctors, dtor, shape
tpsa_t* mad_tpsa_newd    (const desc_t *d, ord_t mo); // if mo > d_mo, mo = d_mo
tpsa_t* mad_tpsa_new     (const tpsa_t *t, ord_t mo); // ok with t=(tpsa_t*)ctpsa
void    mad_tpsa_del     (const tpsa_t *t);

// introspection
const
desc_t* mad_tpsa_desc    (const tpsa_t *t);
ssz_t   mad_tpsa_len     (const tpsa_t *t);
ord_t   mad_tpsa_mo      (      tpsa_t *t, ord_t   mo_ ); // set mo if mo <= ao
int32_t mad_tpsa_uid     (      tpsa_t *t, int32_t uid_); // set uid if != 0
str_t   mad_tpsa_nam     (      tpsa_t *t, str_t   nam_); // set nam if != null
ord_t   mad_tpsa_ord     (const tpsa_t *t, log_t   hi_ ); // mo or hi
log_t   mad_tpsa_isnul   (const tpsa_t *t);
log_t   mad_tpsa_isvalid (const tpsa_t *t);
num_t   mad_tpsa_density (const tpsa_t *t, num_t eps); // ratio nz/nc in [lo,hi]

// initialization / manipulation
void    mad_tpsa_copy    (const tpsa_t *t, tpsa_t *r);
void    mad_tpsa_convert (const tpsa_t *t, tpsa_t *r, ssz_t n, idx_t t2r_[], int pb);
idx_t   mad_tpsa_maxord  (const tpsa_t *t,            ssz_t n, idx_t idx_[]);
void    mad_tpsa_sclord  (const tpsa_t *t, tpsa_t *r, log_t inv, log_t prm); // t[i]*o[i]
void    mad_tpsa_getord  (const tpsa_t *t, tpsa_t *r, ord_t ord);
void    mad_tpsa_cutord  (const tpsa_t *t, tpsa_t *r, int   ord); // ord..mo = 0 or 0..-ord=0
void    mad_tpsa_clrord  (      tpsa_t *t, ord_t ord);
void    mad_tpsa_setvar  (      tpsa_t *t, num_t v, idx_t iv, num_t scl_);
void    mad_tpsa_setprm  (      tpsa_t *t, num_t v, idx_t ip);
void    mad_tpsa_setval  (      tpsa_t *t, num_t v);
void    mad_tpsa_update  (      tpsa_t *t);
void    mad_tpsa_clear   (      tpsa_t *t);

// indexing / monomials (return idx_t = -1 if invalid)
ord_t   mad_tpsa_mono    (const tpsa_t *t, idx_t i, ssz_t n,       ord_t m_[], ord_t *p_);
idx_t   mad_tpsa_idxs    (const tpsa_t *t,          ssz_t n,       str_t s   ); // string mono "[0-9]*"
idx_t   mad_tpsa_idxm    (const tpsa_t *t,          ssz_t n, const ord_t m []);
idx_t   mad_tpsa_idxsm   (const tpsa_t *t,          ssz_t n, const idx_t m []); // sparse mono [(i,o)]
idx_t   mad_tpsa_cycle   (const tpsa_t *t, idx_t i, ssz_t n,       ord_t m_[], num_t *v_);

// accessors
num_t   mad_tpsa_get0    (const tpsa_t *t);
num_t   mad_tpsa_geti    (const tpsa_t *t, idx_t i);
num_t   mad_tpsa_gets    (const tpsa_t *t, ssz_t n,       str_t s  ); // string mono "[0-9]*"
num_t   mad_tpsa_getm    (const tpsa_t *t, ssz_t n, const ord_t m[]);
num_t   mad_tpsa_getsm   (const tpsa_t *t, ssz_t n, const idx_t m[]); // sparse mono [(i,o)]
void    mad_tpsa_set0    (      tpsa_t *t, /* i = 0 */               num_t a, num_t b);
void    mad_tpsa_seti    (      tpsa_t *t, idx_t i,                  num_t a, num_t b);
void    mad_tpsa_sets    (      tpsa_t *t, ssz_t n,       str_t s  , num_t a, num_t b);
void    mad_tpsa_setm    (      tpsa_t *t, ssz_t n, const ord_t m[], num_t a, num_t b);
void    mad_tpsa_setsm   (      tpsa_t *t, ssz_t n, const idx_t m[], num_t a, num_t b);
void    mad_tpsa_cpy0    (const tpsa_t *t, tpsa_t *r);
void    mad_tpsa_cpyi    (const tpsa_t *t, tpsa_t *r,          idx_t i);
void    mad_tpsa_cpys    (const tpsa_t *t, tpsa_t *r, ssz_t n, str_t s); // string mono "[0-9]*"
void    mad_tpsa_cpym    (const tpsa_t *t, tpsa_t *r, ssz_t n, const ord_t m[]);
void    mad_tpsa_cpysm   (const tpsa_t *t, tpsa_t *r, ssz_t n, const idx_t m[]); // sparse mono [(i,o)]

// accessors vector based
void    mad_tpsa_getv    (const tpsa_t *t, idx_t i, ssz_t n,       num_t v[]);
void    mad_tpsa_setv    (      tpsa_t *t, idx_t i, ssz_t n, const num_t v[]);

// operators
log_t   mad_tpsa_equ     (const tpsa_t *a, const tpsa_t *b, num_t tol_);
void    mad_tpsa_dif     (const tpsa_t *a, const tpsa_t *b, tpsa_t *c); // (a_i-b_i)/max(|a_i|,1)
void    mad_tpsa_add     (const tpsa_t *a, const tpsa_t *b, tpsa_t *c);
void    mad_tpsa_sub     (const tpsa_t *a, const tpsa_t *b, tpsa_t *c);
void    mad_tpsa_mul     (const tpsa_t *a, const tpsa_t *b, tpsa_t *c);
void    mad_tpsa_div     (const tpsa_t *a, const tpsa_t *b, tpsa_t *c);
void    mad_tpsa_pow     (const tpsa_t *a, const tpsa_t *b, tpsa_t *c);
void    mad_tpsa_powi    (const tpsa_t *a, int           n, tpsa_t *c);
void    mad_tpsa_pown    (const tpsa_t *a, num_t         v, tpsa_t *c);

// functions
num_t   mad_tpsa_nrm     (const tpsa_t *a);
void    mad_tpsa_abs     (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_sqrt    (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_exp     (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_log     (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_sincos  (const tpsa_t *a, tpsa_t *s, tpsa_t *c);
void    mad_tpsa_sin     (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_cos     (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_tan     (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_cot     (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_sinc    (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_sincosh (const tpsa_t *a, tpsa_t *s, tpsa_t *c);
void    mad_tpsa_sinh    (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_cosh    (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_tanh    (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_coth    (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_sinhc   (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_asin    (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_acos    (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_atan    (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_acot    (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_asinc   (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_asinh   (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_acosh   (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_atanh   (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_acoth   (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_asinhc  (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_erf     (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_erfc    (const tpsa_t *a, tpsa_t *c);
void    mad_tpsa_unit    (const tpsa_t *a, tpsa_t *c);

void    mad_tpsa_acc     (const tpsa_t *a, num_t v, tpsa_t *c); // c += v*a, aliasing OK
void    mad_tpsa_scl     (const tpsa_t *a, num_t v, tpsa_t *c); // c  = v*a
void    mad_tpsa_inv     (const tpsa_t *a, num_t v, tpsa_t *c); // c  = v/a
void    mad_tpsa_invsqrt (const tpsa_t *a, num_t v, tpsa_t *c); // c  = v/sqrt(a)

void    mad_tpsa_atan2   (const tpsa_t *y, const tpsa_t *x, tpsa_t *r);
void    mad_tpsa_hypot   (const tpsa_t *x, const tpsa_t *y, tpsa_t *r);
void    mad_tpsa_hypot3  (const tpsa_t *x, const tpsa_t *y, const tpsa_t *z, tpsa_t *r);

// functions for differential algebra
void    mad_tpsa_integ   (const tpsa_t *a, tpsa_t *c, idx_t iv);
void    mad_tpsa_deriv   (const tpsa_t *a, tpsa_t *c, idx_t iv);
void    mad_tpsa_derivm  (const tpsa_t *a, tpsa_t *c, ssz_t n, const ord_t m[]);
void    mad_tpsa_poisbra (const tpsa_t *a, const tpsa_t *b, tpsa_t *c, int nv);
void    mad_tpsa_taylor  (const tpsa_t *a, ssz_t n, const num_t coef[], tpsa_t *c);

// high level functions
void    mad_tpsa_axpb       (num_t a, const tpsa_t *x,
                             num_t b, tpsa_t *r);
void    mad_tpsa_axpbypc    (num_t a, const tpsa_t *x,
                             num_t b, const tpsa_t *y,
                             num_t c, tpsa_t *r);
void    mad_tpsa_axypb      (num_t a, const tpsa_t *x, const tpsa_t *y,
                             num_t b, tpsa_t *r);
void    mad_tpsa_axypbzpc   (num_t a, const tpsa_t *x, const tpsa_t *y,
                             num_t b, const tpsa_t *z,
                             num_t c, tpsa_t *r);
void    mad_tpsa_axypbvwpc  (num_t a, const tpsa_t *x, const tpsa_t *y,
                             num_t b, const tpsa_t *v, const tpsa_t *w,
                             num_t c, tpsa_t *r);
void    mad_tpsa_ax2pby2pcz2(num_t a, const tpsa_t *x,
                             num_t b, const tpsa_t *y,
                             num_t c, const tpsa_t *z, tpsa_t *r);

void    mad_tpsa_axpsqrtbpcx2    (const tpsa_t *x, num_t a, num_t b, num_t c, tpsa_t *r);
void    mad_tpsa_logaxpsqrtbpcx2 (const tpsa_t *x, num_t a, num_t b, num_t c, tpsa_t *r);
void    mad_tpsa_logxdy          (const tpsa_t *x, const tpsa_t *y, tpsa_t *r);

// map functions
void    mad_tpsa_vec2fld  (ssz_t na, const tpsa_t *a   ,                     tpsa_t *mc[]);
void    mad_tpsa_fld2vec  (ssz_t na, const tpsa_t *ma[],                     tpsa_t *c   );
void    mad_tpsa_fgrad    (ssz_t na, const tpsa_t *ma[], const tpsa_t * b  , tpsa_t *c   );
void    mad_tpsa_liebra   (ssz_t na, const tpsa_t *ma[], const tpsa_t *mb[], tpsa_t *mc[]);
void    mad_tpsa_exppb    (ssz_t na, const tpsa_t *ma[], const tpsa_t *mb[], tpsa_t *mc[]); // exp(:F:) K
void    mad_tpsa_logpb    (ssz_t na, const tpsa_t *ma[], const tpsa_t *mb[], tpsa_t *mc[]); // exp(log(:F:))K

ord_t   mad_tpsa_mord     (ssz_t na, const tpsa_t *ma[], log_t hi); // max mo (or max hi)
num_t   mad_tpsa_mnrm     (ssz_t na, const tpsa_t *ma[]);
void    mad_tpsa_minv     (ssz_t na, const tpsa_t *ma[], ssz_t nb,                     tpsa_t *mc[]);
void    mad_tpsa_pminv    (ssz_t na, const tpsa_t *ma[], ssz_t nb,                     tpsa_t *mc[], idx_t select[]);
void    mad_tpsa_compose  (ssz_t na, const tpsa_t *ma[], ssz_t nb, const tpsa_t *mb[], tpsa_t *mc[]);
void    mad_tpsa_translate(ssz_t na, const tpsa_t *ma[], ssz_t nb, const num_t   tb[], tpsa_t *mc[]);
void    mad_tpsa_eval     (ssz_t na, const tpsa_t *ma[], ssz_t nb, const num_t   tb[], num_t   tc[]);
void    mad_tpsa_mconv    (ssz_t na, const tpsa_t *ma[], ssz_t nc,                     tpsa_t *mc[], ssz_t n, idx_t t2r_[], int pb);

// I/O
void    mad_tpsa_print    (const tpsa_t *t, str_t name_, num_t eps_, int nohdr_, FILE *stream_);
tpsa_t* mad_tpsa_scan     (                                                      FILE *stream_);
const
desc_t* mad_tpsa_scan_hdr (     int *kind_, char  name_[],                       FILE *stream_);
void    mad_tpsa_scan_coef(      tpsa_t *t,                                      FILE *stream_);

// unsafe operation (mo vs allocated!!)
tpsa_t* mad_tpsa_init     (      tpsa_t *t, const desc_t *d, ord_t mo);

// debug
int     mad_tpsa_debug    (const tpsa_t *t, str_t name_, str_t fnam_, int line_, FILE *stream_);
void    mad_tpsa_prtdensity (FILE *stream_);
void    mad_tpsa_clrdensity (void);
]]

-- functions for GTPSAs complex (mad_ctpsa.h)

cdef [[
// types
typedef struct ctpsa_ ctpsa_t; // mad_ctpsa.h, mad_desc.h, mad_mono.h, mad_bit.h

// ctors, dtor
ctpsa_t* mad_ctpsa_newd    (const  desc_t *d, ord_t mo); // if mo > d_mo, mo = d_mo
ctpsa_t* mad_ctpsa_new     (const ctpsa_t *t, ord_t mo); // ok with t=(ctpsa_t*)tpsa
void     mad_ctpsa_del     (const ctpsa_t *t);

// introspection
const
desc_t*  mad_ctpsa_desc    (const ctpsa_t *t);
ssz_t    mad_ctpsa_len     (const ctpsa_t *t);
ord_t    mad_ctpsa_mo      (      ctpsa_t *t, ord_t   mo_ ); // set mo if mo <= ao
int32_t  mad_ctpsa_uid     (      ctpsa_t *t, int32_t uid_); // set uid if != 0
str_t    mad_ctpsa_nam     (      ctpsa_t *t, str_t   nam_); // set nam if != null
ord_t    mad_ctpsa_ord     (const ctpsa_t *t, log_t   hi_ ); // mo or hi
log_t    mad_ctpsa_isnul   (const ctpsa_t *t);
log_t    mad_ctpsa_isvalid (const ctpsa_t *t);
num_t    mad_ctpsa_density (const ctpsa_t *t, num_t eps); // ratio nz/nc in [lo,hi]

// initialization / manipulation
void     mad_ctpsa_copy    (const ctpsa_t *t, ctpsa_t *r);
void     mad_ctpsa_convert (const ctpsa_t *t, ctpsa_t *r, ssz_t n, idx_t t2r_[], int pb);
idx_t    mad_ctpsa_maxord  (const ctpsa_t *t,             ssz_t n, idx_t idx_[]);
void     mad_ctpsa_sclord  (const ctpsa_t *t, ctpsa_t *r, log_t inv, log_t prm); // t[i]*o[i]
void     mad_ctpsa_getord  (const ctpsa_t *t, ctpsa_t *r, ord_t ord);
void     mad_ctpsa_cutord  (const ctpsa_t *t, ctpsa_t *r, int   ord); // ord..mo = 0 or 0..-ord=0
void     mad_ctpsa_clrord  (      ctpsa_t *t, ord_t ord);
void     mad_ctpsa_update  (      ctpsa_t *t);
void     mad_ctpsa_clear   (      ctpsa_t *t);

// initialization without complex-by-value
void     mad_ctpsa_setvar_r(      ctpsa_t *t, num_t v_re, num_t v_im, idx_t iv, num_t scl_re_, num_t scl_im_);
void     mad_ctpsa_setprm_r(      ctpsa_t *t, num_t v_re, num_t v_im, idx_t ip);
void     mad_ctpsa_setval_r(      ctpsa_t *t, num_t v_re, num_t v_im);

// real, imaginary, norm, phase, conversion
void     mad_ctpsa_cplx    (const  tpsa_t *re_, const tpsa_t *im_, ctpsa_t *r);
void     mad_ctpsa_real    (const ctpsa_t *t,  tpsa_t *r);
void     mad_ctpsa_imag    (const ctpsa_t *t,  tpsa_t *r);
void     mad_ctpsa_cabs    (const ctpsa_t *t,  tpsa_t *r);
void     mad_ctpsa_carg    (const ctpsa_t *t,  tpsa_t *r);
void     mad_ctpsa_rect    (const ctpsa_t *t, ctpsa_t *r);
void     mad_ctpsa_polar   (const ctpsa_t *t, ctpsa_t *r);

// indexing / monomials (return idx_t = -1 if invalid)
ord_t    mad_ctpsa_mono    (const ctpsa_t *t, idx_t i, ssz_t n,       ord_t m_[], ord_t *p_);
idx_t    mad_ctpsa_idxs    (const ctpsa_t *t,          ssz_t n,       str_t s   ); // string mono "[0-9]*"
idx_t    mad_ctpsa_idxm    (const ctpsa_t *t,          ssz_t n, const ord_t m []);
idx_t    mad_ctpsa_idxsm   (const ctpsa_t *t,          ssz_t n, const idx_t m []); // sparse mono [(i,o)]
idx_t    mad_ctpsa_cycle   (const ctpsa_t *t, idx_t i, ssz_t n,       ord_t m_[], cpx_t *v_);

// indexing / monomials to tpsa
void     mad_ctpsa_cpy0    (const ctpsa_t *t, ctpsa_t *r);
void     mad_ctpsa_cpyi    (const ctpsa_t *t, ctpsa_t *r,          idx_t i);
void     mad_ctpsa_cpys    (const ctpsa_t *t, ctpsa_t *r, ssz_t n, str_t s); // string mono "[0-9]*"
void     mad_ctpsa_cpym    (const ctpsa_t *t, ctpsa_t *r, ssz_t n, const ord_t m[]);
void     mad_ctpsa_cpysm   (const ctpsa_t *t, ctpsa_t *r, ssz_t n, const idx_t m[]); // sparse mono [(i,o)]

// accessors without complex-by-value
void     mad_ctpsa_get0_r  (const ctpsa_t *t, cpx_t *r);
void     mad_ctpsa_geti_r  (const ctpsa_t *t, idx_t i, cpx_t *r);
void     mad_ctpsa_gets_r  (const ctpsa_t *t, ssz_t n,       str_t s  , cpx_t *r);
void     mad_ctpsa_getm_r  (const ctpsa_t *t, ssz_t n, const ord_t m[], cpx_t *r);
void     mad_ctpsa_getsm_r (const ctpsa_t *t, ssz_t n, const idx_t m[], cpx_t *r);
void     mad_ctpsa_set0_r  (      ctpsa_t *t, /* i = 0 */               num_t a_re, num_t a_im, num_t b_re, num_t b_im);
void     mad_ctpsa_seti_r  (      ctpsa_t *t, idx_t i,                  num_t a_re, num_t a_im, num_t b_re, num_t b_im);
void     mad_ctpsa_sets_r  (      ctpsa_t *t, ssz_t n,       str_t s  , num_t a_re, num_t a_im, num_t b_re, num_t b_im);
void     mad_ctpsa_setm_r  (      ctpsa_t *t, ssz_t n, const ord_t m[], num_t a_re, num_t a_im, num_t b_re, num_t b_im);
void     mad_ctpsa_setsm_r (      ctpsa_t *t, ssz_t n, const idx_t m[], num_t a_re, num_t a_im, num_t b_re, num_t b_im);

// accessors vector based
void     mad_ctpsa_getv    (const ctpsa_t *t, idx_t i, ssz_t n,       cpx_t v[]); // return copied length
void     mad_ctpsa_setv    (      ctpsa_t *t, idx_t i, ssz_t n, const cpx_t v[]); // return copied length

// operators
log_t mad_ctpsa_equ        (const ctpsa_t *a, const ctpsa_t *b,       num_t tol_);
void  mad_ctpsa_dif        (const ctpsa_t *a, const ctpsa_t *b,       ctpsa_t *c); // (a_i-b_i)/max(|a_i|,1)
void  mad_ctpsa_add        (const ctpsa_t *a, const ctpsa_t *b,       ctpsa_t *c);
void  mad_ctpsa_sub        (const ctpsa_t *a, const ctpsa_t *b,       ctpsa_t *c);
void  mad_ctpsa_mul        (const ctpsa_t *a, const ctpsa_t *b,       ctpsa_t *c);
void  mad_ctpsa_div        (const ctpsa_t *a, const ctpsa_t *b,       ctpsa_t *c);
void  mad_ctpsa_pow        (const ctpsa_t *a, const ctpsa_t *b,       ctpsa_t *c);
void  mad_ctpsa_powi       (const ctpsa_t *a, int            n,       ctpsa_t *c);

// operators without complex-by-value
void  mad_ctpsa_pown_r     (const ctpsa_t *a, num_t v_re, num_t v_im, ctpsa_t *c);

// operators with internal real-to-complex conversion
log_t mad_ctpsa_equt    (const ctpsa_t *a, const  tpsa_t *b, num_t tol_);
void  mad_ctpsa_dift    (const ctpsa_t *a, const  tpsa_t *b, ctpsa_t *c);
void  mad_ctpsa_tdif    (const  tpsa_t *a, const ctpsa_t *b, ctpsa_t *c);
void  mad_ctpsa_addt    (const ctpsa_t *a, const  tpsa_t *b, ctpsa_t *c);
void  mad_ctpsa_subt    (const ctpsa_t *a, const  tpsa_t *b, ctpsa_t *c);
void  mad_ctpsa_tsub    (const  tpsa_t *a, const ctpsa_t *b, ctpsa_t *c);
void  mad_ctpsa_mult    (const ctpsa_t *a, const  tpsa_t *b, ctpsa_t *c);
void  mad_ctpsa_divt    (const ctpsa_t *a, const  tpsa_t *b, ctpsa_t *c);
void  mad_ctpsa_tdiv    (const  tpsa_t *a, const ctpsa_t *b, ctpsa_t *c);
void  mad_ctpsa_powt    (const ctpsa_t *a, const  tpsa_t *b, ctpsa_t *c);
void  mad_ctpsa_tpow    (const  tpsa_t *a, const ctpsa_t *b, ctpsa_t *c);

// functions
num_t mad_ctpsa_nrm     (const ctpsa_t *a);
void  mad_ctpsa_unit    (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_conj    (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_sqrt    (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_exp     (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_log     (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_sincos  (const ctpsa_t *a, ctpsa_t *s, ctpsa_t *c);
void  mad_ctpsa_sin     (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_cos     (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_tan     (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_cot     (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_sinc    (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_sincosh (const ctpsa_t *a, ctpsa_t *s, ctpsa_t *c);
void  mad_ctpsa_sinh    (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_cosh    (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_tanh    (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_coth    (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_sinhc   (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_asin    (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_acos    (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_atan    (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_acot    (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_asinc   (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_asinh   (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_acosh   (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_atanh   (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_acoth   (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_asinhc  (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_erf     (const ctpsa_t *a, ctpsa_t *c);
void  mad_ctpsa_erfc    (const ctpsa_t *a, ctpsa_t *c);

void  mad_ctpsa_hypot   (const ctpsa_t *x, const ctpsa_t *y, ctpsa_t *r);
void  mad_ctpsa_hypot3  (const ctpsa_t *x, const ctpsa_t *y, const ctpsa_t *z, ctpsa_t *r);

// functions without complex-by-value
void  mad_ctpsa_acc_r    (const ctpsa_t *a, num_t v_re, num_t v_im, ctpsa_t *c);
void  mad_ctpsa_scl_r    (const ctpsa_t *a, num_t v_re, num_t v_im, ctpsa_t *c);
void  mad_ctpsa_inv_r    (const ctpsa_t *a, num_t v_re, num_t v_im, ctpsa_t *c);
void  mad_ctpsa_invsqrt_r(const ctpsa_t *a, num_t v_re, num_t v_im, ctpsa_t *c);

// functions for differential algebra
void  mad_ctpsa_integ   (const ctpsa_t *a, ctpsa_t *c, idx_t iv);
void  mad_ctpsa_deriv   (const ctpsa_t *a, ctpsa_t *c, idx_t iv);
void  mad_ctpsa_derivm  (const ctpsa_t *a, ctpsa_t *c, ssz_t n, const ord_t m[]);
void  mad_ctpsa_poisbra (const ctpsa_t *a, const ctpsa_t *b, ctpsa_t *c, int nv);
void  mad_ctpsa_taylor  (const ctpsa_t *a, ssz_t n, const cpx_t coef[], ctpsa_t *c);

// functions for differential algebra with internal real-to-complex conversion
void  mad_ctpsa_poisbrat(const ctpsa_t *a, const  tpsa_t *b, ctpsa_t *c, int nv);
void  mad_ctpsa_tpoisbra(const  tpsa_t *a, const ctpsa_t *b, ctpsa_t *c, int nv);

// high level functions without complex-by-value
void mad_ctpsa_axpb_r        (num_t a_re, num_t a_im, const ctpsa_t *x,
                              num_t b_re, num_t b_im, ctpsa_t *r);
void mad_ctpsa_axpbypc_r     (num_t a_re, num_t a_im, const ctpsa_t *x,
                              num_t b_re, num_t b_im, const ctpsa_t *y,
                              num_t c_re, num_t c_im, ctpsa_t *r);
void mad_ctpsa_axypb_r       (num_t a_re, num_t a_im, const ctpsa_t *x, const ctpsa_t *y,
                              num_t b_re, num_t b_im, ctpsa_t *r);
void mad_ctpsa_axypbzpc_r    (num_t a_re, num_t a_im, const ctpsa_t *x, const ctpsa_t *y,
                              num_t b_re, num_t b_im, const ctpsa_t *z,
                              num_t c_re, num_t c_im, ctpsa_t *r);
void mad_ctpsa_axypbvwpc_r   (num_t a_re, num_t a_im, const ctpsa_t *x, const ctpsa_t *y,
                              num_t b_re, num_t b_im, const ctpsa_t *v, const ctpsa_t *w,
                              num_t c_re, num_t c_im, ctpsa_t *r);
void mad_ctpsa_ax2pby2pcz2_r (num_t a_re, num_t a_im, const ctpsa_t *x,
                              num_t b_re, num_t b_im, const ctpsa_t *y,
                              num_t c_re, num_t c_im, const ctpsa_t *z, ctpsa_t *r);
void mad_ctpsa_axpsqrtbpcx2_r(const ctpsa_t *x, num_t a_re, num_t a_im, num_t b_re, num_t b_im,
                                                num_t c_re, num_t c_im, ctpsa_t *r);
void mad_ctpsa_logaxpsqrtbpcx2_r(const ctpsa_t *x, num_t a_re, num_t a_im, num_t b_re, num_t b_im,
                                                   num_t c_re, num_t c_im, ctpsa_t *r);
void mad_ctpsa_logxdy         (const ctpsa_t *x, const ctpsa_t *y, ctpsa_t *r);

// map functions
void     mad_ctpsa_vec2fld  (ssz_t na, const ctpsa_t *a   ,                      ctpsa_t *mc[]); // F . grad
void     mad_ctpsa_fld2vec  (ssz_t na, const ctpsa_t *ma[],                      ctpsa_t *c   );
void     mad_ctpsa_fgrad    (ssz_t na, const ctpsa_t *ma[], const ctpsa_t * b  , ctpsa_t *c   );
void     mad_ctpsa_liebra   (ssz_t na, const ctpsa_t *ma[], const ctpsa_t *mb[], ctpsa_t *mc[]);
void     mad_ctpsa_exppb    (ssz_t na, const ctpsa_t *ma[], const ctpsa_t *mb[], ctpsa_t *mc[]); // exp(:F:) K
void     mad_ctpsa_logpb    (ssz_t na, const ctpsa_t *ma[], const ctpsa_t *mb[], ctpsa_t *mc[]); // exp(log(:F:)) K

ord_t    mad_ctpsa_mord     (ssz_t na, const ctpsa_t *ma[], log_t hi); // max mo (or max hi)
num_t    mad_ctpsa_mnrm     (ssz_t na, const ctpsa_t *ma[]);
void     mad_ctpsa_minv     (ssz_t na, const ctpsa_t *ma[], ssz_t nb,                      ctpsa_t *mc[]);
void     mad_ctpsa_pminv    (ssz_t na, const ctpsa_t *ma[], ssz_t nb,                      ctpsa_t *mc[], idx_t select[]);
void     mad_ctpsa_compose  (ssz_t na, const ctpsa_t *ma[], ssz_t nb, const ctpsa_t *mb[], ctpsa_t *mc[]);
void     mad_ctpsa_translate(ssz_t na, const ctpsa_t *ma[], ssz_t nb, const cpx_t    tb[], ctpsa_t *mc[]);
void     mad_ctpsa_eval     (ssz_t na, const ctpsa_t *ma[], ssz_t nb, const cpx_t    tb[], cpx_t    tc[]);
void     mad_ctpsa_mconv    (ssz_t na, const ctpsa_t *ma[], ssz_t nc,                      ctpsa_t *mc[], ssz_t n, idx_t t2r_[], int pb);

// I/O
void     mad_ctpsa_print    (const ctpsa_t *t, str_t name_, num_t eps_, int nohdr_, FILE *stream_);
ctpsa_t* mad_ctpsa_scan     (                                                       FILE *stream_);
const
desc_t*  mad_ctpsa_scan_hdr (      int *kind_, char  name_[],                       FILE *stream_);
void     mad_ctpsa_scan_coef(      ctpsa_t *t,                                      FILE *stream_);

// unsafe operation (mo vs allocated!!)
ctpsa_t* mad_ctpsa_init     (ctpsa_t *t, const desc_t *d, ord_t mo);

// debug
int      mad_ctpsa_debug    (const ctpsa_t *t, str_t name_, str_t fnam_, int line_, FILE *stream_);
]]

-- functions for synchrotron radiation (mad_rad.h)

cdef [[
num_t mad_rad_InvSynFracInt (num_t x); // HBU 2007
]]

-- functions for tracking slice in C/C++

cdef [[
typedef union mflw_ mflw_t;
typedef void (trkfun) (mflw_t*, num_t, int);

// --- interface --------------------------------------------------------------o

// -- track one slice
void mad_trk_slice_dkd (mflw_t *m, num_t lw, trkfun *dft, trkfun *kck, int ord);
void mad_trk_slice_tkt (mflw_t *m, num_t lw, trkfun *dft, trkfun *kck, int ord);
void mad_trk_slice_kmk (mflw_t *m, num_t lw, trkfun *dft, trkfun *kck, int ord);
void mad_trk_slice_tpt (mflw_t *m, num_t lw, trkfun *dft, trkfun *kck, int knd);
void mad_trk_slice_one (mflw_t *m, num_t lw, trkfun *dft_or_kck);

// -- tilt & misalignment
void mad_trk_tilt_r         (mflw_t *m, num_t lw);
void mad_trk_tilt_t         (mflw_t *m, num_t lw);
void mad_trk_tilt_p         (mflw_t *m, num_t lw);

void mad_trk_misalign_r     (mflw_t *m, num_t lw);
void mad_trk_misalign_t     (mflw_t *m, num_t lw);
void mad_trk_misalign_p     (mflw_t *m, num_t lw);

// -- fringe maps
void mad_trk_strex_fringe_r (mflw_t *m, num_t lw);
void mad_trk_curex_fringe_r (mflw_t *m, num_t lw);
void mad_trk_rfcav_fringe_r (mflw_t *m, num_t lw);

void mad_trk_strex_fringe_t (mflw_t *m, num_t lw);
void mad_trk_curex_fringe_t (mflw_t *m, num_t lw);
void mad_trk_rfcav_fringe_t (mflw_t *m, num_t lw);

void mad_trk_strex_fringe_p (mflw_t *m, num_t lw);
void mad_trk_curex_fringe_p (mflw_t *m, num_t lw);
void mad_trk_rfcav_fringe_p (mflw_t *m, num_t lw);

// -- patches
void mad_trk_xrotation_r    (mflw_t *m, num_t lw, int _);
void mad_trk_yrotation_r    (mflw_t *m, num_t lw, int _);
void mad_trk_srotation_r    (mflw_t *m, num_t lw, int _);
void mad_trk_translate_r    (mflw_t *m, num_t lw, int _);
void mad_trk_changeref_r    (mflw_t *m, num_t lw, int _);

void mad_trk_xrotation_t    (mflw_t *m, num_t lw, int _);
void mad_trk_yrotation_t    (mflw_t *m, num_t lw, int _);
void mad_trk_srotation_t    (mflw_t *m, num_t lw, int _);
void mad_trk_translate_t    (mflw_t *m, num_t lw, int _);
void mad_trk_changeref_t    (mflw_t *m, num_t lw, int _);

void mad_trk_xrotation_p    (mflw_t *m, num_t lw, int _);
void mad_trk_yrotation_p    (mflw_t *m, num_t lw, int _);
void mad_trk_srotation_p    (mflw_t *m, num_t lw, int _);
void mad_trk_translate_p    (mflw_t *m, num_t lw, int _);
void mad_trk_changeref_p    (mflw_t *m, num_t lw, int _);

// -- DKD maps
void mad_trk_strex_drift_r  (mflw_t *m, num_t lw, int _);
void mad_trk_strex_kick_r   (mflw_t *m, num_t lw, int _);
void mad_trk_strex_kickhs_r (mflw_t *m, num_t lw, int _);
void mad_trk_curex_drift_r  (mflw_t *m, num_t lw, int _);
void mad_trk_curex_kick_r   (mflw_t *m, num_t lw, int _);

void mad_trk_strex_drift_t  (mflw_t *m, num_t lw, int _);
void mad_trk_strex_kick_t   (mflw_t *m, num_t lw, int _);
void mad_trk_strex_kickhs_t (mflw_t *m, num_t lw, int _);
void mad_trk_curex_drift_t  (mflw_t *m, num_t lw, int _);
void mad_trk_curex_kick_t   (mflw_t *m, num_t lw, int _);

void mad_trk_strex_drift_p  (mflw_t *m, num_t lw, int _);
void mad_trk_strex_kick_p   (mflw_t *m, num_t lw, int _);
void mad_trk_strex_kickhs_p (mflw_t *m, num_t lw, int _);
void mad_trk_curex_drift_p  (mflw_t *m, num_t lw, int _);
void mad_trk_curex_kick_p   (mflw_t *m, num_t lw, int _);

// -- TKT maps
void mad_trk_sbend_thick_r  (mflw_t *m, num_t lw, int _);
void mad_trk_sbend_kick_r   (mflw_t *m, num_t lw, int _);
void mad_trk_rbend_thick_r  (mflw_t *m, num_t lw, int _);
void mad_trk_rbend_kick_r   (mflw_t *m, num_t lw, int _);
void mad_trk_quad_thick_r   (mflw_t *m, num_t lw, int _);
void mad_trk_quad_thicks_r  (mflw_t *m, num_t lw, int _);
void mad_trk_quad_thickh_r  (mflw_t *m, num_t lw, int _);
void mad_trk_quad_kick_r    (mflw_t *m, num_t lw, int _);
void mad_trk_quad_kicks_r   (mflw_t *m, num_t lw, int _);
void mad_trk_quad_kickh_r   (mflw_t *m, num_t lw, int _);
void mad_trk_quad_kick__r   (mflw_t *m, num_t lw, int is);
void mad_trk_quad_kicks__r  (mflw_t *m, num_t lw, int is);
void mad_trk_quad_kickh__r  (mflw_t *m, num_t lw, int is);

void mad_trk_sbend_thick_t  (mflw_t *m, num_t lw, int _);
void mad_trk_sbend_kick_t   (mflw_t *m, num_t lw, int _);
void mad_trk_rbend_thick_t  (mflw_t *m, num_t lw, int _);
void mad_trk_rbend_kick_t   (mflw_t *m, num_t lw, int _);
void mad_trk_quad_thick_t   (mflw_t *m, num_t lw, int _);
void mad_trk_quad_thicks_t  (mflw_t *m, num_t lw, int _);
void mad_trk_quad_thickh_t  (mflw_t *m, num_t lw, int _);
void mad_trk_quad_kick_t    (mflw_t *m, num_t lw, int _);
void mad_trk_quad_kicks_t   (mflw_t *m, num_t lw, int _);
void mad_trk_quad_kickh_t   (mflw_t *m, num_t lw, int _);
void mad_trk_quad_kick__t   (mflw_t *m, num_t lw, int is);
void mad_trk_quad_kicks__t  (mflw_t *m, num_t lw, int is);
void mad_trk_quad_kickh__t  (mflw_t *m, num_t lw, int is);

void mad_trk_sbend_thick_p  (mflw_t *m, num_t lw, int _);
void mad_trk_sbend_kick_p   (mflw_t *m, num_t lw, int _);
void mad_trk_rbend_thick_p  (mflw_t *m, num_t lw, int _);
void mad_trk_rbend_kick_p   (mflw_t *m, num_t lw, int _);
void mad_trk_quad_thick_p   (mflw_t *m, num_t lw, int _);
void mad_trk_quad_thicks_p  (mflw_t *m, num_t lw, int _);
void mad_trk_quad_thickh_p  (mflw_t *m, num_t lw, int _);
void mad_trk_quad_kick_p    (mflw_t *m, num_t lw, int _);
void mad_trk_quad_kicks_p   (mflw_t *m, num_t lw, int _);
void mad_trk_quad_kickh_p   (mflw_t *m, num_t lw, int _);
void mad_trk_quad_kick__p   (mflw_t *m, num_t lw, int is);
void mad_trk_quad_kicks__p  (mflw_t *m, num_t lw, int is);
void mad_trk_quad_kickh__p  (mflw_t *m, num_t lw, int is);

// -- other maps
void mad_trk_solen_thick_r  (mflw_t *m, num_t lw, int _);
void mad_trk_esept_thick_r  (mflw_t *m, num_t lw, int _);
void mad_trk_rfcav_kick_r   (mflw_t *m, num_t lw, int _);
void mad_trk_rfcav_kickn_r  (mflw_t *m, num_t lw, int _);

void mad_trk_solen_thick_t  (mflw_t *m, num_t lw, int _);
void mad_trk_esept_thick_t  (mflw_t *m, num_t lw, int _);
void mad_trk_rfcav_kick_t   (mflw_t *m, num_t lw, int _);
void mad_trk_rfcav_kickn_t  (mflw_t *m, num_t lw, int _);

void mad_trk_solen_thick_p  (mflw_t *m, num_t lw, int _);
void mad_trk_esept_thick_p  (mflw_t *m, num_t lw, int _);
void mad_trk_rfcav_kick_p   (mflw_t *m, num_t lw, int _);
void mad_trk_rfcav_kickn_p  (mflw_t *m, num_t lw, int _);

// -- do nothing
void mad_trk_fnil           (mflw_t *m, num_t lw, int _);

// -- benchmark
void mad_trk_spdtest (int n, int k);
void mad_trk_cpptest (void);
]]

-- end ------------------------------------------------------------------------o
return C
