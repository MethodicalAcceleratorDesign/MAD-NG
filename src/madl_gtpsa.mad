--[=[
 o-----------------------------------------------------------------------------o
 |
 | Generalised Truncated Power Series Algebra module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides full set of functions and operations on real and complex TPSA.
  - Support monomials with parameters and inhomogeneous orders.

 o-----------------------------------------------------------------------------o
]=]

local MD, MR, MC = {}, {}, {}

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'
local istype   in ffi
local min, max in math

local _C, option, tostring, complex, vector, cvector, ivector,
      monomial                                                 in MAD
local abs, exp, log                                            in MAD.gmath
local openfile, strtrim, num2str                               in MAD.utility

-- To review
local is_nil, is_boolean, is_number, is_integer, is_natural, is_complex,
      is_matrix, is_cmatrix, is_vector, is_ivector, is_cvector,
      is_scalar, is_monomial, is_string, is_table, is_lengthable,
      is_iterable, is_mappable, get_metamethod                 in MAD.typeid

-- tmp for returned values
local  res = ffi.new 'num_t[1]'
local cres = ffi.new 'cpx_t[1]'

-- array of indexes
local int_arr = ffi.typeof 'idx_t[?]'

-- tpsa names
local chr_arr = ffi.typeof 'char [?]'

local assert, error, tostring =
      assert, error, tostring

local gmm = get_metamethod

-- types ----------------------------------------------------------------------o

ffi.cdef [[
enum { NAMSZ=16 };

struct desc_ { // warning: must be kept identical to C definition
  const int   id;          // index in list of registered descriptors
  const int   nn, nv, np;  // #variables, #parameters, nn=nv+np <= 100000
  const ord_t mo, po, sh_; // max order of vars & params, shared with id or -1
  const ord_t *const no;   // orders of each vars & params, no[nn]
};             // end of compatibility with Lua FFI (rest is not visible)

struct tpsa_ { // warning: must be kept identical to C definition and ctpsa
  const desc_t *const d;      // ptr to tpsa descriptor
  const ord_t lo, hi, mo, ao; // lowest/highest used ord, max ord, allocated ord
  int32_t     uid;            // special "user" field for external use (padding)
  const char  nam_[NAMSZ];    // tpsa name (hidden)
  const num_t coef[?];
};

struct ctpsa_ { // warning: must be kept identical to C definition and tpsa
  const desc_t *const d;      // ptr to cptsa descriptor
  const ord_t lo, hi, mo, ao; // lowest/highest used ord, max ord, allocated ord
  int32_t     uid;            // special "user" field for external use (padding)
  const char  nam_[NAMSZ];    // tpsa name (hidden)
  const cpx_t coef[?];
};
]]

local   desc_ctor = ffi.typeof 'struct  desc_'
local   tpsa_ctor = ffi.typeof 'struct  tpsa_'
local  ctpsa_ctor = ffi.typeof 'struct ctpsa_'

local  tpsa_cref  = ffi.typeof 'struct  tpsa_&'
local ctpsa_cref  = ffi.typeof 'struct ctpsa_&'

local  tpsa_size  = ffi.offsetof( tpsa_ctor, 'coef')
local ctpsa_size  = ffi.offsetof(ctpsa_ctor, 'coef')

local is_gtpsad = \x -> istype( desc_ctor, x)
local is_tpsa   = \x -> istype( tpsa_ctor, x)
local is_ctpsa  = \x -> istype(ctpsa_ctor, x)
local isa_tpsa  = \x -> is_tpsa(x) or is_ctpsa(x)

-- locals for arg and ret

local  int = ffi.new   'int[1]'
local  ord = ffi.new 'ord_t[1]'
local  val = ffi.new 'num_t[1]'
local cval = ffi.new 'cpx_t[1]'

-- descriptors ----------------------------------------------------------------o

--[=[
  variables + parameters

  nv: number of vars         (number)
  mo: max vars order         (number)
  np: number of parameters   (number of parameters)
  po: parameters order       (number)
  no: vars+params orders     (string or array, override nv, mo, np and po)
  vo: max vars order         (number) alias for mo

  default: nv=6, mo=1, np=0, po=0, no=nil

  gtpsad(nil)                            : 6 vars of order 1.
  gtpsad(3)         -> nv=3              : 3 vars of order 1.
  gtpsad{mo=3}      -> mo=3              : 6 vars of order 3.
  gtpsad(4,3)       -> nv=4,mo=3         : 4 vars of order 3.
  gtpsad{nv=4,mo=3}                      : as above.
  gtpsad(4,2,2,1) -> nv=4,mo=2,np=2,po=1 : 4 vars of order 2 and..
  gtpsad{nv=4,mo=2,np=2,po=1}            : ..2 parameters of order 1.
  gtpsad{nv=6,mo=2,np=94,po=1}           : 6 vars of order 2 and..
                                         : ..94 parameters of order 1.
  gtpsad{nv=2,np=2,po=1,no={3,3,1,1}}    : 2 vars + 2 params of orders 3,3,1,1..
         -> mo=3                         : with x-order limited to 1.
--]=]

local function gtpsad (nv_, mo_, np_, po_, no_)
  local is = is_mappable(nv_)
  local nv = is and  nv_.nv or nv_ or 6             -- number of variables
  local mo = is and (nv_.mo or nv_.vo) or mo_ or 1  -- variables max order
  local np = is and  nv_.np or np_ or 0             -- number of parameters
  local po = is and  nv_.po or po_ or 0             -- parameters max order
  local no = is and  nv_.no or no_ or nil           -- var. and parm. orders
  local d
  if is_nil(no) then
    d = _C.mad_desc_newvp(nv,mo,np,po)
  else
    if not is_monomial(no) then no = monomial(no) end
    assert(is_natural(nv), "invalid nv (positive integer expected)")
    assert(is_natural(np), "invalid np (positive integer expected)")
    assert(#no == nv+np, "invalid number of orders (#no ~= nv+np)")
    d = _C.mad_desc_newvpo(nv,mo,np,po,no._dat)
  end
  return assert(d, "unexpected null descriptor")
end

local function gtpsad_del (td_)
  _C.mad_desc_del(td_)
end

gtpsad() -- build and set default desc to nv=6,mo=1

-- allocators -----------------------------------------------------------------o

local function tpsa_alloc (d, mo)
  local len = _C.mad_desc_maxlen(d, mo)
  assert(len <= 2^30, "tpsa is too large")
  local tpsa = tpsa_ctor(len) -- VLA (hooked immediately before calling C)
  _C.mad_tpsa_init(tpsa, d, mo)
  return tpsa
end

local function ctpsa_alloc (d, mo)
  local len = _C.mad_desc_maxlen(d, mo)
   assert(len <= 2^29, "ctpsa is too large")
  local ctpsa = ctpsa_ctor(len) -- VLA (hooked immediately before calling C)
  _C.mad_ctpsa_init(ctpsa, d, mo)
  return ctpsa
end

-- ctors ----------------------------------------------------------------------o

-- tpsa()        -> last d
-- tpsa(mo)      -> last d, mo
-- tpsa(d)       -> d, d.mo
-- tpsa(t)       -> t.d, t.mo
-- tpsa(t|d, mo) -> t.d|d, mo

local function xtpsa (td, mo_, ct)
  if is_number(td) and is_nil(mo_) then
    mo_, td = td -- right shift
  end

  if is_nil(td) then
    td = assert(_C.mad_desc_curr, "unexpected null descriptor")
  end

  local mo = mo_ or td.mo
  assert(is_natural(mo), "invalid argument #2 (natural expected)")

  if isa_tpsa(td) then
    td = assert(td.d, "unexpected null descriptor")
  end

  return ct(td, max(0, min(mo, td.mo)))
end

local  tpsa = \td,mo_ -> xtpsa(td, mo_,  tpsa_alloc)
local ctpsa = \td,mo_ -> xtpsa(td, mo_, ctpsa_alloc)

-- checkers -------------------------------------------------------------------o

local function chksiz (r, x, y) -- add, sub, mul
  y = y or x
  assert(x.d == y.d and (is_nil(r) or r.d == x.d and r.mo >= max(x.mo,y.mo)),
         "incompatible GTPSA order or descriptor")
  return r
end

-- desc methods ---------------------------------------------------------------o

local mdat = \m -> (m and #m or 0, m and m._dat or nil)

MD.nv     = \d     -> _C.mad_desc_getnv (d,nil,nil,nil)
MD.np     = \d     => _C.mad_desc_getnv (d,nil,int,ord) return int[0],ord[0] end
MD.maxord = \d,m_  -> _C.mad_desc_maxord(d,mdat(m_))
MD.maxlen = \d,mo_ -> _C.mad_desc_maxlen(d,mo_ or _C.mad_tpsa_dflt)

MD.isvalid        = \d,m   -> d:get_idx(m)          > 0
MD.isvalid_sparse = \d,tbl -> d:get_idx_sparse(tbl) > 0

function MD.get_idx (d, m) -- mono -> idx (0 means invalid)
  if is_string(m) then return _C.mad_desc_idxs(d, #m, m)+1 end
  if not is_monomial(m) then m = monomial(m) end
  return _C.mad_desc_idxm(d, m.n, m._dat)+1
end

function MD.get_idx_sparse (d, tbl) -- tbl = {idx1, ord1, idx2, ord2, ... } -> idx
  assert(is_table(tbl), "invalid argument #2 (table expected)")
  local n = #tbl
  local m = int_arr(n) ; for i=1,n do m[i-1] = tbl[i] end
  return _C.mad_desc_idxsm(d, n, m)+1
end

function MD.get_mono (d, i, r) -- idx -> mono
  assert(is_natural(i), "invalid argument #2 (index expected)")
  local m = r or monomial(d.nn)
  assert(is_monomial(m), "invalid argument #3 (monomial expected)")
  return m, _C.mad_desc_mono(d, i-1, m.n, m._dat, nil) -- return order and mono
end

function MD.nxtbyvar (d, m) -- mono -> idx (-1 means invalid or no more)
  if not is_monomial(m) then m = monomial(m) end
  return _C.mad_desc_nxtbyvar(d, m.n, m._dat), m
end

function MD.nxtbyord (d, m) -- mono -> idx (-1 means invalid or no more)
  if not is_monomial(m) then m = monomial(m) end
  return _C.mad_desc_nxtbyord(d, m.n, m._dat), m
end

-- maxord, maxlen, mlen, mord, trunc, debug -----------------------------------o

MR.nv     = \x     -> _C.mad_desc_getnv (x.d,nil,nil,nil)
MR.np     = \x     => _C.mad_desc_getnv (x.d,nil,int,ord) return int[0],ord[0] end
MR.maxord = \x,m_  -> _C.mad_desc_maxord(x.d,mdat(m_))
MR.maxlen = \x,mo_ -> _C.mad_desc_maxlen(x.d,mo_ or x.mo)

MR.desc   = \x     -> _C.mad_tpsa_desc (x)
MC.desc   = \x     -> _C.mad_ctpsa_desc(x)

MR.mlen   = \x,hi  -> _C.mad_tpsa_len (x, hi or false)
MC.mlen   = \x,hi  -> _C.mad_ctpsa_len(x, hi or false)

MR.mord   = \x,hi  -> _C.mad_tpsa_ord (x, hi or false)
MC.mord   = \x,hi  -> _C.mad_ctpsa_ord(x, hi or false)

MR.trunc  = \x,to_ -> _C.mad_tpsa_mo (x, to_ or _C.mad_tpsa_same)
MC.trunc  = \x,to_ -> _C.mad_ctpsa_mo(x, to_ or _C.mad_tpsa_same)

MR.nam    = \x     -> ffi.string(_C.mad_tpsa_nam (x,nil))
MC.nam    = \x     -> ffi.string(_C.mad_ctpsa_nam(x,nil))

MR.setnam = \x,s   => _C.mad_tpsa_nam (x,s) return x end
MC.setnam = \x,s   => _C.mad_ctpsa_nam(x,s) return x end

MR.isvalid = \x    -> _C.mad_tpsa_isvalid (x)
MC.isvalid = \x    -> _C.mad_ctpsa_isvalid(x)

MR.density = \x,eps -> _C.mad_tpsa_density (x, eps or 0)
MC.density = \x,eps -> _C.mad_ctpsa_density(x, eps or 0)

MR.debug = \x,nam_,fnam_,lin_,fil_ => _C.mad_tpsa_debug (x,nam_,fnam_,lin_ or 0,fil_) end
MC.debug = \x,nam_,fnam_,lin_,fil_ => _C.mad_ctpsa_debug(x,nam_,fnam_,lin_ or 0,fil_) end

-- same, copy, getord, cutord, convert, setvar, clear -------------------------o

-- x:same()
-- x:same(e)
-- x:same(e,mo)
-- x:same(nil,mo)
-- x:same(mo) => x:same(e), i.e. wrong order

function MR.__same (x, e_, mo_)
  if is_nil(e_) or is_number(e_) then
    return  tpsa_alloc(x.d, mo_ or x.mo)
  elseif is_complex(e_) then
    return ctpsa_alloc(x.d, mo_ or x.mo)
  else
    error("invalid argument #2 (nil or scalar expected)")
  end
end

function MC.__same (x, e_, mo_)
  if is_nil(e_) or is_complex(e_) then
    return ctpsa_alloc(x.d, mo_ or x.mo)
  elseif is_number(e_) then
    return  tpsa_alloc(x.d, mo_ or x.mo)
  else
    error("invalid argument #2 (nil or scalar expected)")
  end
end

function MR.__copy (x, y_)
  if is_nil(y_) then
    y_ = tpsa_alloc(x.d, x.mo)
   _C.mad_tpsa_copy(x, y_)
  elseif is_tpsa(y_) then
   _C.mad_tpsa_copy(chksiz(x,y_), y_)
  else
    assert(is_ctpsa(y_), "invalid argument #2 (tpsa or ctpsa expected)")
    _C.mad_ctpsa_cplx(chksiz(x,y_), nil, y_)
  end
  return y_
end

function MC.__copy (x, y_)
  if is_nil(y_) then
    y_ = ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_copy(x, y_)
  elseif is_ctpsa(y_) then
    _C.mad_ctpsa_copy(chksiz(x,y_), y_)
  else
    assert(is_tpsa(y_), "invalid argument #2 (tpsa or ctpsa expected)")
    _C.mad_ctpsa_real(chksiz(x,y_), y_)
  end
  return y_
end

function MR.clrord (x, o)
  _C.mad_tpsa_clrord(x, o)
  return x
end

function MC.clrord (x, o)
  _C.mad_ctpsa_clrord(x, o)
  return x
end

function MR.sclord (x, inv_, prm_, y_)
  if is_nil(y_) then
    y_ = tpsa_alloc(x.d, x.mo)
    _C.mad_tpsa_sclord(x, y_, inv_ or false, prm_ or false)
  else
    assert(is_tpsa(y_), "invalid argument #4 (tpsa expected)")
    _C.mad_tpsa_sclord(chksiz(x,y_), y_, inv_ or false, prm_ or false)
  end
  return y_
end

function MC.sclord (x, inv_, prm_, y_)
  if is_nil(y_) then
    y_ = ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_sclord(x, y_, inv_ or false, prm_ or false)
  else
    assert(is_ctpsa(y_), "invalid argument #4 (ctpsa expected)")
    _C.mad_ctpsa_sclord(chksiz(x,y_), y_, inv_ or false, prm_ or false)
  end
  return y_
end

function MR.getord (x, o, y_)
  if is_nil(y_) then
    y_ = tpsa_alloc(x.d, x.mo)
    _C.mad_tpsa_getord(x, y_, o)
  else
    assert(is_tpsa(y_), "invalid argument #3 (tpsa expected)")
    _C.mad_tpsa_getord(chksiz(x,y_), y_, o)
  end
  return y_
end

function MC.getord (x, o, y_)
  if is_nil(y_) then
    y_ = ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_getord(x, y_, o)
  else
    assert(is_ctpsa(y_), "invalid argument #3 (ctpsa expected)")
    _C.mad_ctpsa_getord(chksiz(x,y_), y_, o)
  end
  return y_
end

function MR.cutord (x, o, y_)
  if is_nil(y_) then
    y_ = tpsa_alloc(x.d, x.mo)
    _C.mad_tpsa_cutord(x, y_, o)
  else
    assert(is_tpsa(y_), "invalid argument #3 (tpsa expected)")
    _C.mad_tpsa_cutord(chksiz(x,y_), y_, o)
  end
  return y_
end

function MC.cutord (x, o, y_)
  if is_nil(y_) then
    y_ = ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_cutord(x, y_, o)
  else
    assert(is_ctpsa(y_), "invalid argument #3 (ctpsa expected)")
    _C.mad_ctpsa_cutord(chksiz(x,y_), y_, o)
  end
  return y_
end

function MR.maxbyord (x, v_)
  local v = v_ or ivector(x.mo+1)
  assert(is_ivector(v), "invalid argument #2 (ivector expected)")
  local i = _C.mad_tpsa_maxord(x, #v, v._dat)
  for o=1,#v do v[o] = v[o]+1 end
  return i+1, v
end

function MC.maxbyord (x, v_)
  local v = v_ or ivector(x.mo+1)
  assert(is_ivector(v), "invalid argument #2 (ivector expected)")
  local i = _C.mad_ctpsa_maxord(x, #v, v._dat)
  for o=1,#v do v[o] = v[o]+1 end
  return i+1, v
end

function MR.convert (x, y, tbl_, pb_)
  assert(is_tpsa(y), "invalid argument #2 (tpsa expected)")
  local pb, n, m = pb_ or 0, 0, nil
  if tbl_ then
    assert(is_table(tbl_), "invalid argument #3 (table expected)")
    assert(pb==0 or pb==1 or pb==-1, "invalid argument #4 (-1,0,1 expected)")
    n = #tbl_
    m = int_arr(n) ; for i=1,n do m[i-1] = tbl_[i]-1 end
  end
  _C.mad_tpsa_convert(x, y, n, m, pb) return y
end

function MC.convert (x, y, tbl_, pb_)
  assert(is_ctpsa(y), "invalid argument #2 (ctpsa expected)")
  local pb, n, m = pb_ or 0, 0, nil
  if tbl_ then
    assert(is_table(tbl_), "invalid argument #3 (table expected)")
    assert(pb==0 or pb==1 or pb==-1, "invalid argument #4 (-1,0,1 expected)")
    n = #tbl_
    m = int_arr(n) ; for i=1,n do m[i-1] = tbl_[i]-1 end
  end
  _C.mad_ctpsa_convert(x, y, n, m, pb) return y
end

function MR.setval (x, e_) -- clear + set0(e)
  _C.mad_tpsa_setval(x, e_ or 0) return x
end

function MC.setval (x, e_) -- clear + set0(e)
  e_ = complex(e_ or 0)
  _C.mad_ctpsa_setval_r(x, e_.re, e_.im) return x
end

function MR.setvar (x, e_, iv, scl_) -- clear + set0(e) + set1(iv, scl or 1)
  _C.mad_tpsa_setvar(x, e_ or 0, iv, scl_ or 0) return x
end

function MC.setvar (x, e_, iv, scl_) -- clear + set0(e) + set1(iv, scl or 1)
  e_, scl_ = complex(e_ or 0), complex(scl_ or 0)
  _C.mad_ctpsa_setvar_r(x, e_.re, e_.im, iv, scl_.re, scl_.im) return x
end

function MR.setprm (x, e_, ip) -- clear + set0(e) + set1(ip+nv, 1)
  _C.mad_tpsa_setprm(x, e_ or 0, ip) return x
end

function MC.setprm (x, e_, ip) -- clear + set0(e) + set1(ip+nv, 1)
  e_ = complex(e_ or 0)
  _C.mad_ctpsa_setprm_r(x, e_.re, e_.im, ip) return x
end

function MR.clear (x)
  _C.mad_tpsa_clear(x) return x
end

function MC.clear (x)
  _C.mad_ctpsa_clear(x) return x
end

MR.isnul = \x -> _C.mad_tpsa_isnul (x)
MC.isnul = \x -> _C.mad_ctpsa_isnul(x)

MR.isval = \x -> _C.mad_tpsa_isval (x)
MC.isval = \x -> _C.mad_ctpsa_isval(x)

-- indexing -------------------------------------------------------------------o

MR.get_idx        = \x,m   -> x.d:get_idx(m)          -- mono -> idx (0 means invalid)
MR.get_idx_sparse = \x,tbl -> x.d:get_idx_sparse(tbl) -- tbl = {idx1, ord1, ... } -> idx
MR.get_mono       = \x,i,r -> x.d:get_mono(i,r)       -- idx -> mono

function MR.totable (x, p)
  local m = monomial(p == true and x.d.nn or x.d.nv)
  local t = table.new(64,8)
  local n = 1
  for i, v in x:iter(m) do
    local s = m:tostring()
    t[n], t[s], n = s, v, n+1
  end
  return t
end

function MR.fromtable (x, t)
  for i,s in ipairs(t) do x:set(s, t[s]) end
  return x
end

-- getters and setters --------------------------------------------------------o

function MR.get0 (x)
  return x.coef[0]
end

function MC.get0 (x)
  return x.coef[0]
end

function MR.set0 (x, a, b)
  if is_nil(b) then a, b = 0, a end
  _C.mad_tpsa_seti(x, 0, a, b) return x
end

function MC.set0 (x, a, b)
  if is_nil(b) then a, b = 0, a end
  a, b = complex(a), complex(b)
  _C.mad_ctpsa_seti_r(x, 0, a.re, a.im, b.re, b.im) return x
end

function MR.get (x, m) -- idx or str or mono -> num
  if is_integer(m) then
    return _C.mad_tpsa_geti(x, m-1)
  elseif is_string(m) then
    return _C.mad_tpsa_gets(x, #m, m)
  else
    if not is_monomial(m) then m = monomial(m) end
    return _C.mad_tpsa_getm(x, m.n, m._dat)
  end
end

function MC.get (x, m) -- idx or str or mono -> cpx
  if is_integer(m) then
    _C.mad_ctpsa_geti_r(x, m-1, cres)
  elseif is_string(m) then
    _C.mad_ctpsa_gets_r(x, #m, m, cres)
  else
    if not is_monomial(m) then m = monomial(m) end
    _C.mad_ctpsa_getm_r(x, m.n, m._dat, cres)
  end
  return cres[0]
end

function MR.set (x, m, a, b)
  if is_nil(b) then a, b = 0, a end
  if is_integer(m) then
    _C.mad_tpsa_seti(x, m-1, a, b)
  elseif is_string(m) then
    _C.mad_tpsa_sets(x, #m, m, a, b)
  else
    if not is_monomial(m) then m = monomial(m) end
    _C.mad_tpsa_setm(x, m.n, m._dat, a, b)
  end
  return x
end

function MC.set (x, m, a, b)
  if is_nil(b) then a, b = 0, a end
  a, b = complex(a), complex(b)
  if is_integer(m) then
    _C.mad_ctpsa_seti_r(x, m-1, a.re, a.im, b.re, b.im)
  elseif is_string(m) then
    _C.mad_ctpsa_sets_r(x, #m, m, a.re, a.im, b.re, b.im)
  else
    if not is_monomial(m) then m = monomial(m) end
    _C.mad_ctpsa_setm_r(x, m.n, m._dat, a.re, a.im, b.re, b.im)
  end
  return x
end

function MR.cpy (x, m, r) -- idx or str or mono -> num
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
      if is_integer(m) then _C.mad_tpsa_cpyi(x, r, m-1)
  elseif is_string (m) then _C.mad_tpsa_cpys(x, r, #m, m)
  else
    if not is_monomial(m) then m = monomial(m) end
    _C.mad_tpsa_cpym(x, r, m.n, m._dat)
  end
  return r
end

function MC.cpy (x, m, r) -- idx or str or mono -> cpx
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
      if is_integer(m) then _C.mad_ctpsa_cpyi(x, r, m-1)
  elseif is_string (m) then _C.mad_ctpsa_cpys(x, r, #m, m)
  else
    if not is_monomial(m) then m = monomial(m) end
    _C.mad_ctpsa_cpym(x, r, m.n, m._dat)
  end
  return r
end

-- sparse getters and setters -------------------------------------------------o

function MR.get_sparse (x, tbl) -- tbl = {idx1, ord1, idx2, ord2, ... } -> num
  assert(is_table(tbl), "invalid argument #2 (table expected)")
  local n = #tbl
  local m = int_arr(n) ; for i=1,n do m[i-1] = tbl[i] end
  return _C.mad_tpsa_getsm(x, n, m)
end

function MC.get_sparse (x, tbl) -- tbl = {idx1, ord1, idx2, ord2, ... } -> cpx
  assert(is_table(tbl), "invalid argument #2 (table expected)")
  local n = #tbl
  local m = int_arr(n) ; for i=1,n do m[i-1] = tbl[i] end
  _C.mad_ctpsa_getsm_r(x, n, m, cres) return cres[0]
end

function MR.set_sparse (x, tbl, a, b) -- tbl = {idx1, ord1, idx2, ord2, ... }
  assert(is_table(tbl), "invalid argument #2 (table expected)")
  if is_nil(b) then a, b = 0, a end
  local n = #tbl
  local m = int_arr(n) ; for i=1,n do m[i-1] = tbl[i] end
  _C.mad_tpsa_setsm(x, n, m, a, b) return x
end

function MC.set_sparse (x, tbl, a, b) -- tbl = {idx1, ord1, idx2, ord2, ... }
  assert(is_table(tbl), "invalid argument #2 (table expected)")
  if is_nil(b) then a, b = 0, a end
  a, b = complex(a), complex(b)
  local n = #tbl
  local m = int_arr(n) ; for i=1,n do m[i-1] = tbl[i] end
  _C.mad_ctpsa_setsm_r(x, n, m, a.re, a.im, b.re, b.im) return x
end

function MR.cpy_sparse (x, tbl, r) -- tbl = {idx1, ord1, idx2, ord2, ... }
  assert(is_table(tbl), "invalid argument #2 (table expected)")
  local n = #tbl
  local m = int_arr(n) ; for i=1,n do m[i-1] = tbl[i] end
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_cpysm(x, r, n, m)
  return r
end

function MC.cpy_sparse (x, tbl, r) -- tbl = {idx1, ord1, idx2, ord2, ... }
  assert(is_table(tbl), "invalid argument #2 (table expected)")
  local n = #tbl
  local m = int_arr(n) ; for i=1,n do m[i-1] = tbl[i] end
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_cpysm(x, r, n, m)
  return r
end

-- table/vector getters and setters -------------------------------------------o

function MR.getvec (x, i, a)
  assert(is_natural(i), "invalid argument #2 (integer expected)")
  if is_natural(a) then a = vector(a) end
  assert(is_matrix (a), "invalid argument #3 (integer or vector expected)")
  _C.mad_tpsa_getv(x, i-1, a:size(), a._dat) return a
end

function MC.getvec (x, i, a)
  assert(is_natural(i), "invalid argument #2 (integer expected)")
  if is_natural(a) then a = cvector(a) end
  assert(is_cmatrix(a), "invalid argument #3 (integer or cvector expected)")
  _C.mad_ctpsa_getv(x, i-1, a:size(), a._dat) return a
end

function MR.setvec (x, i, a)
  assert(is_natural(i), "invalid argument #2 (integer expected)")
  if not is_matrix(a) and is_iterable(a) then a = vector(#a):fill(a) end
  assert(is_vector(a), "invalid argument #3 (iterable or vector expected)")
  _C.mad_tpsa_setv(x, i-1, a:size(), a._dat) return x
end

function MC.setvec (x, i, a)
  assert(is_natural(i), "invalid argument #2 (integer expected)")
  if not is_cmatrix(a) and is_iterable(a) then a = cvector(#a):fill(a) end
  assert(is_cvector(a), "invalid argument #3 (iterable or cvector expected)")
  _C.mad_ctpsa_setv(x, i-1, a:size(), a._dat) return x
end

function MR.fill (x, a)
  if not is_matrix(a) and is_iterable(a) then a = vector(#a):fill(a) end
  assert(is_vector(a), "invalid argument #2 (iterable or vector expected)")
  _C.mad_tpsa_setv(x, 0, a:size(), a._dat) return x
end

function MC.fill (x, a)
  if not is_cmatrix(a) and is_iterable(a) then a = cvector(#a):fill(a) end
  assert(is_cvector(a), "invalid argument #2 (iterable or cvector expected)")
  _C.mad_ctpsa_setv(x, 0, a:size(), a._dat) return x
end

-- evaluate x at a+h ----------------------------------------------------------o

local  tarr1 = ffi.new 'struct  tpsa_* [1]'
local ctarr1 = ffi.new 'struct ctpsa_* [1]'

function MR.eval (x, h)
  tarr1[0], val[0] = x, h
  _C.mad_tpsa_eval(1, tarr1, 1, val, res) return res[0]
end

function MC.eval (x, h)
  ctarr1[0], cval[0] = x, h
  _C.mad_ctpsa_eval(1, tarr1, 1, val, cres) return cres[0]
end

-- conversion -----------------------------------------------------------------o

function MR.cplx (re_, im_, r) -- (re,im) -> r
  local re, im = re_ or im_, im_ or re_ -- trick for next checks
  assert(is_tpsa(re) and is_tpsa(im), "invalid argument #1 or #2 (tpsa expected)")
  r = chksiz(r,re,im) or ctpsa(re, max(re.mo, im.mo))
  _C.mad_ctpsa_cplx(re_, im_, r) return r
end

function MC.reim (x, re_, im_) -- x -> (re,im)
  re_ = chksiz(re_,x) or tpsa_alloc(x.d, x.mo)
  im_ = chksiz(im_,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_real(x, re_) ; _C.mad_ctpsa_imag(x, im_) -- no shortcut
  return re_, im_
end

function MR.real (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_copy(x, r) return r
end

function MC.real (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_real(x, r) return r
end

function MR.imag (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_clear(r) return r
end

function MC.imag (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_imag(x, r) return r
end

-- operators ------------------------------------------------------------------o

-- unm

function MR.__unm (x, _, r) -- note: _ is dummy arg, see Lua specs.
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_scl(x, -1, r) return r
end

function MC.__unm (x, _, r) -- note: _ is dummy arg, see Lua specs.
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_scl_r(x, -1, 0, r) return r
end

-- equ

local function tpsa_eqn (x, y, tol)
  return x:isval() and abs(x.coef[0]-y) <= tol
end

local function tpsa_eqc (x, y, tol)
  return x:isval() and abs(          y.im) <= tol
                   and abs(x.coef[0]-y.re) <= tol
end

local function ctpsa_eqn (x, y, tol)
  return x:isval() and abs(x.coef[0].im  ) <= tol
                   and abs(x.coef[0].re-y) <= tol
end

local function ctpsa_eqc (x, y, tol)
  return x:isval() and abs(x.coef[0].re-y.re) <= tol
                   and abs(x.coef[0].im-y.im) <= tol
end

function MR.__eq (x, y, tol_)
  if is_nil(y) or is_nil(x) then return false end
  tol_ = tol_ or 0
  assert(is_number(tol_), "invalid argument #3 (number expected)")
  if is_number(x) then                           -- num == tpsa
    return tpsa_eqn(y, x, tol_)
  elseif is_number(y) then                       -- tpsa == num
    return tpsa_eqn(x, y, tol_)
  elseif is_complex(x) then                      -- cpx == tpsa
    return tpsa_eqc(y, x, tol_)
  elseif is_complex(y) then                      -- tpsa == cpx
    return tpsa_eqc(x, y, tol_)
  elseif is_ctpsa(y) then                        -- tpsa == ctpsa
    assert(x.d == y.d, "incompatible GTPSA descriptor")
    return _C.mad_ctpsa_equt(y, x, tol_)
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa == tpsa
    assert(x.d == y.d, "incompatible GTPSA descriptor")
    return _C.mad_tpsa_equ(x, y, tol_)
  else
    return assert(gmm(y,'__eq_tpsa'), "invalid 'tpsa == ?' operation")(x, y, tol_)
  end
end

function MC.__eq (x, y, tol_)
  if is_nil(y) or is_nil(x) then return false end
  tol_ = tol_ or 0
  assert(is_number(tol_), "invalid argument #3 (number expected)")
  if is_number(x) then                           -- num == ctpsa
    return ctpsa_eqn(y, x, tol_)
  elseif is_number(y) then                       -- ctpsa == num
    return ctpsa_eqn(x, y, tol_)
  elseif is_complex(x) then                      -- cpx == tpsa
    return ctpsa_eqc(y, x, tol_)
  elseif is_complex(y) then                      -- ctpsa == cpx
    return ctpsa_eqc(x, y, tol_)
  elseif is_tpsa(y) then                         -- ctpsa == tpsa
    assert(x.d == y.d, "incompatible GTPSA descriptor")
    return _C.mad_ctpsa_equt(x, y, tol_)
  elseif is_ctpsa(y) and is_ctpsa(x) then        -- ctpsa == ctpsa
    assert(x.d == y.d, "incompatible GTPSA descriptor")
    return _C.mad_ctpsa_equ(x, y, tol_)
  else
    return assert(gmm(y,'__eq_tpsa'), "invalid 'ctpsa == ?' operation")(x, y, tol_)
  end
end

MR.__eq_cpx = MR.__eq
MC.__eq_cpx = MC.__eq

-- lt

function MR.__lt (x, y)
  if is_number(x) then                           -- num  < tpsa
    return x < y.coef[0]
  elseif is_number(y) then                       -- tpsa < num
    return x.coef[0] < y
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa < tpsa
    assert(x.d == y.d, "incompatible GTPSA descriptor")
    return x.coef[0] < y.coef[0]
  else
    return assert(gmm(y,'__lt_tpsa'), "invalid 'tpsa < ?' operation")(x, y)
  end
end

MC.__lt = \ error("invalid operation '<' on complex GTPSA")

-- le

function MR.__le (x, y)
  if is_number(x) then                           -- num  <= tpsa
    return x <= y.coef[0]
  elseif is_number(y) then                       -- tpsa <= num
    return x.coef[0] <= y
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa <= tpsa
    assert(x.d == y.d, "incompatible GTPSA descriptor")
    return x.coef[0] <= y.coef[0]
  else
    return assert(gmm(y,'__le_tpsa'), "invalid 'tpsa <= ?' operation")(x, y)
  end
end

MC.__le = \ error("invalid operation '<=' on complex GTPSA")

-- add (see also kadd)

function MR.__add (x, y, r)
  if is_number(x) then                           -- num + tpsa
    r = chksiz(r,y) or tpsa_alloc(y.d, y.mo)
    _C.mad_tpsa_copy(y, r)
    _C.mad_tpsa_seti(r, 0, 1, x)
  elseif is_number(y) then                       -- tpsa + num
    r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
    _C.mad_tpsa_copy(x, r)
    _C.mad_tpsa_seti(r, 0, 1, y)
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa + tpsa
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_tpsa_add(x, y, r)
  elseif is_complex(y) then                      -- tpsa + cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)    -- promote to ctpsa
    _C.mad_ctpsa_cplx(x, nil, r)
    _C.mad_ctpsa_seti_r(r, 0, 1, 0, y.re, y.im)
  elseif is_ctpsa(y) then                        -- tpsa + ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_addt(y, x, r)
  else                                           -- tpsa + ?
    return assert(gmm(y,'__add_tpsa'), "invalid 'tpsa + ?' operation")(x, y, r)
  end
  return r
end

function MR.__add_cpx (x, y, r)                  -- cpx + tpsa
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)      -- promote to ctpsa
  _C.mad_ctpsa_cplx(y, nil, r)
  _C.mad_ctpsa_seti_r(r, 0, 1, 0, x.re, x.im) return r
end

function MC.__add (x, y, r)
  if is_number(x) then                           -- num + ctpsa
    r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
    _C.mad_ctpsa_copy(y, r)
    _C.mad_ctpsa_seti_r(r, 0, 1, 0, x, 0)
  elseif is_scalar(y) then                       -- ctpsa + scl
    y = complex(y)
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_copy(x, r)
    _C.mad_ctpsa_seti_r(r, 0, 1, 0, y.re, y.im)
  elseif is_ctpsa(y) and is_ctpsa(x) then        -- ctpsa + ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_add(x, y, r)
  elseif is_tpsa(y) then                         -- ctpsa + tpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_addt(x, y, r)
  else                                           -- ctpsa + ?
    return assert(gmm(y,'__add_tpsa'), "invalid 'ctpsa + ?' operation")(x, y, r)
  end
  return r
end

function MC.__add_cpx (x, y, r)                  -- cpx + ctpsa
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
  _C.mad_ctpsa_copy(y, r)
  _C.mad_ctpsa_seti_r(r, 0, 1, 0, x.re, x.im) return r
end

-- sub (see also kadd)

function MR.__sub (x, y, r)
  if is_number(x) then                           -- num - tpsa
    r = chksiz(r,y) or tpsa_alloc(y.d, y.mo)
    _C.mad_tpsa_scl(y, -1, r)
    _C.mad_tpsa_seti(r, 0, 1, x)
  elseif is_number(y) then                       -- tpsa - num
    r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
    _C.mad_tpsa_copy(x, r)
    _C.mad_tpsa_seti(r, 0, 1, -y)
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa - tpsa
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_tpsa_sub(x, y, r)
  elseif is_complex(y) then                      -- tpsa - cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)    -- promote to ctpsa
    _C.mad_ctpsa_copy(x, r)
    _C.mad_ctpsa_seti_r(r, 0, 1, 0, -y.re, -y.im)
  elseif is_ctpsa(y) then                        -- tpsa - ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_tsub(x, y, r)
  else                                           -- tpsa - ?
    return assert(gmm(y,'__sub_tpsa'), "invalid 'tpsa - ?' operation")(x, y, r)
  end
  return r
end

function MR.__sub_cpx (x, y, r)                  -- cpx - tpsa
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)      -- promote to ctpsa
  _C.mad_ctpsa_cplx  (y,  nil, r)
  _C.mad_ctpsa_scl_r (r,-1, 0, r)
  _C.mad_ctpsa_seti_r(r, 0, 1, 0, x.re, x.im) return r
end

function MC.__sub (x, y, r)
  if is_number(x) then                           -- num - ctpsa
    r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
    _C.mad_ctpsa_scl_r(y, -1, 0, r)
    _C.mad_ctpsa_seti_r(r, 0, 1, 0, x, 0)
  elseif is_scalar(y) then                       -- ctpsa - scl
    y = complex(-y)
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_copy(x, r)
    _C.mad_ctpsa_seti_r(r, 0, 1, 0, y.re, y.im)
  elseif is_ctpsa(y) and is_ctpsa(x) then        -- ctpsa - ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_sub(x, y, r)
  elseif is_tpsa(y) then                         -- ctpsa - tpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_subt(x, y, r)
  else                                           -- ctpsa - ?
    return assert(gmm(y,'__sub_tpsa'), "invalid 'ctpsa - ?' operation")(x, y, r)
  end
  return r
end

function MC.__sub_cpx (x, y, r)                  -- cpx - ctpsa
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
  _C.mad_ctpsa_scl_r (y,-1, 0, r)
  _C.mad_ctpsa_seti_r(r, 0, 1, 0, x.re, x.im) return r
end

-- mul

function MR.__mul (x, y, r)
  if is_number(x) then                           -- num * tpsa
    r = chksiz(r,y) or tpsa_alloc(y.d, y.mo)
    _C.mad_tpsa_scl(y, x, r)
  elseif is_number(y) then                       -- tpsa * num
    r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
    _C.mad_tpsa_scl(x, y, r)
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa * tpsa
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_tpsa_mul(x, y, r)
  elseif is_complex(y) then                      -- tpsa * cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)    -- promote to ctpsa
    _C.mad_ctpsa_cplx(x, nil, r)
    _C.mad_ctpsa_scl_r(r, y.re, y.im, r)
  elseif is_ctpsa(y) then                        -- tpsa * ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_mult(y, x, r)
  else                                           -- tpsa * ?
    return assert(gmm(y,'__mul_tpsa'), "invalid 'tpsa * ?' operation")(x, y, r)
  end
  return r
end

function MR.__mul_cpx (x, y, r)                  -- cpx * tpsa
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)      -- promote to ctpsa
  _C.mad_ctpsa_cplx (y, nil, r)
  _C.mad_ctpsa_scl_r(r, x.re, x.im, r) return r
end

function MC.__mul (x, y, r)
  if is_number(x) then                           -- num * ctpsa
    r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
    _C.mad_ctpsa_scl_r(y, x, 0, r)
  elseif is_scalar(y) then                       -- ctpsa * scl
    y = complex(y)
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_scl_r(x, y.re, y.im, r)
  elseif is_ctpsa(y) and is_ctpsa(x) then        -- ctpsa * ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_mul(x, y, r)
  elseif is_tpsa(y) then                         -- ctpsa * tpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_mult(x, y, r)
  else                                           -- ctpsa * ?
    return assert(gmm(y,'__mul_tpsa'), "invalid 'ctpsa * ?' operation")(x, y, r)
  end
  return r
end

function MC.__mul_cpx (x, y, r)                  -- cpx * ctpsa
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
  _C.mad_ctpsa_scl_r(y, x.re, x.im, r) return r
end

-- element wise mul (.*)

function MR.__emul (x, y, r)
  return assert(gmm(y,'__emul_tpsa'), "invalid 'tpsa .* ?' operation")(x, y, r)
end

function MC.__emul (x, y, r)
  return assert(gmm(y,'__emul_tpsa'), "invalid 'ctpsa .* ?' operation")(x, y, r)
end

-- div

function MR.__div (x, y, r)
  if is_number(x) then                           -- num / tpsa
    r = chksiz(r,y) or tpsa_alloc(y.d, y.mo)
    _C.mad_tpsa_inv(y, x, r)
  elseif is_number(y) then                       -- tpsa / num
    r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
    _C.mad_tpsa_scl(x, 1/y, r)
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa / tpsa
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_tpsa_div(x, y, r)
  elseif is_complex(y) then                      -- tpsa / cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)    -- promote to ctpsa
    local _y = 1/y
    _C.mad_ctpsa_cplx(x, nil, r)
    _C.mad_ctpsa_scl_r(r, _y.re, _y.im, r)
  elseif is_ctpsa(y) then                        -- tpsa / ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_tdiv(x, y, r)
  else                                           -- tpsa / ?
    return assert(gmm(y,'__div_tpsa'), "invalid 'tpsa / ?' operation")(x, y, r)
  end
  return r
end

function MR.__div_cpx (x, y, r)                  -- cpx / tpsa
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)      -- promote to ctpsa
  _C.mad_ctpsa_cplx(y, nil, r)
  _C.mad_ctpsa_inv_r(r, x.re, x.im, r) return r
end

function MC.__div (x, y, r)
  if is_number(x) then                           -- num / ctpsa
    r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
    _C.mad_ctpsa_inv_r(y, x, 0, r)
  elseif is_scalar(y) then                       -- ctpsa / scl
    y = complex(1/y)
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_scl_r(x, y.re, y.im, r)
  elseif is_ctpsa(y) and is_ctpsa(x) then        -- ctpsa / ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_div(x, y, r)
  elseif is_tpsa(y) then                         -- ctpsa / tpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_divt(x, y, r)
  else                                           -- ctpsa / ?
    return assert(gmm(y,'__div_tpsa'), "invalid 'ctpsa / ?' operation")(x, y, r)
  end
  return r
end

function MC.__div_cpx (x, y, r)                  -- cpx / ctpsa
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
  _C.mad_ctpsa_inv_r(y, x.re, x.im, r) return r
end

-- element wise div (./)

function MR.__ediv (x, y, r_)
  return assert(gmm(y,'__ediv_tpsa'), "invalid 'tpsa ./ ?' operation")(x, y, r)
end

function MC.__ediv (x, y, r_)
  return assert(gmm(y,'__ediv_tpsa'), "invalid 'ctpsa ./ ?' operation")(x, y, r)
end

-- element wise mod (.%)

function MR.__emod (x, y, r_)
  return assert(gmm(y,'__emod_tpsa'), "invalid 'tpsa .% ?' operation")(x, y, r)
end

function MC.__emod (x, y, r_)
  return assert(gmm(y,'__emod_tpsa'), "invalid 'ctpsa .% ?' operation")(x, y, r)
end

-- pow = exp(y*log(x))

function MR.__pow (x, y, r)
  if is_number(y) then                           -- tpsa ^ num
    r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
    if is_integer(y)
    then _C.mad_tpsa_powi(x, y, r)
    else _C.mad_tpsa_pown(x, y, r)
    end
  elseif is_number(x) then                       -- num ^ tpsa
    r = chksiz(r,y) or tpsa_alloc(y.d, y.mo)
    _C.mad_tpsa_scl(y, log(x), r)
    _C.mad_tpsa_exp(r, r)
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa ^ tpsa
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_tpsa_pow(x, y, r)
  elseif is_complex(y) then                      -- tpsa ^ cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)    -- promote to ctpsa
    _C.mad_ctpsa_cplx(x, nil, r)
    _C.mad_ctpsa_pown_r(x, y.re, y.im, r)
  elseif is_ctpsa(y) then                        -- tpsa ^ ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_tpow(x, y, r)
  else                                           -- tpsa ^ ?
    return assert(gmm(y,'__pow_tpsa'), "invalid 'tpsa ^ ?' operation")(x, y, r)
  end
  return r
end

function MR.__pow_cpx (x, y, r)                  -- cpx ^ tpsa
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)      -- promote to ctpsa
  local logx = log(x)
  _C.mad_ctpsa_cplx(y, nil, r)
  _C.mad_ctpsa_scl_r(r, logx.re, logx.im, r)
  _C.mad_ctpsa_exp(r, r) return r
end

function MC.__pow (x, y, r)
  if is_scalar(y) then                           -- ctpsa ^ scl
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    if is_integer(y)
    then _C.mad_ctpsa_powi(x, y, r)
    else y = complex(y)
         _C.mad_ctpsa_pown_r(x, y.re, y.im, r)
    end
  elseif is_number(x) then                       -- num ^ ctpsa
    r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
    local logx = log(complex(x))
    _C.mad_ctpsa_scl_r(y, logx.re, logx.im, r)
    _C.mad_ctpsa_exp(r, r)
  elseif is_tpsa(y) then                         -- ctpsa ^ tpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_powt(x, y, r)
  elseif is_ctpsa(y) and is_ctpsa(x) then        -- ctpsa ^ ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_pow(x, y, r)
  else                                           -- ctpsa ^ ?
    return assert(gmm(y,'__pow_tpsa'), "invalid 'ctpsa ^ ?' operation")(x, y, r)
  end
  return r
end

function MC.__pow_cpx (x, y, r)                  -- cpx ^ ctpsa
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
  local logx = log(x)
  _C.mad_ctpsa_scl_r(y, logx.re, logx.im, r)
  _C.mad_ctpsa_exp(r, r) return r
end

-- element wise pow (.^)

function MR.__epow (x, y, r_)
  return assert(gmm(y,'__epow_tpsa'), "invalid 'tpsa .^ ?' operation")(x, y, r)
end

function MC.__epow (x, y, r_)
  return assert(gmm(y,'__epow_tpsa'), "invalid 'ctpsa .^ ?' operation")(x, y, r)
end

-- dif : r_i = (x_i - y_i) / max(|x_i|, 1)

local difsum, prtsum

function MR.dif (x, y, r, sum)
  if is_boolean(r) then sum, r = r end
  if is_tpsa(y) and is_tpsa(x) then              -- tpsa ~ tpsa
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_tpsa_dif(x, y, r)
  elseif is_ctpsa(y) then                        -- tpsa ~ ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_tdif(x, y, r)
  else
    error("invalid 'tpsa ~ ?' operation")
  end
  return r, sum and difsum(r) or nil
end

function MC.dif (x, y, r, sum)
  if is_boolean(r) then sum, r = r end
  if is_ctpsa(y) and is_ctpsa(x) then            -- ctpsa ~ ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_dif(x, y, r)
  elseif is_tpsa(y) then                         -- ctpsa ~ tpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_dift(x, y, r)
  else
    error("invalid 'ctpsa ~ ?' operation")
  end
  return r, sum and difsum(r, true) or nil
end

-- dif summary

function difsum (x, iscpx)
  local i, v = x:maxbyord()
  local s = { nam = x:nam(), mi = i, c={}, m={}, print=prtsum, iscpx=iscpx }
  for i=1,#v do
    s[i] = v[i]
    if v[i] > 0 then
      s.c[i] = x:get     (v[i])
      s.m[i] = x:get_mono(v[i])
    end
  end
  return s
end

-- print dif summary (method of summary)

function prtsum (s)
  local printf in MAD.utility

  printf(" %s = \n", s.nam:upper())
  if s.mi == 0 then
    io.write("         ALL COMPONENTS ZERO\n")
    return s
  end

  local fmt = option.numfmt ; option.numfmt = "% -.16e"
  for i=1,#s do
    if s[i]>0 then
      printf(" %-6d %s%-2d  %s  %s\n", s[i], s[i] == s.mi and "*" or " ",
             s.m[i]:ord(), s.iscpx and s.c[i]:tostring() or num2str(s.c[i]),
             s.m[i]:tostring())
    end
  end
  option.numfmt = fmt
  return s
end

-- tpsa functions -------------------------------------------------------------o

MR.nrm = \x -> _C.mad_tpsa_nrm(x)

function MR.abs (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_abs(x, r) return r
end

function MR.unit (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_unit(x, r) return r
end

function MR.integ (x, iv, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_integ(x, r, iv) return r
end

function MR.deriv (x, m, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  if is_natural(m) then
    _C.mad_tpsa_deriv(x, r, m)
  else
    if not is_monomial(m) then m = monomial(m) end
    _C.mad_tpsa_derivm(x, r, m.n, m._dat)
  end
  return r
end

function MR.poisbra (x, y, nv_, r)
  assert(is_nil(nv_) or is_natural(nv_),
         "invalid arguments (unsupported GTPSA operation '[,]')")
  if is_tpsa(y) then
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo,y.mo))
    _C.mad_tpsa_poisbra (x, y, r, nv_ or 0)
  elseif is_ctpsa(y) then
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo,y.mo))
    _C.mad_ctpsa_tpoisbra(x, y, r, nv_ or 0) return r
  else
    error("invalid arguments (unsupported GTPSA operation '[,]')")
  end
  return r
end

function MR.acc (x, v, r)  -- r += v*x
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_acc(x, v, r) return r
end

function MR.scl (x, v, r) -- r = v*x
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_scl(x, v, r) return r
end

function MR.inv (x, v_, r)  -- r = v/x
  if is_tpsa(v_) and is_nil(r) then
    v_, r = nil, v_ -- right shift
  end
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_inv(x, v_ or 1, r) return r
end

function MR.invsqrt (x, v_, r) -- r = v/sqrt(x)
  if is_tpsa(v_) and is_nil(r) then
    v_, r = nil, v_ -- right shift
  end
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_invsqrt(x, v_ or 1, r) return r
end

function MR.sqrt (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_sqrt(x, r) return r
end

function MR.exp (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_exp(x, r) return r
end

function MR.log (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_log(x, r) return r
end

function MR.sincos (x, rs, rc)
  rs = chksiz(rs,x) or tpsa_alloc(x.d, x.mo)
  rc = chksiz(rc,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_sincos(x, rs, rc) return rs, rc
end

function MR.sin (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_sin(x, r) return r
end

function MR.cos (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_cos(x, r) return r
end

function MR.tan (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_tan(x, r) return r
end

function MR.cot (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_cot(x, r) return r
end

function MR.sincosh (x, rs, rc)
  rs = chksiz(rs,x) or tpsa_alloc(x.d, x.mo)
  rc = chksiz(rc,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_sincosh(x, rs, rc) return rs, rc
end

function MR.sinh (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_sinh(x, r) return r
end

function MR.cosh (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_cosh(x, r) return r
end

function MR.tanh (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_tanh(x, r) return r
end

function MR.coth (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_coth(x, r) return r
end

function MR.asin (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_asin(x, r) return r
end

function MR.acos (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_acos(x, r) return r
end

function MR.atan (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_atan(x, r) return r
end

function MR.acot (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_acot(x, r) return r
end

function MR.asinh (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_asinh(x, r) return r
end

function MR.acosh (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_acosh(x, r) return r
end

function MR.atanh (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_atanh(x, r) return r
end

function MR.acoth (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_acoth(x, r) return r
end

function MR.sinc (x, r) -- sin(x)/x
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_sinc(x, r) return r
end

function MR.sinhc (x, r) -- sinh(x)/x
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_sinhc(x, r) return r
end

function MR.asinc (x, r) -- asin(x)/x
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_asinc(x, r) return r
end

function MR.asinhc (x, r) -- asinh(x)/x
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_asinhc(x, r) return r
end

function MR.erf (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_erf(x, r) return r
end

function MR.erfc (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_erfc(x, r) return r
end

function MR.hypot (x, y, r)
  r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_tpsa_hypot(x, y, r) return r
end

function MR.hypot3 (x, y, z, r)
  r = chksiz(r,x,y) and chksiz(r,z) or tpsa_alloc(x.d, max(x.mo,y.mo,z.mo))
  _C.mad_tpsa_hypot3(x, y, z, r) return r
end

function MR.atan2 (y, x, r)
  r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_tpsa_atan2(y, x, r) return r
end

-- Erf and Erfc (Faddeeva) based functions
MR.wf    = \x -> real(exp(-x^2)*erfc(-ix))
MR.erfi  = \x -> real(-1i*erf(1i*x))
MR.erfcx = \x -> exp(x^2)*erfc(x)

-- TODO: wf for TPSA (along with erf),
-- it seems that w(z) = exp(-z^2)*erfc(-iz)
--          and w(iz) = exp( z^2)*erfc(  z) are not stable at high orders.

-- ctpsa functions ------------------------------------------------------------o

MC.nrm = \x -> _C.mad_ctpsa_nrm(x)

MC.abs = \x,r -> MC.cabs(x, r)

function MC.cabs (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_cabs(x, r) return r
end

function MC.carg (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_carg(x, r) return r
end

function MC.rect (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_rect(x, r) return r
end

function MC.polar (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_polar(x, r) return r
end

function MC.unit (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_unit(x, r) return r
end

function MC.conj (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_conj(x, r) return r
end

function MC.integ (x, iv, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_integ(x, r, iv) return r
end

function MC.deriv (x, m, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  if is_natural(m) then
    _C.mad_ctpsa_deriv(x, r, m)
  else
    if not is_monomial(m) then m = monomial(m) end
    _C.mad_cpsa_derivm(x, r, m.n, m._dat)
  end
  return r
end

function MC.poisbra(x, y, nv_, r)
  assert(is_nil(nv_) or is_natural(nv_),
         "invalid arguments (unsupported GTPSA operation '[,]')")
  if is_tpsa(y) then
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo,y.mo))
    _C.mad_ctpsa_poisbrat (x, y, r, nv_ or 0)
  elseif is_ctpsa(y) then
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo,y.mo))
    _C.mad_ctpsa_poisbra(x, y, r, nv_ or 0)
  else
    error("invalid arguments (unsupported GTPSA operation '[,]')")
  end
  return r
end

function MC.acc (x, v, r)  -- r += v*x
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_acc(x, v, r) return r
end

function MC.scl (t, v, r) -- r = v*x
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_scl(t, v, r) return r
end

function MC.inv (x, v_, r)  -- r = v/x
  if is_ctpsa(v_) and is_nil(r) then
    v_, r = nil, v_ -- right shift
  end
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  v_ = complex(v_ or 1)
  _C.mad_ctpsa_inv_r(x, v_.re, v_.im, r) return r
end

function MC.invsqrt (x, v_, r) -- r = v/sqrt(x)
  if is_ctpsa(v_) and is_nil(r) then
    v_, r = nil, v_ -- right shift
  end
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  v_ = complex(v_ or 1)
  _C.mad_ctpsa_invsqrt(x, v_.re, v_.im, r) return r
end

function MC.sqrt (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_sqrt(x, r) return r
end

function MC.exp (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_exp(x, r) return r
end

function MC.log (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_log(x, r) return r
end

function MC.sincos (x, rs, rc)
  rs = chksiz(rs,x) or ctpsa_alloc(x.d, x.mo)
  rc = chksiz(rc,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_sincos(x, rs, rc) return rs, rc
end

function MC.sin (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_sin(x, r) return r
end

function MC.cos (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_cos(x, r) return r
end

function MC.tan (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_tan(x, r) return r
end

function MC.cot (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_cot(x, r) return r
end

function MC.sincosh (x, rs, rc)
  rs = chksiz(rs,x) or ctpsa_alloc(x.d, x.mo)
  rc = chksiz(rc,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_sincosh(x, rs, rc) return rs, rc
end

function MC.sinh (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_sinh(x, r) return r
end

function MC.cosh (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_cosh(x, r) return r
end

function MC.tanh (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_tanh(x, r) return r
end

function MC.coth (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_coth(x, r) return r
end

function MC.asin (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_asin(x, r) return r
end

function MC.acos (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_acos(x, r) return r
end

function MC.atan (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_atan(x, r) return r
end

function MC.acot (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_acot(x, r) return r
end

function MC.asinh (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_asinh(x, r) return r
end

function MC.acosh (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_acosh(x, r) return r
end

function MC.atanh (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_atanh(x, r) return r
end

function MC.acoth (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_acoth(x, r) return r
end

function MC.sinc (x, r) -- sin(x)/x
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_sinc(x, r) return r
end

function MC.sinhc (x, r) -- sinh(x)/x
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_sinhc(x, r) return r
end

function MC.asinc (x, r) -- asin(x)/x
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_asinc(x, r) return r
end

function MC.asinhc (x, r) -- asinh(x)/x
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_asinhc(x, r) return r
end

function MC.erf (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_erf(x, r) return r
end

function MC.erfc (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_erfc(x, r) return r
end

function MC.hypot (x, y, r)
  r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_ctpsa_hypot(x, y, r) return r
end

function MC.hypot3 (x, y, z, r)
  r = chksiz(r,x,y) and chksiz(r,z) or ctpsa_alloc(x.d, max(x.mo,y.mo,z.mo))
  _C.mad_ctpsa_hypot3(x, y, z, r) return r
end

-- Erf and Erfc (Faddeeva) based functions
MC.wf    = \x -> erfcx(1i*x)
MC.erfi  = \x -> -1i*erf(1i*x)
MC.erfcx = \x -> exp(x^2)*erfc(x)

-- TODO: wfun for TPSA,
-- it seems that w(z) = exp(-z^2)*erfc(-iz)
--          and w(iz) = exp( z^2)*erfc(  z) are not stable at high orders.

-- tpsa high level functions --------------------------------------------------o

function MR.axpb (x, a, b, r) -- r = ax+b
  assert(is_number(a) and is_number(b), "invalid argument #2 or #3 (number expected)")
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_axpb(a,x,b,r) return r
end

function MR.axpbypc (x, y, a, b, c, r) -- r = ax+by+c
  assert(is_tpsa(y), "invalid argument #2 (tpsa expected)")
  assert(is_number(a) and is_number(b) and is_number(c),
         "invalid argument #3, #4 or #5 (number expected)")
  r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_tpsa_axpbypc(a,x,b,y,c,r) return r
end

function MR.axypb (x, y, a, b, r) -- r = axy+b
  assert(is_tpsa(y), "invalid argument #2 (tpsa expected)")
  assert(is_number(a) and is_number(b), "invalid argument #3 or #4 (number expected)")
  r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_tpsa_axypb(a,x,y,b,r) return r
end

function MR.axypbzpc (x, y, z, a, b, c, r) -- r = axy+bz+c
  assert(is_tpsa(y) and is_tpsa(z), "invalid argument #2 or #3 (tpsa expected)")
  assert(is_number(a) and is_number(b) and is_number(c),
         "invalid argument #4, #5 or #6 (number expected)")
  r = chksiz(r,x,y) and chksiz(r,z) or tpsa_alloc(x.d, max(x.mo,y.mo,z.mo))
  _C.mad_tpsa_axypbzpc(a,x,y,b,z,c,r) return r
end

function MR.axypbvwpc (x, y, v, w, a, b, c, r) -- r = axy+bvw+c
  assert(is_tpsa(y) and is_tpsa(v) and is_tpsa(w),
         "invalid argument #2, #3 or #4 (tpsa expected)")
  assert(is_number(a) and is_number(b) and is_number(c),
         "invalid argument #5, #6 or #7 (number expected)")
  r = chksiz(r,x,y) and chksiz(r,v,w) and chksiz(r,x,v) or
      tpsa_alloc(x.d, max(x.mo,y.mo,v.mo,w.mo))
  _C.mad_tpsa_axypbvwpc(a,x,y,b,v,w,c,r) return r
end

function MR.ax2pby2pcz2 (x, y, z, a, b, c, r) -- r = ax^2+by^2+cz^2
  assert(is_tpsa(y) and is_tpsa(z), "invalid argument #2 or #3 (tpsa expected)")
  assert(is_number(a) and is_number(b) and is_number(c),
         "invalid argument #4, #5 or #6 (number expected)")
  r = chksiz(r,x,y) and chksiz(r,x,z) or tpsa_alloc(x.d, max(x.mo,y.mo,z.mo))
  _C.mad_tpsa_ax2pby2pcz2(a,x,b,y,c,z,r) return r
end

function MR.axpsqrtbpcx2 (x, a, b, c, r) -- r = ax+sqrt(b+cx^2)
  assert(is_number(a) and is_number(b) and is_number(c),
         "invalid argument #2, #3 or #4 (scalar expected)")
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_axpsqrtbpcx2(x, a, b, c, r) return r
end

function MR.logaxpsqrtbpcx2 (x, a, b, c, r) -- r = log(ax+sqrt(b+cx^2))
  assert(is_number(a) and is_number(b) and is_number(c),
         "invalid argument #2, #3 or #4 (scalar expected)")
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_logaxpsqrtbpcx2(x, a, b, c, r) return r
end

function MR.logxdy (x, y, r) -- r = log(x/y)
  assert(is_tpsa(y), "invalid argument #2 (tpsa expected)")
  r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_tpsa_logxdy(x, y, r) return r
end

-- ctpsa high level functions -------------------------------------------------o

function MC.axpb (x, a, b, r) -- r = ax+b
  assert(is_scalar(a) and is_scalar(b), "invalid argument #2 or #3 (scalar expected)")
  a, b = complex(a), complex(b)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_axpb_r(a.re,a.im, x, b.re,b.im, r) return r
end

function MC.axpbypc (x, y, a, b, c, r) -- r = ax+by+c
  assert(is_ctpsa(y), "invalid argument #2 (ctpsa expected)")
  assert(is_scalar(a) and is_scalar(b) and is_scalar(c),
         "invalid argument #3, #4 or #5 (scalar expected)")
  a, b, c = complex(a), complex(b), complex(c)
  r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_ctpsa_axpbypc_r(a.re,a.im, x, b.re,b.im, y, c.re,c.im, r) return r
end

function MC.axypb (x, y, a, b, r) -- r = axy+b
  assert(is_ctpsa(y), "invalid argument #2 (ctpsa expected)")
  assert(is_scalar(a) and is_scalar(b), "invalid argument #3 or #4 (scalar expected)")
  a, b = complex(a), complex(b)
  r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_ctpsa_axypb_r(a.re,a.im, x, y, b.re,b.im, r) return r
end

function MC.axypbzpc (x, y, z, a, b, c, r) -- r = axy+bz+c
  assert(is_ctpsa(y) and is_ctpsa(z), "invalid argument #2 or #3 (ctpsa expected)")
  assert(is_scalar(a) and is_scalar(b) and is_scalar(c),
         "invalid argument #4, #5 or #6 (scalar expected)")
  a, b, c = complex(a), complex(b), complex(c)
  r = chksiz(r,x,y) and chksiz(r,z) or ctpsa_alloc(x.d, max(x.mo,y.mo,z.mo))
  _C.mad_ctpsa_axypbzpc_r(a.re,a.im, x, y, b.re,b.im, z, c.re,c.im, r) return r
end

function MC.axypbvwpc (x, y, v, w, a, b, c, r) -- r = axy+bvw+c
  assert(is_ctpsa(y) and is_ctpsa(v) and is_ctpsa(w),
         "invalid argument #2, #3 or #4 (ctpsa expected)")
  assert(is_scalar(a) and is_scalar(b) and is_scalar(c),
         "invalid argument #5, #6 or #7 (scalar expected)")
  a, b, c = complex(a), complex(b), complex(c)
  r = chksiz(r,x,y) and chksiz(r,v,w) and chksiz(r,x,v) or
      ctpsa_alloc(x.d, max(x.mo,y.mo,v.mo,w.mo))
  _C.mad_ctpsa_axypbvwpc_r(a.re,a.im, x,y, b.re,b.im, v,w, c.re,c.im, r) return r
end

function MC.ax2pby2pcz2 (x, y, z, a, b, c, r) -- r = ax^2+by^2+cz^2
  assert(is_ctpsa(y) and is_ctpsa(z), "invalid argument #2 or #3 (ctpsa expected)")
  assert(is_scalar(a) and is_scalar(b) and is_scalar(c),
         "invalid argument #4, #5 or #6 (scalar expected)")
  a, b, c = complex(a), complex(b), complex(c)
  r = chksiz(r,x,y) and chksiz(r,x,z) or ctpsa_alloc(x.d, max(x.mo,y.mo,z.mo))
  _C.mad_ctpsa_ax2pby2pcz2_r(a.re,a.im, x, b.re,b.im, y, c.re,c.im, z, r) return r
end

function MC.axpsqrtbpcx2 (x, a, b, c, r) -- r = ax+sqrt(b+cx^2)
  assert(is_scalar(a) and is_scalar(b) and is_scalar(c),
         "invalid argument #2, #3 or #4 (scalar expected)")
  a, b, c = complex(a), complex(b), complex(c)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_axpsqrtbpcx2_r(x, a.re,a.im, b.re,b.im, c.re,c.im, r) return r
end

function MC.logaxpsqrtbpcx2 (x, a, b, c, r) -- r = log(ax+sqrt(b+cx^2))
  assert(is_scalar(a) and is_scalar(b) and is_scalar(c),
         "invalid argument #2, #3 or #4 (scalar expected)")
  a, b, c = complex(a), complex(b), complex(c)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_logaxpsqrtbpcx2_r(x, a.re,a.im, b.re,b.im, c.re,c.im, r) return r
end

function MC.logxdy (x, y, r) -- r = log(x/y)
  assert(is_ctpsa(y), "invalid argument #2 (tpsa expected)")
  r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_ctpsa_logxdy(x, y, r) return r
end

-- I/O ------------------------------------------------------------------------o

function MR.write (x, filnam_, name_, tol_, nohdr_)
  if is_number(name_) and is_nil(tol_) then
    name_, tol_ = nil, name_ -- right shift
  end

  local file = assert(openfile(filnam_, 'w', '.dat'),
                      "unable to open GTPSA file in write mode")
  _C.mad_tpsa_print(x, name_, tol_ or option.prteps, nohdr_ or 0, file)

  if is_string(filnam_) then file:close() else file:flush() end
  return x
end

function MC.write (x, filnam_, name_, tol_, nohdr_)
  if is_number(name_) and is_nil(tol_) then
    name_, tol_ = nil, name_ -- right shift
  end

  local file = assert(openfile(filnam_, 'w', '.dat'),
                      "unable to open GTPSA file in write mode")
  _C.mad_ctpsa_print(x, name_, tol_ or option.prteps, nohdr_ or 0, file)

  if is_string(filnam_) then file:close() else file:flush() end
  return x
end

function MR.print (x, name_, tol_, nohdr_)
  return x:write(nil, name_, tol_, nohdr_)
end

local cbuf = chr_arr(_C.NAMSZ) -- GTPSA name, see NAMSZ in mad_tpsa.h

function MR.read (x_, filnam_, kind_)
  local file = assert(openfile(filnam_, 'r', '.dat'),
                      "unable to open GTPSA file in read mode")
  int[0] = kind_ == "R" and 0 or kind_ == "C" and 1 or -1 -- 0:R, 1:C, -1:detect

  local d, x = _C.mad_tpsa_scan_hdr(int, cbuf, file)
  if d ~= nil then
    if int[0] == 1
    then x = ctpsa(d) _C.mad_ctpsa_nam(x,cbuf) _C.mad_ctpsa_scan_coef(x,file)
    else x = tpsa (d) _C. mad_tpsa_nam(x,cbuf) _C. mad_tpsa_scan_coef(x,file)
    end
  end

  if is_string(filnam_) then file:close() end
  return x -- return nil if no GTPSA found
end

-- iterators ------------------------------------------------------------------o

local function riterx (x, i)
  i = _C.mad_tpsa_cycle(x, i, 0, nil, val)
  if i >= 0 then return i, val[0] end
end

local function citerx (x, i)
  i = _C.mad_ctpsa_cycle(x, i, 0, nil, cval)
  if i >= 0 then return i, cval[0] end
end

local function riters (s, i)
  i = _C.mad_tpsa_cycle(s.x, i, s.m.n, s.m._dat, val)
  if i >= 0 then return i, val[0], s.m end
end

local function citers (s, i)
  i = _C.mad_ctpsa_cycle(s.x, i, s.m.n, s.m._dat, cval)
  if i >= 0 then return i, cval[0], s.m end
end

local function mkiter (x, m_, i_)
  if is_number(m_) and is_nil(i_) then i_, m_ = m_, nil end -- right shift
  if m_ then
    if not is_monomial(m_) then m_ = monomial(m_) end
    return is_tpsa(x) and riters or citers, {x=x, m=m_}, (i_ or 0)-1
  else
    return is_tpsa(x) and riterx or citerx, x, (i_ or 0)-1
  end
end

MR.__ipairs, MR.iter = mkiter, mkiter
MC.__ipairs, MC.iter = mkiter, mkiter

-- metamethods ----------------------------------------------------------------o

MR.unm = \x,r_ -> MR.__unm(x,nil,r_)
MC.unm = \x,r_ -> MC.__unm(x,nil,r_)

MR.  add, MR.  sub, MR.  mul, MR.  div, MR.  pow =
MR.__add, MR.__sub, MR.__mul, MR.__div, MR.__pow

MC.  add, MC.  sub, MC.  mul, MC.  div, MC.  pow =
MC.__add, MC.__sub, MC.__mul, MC.__div, MC.__pow

MR.  emul, MR.  ediv, MR.  emod, MR.  epow =
MR.__emul, MR.__ediv, MR.__emod, MR.__epow

MC.  emul, MC.  ediv, MC.  emod, MC.  epow =
MC.__emul, MC.__ediv, MC.__emod, MC.__epow

MR.  eq, MR.  lt, MR.  le, MR.  same, MR.  copy =
MR.__eq, MR.__lt, MR.__le, MR.__same, MR.__copy

MC.  eq, MC.  lt, MC.  le, MC.  same, MC.  copy =
MC.__eq, MC.__lt, MC.__le, MC.__same, MC.__copy

MD.__index = MD
MR.__index = MR
MC.__index = MC

function MD.__newindex (_, i)
  error("invalid GTPSAD member '".. tostring(i) .."'")
end

function MR.__newindex (_, i)
  error("invalid GTPSA member '".. tostring(i) .."'")
end

-- MR -> MC -------------------------------------------------------------------o

for k,v in pairs(MR) do
  if is_nil(MC[k]) then MC[k] = v end
end

-- TODO: set concepts for MR and MC

-- env ------------------------------------------------------------------------o

MAD.typeid.is_gtpsad = is_gtpsad
MAD.typeid.is_tpsa   = is_tpsa
MAD.typeid.is_ctpsa  = is_ctpsa
MAD.typeid.isa_tpsa  = isa_tpsa

-- metatables -----------------------------------------------------------------o

MD.__metatable = MD
MR.__metatable = MR
MC.__metatable = MC

ffi.metatype( desc_ctor, MD)
ffi.metatype( tpsa_ctor, MR)
ffi.metatype(ctpsa_ctor, MC)

-- end ------------------------------------------------------------------------o
return {
   tpsa  =  tpsa,
  ctpsa  = ctpsa,
  gtpsad = gtpsad,
  gtpsad_del = gtpsad_del,
  -- __help = require 'madh_gtpsa',
}
