--[=[
 o-----------------------------------------------------------------------------o
 |
 | Generalised Truncated Power Series Algebra module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides full set of functions and operations on real and complex TPSA.
  - Support monomials with parameters and inhomogeneous orders.

 o-----------------------------------------------------------------------------o
]=]

local MR, MC = {}, {}

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'
local istype   in ffi
local min, max in math

local _C, option, tostring, complex, vector, cvector, monomial in MAD
local log, exp                                                 in MAD.gmath
local openfile, strtrim                                        in MAD.utility

-- To review
local is_nil, is_number, is_integer, is_complex, is_scalar,
      is_string, is_table, is_matrix, is_cmatrix, is_vector,
      is_cvector, is_monomial, is_lengthable, is_iterable,
      is_mappable, get_metamethod                                  in MAD.typeid

-- tmp for returned values
local  res = ffi.new  'num_t[1]'
local cres = ffi.new 'cnum_t[1]'

-- constants
local dbl_sz = ffi.sizeof  'num_t'
local cpx_sz = ffi.sizeof 'cnum_t'

-- array of indexes
local int_arr = ffi.typeof 'idx_t [?]'

-- tpsa names
local chr_arr = ffi.typeof 'char [?]'

local assert, error, tostring =
      assert, error, tostring

local gmm = get_metamethod

-- types ----------------------------------------------------------------------o

ffi.cdef [[
typedef uint64_t bit_t; // mad_bit.h

struct desc { // warning: must be kept identical to C definition
  const int   id;          // index in list of registered descriptors
  const int   nn, nv, np;  // #variables, #parameters, nn=nv+np <= 100000
  const ord_t mo, po, to;  // max order of vars & params, global order of truncation
  const ord_t *const no;   // orders of each vars & params, no[nn]
};            // end of compatibility with Lua FFI (rest is not visible)

struct tpsa { // warning: must be kept identical to C definition and ctpsa
  const desc_t *const d;  // ptr to tpsa descriptor
  int32_t           uid;  // special "user" field for external use (padding)
  const ord_t mo, lo, hi; // max ord (allocated), lowest/highest used ord
  const bit_t nz;         // zero/non-zero homogeneous polynomials
  const char  nam_[16];   // tpsa name (hidden)
  const num_t coef[?];
};

struct ctpsa { // warning: must be kept identical to C definition and tpsa
  const desc_t *const d;  // ptr to cptsa descriptor
  int32_t           uid;  // special "user" field for external use (padding)
  const ord_t mo, lo, hi; // max ord (allocated), lowest/highest used ord
  const bit_t nz;         // zero/non-zero homogeneous polynomials
  const char  nam_[16];   // tpsa name (hidden)
  const cnum_t coef[?];
};
]]

local gtpsad_ctor = ffi.typeof 'struct  desc'
local   tpsa_ctor = ffi.typeof 'struct  tpsa'
local  ctpsa_ctor = ffi.typeof 'struct ctpsa'

local  tpsa_cref  = ffi.typeof 'struct  tpsa&'
local ctpsa_cref  = ffi.typeof 'struct ctpsa&'

local  tpsa_size  = ffi.offsetof( tpsa_ctor, 'coef')
local ctpsa_size  = ffi.offsetof(ctpsa_ctor, 'coef')

local is_gtpsad = \x -> istype(gtpsad_ctor, x)
local is_tpsa   = \x -> istype( tpsa_ctor , x)
local is_ctpsa  = \x -> istype(ctpsa_ctor , x)
local isa_tpsa  = \x -> is_tpsa(x) or is_ctpsa(x)

-- locals for arg and ret

local  int = ffi.new    'int[1]'
local  ord = ffi.new  'ord_t[1]'
local  val = ffi.new  'num_t[1]'
local cval = ffi.new 'cnum_t[1]'

-- descriptors ----------------------------------------------------------------o

--[=[
  variables + parameters

  nv: number of vars         (number)
  mo: max vars order         (number)
  np: number of parameters   (number of parameters, as right part of variables)
  no: vars+params orders     (string or array, discard/override nv and mo)
  po: parameters cross-order (number)

  default: nv=6, mo=1, np=0, po=0, no=nil

  gtpsad(nil)                            : 6 vars of order 1.
  gtpsad(3)         -> nv=3              : 3 vars of order 1.
  gtpsad{mo=3}      -> mo=3              : 6 vars of order 3.
  gtpsad(4,3)       -> nv=4,mo=3         : 4 vars of order 3.
  gtpsad{nv=4,mo=3}                      : as above.
  gtpsad(4,2,2,1) -> nv=4,mo=2,np=2,po=1 : 4 vars of order 2 and..
  gtpsad{nv=4,mo=2,np=2,po=1}            : ..2 parameters of order 1.
  gtpsad{nv=6,mo=2,np=94,po=1}           : 6 vars of order 2 and..
                                         : ..94 parameters of order 1.
  gtpsad{nv=2,np=2,no={3,3,1,1},po=1}    : 2 vars + 2 params of orders 3,3,1,1..
         -> mo=3                         : with x-order limited to 1.
--]=]

local function gtpsad (nv_, mo_, np_, po_)
  local is = is_mappable(nv_)
  local nv = is and nv_.nv or nv_ or 6   -- number of variables
  local mo = is and nv_.mo or mo_ or 1   -- variables order
  local np = is and nv_.np or np_ or 0   -- number of parameters
  local po = is and nv_.po or po_ or 0   -- parameters max cross-order
  local no = is and nv_.no or nil        -- variables orders
  local d
  if is_nil(no) then
    d = _C.mad_desc_newvp(nv,np,mo,po)
  else
    if not is_monomial(no) then no = monomial(no) end
    assert(#no == nv+np, "invalid number of orders (#no ~= nv+np)")
    d = _C.mad_desc_newvpo(nv,np,no._dat,po)
  end
  return assert(d, "unexpected null descriptor")
end

local function gtpsad_release (td)
  _C.mad_desc_del(td)
end

gtpsad() -- build and set default desc to nv=6,mo=1

-- allocators -----------------------------------------------------------------o

local function tpsa_alloc (d, mo)
  local len = _C.mad_desc_ordlen(d, mo)
  assert(len <= 2^30, "tpsa is too large")
  local tpsa = tpsa_ctor(len) -- VLA (hooked immediately before calling C)
  _C.mad_tpsa_init(tpsa, d, mo)
  return tpsa
end

local function ctpsa_alloc (d, mo)
  local len = _C.mad_desc_ordlen(d, mo)
   assert(len <= 2^29, "ctpsa is too large")
  local ctpsa = ctpsa_ctor(len) -- VLA (hooked immediately before calling C)
  _C.mad_ctpsa_init(ctpsa, d, mo)
  return ctpsa
end

-- ctors ----------------------------------------------------------------------o

-- tpsa()        -> last d
-- tpsa(mo)      -> last d, mo
-- tpsa(d)       -> d, d.mo
-- tpsa(t)       -> t.d, t.mo
-- tpsa(t|d, mo) -> t.d|d, mo

local function tpsa (td, mo_)
  if is_number(td) and is_nil(mo_) then
    mo_, td = td -- right shift
  end

  if is_nil(td) then
    td = assert(_C.mad_desc_curr, "unexpected null descriptor")
  end

  local mo = mo_ or td.mo
  assert(is_integer(mo), "invalid argument #2 (integer expected)")

  if isa_tpsa(td) then
    td = assert(td.d, "unexpected null descriptor")
  end

  return tpsa_alloc(td, max(0, min(mo, td.mo)))
end

local function ctpsa (td, mo_)
  if is_number(td) and is_nil(mo_) then
    mo_, td = td -- right shift
  end

  if is_nil(td) then
    td = assert(_C.mad_desc_curr, "unexpected null descriptor")
  end

  local mo = mo_ or td.mo
  assert(is_integer(mo), "invalid argument #2 (integer expected)")

  if isa_tpsa(td) then
    td = assert(td.d, "unexpected null descriptor")
  end

  return ctpsa_alloc(td, max(0, min(mo, td.mo)))
end

-- checkers -------------------------------------------------------------------o

local function chksiz (r, x, y) -- add, sub, mul
  y = y or x
  assert(x.d == y.d and (is_nil(r) or r.d == x.d and r.mo >= max(x.mo,y.mo)),
         "incompatible GTPSA order or descriptor")
  return r
end

-- maxlen, ordlen, gtrunc, debug ----------------------------------------------o

MR.__len  = \x     -> _C.mad_tpsa_len (x)
MC.__len  = \x     -> _C.mad_ctpsa_len(x)

MR.ord    = \x     -> _C.mad_tpsa_ord (x)
MC.ord    = \x     -> _C.mad_ctpsa_ord(x)

MR.nv     = \x     -> _C.mad_desc_getnv (x.d,nil,nil,nil)
MR.np     = \x     => _C.mad_desc_getnv (x.d,nil,int,ord) return int[0],ord[0] end
MR.maxord = \x     -> _C.mad_desc_maxord(x.d)
MR.maxlen = \x     -> _C.mad_desc_maxlen(x.d)
MR.ordlen = \x,mo_ -> _C.mad_desc_ordlen(x.d,mo_ or x.mo)
MR.gtrunc = \x,to_ -> _C.mad_desc_gtrunc(x.d,to_ or _C.mad_tpsa_same)

MR.nam    = \x     -> ffi.string(_C.mad_tpsa_nam (x))
MC.nam    = \x     -> ffi.string(_C.mad_ctpsa_nam(x))

MR.setnam = \x,s   => _C.mad_tpsa_setnam (x,s) return x end
MC.setnam = \x,s   => _C.mad_ctpsa_setnam(x,s) return x end

MR.isvalid = \x    -> _C.mad_tpsa_isvalid (x)
MC.isvalid = \x    -> _C.mad_ctpsa_isvalid(x)

MR.debug = \x,nam_,fnam_,lin_,fil_ => _C.mad_tpsa_debug (x,nam_,fnam_,lin_ or 0,fil_) end
MC.debug = \x,nam_,fnam_,lin_,fil_ => _C.mad_ctpsa_debug(x,nam_,fnam_,lin_ or 0,fil_) end

function MR.nxtbyvar (x, m) -- mono -> idx (-1 means invalid or no more)
  if not is_monomial(m) then m = monomial(m) end
  return _C.mad_desc_nxtbyvar(x.d, m.n, m._dat), m
end

function MR.nxtbyord (x, m) -- mono -> idx (-1 means invalid or no more)
  if not is_monomial(m) then m = monomial(m) end
  return _C.mad_desc_nxtbyord(x.d, m.n, m._dat), m
end

-- same, copy, getord, cutord, convert, setvar, clear -------------------------o

-- x:same()
-- x:same(e)
-- x:same(e,mo)
-- x:same(nil,mo)
-- x:same(mo) => x:same(e), i.e. wrong order

function MR.__same (x, e_, mo_)
  if is_nil(e_) or is_number(e_) then
    return  tpsa_alloc(x.d, mo_ or x.mo)
  elseif is_complex(e_) then
    return ctpsa_alloc(x.d, mo_ or x.mo)
  else
    error("invalid argument #2 (nil or scalar expected)")
  end
end

function MC.__same (x, e_, mo_)
  if is_nil(e_) or is_complex(e_) then
    return ctpsa_alloc(x.d, mo_ or x.mo)
  elseif is_number(e_) then
    return  tpsa_alloc(x.d, mo_ or x.mo)
  else
    error("invalid argument #2 (nil or scalar expected)")
  end
end

function MR.__copy (x, y_)
  if is_nil(y_) then
    y_ = tpsa_alloc(x.d, x.mo)
   _C.mad_tpsa_copy(x, y_)
  elseif is_tpsa(y_) then
   _C.mad_tpsa_copy(chksiz(x,y_), y_)
  else
    assert(is_ctpsa(y_), "invalid argument #2 (tpsa or ctpsa expected)")
    _C.mad_ctpsa_cplx(chksiz(x,y_), nil, y_)
  end
  return y_
end

function MC.__copy (x, y_)
  if is_nil(y_) then
    y_ = ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_copy(x, y_)
  elseif is_ctpsa(y_) then
    _C.mad_ctpsa_copy(chksiz(x,y_), y_)
  else
    assert(is_tpsa(y_), "invalid argument #2 (tpsa or ctpsa expected)")
    _C.mad_ctpsa_real(chksiz(x,y_), y_)
  end
  return y_
end

function MR.sclord (x, inv_, y_)
  if is_nil(y_) then
    y_ = tpsa_alloc(x.d, x.mo)
    _C.mad_tpsa_sclord(x, y_, inv_ or false)
  else
    assert(is_tpsa(y_), "invalid argument #3 (tpsa expected)")
    _C.mad_tpsa_sclord(chksiz(x,y_), y_, inv_ or false)
  end
  return y_
end

function MC.sclord (x, inv_, y_)
  if is_nil(y_) then
    y_ = ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_sclord(x, y_, inv_ or false)
  else
    assert(is_ctpsa(y_), "invalid argument #3 (ctpsa expected)")
    _C.mad_ctpsa_sclord(chksiz(x,y_), y_, inv_ or false)
  end
  return y_
end

function MR.getord (x, o, y_)
  if is_nil(y_) then
    y_ = tpsa_alloc(x.d, x.mo)
    _C.mad_tpsa_getord(x, y_, o)
  else
    assert(is_tpsa(y_), "invalid argument #3 (tpsa expected)")
    _C.mad_tpsa_getord(chksiz(x,y_), y_, o)
  end
  return y_
end

function MC.getord (x, o, y_)
  if is_nil(y_) then
    y_ = ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_getord(x, y_, o)
  else
    assert(is_ctpsa(y_), "invalid argument #3 (ctpsa expected)")
    _C.mad_ctpsa_getord(chksiz(x,y_), y_, o)
  end
  return y_
end

function MR.cutord (x, o, y_)
  if is_nil(y_) then
    y_ = tpsa_alloc(x.d, x.mo)
    _C.mad_tpsa_cutord(x, y_, o)
  else
    assert(is_tpsa(y_), "invalid argument #3 (tpsa expected)")
    _C.mad_tpsa_cutord(chksiz(x,y_), y_, o)
  end
  return y_
end

function MC.cutord (x, o, y_)
  if is_nil(y_) then
    y_ = ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_cutord(x, y_, o)
  else
    assert(is_ctpsa(y_), "invalid argument #3 (ctpsa expected)")
    _C.mad_ctpsa_cutord(chksiz(x,y_), y_, o)
  end
  return y_
end

function MR.convert (x, y, tbl_, pb_)
  assert(is_tpsa(y), "invalid argument #2 (tpsa expected)")
  local pb, n, m = pb_ or 0, 0, nil
  if tbl_ then
    assert(is_table(tbl_), "invalid argument #3 (table expected)")
    assert(pb==0 or pb==1 or pb==-1, "invalid argument #4 (-1,0,1 expected)")
    n = #tbl_
    m = int_arr(n) ; for i=1,n do m[i-1] = tbl_[i]-1 end
  end
  _C.mad_tpsa_convert(x, y, n, m, pb) return y
end

function MC.convert (x, y, tbl_, pb_)
  assert(is_ctpsa(y), "invalid argument #2 (ctpsa expected)")
  local pb, n, m = pb_ or 0, 0, nil
  if tbl_ then
    assert(is_table(tbl_), "invalid argument #3 (table expected)")
    assert(pb==0 or pb==1 or pb==-1, "invalid argument #4 (-1,0,1 expected)")
    n = #tbl_
    m = int_arr(n) ; for i=1,n do m[i-1] = tbl_[i]-1 end
  end
  _C.mad_ctpsa_convert(x, y, n, m, pb) return y
end

function MR.setvar (x, e_, iv_, scl_) -- clear + set0(e) + set1(iv, scl or 1)
  _C.mad_tpsa_setvar(x, e_ or 0, iv_ or 0, scl_ or 0) return x
end

function MC.setvar (x, e_, iv_, scl_) -- clear + set0(e) + set1(iv, scl or 1)
  e_, scl_ = complex(e_ or 0), complex(scl_ or 0)
  _C.mad_ctpsa_setvar_r(x, e_.re, e_.im, iv_ or 0, scl_.re, scl_.im) return x
end

function MR.clear (x)
  _C.mad_tpsa_clear(x) return x
end

function MC.clear (x)
  _C.mad_ctpsa_clear(x) return x
end

MR.isnul = \x -> _C.mad_tpsa_isnul(x)
MC.isnul = \x -> _C.mad_ctpsa_isnul(x)

-- indexing -------------------------------------------------------------------o

function MR.get_idx (x, m) -- mono -> idx (0 means invalid)
  if is_string(m) then return _C.mad_tpsa_idxs(x, #m, m)+1 end
  if not is_monomial(m) then m = monomial(m) end
  return _C.mad_tpsa_idxm(x, m.n, m._dat)+1
end

function MC.get_idx (x, m) -- mono -> idx (0 means invalid)
  if is_string(m) then return _C.mad_ctpsa_idxs(x, #m, m)+1 end
  if not is_monomial(m) then m = monomial(m) end
  return _C.mad_ctpsa_idxm(x, m.n, m._dat)+1
end

function MR.get_idx_sparse (x, tbl) -- tbl = {idx1, ord1, idx2, ord2, ... } -> idx
  assert(is_table(tbl), "invalid argument #2 (table expected)")
  local n = #tbl
  local m = int_arr(n) ; for i=1,n do m[i-1] = tbl[i] end
  return _C.mad_tpsa_idxsm(x, n, m)+1
end

function MC.get_idx_sparse (x, tbl) -- tbl = {idx1, ord1, idx2, ord2, ... } -> idx
  assert(is_table(tbl), "invalid argument #2 (table expected)")
  local n = #tbl
  local m = int_arr(n) ; for i=1,n do m[i-1] = tbl[i] end
  return _C.mad_ctpsa_idxsm(x, n, m)+1
end

function MR.get_mono (x, i, r) -- idx -> mono
  assert(is_integer(i), "invalid argument #2 (index expected)")
  local m = r or monomial(x.d.nn)
  assert(is_monomial(m), "invalid argument #2 (table or monomial expected)")
  return _C.mad_tpsa_mono(t, m.n, m._dat, i-1) -- set m, return order
end

function MC.get_mono (x, i, r) -- idx -> mono
  assert(is_integer(i), "invalid argument #2 (index expected)")
  local m = r or monomial(x.d.nn)
  assert(is_monomial(m), "invalid argument #2 (table or monomial expected)")
  return _C.mad_ctpsa_mono(t, m.n, m._dat, i-1) -- set m, return order
end

function MR.cycle (x, i, m_) -- loop over indexes for non-zero value, (i=0 means end)
  if m_ then
    if not is_monomial(m_) then m_ = monomial(m_) end
    i = _C.mad_tpsa_cycle(x, m_.n, m_._dat, i-1, val)
  else
    i = _C.mad_tpsa_cycle(x, 0   , nil    , i-1, val)
  end
  return i+1, val[0], m_
end

function MC.cycle (x, i, m_) -- loop over indexes for non-zero value, (i=0 means end)
  if m_ then
    if not is_monomial(m_) then m_ = monomial(m_) end
    i = _C.mad_ctpsa_cycle(x, m_.n, m_._dat, i-1, cval)
  else
    i = _C.mad_ctpsa_cycle(x, 0   , nil    , i-1, cval)
  end
  return i+1, cval[0], m_
end

function MR.totable (x, p)
  local m = monomial(p == true and x.d.nn or x.d.nv)
  local t = table.new(#x,#x)
  local i, n, v = 0, 1
  while true do
    i, v = x:cycle(i, m)
    if i == 0 then break end
    local s = m:tostring()
    t[n], t[s], n = s, v, n+1
  end
  return t
end

function MR.fromtable (x, t)
  for i,s in ipairs(t) do x:set(s, t[s]) end
  return x
end

-- getters and setters --------------------------------------------------------o

function MR.get0 (x)
  return x.coef[0]
end

function MC.get0 (x)
  return x.coef[0]
end

function MR.set0 (x, a, b)
  if is_nil(b) then a, b = 0, a end
  _C.mad_tpsa_set0(x, a, b) return x
end

function MC.set0 (x, a, b)
  if is_nil(b) then a, b = 0, a end
  a, b = complex(a), complex(b)
  _C.mad_ctpsa_set0_r(x, a.re, a.im, b.re, b.im) return x
end

function MR.get (x, m) -- idx or str or mono -> num
  if is_integer(m) then
    return m == 1 and x.coef[0] or _C.mad_tpsa_geti(x, m-1)
  elseif is_string(m) then
    return _C.mad_tpsa_gets(x, #m, m)
  else
    if not is_monomial(m) then m = monomial(m) end
    return _C.mad_tpsa_getm(x, m.n, m._dat)
  end
end

function MC.get (x, m) -- idx or str or mono -> cnum
  if is_integer(m) then
    if m == 1
    then return x.coef[0]
    else _C.mad_ctpsa_geti_r(x, m-1, cres)
    end
  elseif is_string(m) then
    _C.mad_ctpsa_gets_r(x, #m, m, cres)
  else
    if not is_monomial(m) then m = monomial(m) end
    _C.mad_ctpsa_getm_r(x, m.n, m._dat, cres)
  end
  return cres[0]
end

function MR.set (x, m, a, b)
  if is_nil(b) then a, b = 0, a end
  if is_integer(m) then
    if m == 1
    then _C.mad_tpsa_set0(x,      a, b)
    else _C.mad_tpsa_seti(x, m-1, a, b)
    end
  elseif is_string(m) then
    _C.mad_tpsa_sets(x, #m, m, a, b)
  else
    if not is_monomial(m) then m = monomial(m) end
    _C.mad_tpsa_setm(x, m.n, m._dat, a, b)
  end
  return x
end

function MC.set (x, m, a, b)
  if is_nil(b) then a, b = 0, a end
  a, b = complex(a), complex(b)
  if is_integer(m) then
    if m == 1
    then _C.mad_ctpsa_set0_r(x,      a.re, a.im, b.re, b.im)
    else _C.mad_ctpsa_seti_r(x, m-1, a.re, a.im, b.re, b.im)
    end
  elseif is_string(m) then
    _C.mad_ctpsa_sets_r(x, #m, m, a.re, a.im, b.re, b.im)
  else
    if not is_monomial(m) then m = monomial(m) end
    _C.mad_ctpsa_setm_r(x, m.n, m._dat, a.re, a.im, b.re, b.im)
  end
  return x
end

-- sparse getters and setters -------------------------------------------------o

function MR.get_sparse (x, tbl) -- tbl = {idx1, ord1, idx2, ord2, ... } -> num
  assert(is_table(tbl), "invalid argument #2 (table expected)")
  local n = #tbl
  local m = int_arr(n) ; for i=1,n do m[i-1] = tbl[i] end
  return _C.mad_tpsa_getsm(x, n, m)
end

function MC.get_sparse (x, tbl) -- tbl = {idx1, ord1, idx2, ord2, ... } -> cnum
  assert(is_table(tbl), "invalid argument #2 (table expected)")
  local n = #tbl
  local m = int_arr(n) ; for i=1,n do m[i-1] = tbl[i] end
  _C.mad_ctpsa_getsm_r(x, n, m, cres) return cres[0]
end

function MR.set_sparse (x, tbl, a, b) -- tbl = {idx1, ord1, idx2, ord2, ... }
  assert(is_table(tbl), "invalid argument #2 (table expected)")
  if is_nil(b) then a, b = 0, a end
  local n = #tbl
  local m = int_arr(n) ; for i=1,n do m[i-1] = tbl[i] end
  _C.mad_tpsa_setsm(x, n, m, a, b) return x
end

function MC.set_sparse (x, tbl, a, b) -- tbl = {idx1, ord1, idx2, ord2, ... }
  assert(is_table(tbl), "invalid argument #2 (table expected)")
  if is_nil(b) then a, b = 0, a end
  a, b = complex(a), complex(b)
  local n = #tbl
  local m = int_arr(n) ; for i=1,n do m[i-1] = tbl[i] end
  _C.mad_ctpsa_setsm_r(x, n, m, a.re, a.im, b.re, b.im) return x
end

-- table/vector getters and setters -------------------------------------------o

function MR.getvec (x, i, a)
  assert(is_integer(i), "invalid argument #2 (integer expected)")
  if is_integer(a) then a = vector(a) end
  assert(is_matrix (a), "invalid argument #3 (integer or vector expected)")
  _C.mad_tpsa_getv(x, i-1, a:size(), a._dat) return a
end

function MC.getvec (x, i, a)
  assert(is_integer(i), "invalid argument #2 (integer expected)")
  if is_integer(a) then a = cvector(a) end
  assert(is_cmatrix(a), "invalid argument #3 (integer or cvector expected)")
  _C.mad_ctpsa_getv(x, i-1, a:size(), a._dat) return a
end

function MR.setvec (x, i, a)
  assert(is_integer(i), "invalid argument #2 (integer expected)")
  if not is_matrix(a) and is_iterable(a) then a = vector(#a):fill(a) end
  assert(is_vector(a), "invalid argument #3 (iterable or vector expected)")
  _C.mad_tpsa_setv(x, i-1, a:size(), a._dat) return x
end

function MC.setvec (x, i, a)
  assert(is_integer(i), "invalid argument #2 (integer expected)")
  if not is_cmatrix(a) and is_iterable(a) then a = cvector(#a):fill(a) end
  assert(is_cvector(a), "invalid argument #3 (iterable or cvector expected)")
  _C.mad_ctpsa_setv(x, i-1, a:size(), a._dat) return x
end

function MR.fill (x, a)
  if not is_matrix(a) and is_iterable(a) then a = vector(#a):fill(a) end
  assert(is_vector(a), "invalid argument #2 (iterable or vector expected)")
  _C.mad_tpsa_setv(x, 0, a:size(), a._dat) return x
end

function MC.fill (x, a)
  if not is_cmatrix(a) and is_iterable(a) then a = cvector(#a):fill(a) end
  assert(is_cvector(a), "invalid argument #2 (iterable or cvector expected)")
  _C.mad_ctpsa_setv(x, 0, a:size(), a._dat) return x
end

-- evaluate x at a+h ----------------------------------------------------------o

local  tarr1 = ffi.new 'struct  tpsa* [1]'
local ctarr1 = ffi.new 'struct ctpsa* [1]'

function MR.eval (x, h)
  tarr1[0], val[0] = x, h
  _C.mad_tpsa_eval(1, tarr1, 1, val, res) return res[0]
end

function MC.eval (x, h)
  ctarr1[0], cval[0] = x, h
  _C.mad_ctpsa_eval(1, tarr1, 1, val, cres) return cres[0]
end

-- conversion -----------------------------------------------------------------o

function MR.cplx (re_, im_, r) -- (re,im) -> r
  local re, im = re_ or im_, im_ or re_ -- trick for next checks
  assert(is_tpsa(re) and is_tpsa(im), "invalid argument #1 or #2 (tpsa expected)")
  r = chksiz(r,re,im) or ctpsa(re, max(re.mo, im.mo))
  _C.mad_ctpsa_cplx(re_, im_, r) return r
end

function MC.reim (x, re_, im_) -- x -> (re,im)
  re_ = chksiz(re_,x) or tpsa_alloc(x.d, x.mo)
  im_ = chksiz(im_,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_real(x, re_) ; _C.mad_ctpsa_imag(x, im_) -- no shortcut
  return re_, im_
end

function MR.real (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_copy(x, r) return r
end

function MC.real (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_real(x, r) return r
end

function MR.imag (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_clear(r) return r
end

function MC.imag (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_imag(x, r) return r
end

-- operators ------------------------------------------------------------------o

-- unm

function MR.__unm (x, _, r) -- note: _ is dummy arg, see Lua specs.
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_scl(x, -1, r) return r
end

function MC.__unm (x, _, r) -- note: _ is dummy arg, see Lua specs.
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_scl_r(x, -1, 0, r) return r
end

-- equ

local function tpsa_eqn (x, y, tol)
  return x.hi == 0 and abs(x.coef[0]-y) <= tol
end

local function tpsa_eqc (x, y, tol)
  return x.hi == 0 and abs(          y.im) <= tol
                   and abs(x.coef[0]-y.re) <= tol
end

local function ctpsa_eqn (x, y, tol)
  return x.hi == 0 and abs(x.coef[0].im  ) <= tol
                   and abs(x.coef[0].re-y) <= tol
end

local function ctpsa_eqc (x, y, tol)
  return x.hi == 0 and abs(x.coef[0].re-y.re) <= tol
                   and abs(x.coef[0].im-y.im) <= tol
end

function MR.__eq (x, y, tol_)
  if is_nil(y) or is_nil(x) then return false end
  tol_ = tol_ or 0
  assert(is_number(tol_), "invalid argument #3 (number expected)")
  if is_number(x) then                           -- num == tpsa
    return tpsa_eqn(y, x, tol_)
  elseif is_number(y) then                       -- tpsa == num
    return tpsa_eqn(x, y, tol_)
  elseif is_complex(x) then                      -- cpx == tpsa
    return tpsa_eqc(y, x, tol_)
  elseif is_complex(y) then                      -- tpsa == cpx
    return tpsa_eqc(x, y, tol_)
  elseif is_ctpsa(y) then                        -- tpsa == ctpsa
    assert(x.d == y.d, "incompatible GTPSA descriptor")
    return _C.mad_ctpsa_equt(y, x, tol_)
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa == tpsa
    assert(x.d == y.d, "incompatible GTPSA descriptor")
    return _C.mad_tpsa_equ(x, y, tol_)
  else
    return assert(gmm(y,'__eq_tpsa'), "invalid 'tpsa == ?' operation")(x, y, tol_)
  end
end

function MC.__eq (x, y, tol_)
  if is_nil(y) or is_nil(x) then return false end
  tol_ = tol_ or 0
  assert(is_number(tol_), "invalid argument #3 (number expected)")
  if is_number(x) then                           -- num == ctpsa
    return ctpsa_eqn(y, x, tol_)
  elseif is_number(y) then                       -- ctpsa == num
    return ctpsa_eqn(x, y, tol_)
  elseif is_complex(x) then                      -- cpx == tpsa
    return ctpsa_eqc(y, x, tol_)
  elseif is_complex(y) then                      -- ctpsa == cpx
    return ctpsa_eqc(x, y, tol_)
  elseif is_tpsa(y) then                         -- ctpsa == tpsa
    assert(x.d == y.d, "incompatible GTPSA descriptor")
    return _C.mad_ctpsa_equt(x, y, tol_)
  elseif is_ctpsa(y) and is_ctpsa(x) then        -- ctpsa == ctpsa
    assert(x.d == y.d, "incompatible GTPSA descriptor")
    return _C.mad_ctpsa_equ(x, y, tol_)
  else
    return assert(gmm(y,'__eq_tpsa'), "invalid 'ctpsa == ?' operation")(x, y, tol_)
  end
end

-- lt

function MR.__lt (x, y)
  if is_number(x) then                           -- num  < tpsa
    return x < y.coef[0]
  elseif is_number(y) then                       -- tpsa < num
    return x.coef[0] < y
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa < tpsa
    assert(x.d == y.d, "incompatible GTPSA descriptor")
    return x.coef[0] < y.coef[0]
  else
    return assert(gmm(y,'__lt_tpsa'), "invalid 'tpsa < ?' operation")(x, y)
  end
end

MC.__lt = \ error("invalid operation '<' on complex GTPSA")

-- le

function MR.__le (x, y)
  if is_number(x) then                           -- num  <= tpsa
    return x <= y.coef[0]
  elseif is_number(y) then                       -- tpsa <= num
    return x.coef[0] <= y
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa <= tpsa
    assert(x.d == y.d, "incompatible GTPSA descriptor")
    return x.coef[0] <= y.coef[0]
  else
    return assert(gmm(y,'__le_tpsa'), "invalid 'tpsa <= ?' operation")(x, y)
  end
end

MC.__le = \ error("invalid operation '<=' on complex GTPSA")

-- add (see also kadd)

function MR.__add (x, y, r)
  if is_number(x) then                           -- num + tpsa
    r = chksiz(r,y) or tpsa_alloc(y.d, y.mo)
    _C.mad_tpsa_copy(y, r)
    _C.mad_tpsa_set0(r, 1, x)
  elseif is_number(y) then                       -- tpsa + num
    r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
    _C.mad_tpsa_copy(x, r)
    _C.mad_tpsa_set0(r, 1, y)
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa + tpsa
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_tpsa_add(x, y, r)
  elseif is_complex(y) then                      -- tpsa + cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)    -- promote to ctpsa
    _C.mad_ctpsa_cplx(x, nil, r)
    _C.mad_ctpsa_set0_r(r, 1, 0, y.re, y.im)
  elseif is_ctpsa(y) then                        -- tpsa + ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_tadd(x, y, r)
  else                                           -- tpsa + ?
    return assert(gmm(y,'__add_tpsa'), "invalid 'tpsa + ?' operation")(x, y, r)
  end
  return r
end

function MR.__add_cpx (x, y, r)                  -- cpx + tpsa
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)      -- promote to ctpsa
  _C.mad_ctpsa_cplx(y, nil, r)
  _C.mad_ctpsa_set0_r(r, 1, 0, x.re, x.im) return r
end

function MC.__add (x, y, r)
  if is_number(x) then                           -- num + ctpsa
    r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
    _C.mad_ctpsa_copy(y, r)
    _C.mad_ctpsa_set0_r(r, 1, 0, x, 0)
  elseif is_scalar(y) then                       -- ctpsa + scl
    y = complex(y)
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_copy(x, r)
    _C.mad_ctpsa_set0_r(r, 1, 0, y.re, y.im)
  elseif is_ctpsa(y) and is_ctpsa(x) then        -- ctpsa + ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_add(x, y, r)
  elseif is_tpsa(y) then                         -- ctpsa + tpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_addt(x, y, r)
  else                                           -- ctpsa + ?
    return assert(gmm(y,'__add_tpsa'), "invalid 'ctpsa + ?' operation")(x, y, r)
  end
  return r
end

function MC.__add_cpx (x, y, r)                  -- cpx + ctpsa
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
  _C.mad_ctpsa_copy(y, r)
  _C.mad_ctpsa_set0_r(r, 1, 0, x.re, x.im) return r
end

-- sub (see also kadd)

function MR.__sub (x, y, r)
  if is_number(x) then                           -- num - tpsa
    r = chksiz(r,y) or tpsa_alloc(y.d, y.mo)
    _C.mad_tpsa_scl(y, -1, r)
    _C.mad_tpsa_set0(r, 1, x)
  elseif is_number(y) then                       -- tpsa - num
    r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
    _C.mad_tpsa_copy(x, r)
    _C.mad_tpsa_set0(r, 1, -y)
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa - tpsa
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_tpsa_sub(x, y, r)
  elseif is_complex(y) then                      -- tpsa - cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)    -- promote to ctpsa
    _C.mad_ctpsa_copy(x, r)
    _C.mad_ctpsa_set0_r(r, 1, 0, -y.re, -y.im)
  elseif is_ctpsa(y) then                        -- tpsa - ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_tsub(x, y, r)
  else                                           -- tpsa - ?
    return assert(gmm(y,'__sub_tpsa'), "invalid 'tpsa - ?' operation")(x, y, r)
  end
  return r
end

function MR.__sub_cpx (x, y, r)                  -- cpx - tpsa
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)      -- promote to ctpsa
  _C.mad_ctpsa_cplx(y, nil, r)
  _C.mad_ctpsa_set0_r(r, 1, 0, x.re, x.im) return r
end

function MC.__sub (x, y, r)
  if is_number(x) then                           -- num - ctpsa
    r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
    _C.mad_ctpsa_scl(y, -1, r)
    _C.mad_ctpsa_set0_r(r, 1, 0, x, 0)
  elseif is_scalar(y) then                       -- ctpsa - scl
    y = complex(-y)
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_copy(x, r)
    _C.mad_ctpsa_set0_r(r, 1, 0, y.re, y.im)
  elseif is_ctpsa(y) and is_ctpsa(x) then        -- ctpsa - ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_sub(x, y, r)
  elseif is_tpsa(y) then                         -- ctpsa - tpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_subt(x, y, r)
  else                                           -- ctpsa - ?
    return assert(gmm(y,'__sub_tpsa'), "invalid 'ctpsa - ?' operation")(x, y, r)
  end
  return r
end

function MC.__sub_cpx (x, y, r)                  -- cpx - ctpsa
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
  _C.mad_ctpsa_copy(y, r)
  _C.mad_ctpsa_set0_r(r, 1, 0, x.re, x.im) return r
end

-- mul

function MR.__mul (x, y, r)
  if is_number(x) then                           -- num * tpsa
    r = chksiz(r,y) or tpsa_alloc(y.d, y.mo)
    _C.mad_tpsa_scl(y, x, r)
  elseif is_number(y) then                       -- tpsa * num
    r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
    _C.mad_tpsa_scl(x, y, r)
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa * tpsa
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_tpsa_mul(x, y, r)
  elseif is_complex(y) then                      -- tpsa * cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)    -- promote to ctpsa
    _C.mad_ctpsa_cplx(x, nil, r)
    _C.mad_ctpsa_scl_r(r, y.re, y.im, r)
  elseif is_ctpsa(y) then                        -- tpsa * ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_tmul(x, y, r)
  else                                           -- tpsa * ?
    return assert(gmm(y,'__mul_tpsa'), "invalid 'tpsa * ?' operation")(x, y, r)
  end
  return r
end

function MR.__mul_cpx (x, y, r)                  -- cpx * tpsa
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)      -- promote to ctpsa
  _C.mad_ctpsa_cplx(y, nil, r)
  _C.mad_ctpsa_scl_r(r, x.re, x.im, r) return r
end

function MC.__mul (x, y, r)
  if is_number(x) then                           -- num * ctpsa
    r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
    _C.mad_ctpsa_scl_r(y, x, 0, r)
  elseif is_scalar(y) then                       -- ctpsa * scl
    y = complex(y)
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    _C.mad_ctpsa_scl_r(x, y.re, y.im, r)
  elseif is_ctpsa(y) and is_ctpsa(x) then        -- ctpsa * ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_mul(x, y, r)
  elseif is_tpsa(y) then                         -- ctpsa * tpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_mult(x, y, r)
  else                                           -- ctpsa * ?
    return assert(gmm(y,'__mul_tpsa'), "invalid 'ctpsa * ?' operation")(x, y, r)
  end
  return r
end

function MC.__mul_cpx (x, y, r)                  -- cpx * ctpsa
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
  _C.mad_ctpsa_scl_r(y, x.re, x.im, r) return r
end

-- element wise mul (.*)

function MR.__emul (x, y, r)
  return assert(gmm(y,'__emul_tpsa'), "invalid 'tpsa .* ?' operation")(x, y, r)
end

function MC.__emul (x, y, r)
  return assert(gmm(y,'__emul_tpsa'), "invalid 'ctpsa .* ?' operation")(x, y, r)
end

-- div

function MR.__div (x, y, r)
  if is_number(x) then                           -- num / tpsa
    r = chksiz(r,y) or tpsa_alloc(y.d, y.mo)
    _C.mad_tpsa_inv(y, x, r)
  elseif is_number(y) then                       -- tpsa / num
    r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
    _C.mad_tpsa_scl(x, 1/y, r)
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa / tpsa
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_tpsa_div(x, y, r)
  elseif is_complex(y) then                      -- tpsa / cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)    -- promote to ctpsa
    local _y = 1/y
    _C.mad_ctpsa_cplx(x, nil, r)
    _C.mad_ctpsa_scl_r(r, _y.re, _y.im, r)
  elseif is_ctpsa(y) then                        -- tpsa / ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_tdiv(x, y, r)
  else                                           -- tpsa / ?
    return assert(gmm(y,'__div_tpsa'), "invalid 'tpsa / ?' operation")(x, y, r)
  end
  return r
end

function MR.__div_cpx (x, y, r)                  -- cpx / tpsa
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)      -- promote to ctpsa
  _C.mad_ctpsa_cplx(y, nil, r)
  _C.mad_ctpsa_inv_r(r, x.re, x.im, r) return r
end

function MC.__div (x, y, r)
  if is_number(x) then                           -- num / ctpsa
    r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
    _C.mad_ctpsa_inv_r(y, x, 0, r)
  elseif is_scalar(y) then                       -- ctpsa / scl
    y = complex(1/y)
    _C.mad_ctpsa_scl_r(x, y.re, y.im, r)
  elseif is_ctpsa(y) and is_ctpsa(x) then        -- ctpsa / ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_div(x, y, r)
  elseif is_tpsa(y) then                         -- ctpsa / tpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_divt(x, y, r)
  else                                           -- ctpsa / ?
    return assert(gmm(y,'__div_tpsa'), "invalid 'ctpsa / ?' operation")(x, y, r)
  end
  return r
end

function MC.__div_cpx (x, y, r)                  -- cpx / ctpsa
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
  _C.mad_ctpsa_inv_r(y, x.re, x.im, r) return r
end

-- element wise div (./)

function MR.__ediv (x, y, r_)
  return assert(gmm(y,'__ediv_tpsa'), "invalid 'tpsa ./ ?' operation")(x, y, r)
end

function MC.__ediv (x, y, r_)
  return assert(gmm(y,'__ediv_tpsa'), "invalid 'ctpsa ./ ?' operation")(x, y, r)
end

-- element wise mod (.%)

function MR.__emod (x, y, r_)
  return assert(gmm(y,'__emod_tpsa'), "invalid 'tpsa .% ?' operation")(x, y, r)
end

function MC.__emod (x, y, r_)
  return assert(gmm(y,'__emod_tpsa'), "invalid 'ctpsa .% ?' operation")(x, y, r)
end

-- pow = exp(y*log(x))

function MR.__pow (x, y, r)
  if is_number(y) then                           -- tpsa ^ num
    r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
    if is_integer(y)
    then _C.mad_tpsa_powi(x, y, r)
    else _C.mad_tpsa_pown(x, y, r)
    end
  elseif is_number(x) then                       -- num ^ tpsa
    r = chksiz(r,y) or tpsa_alloc(y.d, y.mo)
    _C.mad_tpsa_scl(y, log(x), r)
    _C.mad_tpsa_exp(r, r)
  elseif is_tpsa(y) and is_tpsa(x) then          -- tpsa ^ tpsa
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_tpsa_pow(x, y, r)
  elseif is_complex(y) then                      -- tpsa ^ cpx
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)    -- promote to ctpsa
    _C.mad_ctpsa_cplx(x, nil, r)
    _C.mad_ctpsa_pown_r(x, y.re, y.im, r)
  elseif is_ctpsa(y) then                        -- tpsa ^ ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_tpow(x, y, r)
  else                                           -- tpsa ^ ?
    return assert(gmm(y,'__pow_tpsa'), "invalid 'tpsa ^ ?' operation")(x, y, r)
  end
  return r
end

function MR.__pow_cpx (x, y, r)                  -- cpx ^ tpsa
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)      -- promote to ctpsa
  local logx = log(x)
  _C.mad_ctpsa_cplx(y, nil, r)
  _C.mad_ctpsa_scl_r(r, logx.re, logx.im, r)
  _C.mad_ctpsa_exp(r, r) return r
end

function MC.__pow (x, y, r)
  if is_scalar(y) then                           -- ctpsa ^ scl
    r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
    if is_integer(y)
    then _C.mad_ctpsa_powi(x, y, r)
    else y = complex(y)
         _C.mad_ctpsa_pown_r(x, y.re, y.im, r)
    end
  elseif is_number(x) then                       -- num ^ ctpsa
    r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
    local logx = log(complex(x))
    _C.mad_ctpsa_scl_r(y, logx.re, logx.im, r)
    _C.mad_ctpsa_exp(r, r)
  elseif is_tpsa(y) then                         -- ctpsa ^ tpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_powt(x, y, r)
  elseif is_ctpsa(y) and is_ctpsa(x) then        -- ctpsa ^ ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_pow(x, y, r)
  else                                           -- ctpsa ^ ?
    return assert(gmm(y,'__pow_tpsa'), "invalid 'ctpsa ^ ?' operation")(x, y, r)
  end
  return r
end

function MC.__pow_cpx (x, y, r)                  -- cpx ^ ctpsa
  r = chksiz(r,y) or ctpsa_alloc(y.d, y.mo)
  local logx = log(x)
  _C.mad_ctpsa_scl_r(y, logx.re, logx.im, r)
  _C.mad_ctpsa_exp(r, r) return r
end

-- element wise pow (.^)

function MR.__epow (x, y, r_)
  return assert(gmm(y,'__epow_tpsa'), "invalid 'tpsa .^ ?' operation")(x, y, r)
end

function MC.__epow (x, y, r_)
  return assert(gmm(y,'__epow_tpsa'), "invalid 'ctpsa .^ ?' operation")(x, y, r)
end

-- dif : r_i = (x_i - y_i) / max(|x_i|, 1)

function MR.dif (x, y, r)
  if is_tpsa(y) and is_tpsa(x) then              -- tpsa ~ tpsa
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_tpsa_dif(x, y, r)
  elseif is_ctpsa(y) then                        -- tpsa ~ ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_tdif(x, y, r)
  else
    error("invalid 'tpsa ~ ?' operation")
  end
  return r
end

function MC.dif (x, y, r)
  if is_ctpsa(y) and is_ctpsa(x) then            -- ctpsa ~ ctpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_dif(x, y, r)
  elseif is_tpsa(y) then                         -- ctpsa ~ tpsa
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo, y.mo))
    _C.mad_ctpsa_dift(x, y, r)
  else
    error("invalid 'ctpsa ~ ?' operation")
  end
  return r
end

-- tpsa functions -------------------------------------------------------------o

MR.nrm = \x -> _C.mad_tpsa_nrm(x)

function MR.abs (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_abs(x, r) return r
end

function MR.unit (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_unit(x, r) return r
end

function MR.integ (x, iv, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_integ(x, r, iv) return r
end

function MR.deriv (x, m, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  if is_integer(m) then
    _C.mad_tpsa_deriv(x, r, m)
  else
    if not is_monomial(m) then m = monomial(m) end
    _C.mad_tpsa_derivm(x, r, m.n, m._dat)
  end
  return r
end

function MR.poibra (x, y, nv_, r)
  assert(is_nil(nv_) or is_integer(nv_),
         "invalid arguments (unsupported GTPSA operation '[,]')")
  if is_tpsa(y) then
    r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo,y.mo))
    _C.mad_tpsa_poibra (x, y, r, nv_ or 0)
  elseif is_ctpsa(y) then
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo,y.mo))
    _C.mad_ctpsa_tpoibra(x, y, r, nv_ or 0) return r
  else
    error("invalid arguments (unsupported GTPSA operation '[,]')")
  end
  return r
end

function MR.acc (x, v, r)  -- r += v*x
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_acc(x, v, r) return r
end

function MR.scl (x, v, r) -- r = v*x
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_scl(x, v, r) return r
end

function MR.inv (x, v_, r)  -- r = v/x
  if is_tpsa(v_) and is_nil(r) then
    v_, r = nil, v_ -- right shift
  end
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_inv(x, v_ or 1, r) return r
end

function MR.invsqrt (x, v_, r) -- r = v/sqrt(x)
  if is_tpsa(v_) and is_nil(r) then
    v_, r = nil, v_ -- right shift
  end
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_invsqrt(x, v_ or 1, r) return r
end

function MR.sqrt (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_sqrt(x, r) return r
end

function MR.exp (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_exp(x, r) return r
end

function MR.log (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_log(x, r) return r
end

function MR.sincos (x, rs, rc)
  rs = chksiz(rs,x) or tpsa_alloc(x.d, x.mo)
  rc = chksiz(rc,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_sincos(x, rs, rc) return rs, rc
end

function MR.sin (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_sin(x, r) return r
end

function MR.cos (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_cos(x, r) return r
end

function MR.tan (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_tan(x, r) return r
end

function MR.cot (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_cot(x, r) return r
end

function MR.sincosh (x, rs, rc)
  rs = chksiz(rs,x) or tpsa_alloc(x.d, x.mo)
  rc = chksiz(rc,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_sincosh(x, rs, rc) return rs, rc
end

function MR.sinh (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_sinh(x, r) return r
end

function MR.cosh (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_cosh(x, r) return r
end

function MR.tanh (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_tanh(x, r) return r
end

function MR.coth (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_coth(x, r) return r
end

function MR.asin (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_asin(x, r) return r
end

function MR.acos (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_acos(x, r) return r
end

function MR.atan (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_atan(x, r) return r
end

function MR.acot (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_acot(x, r) return r
end

function MR.asinh (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_asinh(x, r) return r
end

function MR.acosh (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_acosh(x, r) return r
end

function MR.atanh (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_atanh(x, r) return r
end

function MR.acoth (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_acoth(x, r) return r
end

function MR.sinc (x, r) -- sin(x)/x
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_sinc(x, r) return r
end

function MR.sinhc (x, r) -- sinh(x)/x
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_sinhc(x, r) return r
end

function MR.asinc (x, r) -- asin(x)/x
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_asinc(x, r) return r
end

function MR.asinhc (x, r) -- asinh(x)/x
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_asinhc(x, r) return r
end

function MR.erf (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_erf(x, r) return r
end

function MR.erfc (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_erfc(x, r) return r
end

function MR.hypot (x, y, r)
  r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_tpsa_hypot(x, y, r) return r
end

function MR.atan2 (y, x, r)
  r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_tpsa_atan2(y, x, r) return r
end

-- Erf and Erfc (Faddeeva) based functions
MR.wf    = \x -> real(exp(-z^2)*erfc(-iz))
MR.erfi  = \x -> real(-1i*erf(1i*x))
MR.erfcx = \x -> exp(z^2)*erfc(z)

-- TODO: wf for TPSA (along with erf),
-- it seems that w(z) = exp(-z^2)*erfc(-iz)
--          and w(iz) = exp( z^2)*erfc(  z) are not stable at high orders.

-- ctpsa functions ------------------------------------------------------------o

MC.nrm = \x -> _C.mad_ctpsa_nrm(x)

MC.abs = \x,r -> MC.cabs(x, r)

function MC.cabs (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_cabs(x, r) return r
end

function MC.carg (x, r)
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_carg(x, r) return r
end

function MC.unit (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_unit(x, r) return r
end

function MC.conj (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_conj(x, r) return r
end

function MC.integ (x, iv, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_integ(x, r, iv) return r
end

function MC.deriv (x, m, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  if is_integer(m) then
    _C.mad_ctpsa_deriv(x, r, m)
  else
    if not is_monomial(m) then m = monomial(m) end
    _C.mad_cpsa_derivm(x, r, m.n, m._dat)
  end
  return r
end

function MC.poisbra(x, y, nv_, r)
  assert(is_nil(nv_) or is_integer(nv_),
         "invalid arguments (unsupported GTPSA operation '[,]')")
  if is_tpsa(y) then
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo,y.mo))
    _C.mad_ctpsa_poibrat (x, y, r, nv_ or 0)
  elseif is_ctpsa(y) then
    r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo,y.mo))
    _C.mad_ctpsa_poibra(x, y, r, nv_ or 0)
  else
    error("invalid arguments (unsupported GTPSA operation '[,]')")
  end
  return r
end

function MC.acc (x, v, r)  -- r += v*x
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_acc(x, v, r) return r
end

function MC.scl (t, v, r) -- r = v*x
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_scl(t, v, r) return r
end

function MC.inv (x, v_, r)  -- r = v/x
  if is_ctpsa(v_) and is_nil(r) then
    v_, r = nil, v_ -- right shift
  end
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  v_ = complex(v_ or 1)
  _C.mad_ctpsa_inv_r(x, v_.re, v_.im, r) return r
end

function MC.invsqrt (x, v_, r) -- r = v/sqrt(x)
  if is_ctpsa(v_) and is_nil(r) then
    v_, r = nil, v_ -- right shift
  end
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  v_ = complex(v_ or 1)
  _C.mad_ctpsa_invsqrt(x, v_.re, v_.im, r) return r
end

function MC.sqrt (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_sqrt(x, r) return r
end

function MC.exp (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_exp(x, r) return r
end

function MC.log (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_log(x, r) return r
end

function MC.sincos (x, rs, rc)
  rs = chksiz(rs,x) or ctpsa_alloc(x.d, x.mo)
  rc = chksiz(rc,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_sincos(x, rs, rc) return rs, rc
end

function MC.sin (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_sin(x, r) return r
end

function MC.cos (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_cos(x, r) return r
end

function MC.tan (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_tan(x, r) return r
end

function MC.cot (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_cot(x, r) return r
end

function MC.sincosh (x, rs, rc)
  rs = chksiz(rs,x) or ctpsa_alloc(x.d, x.mo)
  rc = chksiz(rc,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_sincosh(x, rs, rc) return rs, rc
end

function MC.sinh (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_sinh(x, r) return r
end

function MC.cosh (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_cosh(x, r) return r
end

function MC.tanh (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_tanh(x, r) return r
end

function MC.coth (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_coth(x, r) return r
end

function MC.asin (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_asin(x, r) return r
end

function MC.acos (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_acos(x, r) return r
end

function MC.atan (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_atan(x, r) return r
end

function MC.acot (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_acot(x, r) return r
end

function MC.asinh (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_asinh(x, r) return r
end

function MC.acosh (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_acosh(x, r) return r
end

function MC.atanh (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_atanh(x, r) return r
end

function MC.acoth (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_acoth(x, r) return r
end

function MC.sinc (x, r) -- sin(x)/x
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_sinc(x, r) return r
end

function MC.sinhc (x, r) -- sinh(x)/x
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_sinhc(x, r) return r
end

function MC.asinc (x, r) -- asin(x)/x
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_asinc(x, r) return r
end

function MC.asinhc (x, r) -- asinh(x)/x
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_asinhc(x, r) return r
end

function MC.erf (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_erf(x, r) return r
end

function MC.erfc (x, r)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_erfc(x, r) return r
end

function MC.hypot (x, y, r)
  r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_ctpsa_hypot(x, y, r) return r
end

function MC.hypot3 (x, y, z, r)
  r = chksiz(r,x,y) and chksiz(r,z) or ctpsa_alloc(x.d, max(x.mo,y.mo,z.mo))
  _C.mad_ctpsa_hypot3(x, y, z, r) return r
end

-- Erf and Erfc (Faddeeva) based functions
MC.wf    = \x -> erfcx(1i*x)
MC.erfi  = \x -> -1i*erf(1i*x)
MC.erfcx = \x -> exp(z^2)*erfc(z)

-- TODO: wfun for TPSA,
-- it seems that w(z) = exp(-z^2)*erfc(-iz)
--          and w(iz) = exp( z^2)*erfc(  z) are not stable at high orders.

-- tpsa high level functions --------------------------------------------------o

function MR.axpb (x, a, b, r) -- r = ax+b
  assert(is_number(a) and is_number(b), "invalid argument #2 or #3 (number expected)")
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_axpb(a,x,b,r) return r
end

function MR.axpbypc (x, y, a, b, c, r) -- r = ax+by+c
  assert(is_tpsa(y), "invalid argument #2 (tpsa expected)")
  assert(is_number(a) and is_number(b) and is_number(c),
         "invalid argument #3, #4 or #5 (number expected)")
  r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_tpsa_axpbypc(a,x,b,y,c,r) return r
end

function MR.axypb (x, y, a, b, r) -- r = axy+b
  assert(is_tpsa(y), "invalid argument #2 (tpsa expected)")
  assert(is_number(a) and is_number(b), "invalid argument #3 or #4 (number expected)")
  r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_tpsa_axypb(a,x,y,b,r) return r
end

function MR.axypbzpc (x, y, z, a, b, c, r) -- r = axy+bz+c
  assert(is_tpsa(y) and is_tpsa(z), "invalid argument #2 or #3 (tpsa expected)")
  assert(is_number(a) and is_number(b) and is_number(c),
         "invalid argument #4, #5 or #6 (number expected)")
  r = chksiz(r,x,y) and chksiz(r,z) or tpsa_alloc(x.d, max(x.mo,y.mo,z.mo))
  _C.mad_tpsa_axypbzpc(a,x,y,b,z,c,r) return r
end

function MR.axypbvwpc (x, y, v, w, a, b, c, r) -- r = axy+bvw+c
  assert(is_tpsa(y) and is_tpsa(v) and is_tpsa(w),
         "invalid argument #2, #3 or #4 (tpsa expected)")
  assert(is_number(a) and is_number(b) and is_number(c),
         "invalid argument #5, #6 or #7 (number expected)")
  r = chksiz(r,x,y) and chksiz(r,v,w) and chksiz(r,x,v) or
      tpsa_alloc(x.d, max(x.mo,y.mo,v.mo,w.mo))
  _C.mad_tpsa_axypbvwpc(a,x,y,b,v,w,c,r) return r
end

function MR.ax2pby2pcz2 (x, y, z, a, b, c, r) -- r = ax^2+by^2+cz^2
  assert(is_tpsa(y) and is_tpsa(z), "invalid argument #2 or #3 (tpsa expected)")
  assert(is_number(a) and is_number(b) and is_number(c),
         "invalid argument #4, #5 or #6 (number expected)")
  r = chksiz(r,x,y) and chksiz(r,x,z) or tpsa_alloc(x.d, max(x.mo,y.mo,z.mo))
  _C.mad_tpsa_ax2pby2pcz2(a,x,b,y,c,z,r) return r
end

function MR.axpsqrtbpcx2 (x, a, b, c, r) -- r = ax+sqrt(b+cx^2)
  assert(is_number(a) and is_number(b) and is_number(c),
         "invalid argument #2, #3 or #4 (scalar expected)")
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_axpsqrtbpcx2(x, a, b, c, r) return r
end

function MR.logaxpsqrtbpcx2 (x, a, b, c, r) -- r = log(ax+sqrt(b+cx^2))
  assert(is_number(a) and is_number(b) and is_number(c),
         "invalid argument #2, #3 or #4 (scalar expected)")
  r = chksiz(r,x) or tpsa_alloc(x.d, x.mo)
  _C.mad_tpsa_logaxpsqrtbpcx2(x, a, b, c, r) return r
end

function MR.logxdy (x, y, r) -- r = log(x/y)
  assert(is_tpsa(y), "invalid argument #2 (tpsa expected)")
  r = chksiz(r,x,y) or tpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_tpsa_logxdy(x, y, r) return r
end

-- ctpsa high level functions -------------------------------------------------o

function MC.axpb (x, a, b, r) -- r = ax+b
  assert(is_scalar(a) and is_scalar(b), "invalid argument #2 or #3 (scalar expected)")
  a, b = complex(a), complex(b)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_axpb_r(a.re,a.im, x, b.re,b.im, r) return r
end

function MC.axpbypc (x, y, a, b, c, r) -- r = ax+by+c
  assert(is_ctpsa(y), "invalid argument #2 (ctpsa expected)")
  assert(is_scalar(a) and is_scalar(b) and is_scalar(c),
         "invalid argument #3, #4 or #5 (scalar expected)")
  a, b, c = complex(a), complex(b), complex(c)
  r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_ctpsa_axpbypc_r(a.re,a.im, x, b.re,b.im, y, c.re,c.im, r) return r
end

function MC.axypb (x, y, a, b, r) -- r = axy+b
  assert(is_ctpsa(y), "invalid argument #2 (ctpsa expected)")
  assert(is_scalar(a) and is_scalar(b), "invalid argument #3 or #4 (scalar expected)")
  a, b = complex(a), complex(b)
  r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_ctpsa_axypb_r(a.re,a.im, x, y, b.re,b.im, r) return r
end

function MC.axypbzpc (x, y, z, a, b, c, r) -- r = axy+bz+c
  assert(is_ctpsa(y) and is_ctpsa(z), "invalid argument #2 or #3 (ctpsa expected)")
  assert(is_scalar(a) and is_scalar(b) and is_scalar(c),
         "invalid argument #4, #5 or #6 (scalar expected)")
  a, b, c = complex(a), complex(b), complex(c)
  r = chksiz(r,x,y) and chksiz(r,z) or ctpsa_alloc(x.d, max(x.mo,y.mo,z.mo))
  _C.mad_ctpsa_axypbzpc_r(a.re,a.im, x, y, b.re,b.im, z, c.re,c.im, r) return r
end

function MC.axypbvwpc (x, y, v, w, a, b, c, r) -- r = axy+bvw+c
  assert(is_ctpsa(y) and is_ctpsa(v) and is_ctpsa(w),
         "invalid argument #2, #3 or #4 (ctpsa expected)")
  assert(is_scalar(a) and is_scalar(b) and is_scalar(c),
         "invalid argument #5, #6 or #7 (scalar expected)")
  r = chksiz(r,x,y) and chksiz(r,v,w) and chksiz(r,x,v) or
      ctpsa_alloc(x.d, max(x.mo,y.mo,v.mo,w.mo))
  _C.mad_ctpsa_axypbvwpc_r(a.re,a.im, x,y, b.re,b.im, v,w, c.re,c.im, r) return r
end

function MC.ax2pby2pcz2 (x, y, z, a, b, c, r) -- r = ax^2+by^2+cz^2
  assert(is_ctpsa(y) and is_ctpsa(z), "invalid argument #2 or #3 (ctpsa expected)")
  assert(is_scalar(a) and is_scalar(b) and is_scalar(c),
         "invalid argument #4, #5 or #6 (scalar expected)")
  r = chksiz(r,x,y) and chksiz(r,x,z) or ctpsa_alloc(x.d, max(x.mo,y.mo,z.mo))
  _C.mad_ctpsa_ax2pby2pcz2_r(a.re,a.im, x, b.re,b.im, y, c.re,c.im, z, r) return r
end

function MC.axpsqrtbpcx2 (x, a, b, c, r) -- r = ax+sqrt(b+cx^2)
  assert(is_scalar(a) and is_scalar(b) and is_scalar(c),
         "invalid argument #2, #3 or #4 (scalar expected)")
  a, b, c = complex(a), complex(b), complex(c)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_axpsqrtbpcx2_r(x, a.re,a.im, b.re,b.im, c.re,c.im, r) return r
end

function MC.logaxpsqrtbpcx2 (x, a, b, c, r) -- r = log(ax+sqrt(b+cx^2))
  assert(is_scalar(a) and is_scalar(b) and is_scalar(c),
         "invalid argument #2, #3 or #4 (scalar expected)")
  a, b, c = complex(a), complex(b), complex(c)
  r = chksiz(r,x) or ctpsa_alloc(x.d, x.mo)
  _C.mad_ctpsa_logaxpsqrtbpcx2_r(x, a.re,a.im, b.re,b.im, c.re,c.im, r) return r
end

function MC.logxdy (x, y, r) -- r = log(x/y)
  assert(is_ctpsa(y), "invalid argument #2 (tpsa expected)")
  r = chksiz(r,x,y) or ctpsa_alloc(x.d, max(x.mo,y.mo))
  _C.mad_ctpsa_logxdy(x, y, r) return r
end

-- I/O ------------------------------------------------------------------------o

function MR.write (x, filnam_, name_, tol_, nohdr_)
  if is_number(name_) and is_nil(tol_) then
    name_, tol_ = nil, name_ -- right shift
  end

  local file = assert(openfile(filnam_, 'w', '.dat'),
                      "unable to open GTPSA file in write mode")
  _C.mad_tpsa_print(x, name_, tol_ or option.prteps, nohdr_ or 0, file)

  if is_string(filnam_) then file:close() else file:flush() end
  return x
end

function MC.write (x, filnam_, name_, tol_, nohdr_)
  if is_number(name_) and is_nil(tol_) then
    name_, tol_ = nil, name_ -- right shift
  end

  local file = assert(openfile(filnam_, 'w', '.dat'),
                      "unable to open GTPSA file in write mode")
  _C.mad_ctpsa_print(x, name_, tol_ or option.prteps, nohdr_ or 0, file)

  if is_string(filnam_) then file:close() else file:flush() end
  return x
end

function MR.print (x, name_, tol_, nohdr_)
  return x:write(nil, name_, tol_, nohdr_)
end

local cbuf = chr_arr(16) -- GTPSA name, see NAMSZ in mad_tpsa.h

function MR.read (x_, filnam_, kind_)
  local file = assert(openfile(filnam_, 'r', '.dat'),
                      "unable to open GTPSA file in read mode")
  int[0] = kind_ == "R" and 0 or kind_ == "C" and 1 or -1 -- 0:R, 1:C, -1:detect

  local d, x = _C.mad_tpsa_scan_hdr(int, cbuf, file)
  if d ~= nil then
    if int[0] == 1
    then x = ctpsa(d) _C.mad_ctpsa_setnam(x,cbuf) _C.mad_ctpsa_scan_coef(x,file)
    else x = tpsa (d) _C.mad_tpsa_setnam (x,cbuf) _C.mad_tpsa_scan_coef (x,file)
    end
  end

  if is_string(filnam_) then file:close() end
  return x -- return nil if no GTPSA found
end

-- metamethods ----------------------------------------------------------------o

MR.unm = \x,r_ -> MR.__unm(x,nil,r_)
MC.unm = \x,r_ -> MC.__unm(x,nil,r_)

MR.  add, MR.  sub, MR.  mul, MR.  div, MR.  pow =
MR.__add, MR.__sub, MR.__mul, MR.__div, MR.__pow

MC.  add, MC.  sub, MC.  mul, MC.  div, MC.  pow =
MC.__add, MC.__sub, MC.__mul, MC.__div, MC.__pow

MR.  emul, MR.  ediv, MR.  emod, MR.  epow =
MR.__emul, MR.__ediv, MR.__emod, MR.__epow

MC.  emul, MC.  ediv, MC.  emod, MC.  epow =
MC.__emul, MC.__ediv, MC.__emod, MC.__epow

MR.  eq, MR.  lt, MR.  le, MR.  same, MR.  copy, MR.length =
MR.__eq, MR.__lt, MR.__le, MR.__same, MR.__copy, MR.__len

MC.  eq, MC.  lt, MC.  le, MC.  same, MC.  copy, MC.length =
MC.__eq, MC.__lt, MC.__le, MC.__same, MC.__copy, MC.__len

MR.__index = MR
MC.__index = MC

function MR.__newindex (_, i)
  error("invalid GTPSA member '".. tostring(i) .."'")
end

-- MR -> MC -------------------------------------------------------------------o

for k,v in pairs(MR) do
  if is_nil(MC[k]) then MC[k] = v end
end

-- TODO: set concepts for MR and MC

-- env ------------------------------------------------------------------------o

MAD.typeid.is_gtpsad = is_gtpsad
MAD.typeid.is_tpsa   = is_tpsa
MAD.typeid.is_ctpsa  = is_ctpsa
MAD.typeid.isa_tpsa  = isa_tpsa

-- metatables -----------------------------------------------------------------o

MR.__metatable = MR
MC.__metatable = MC

ffi.metatype( tpsa_ctor, MR)
ffi.metatype(ctpsa_ctor, MC)

-- end ------------------------------------------------------------------------o
return {
   tpsa  =  tpsa,
  ctpsa  = ctpsa,
  gtpsad = gtpsad,
  gtpsad_release = gtpsad_release,
  -- __help = require 'madh_gtpsa',
}
