--[=[
 o-----------------------------------------------------------------------------o
 |
 | Matrix module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides full set of functions and operations on real and complex matrices.
  - Vectors are column oriented matrices, i.e. implemented as [n x 1] matrices.

 o-----------------------------------------------------------------------------o
]=]

local MR, MC = { __help = {} }, {}

-- help -----------------------------------------------------------------------o

MR.__help.self = [=[
NAME
  matrix -- real and complex vectors and matrices

SYNOPSIS
  mr1 = matrix(nrow [, ncol])          -- default ncol = nrow (square matrix)
  mr2 = matrix {{...}, ...}            -- from table (rows length must be equal)

  mc1 = cmatrix(nrow [, ncol])         -- complex variant
  mc2 = cmatrix {{...}, ...}           -- complex variant

  vr1 = vector(nrow)                   -- vector = [nrow x 1] (column matrix)
  vr2 = vector {...}                   -- from table (column vector)

  vc1 = cvector(nrow)                  -- complex variant
  vc2 = cvector {...}                  -- complex variant

DESCRIPTION
  The module matrix implements the operators and math functions on matrices:
  (minus) -, +, -, *, /, %, ^, ==, #, [], ..,
  unm, add, sub, mul (emul), div (ediv), mod, pow, eq,
  zeros, ones, eye, fill, copy, same,
  rows, cols, size (length), sizes, tsizes,
  get, get0, geti, getrow, getcol, getvec, getdiag, getsub,
  set, set0, seti, setrow, setcol, setvec, setdiag, setsub,
  transpose, t, trans, ctrans, conjugate,
  dot, inner, cross, mixed, outer, trace, tr,

  carg, real, imag, conj, norm, unit, rect, polar,
  ceil, floor, frac, trunc, round,
  abs, angle, exp, log, sqrt,
  sin, cos, tan, sinh, cosh, tanh,
  asin, acos, atan, asinh, acosh, atanh,
  erf, tgamma, lgamma,
  solve, svd, eigen,
  fft, ifft, rfft, irfft, conv, corr, covar,

  is_matrix, is_cmatrix, isa_matrix, is_vector, is_cvector, isa_vector,
  foreach, map, map2, map3, foldl, foldr,
  concat, reshape, unsafe_reshape, fromtable, set_check_bounds.

  By default, boundaries checking is true.

RETURN VALUES
  The constructed matrices, vectors are specialized matrices.

ERRORS
  TODO

EXAMPLES
  m1 = matrix(2,3)                    -- matrix [2 x 3]
  m2 = matrix(3)                      -- square matrix [3 x 3]
  m3 = vector(3)                      -- column vector [3 x 1]
  m4 = matrix {{1,2},{3,4},{5,6}}     -- from table [3 x 2]
  m5 = vector {1,2,3,4,5,6}           -- column vector [6 x 1] = {{1},{2},...}
  m6 = vector {{1,2,3,4,5,6}}         -- row vector [1 x 6]

  c1 = cmatrix(2,3)                   -- cmatrix [2 x 3]
  c2 = cmatrix {{1,2+2i},{3,4+2i},{5,6+2i}}
  c3 = cvector {1,2,3,4,5,6}          -- column cvector [6 x 1]
  c4 = cvector {{1,2,3,4,5,6}}        -- row cvector [1 x 6]
  c5 = c2:transpose()                 -- row cmatrix, transpose conjugate
  I6 = cmatrix(6):eye()               -- identity cmatrix [6 x 6]

SEE ALSO
  gmath, gfunc, complex
]=]

-- documentation --------------------------------------------------------------o

MR.__help['3D Geometry relations'] = [=[
3D GEOMETRY RELATIONS
  inner prod:   u'.v = |u|.|v| cos(u^v)
  cross prod:   uxv = |u|.|v| sin(u^v) \vec{n}
  mixed prod:   (uxv)'.w = u'.(vxw) = det(u,v,w)
  outer prod:   u.v' = matrix
  dbl x-prod:   ux(vxw) = (u.w) \vec{v} - (u.v) \vec{w}
                (uxv)xw = (u.w) \vec{v} - (v.w) \vec{u}
  norm      :   |u| = sqrt(u'.u)
  angle     :   u^v = acos(u'.v / |u|.|v|)  in [0,pi] (or [-pi,pi] if n)
  unit      :   u / |u|
  projection:   u'.v
  projector :   I -   u.u' / u'.u
  reflector :   I - 2 u.u' / u'.u
  area      :   |uxv|
  volume    :   |(uxv)'.w|
  unitary   :   |u| = 1
  orthogonal:   u'.v = 0
  collinear :   |uxv| = 0
  coplanar  :   (uxv)'.w = 0
]=]

-- locals ---------------------------------------------------------------------o

local new, istype, metatype, cast, typeof, sizeof, fill, cdef, gc
      in require 'ffi'

local _C, is_nil, is_number, is_table, is_complex, is_scalar,
      carg, real, imag, conj, norm, rect, polar,
      abs, ceil, floor, exp, log, sqrt,
      sin, cos, tan, sinh, cosh, tanh,
      asin, acos, atan, asinh, acosh, atanh,
      unm, mod, pow, min, max,
      ident, rep,
      is_callable, is_indexable, has_method, get_metatable, defhelp in MAD

-- tmp for returned values
local cres = new 'complex[1]'

-- tmp for index identity TODO (should come from func module)
local sid = setmetatable({ n=0 }, {
  __len       = \s   -> s.n,
  __call      = \s,n => s.n=n return s end,
  __index     = \_,i -> i,
  __newindex := error("invalid write access"),
})

-- constructors ---------------------------------------------------------------o

cdef [[
typedef struct { int32_t nr, nc; double  data[?]; }  matrix_t;
typedef struct { int32_t nr, nc; complex data[?]; } cmatrix_t;
]]

local  matrix_ctor_v = typeof ' matrix_t'
local cmatrix_ctor_v = typeof 'cmatrix_t'
local  matrix_cref_v = typeof ' matrix_t&'
local cmatrix_cref_v = typeof 'cmatrix_t&'

local is_matrix  = \x -> istype( matrix_ctor_v, x)
local is_cmatrix = \x -> istype(cmatrix_ctor_v, x)
local isa_matrix = \x -> is_matrix(x) or is_cmatrix(x)

local is_vector  = \x -> is_matrix(x)  and (x.nr == 1 or x.nc == 1)
local is_cvector = \x -> is_cmatrix(x) and (x.nr == 1 or x.nc == 1)
local isa_vector = \x -> isa_matrix(x) and (x.nr == 1 or x.nc == 1)

-- allocators

local function matrix_alloc (nr, nc)
  local len, mat = nr*nc, nil
  if len < _C.mad_alloc_threshold then
    mat = matrix_ctor_v(len) -- VLA
  else
    local siz = sizeof(matrix_ctor_v, len)
    local ptr = _C.mad_malloc(siz)
    mat = gc(cast(matrix_cref_v, ptr), _C.mad_free)
    fill(mat, siz)
  end
  mat.nr, mat.nc = nr, nc
  return mat
end

local function cmatrix_alloc (nr, nc)
  local len, mat = nr*nc, nil
  if len < _C.mad_alloc_threshold/2 then
    mat = cmatrix_ctor_v(len) -- VLA
  else
    local siz = sizeof(cmatrix_ctor_v, len)
    local ptr = _C.mad_malloc(siz)
    mat = gc(cast(cmatrix_cref_v, ptr), _C.mad_free)
    fill(mat, siz)
  end
  mat.nr, mat.nc = nr, nc
  return mat
end

local function fromtable (ctor, tbl)
  local nr, nc = #tbl or 0, is_table(tbl[1]) and #tbl[1] or 1
  assert(nr > 0 and nc > 0, "invalid argument #1 (non-empty table expected)")
  return ctor(nr,nc):fromtable(tbl)
end

-- constructors

local function matrix (nr, nc_)
  if is_table(nr) then
    return fromtable(matrix_alloc, nr)
  end
  local nc = nc_ or nr -- square
  assert(is_number(nr) and nr > 0 and is_number(nc) and nc > 0,
         "invalid argument #1 or #2 (nrow[,ncol] or table [of tables] expected)")
  return matrix_alloc(nr, nc)
end

local function cmatrix (nr, nc_)
  if is_table(nr) then
    return fromtable(cmatrix_alloc, nr)
  end
  local nc = nc_ or nr -- square
  assert(is_number(nr) and nr > 0 and is_number(nc) and nc > 0,
         "invalid argument #1 or #2 (nrow[,ncol] or table [of tables] expected)")
  return cmatrix_alloc(nr, nc)
end

local  vector = \n ->  matrix(n, 1)
local cvector = \n -> cmatrix(n, 1)

-- implementation -------------------------------------------------------------o

local idx0 = \i,j,c   -> ( i   *c +  j   )
local idx  = \i,j,c   -> ((i-1)*c + (j-1))

local geti = \x,i     -> x.data[i-1]
local seti = \x,i,e   => x.data[i-1] = e end
local get0 = \x,i,j   -> x.data[idx0(i, j, x.nc)]
local set0 = \x,i,j,e => x.data[idx0(i, j, x.nc)] = e end
local get  = \x,i,j   -> x.data[idx (i, j, x.nc)]
local set  = \x,i,j,e => x.data[idx (i, j, x.nc)] = e end

local function safe_geti (x, i)
  assert(1 <= i and i <= x.nr*x.nc, "1-index out of bounds")
  return geti(x, i)
end

local function safe_get0 (x, i, j)
  assert(0 <= i and i < x.nr and 0 <= j and j < x.nc, "0-index out of bounds")
  return get0(x, i, j)
end

local function safe_get (x, i, j)
  assert(1 <= i and i <= x.nr and 1 <= j and j <= x.nc, "1-index out of bounds")
  return get (x, i, j)
end

local function safe_seti (x, i, e)
  assert(1 <= i and i <= x.nr*x.nc, "1-index out of bounds")
  seti(x, i, e)
end

local function safe_set0 (x, i, j, e)
  assert(0 <= i and i < x.nr and 0 <= j and j < x.nc, "0-index out of bounds")
  set0(x, i, j, e)
end

local function safe_set (x, i, j, e)
  assert(1 <= i and i <= x.nr and 1 <= j and j <= x.nc, "1-index out of bounds")
  set (x, i, j, e)
end

function MR.set_bounds_check (M, flag)
  local old = M.geti == safe_geti
  if flag == false then
    M.geti, M.get0, M.get = geti, get0, get
    M.seti, M.set0, M.set = seti, set0, set
  else
    M.geti, M.get0, M.get = safe_geti, safe_get0, safe_get
    M.seti, M.set0, M.set = safe_seti, safe_set0, safe_set
  end
  return old;
end

MR.set_bounds_check(MR, true) -- default

-- sizes check helper

local function chksiz (r, x, y)
  assert(is_nil(r) or (r:rows() == x:rows() and r:cols() == x:cols()) and
         is_nil(y) or (y:rows() == x:rows() and y:cols() == x:cols()),
         "incompatible matrix sizes")
  return r
end

local function chksizm (r, x, y)
  assert(is_nil(r) or (r:rows() == x:rows() and r:cols() == y:cols()) and
         x:cols() == y:rows(), "incompatible matrix sizes")
  return r
end

local function chksizd (r, x, y)
  assert(is_nil(r) or (r:rows() == x:rows() and r:cols() == y:rows()) and
         x:cols() == y:cols(), "incompatible matrix sizes")
  return r
end

-- sizes, same, shape ---------------------------------------------------------o

MR.rows   = \x -> x.nr
MR.cols   = \x -> x.nc
MR.size   = \x -> x.nr * x.nc
MR.sizes  = \x -> (x.nr, x.nc)
MR.tsizes = \x -> (x.nc, x.nr)
MR.length = MR.size

--   valid invocation: x:same(), x:same(e), x:same(nr, nc), x:same(e, nr, nc)
-- invalid invocation: x:same(e, nr), will be interpreted as x:same(nr, nc)
function MR.same (x, e_, nr_, nc_)
  if is_nil(nc_) then
    nr_, nc_, e_ = e_, nr_, x.data[0]
  end
  if is_number(e_)
  then return  matrix(nr_ or x.nr, nc_ or x.nc)
  else return cmatrix(nr_ or x.nr, nc_ or x.nc)
  end
end

function MR.reshape (x, nr_, nc_)
  local nr, nc = nr_ or x.nr, nc_ or x.nc
  assert(nr*nc <= x:size(), "incompatible matrix sizes")
  x.nr, x.nc = nr, nc
  return x
end

function MR.unsafe_reshape (x, nr_, nc_)
  -- no check, user is responsible for keeping track of the size allocated
  -- accessing data beyond allocated size trigs a segmentation fault
  x.nr, x.nc = nr_ or x.nr, nc_ or x.nc
  return x
end

-- fill, get, set -------------------------------------------------------------o

function MR.zeros (x)
  fill(x.data, sizeof(is_matrix(x) and 'double' or 'complex', x:size()))
  return x
end

function MR.ones (x, e_)
  local n, e = x:size(), e_ or 1
  for i=0,n-1 do x.data[i] = e end
  return x
end

function MR.eye (x, e_) -- zeros + diagonal
  x:zeros()
  local n, nc, e = x:size(), x:cols(), e_ or 1
  for i=0,n-1,nc+1 do x.data[i] = e end
  return x
end

function MR.fill (x, a)
  if is_scalar   (a) then return x:ones     (a) end
  if is_indexable(a) then return x:fromtable(a) end
  if is_callable (a) then -- function generator
    for i=0,x:rows()-1 do
      for j=0,x:cols()-1 do
        set0(x,i,j, a(get0(x,i,j), i+1,j+1))
      end
    end
    return x
  end
  error("invalid argument #2 (scalar, indexable or callable expected)")
end

function MR.getdiag (x, r_) -- equivalent to x:get_vec(1..x:size()..x:cols()+1)
  local n = min(x:sizes())
  local r = r_ or x:same(n,1)
  assert(is_table(r) or n <= #r, "incompatible sizes")
  for i=0,n-1 do r[i+1] = get0(x,i,i) end
  return r
end

function MR.setdiag (x, y)  -- y: scalar, range, table, matrix
  if is_scalar(y) then y = rep(y) end
  local n = min(#y, x:sizes())
  for i=0,n-1 do set0(x,i,i, y[i+1]) end
  return x
end

function MR.getrow (x, ir, r_)  -- ir: number, range, table, matrix
  if is_number(ir) then ir = {ir} end
  local k, nr, nc = 1, #ir, x:cols()
  local r = r_ or x:same(nr,nc)
  assert(is_table(r) or nr*nc <= #r, "incompatible sizes")
  for _,i in ipairs(ir) do
    for j=1,nc do
      r[k] = safe_get(x,i,j)  k=k+1
    end
  end
  return r
end

function MR.setrow (x, ir, y)  -- ir/y: number/scalar, range, table, matrix
  if is_number(ir) then ir = {ir} end
  if is_scalar(y)  then y  = rep(y) end
  local k, nc = 1, x:cols()
  assert(#ir*nc <= #y, "incompatible sizes")
  for _,i in ipairs(ir) do
    for j=1,nc do
      safe_set(x,i,j, y[k])  k=k+1
    end
  end
  return x
end

function MR.getcol (x, jc, r_)  -- jc: number, range, table, matrix
  if is_number(jc) then jc = {jc} end
  local k, nr, nc = 1, x:rows(), #jc
  local r = r_ or x:same(nr,nc)
  assert(is_table(r) or nr*nc <= #r, "incompatible sizes")
  for i=1,nr do
    for _,j in ipairs(jc) do
      r[k] = safe_get(x,i,j)  k=k+1
    end
  end
  return r
end

function MR.setcol (x, jc, y)  -- jc/y: number/scalar, range, table, matrix
  if is_number(jc) then jc = {jc} end
  if is_scalar(y)  then y  = rep(y) end
  local k, nr = 1, x:rows()
  assert(nr*#jc <= #y, "incompatible sizes")
  for i=1,nr do
    for _,j in ipairs(jc) do
      safe_set(x,i,j, y[k])  k=k+1
    end
  end
  return x
end

function MR.getvec (x, ij, r_)  -- ij: number, range, table, matrix
  if is_number(ij) then ij = {ij} end
  local n = #ij
  local r = r_ or x:same(n,1)
  assert(is_table(r) or n <= #r, "incompatible sizes")
  for i,ii in ipairs(ij) do r[i] = safe_geti(x,ii) end
  return r
end

function MR.setvec (x, ij, y)  -- ij/y: number/scalar, range, table, matrix
  if is_number(ij) then ij = {ij} end
  if is_scalar(y)  then y  = rep(y) end
  assert(#ij <= #y, "incompatible sizes")
  for i,ii in ipairs(ij) do safe_seti(x,ii, y[i]) end
  return x
end

function MR.getsub (x, ir, jc, r_) -- ir,jc: number, range, table, matrix
  if is_number(ir) then ir = {ir} end
  if is_number(jc) then jc = {jc} end
  local k, nr, nc = 1, #ir, #jc
  local r = r_ or x:same(nr,nc)
  assert(is_table(r) or nr*nc <= #r, "incompatible sizes")
  for _,i in ipairs(ir) do
    for _,j in ipairs(jc) do
      r[k] = safe_get(x,i,j)  k=k+1
    end
  end
  return r
end

function MR.setsub (x, ir, jc, y) -- ir,jc/y: number/scalar, range, table, matrix
  if is_number(ir) then ir = {ir} end
  if is_number(jc) then jc = {jc} end
  if is_scalar(y)  then y  = rep(y) end
  assert(#ir*#jc <= #y, "incompatible sizes")
  local k = 1
  for _,i in ipairs(ir) do
    for _,j in ipairs(jc) do
      safe_set(x,i,j, y[k])  k=k+1
    end
  end
  return x
end

-- foreach, map, fold ---------------------------------------------------------o

function MR.foreach (x, f, ij_)
  assert(is_callable(f), "invalid argument #2 (callable expected)")
  if ij_ == nil then
    for i=0,x:size()-1 do f(x.data[i]) end
  else
    local ij = ij_
    if is_number(ij) then ij = {ij} end
    for _,i in ipairs(ij) do f(safe_geti(x,i)) end
  end
  return x
end

function MR.map (x, f, ij_, r_)
  assert(is_callable(f), "invalid argument #2 (callable expected)")

  if ij_ == nil then
    local n, r0 = x:size(), f(x.data[0])
    local r = r_ or x:same(r0)
    assert(is_table(r) or n <= #r, "incompatible sizes")
    r[1] = r0
    for i=2,n do r[i] = f(geti(x,i)) end
    return r
  end

  local ij = ij_ or sid(x:size())
  if is_number(ij) then ij = {ij} end
  local n, r0 = #ij, f(safe_geti(x,ij[1]))
  local r = r_ or x:same(r0)
  assert(is_table(r) or n <= #r, "incompatible sizes")
  r[ij[1]] = r0
  for i=2,n do r[ij[i]] = f(safe_geti(x,ij[i])) end
  return r
end

function MR.map2 (x, y, f, ij_, r_)
  assert(is_callable(f), "invalid argument #3 (callable expected)")
  if is_scalar(y) then y = rep(y) end

  if ij_ == nil then
    local n, r0 = x:size(), f(x.data[0], y[1])
    local r = r_ or x:same(r0)
    assert((is_table(r) or n <= #r) and n <= #y, "incompatible sizes")
    r[1] = r0
    for i=2,n do r[i] = f(geti(x,i), y[i]) end
    return r
  end

  local ij = ij_ or sid(x:size())
  if is_number(ij) then ij = {ij} end
  local n, r0 = #ij, f(safe_geti(x,ij[1]), y[ij[1]])
  local r = r_ or x:same(r0)
  assert((is_table(r) or n <= #r) and n <= #y, "incompatible sizes")
  r[ij[1]] = r0
  for i=2,n do r[ij[i]] = f(safe_geti(x,ij[i]), y[ij[i]]) end
  return r

end

function MR.map3 (x, y, z, f, r_)
  assert(is_callable(f), "invalid argument #4 (callable expected)")
  if is_scalar(y) then y = rep(y) end
  if is_scalar(z) then z = rep(z) end
  local n, r0 = x:size(), f(x.data[0], y[1], z[1])
  local r = r_ or x:same(r0)
  assert((is_table(r) or n <= #r) and n <= #y and n <= #z, "incompatible sizes")
  r[1] = r0
  for i=2,n do r[i] = f(geti(x,i), y[i], z[i]) end
  return r
end

function MR.foldl (x, r, f)
  local nr, nc = x:sizes()
  if nr == r:rows() then
    for i=0,nr-1 do
      local ri = r:get0(i, 0)
      for j=0,nc-1 do ri = f(ri, x:get0(i,j)) end
      r:set0(i, 0, ri)
    end
  elseif nc == r:cols() then
    for j=0,nc-1 do
      local rj = r:get0(0, j)
      for i=0,nr-1 do rj = f(rj, x:get0(i,j)) end
      r:set0(0, j, rj)
    end
  else
    error("incompatible matrix sizes")
  end
  return r
end

function MR.foldr (x, r, f)
  local nr, nc = x:sizes()
  if nr == r:rows() then
    for i=0,nr-1 do
      local ri = r:get0(i, 0)
      for j=0,nc-1 do ri = f(x:get0(i,j), ri) end
      r:set0(i, 0, ri)
    end
  elseif nc == r:cols() then
    for j=0,nc-1 do
      local rj = r:get0(0, j)
      for i=0,nr-1 do rj = f(x:get0(i,j), rj) end
      r:set0(0, j, rj)
    end
  else
    error("incompatible matrix sizes")
  end
  return r
end

-- conjugate, transpose -------------------------------------------------------o

function MR.conjugate (x, r_)
  local r = r_ or is_matrix(x) and matrix(x:sizes()) or cmatrix(x:sizes())
  assert(x:rows() == r:rows() and x:cols() == r:cols(), "incompatible matrix sizes")
  if is_matrix(x) and x.data ~= r.data then
    _C.mad_vec_copy (x.data, r.data, x:size()) -- copy
  elseif is_cmatrix(x) then
    _C.mad_cvec_conj(x.data, r.data, x:size()) -- conjugate
  end
  return r
end

function MR.transpose (x, r_, c_)
  local nr, nc = x:sizes()
  local r = r_ or is_matrix(x) and matrix(nc, nr) or cmatrix(nc, nr)
  local c = c_ or true
  assert(nr == r:cols() and nc == r:rows(), "incompatible matrix sizes")
  if is_matrix(x) then
    _C.mad_mat_trans  (x.data, r.data, nr, nc)  -- transpose
  elseif c == true then
    _C.mad_cmat_ctrans(x.data, r.data, nr, nc)  -- conjugate transpose
  else
    _C.mad_cmat_trans (x.data, r.data, nr, nc)  -- transpose (no conjugate)
  end
  return r
end

MR.t      = MR.transpose            -- shortcut
MR.trans  = \x,r_ -> x:t(r_, false) -- never  conjugate
MR.ctrans = \x,r_ -> x:t(r_, true ) -- always conjugate

function MR.trace (x)
  local n, r = min(x:sizes()), 0
  for i=0,n-1 do r = r + x:get0(i,i) end
  return r
end

MR.tr = MR.trace -- shortcut

-- inner, cross, mixed, outer -------------------------------------------------o

function MR.inner (x, y)
  -- (x:t() * y):tr() without temporaries
  assert(isa_matrix(y), "matrix expected for 2nd argument")
  assert(x:rows() == y:rows(), "incompatible matrix sizes")

  if is_matrix(x) then
    if is_matrix(y) then
      return _C.mad_mat_dot(x.data, y.data, x:cols(), y:cols(), x:rows())
    else
      _C.mad_mat_dotm_r(x.data, y.data, cres, x:cols(), y:cols(), x:rows())
      return cres[0]
    end
  end

  if is_cmatrix(x) then
    if is_matrix(y) then
      _C.mad_cmat_dotm_r(x.data, y.data, cres, x:cols(), y:cols(), x:rows())
    else
      _C.mad_cmat_dot_r(x.data, y.data, cres, x:cols(), y:cols(), x:rows())
    end
    return cres[0]
  end

  error("invalid matrix dot operands")
end

MR.dot = MR.inner -- shortcut

function MR.cross (x, y, r_)
  assert(isa_matrix(y), "matrix expected for 2nd argument")
  local nr, nc = x:sizes()
  assert(nr == 3, "invalid matrix sizes")
  local r = r_ or is_matrix(x) and is_matrix(y) and matrix(3,nc) or cmatrix(3,nc)
  assert(nr == y:rows() and nc == y:cols() and
         nr == r:rows() and nc == r:cols(), "incompatible matrix sizes")
  local i0, i1, i2 = 0, nc, 2*nc
  for i=0,nc-1 do
    r.data[i0] = x.data[i1] * y.data[i2] - x.data[i2] * y.data[i1]
    r.data[i1] = x.data[i2] * y.data[i0] - x.data[i0] * y.data[i2]
    r.data[i2] = x.data[i0] * y.data[i1] - x.data[i1] * y.data[i0]
    i0, i1, i2 = i0+1, i1+1, i2+1
  end
  return r
end

function MR.mixed (x, y, z, r_)
  -- x:cross(y):dot(z) without temporary
  assert(isa_matrix(y) and isa_matrix(z), "matrices expected for 2nd and 3rd arguments")
  local nr, nc = x:sizes()
  assert(nr == 3, "invalid matrix sizes")
  local r
  if nc == 1 then -- single mixed product (r_ ignored)
    assert(nr == y:rows() and 1 == y:cols() and
           nr == z:rows() and 1 == z:cols(), "incompatible matrix sizes")
    r = conj(x.data[1] * y.data[2] - x.data[2] * y.data[1]) * z.data[0] +
        conj(x.data[2] * y.data[0] - x.data[0] * y.data[2]) * z.data[1] +
        conj(x.data[0] * y.data[1] - x.data[1] * y.data[0]) * z.data[2]
  else -- multiple mixed products
    r = r_ or is_matrix(x) and is_matrix(y) and matrix(nc,1) or cmatrix(nc,1)
    assert(nr == y:rows() and nc == y:cols() and
           nr == z:rows() and nc == z:cols() and
           nc == r:rows() and 1  == r:cols(), "incompatible matrix sizes")
    local i0, i1, i2 = 0, nc, 2*nc
    for i=0,nc-1 do
      r.data[i] = conj(x.data[i1] * y.data[i2] - x.data[i2] * y.data[i1]) * z.data[i0] +
                  conj(x.data[i2] * y.data[i0] - x.data[i0] * y.data[i2]) * z.data[i1] +
                  conj(x.data[i0] * y.data[i1] - x.data[i1] * y.data[i0]) * z.data[i2]
      i0, i1, i2 = i0+1, i1+1, i2+1
    end
  end
  return r
end

function MR.outer (x, y, r_)
  -- x * y:t() without temporary
  assert(isa_matrix(y), "matrix expected for 2nd argument")
  local nr, nc = x:rows(), y:rows()
  assert(x:cols() == 1 and y:cols() == 1, "invalid matrix sizes")
  local r = r_ or is_matrix(x) and is_matrix(y) and matrix(nr,nc) or cmatrix(nr,nc)
  assert(nr == r:rows() and nc == r:cols(), "incompatible matrix sizes")
  for i=0,nr-1 do
    for j=0,nc-1 do r:set0(i,j, x.data[i] * conj(y.data[j])) end
  end
  return r
end

-- unit, center, norm, angle --------------------------------------------------o

function MR.unit(x, r_)
  local n = x:norm()
  assert(n ~= 0, "null matrix")
  local r = r_ or x
  if n ~= 1 then x:div(n, r) end
  return r
end

function MR.center(x, r_) -- center data on average
  local r = r_ or x
      if is_vector (x) then _C.mad_vec_center (x.data, r.data, x:size())
  elseif is_matrix (x) then _C.mad_mat_center (x.data, r.data, x:rows(), x:cols())
  elseif is_cvector(x) then _C.mad_cvec_center(x.data, r.data, x:size())
  elseif is_cmatrix(x) then _C.mad_cmat_center(x.data, r.data, x:rows(), x:cols())
  end
  return r
end

function MR.norm (x)
  -- Frobenius norm (consistent with inner product)
  if is_matrix(x) then
    return sqrt(_C.mad_vec_dot(x.data, x.data, x:size()))
  else
    _C.mad_cvec_dot_r(x.data, x.data, cres, x:size())
    return sqrt(cres[0])
  end
end

function MR.angle (x, y, n_)
  local w = x:inner(y)
  local v = x:norm() * y:norm()
  assert(v ~= 0, "null vector") -- convention: return pi/2 ?
  local a = acos(w / v) -- [0, pi]
  if n_ and x:mixed(y, n_) < 0 then a = -a end -- [-pi, pi]
  return a
end

-- generic functions ----------------------------------------------------------o

MR.copy  = \x,r_ -> x:map(ident, r_)

MR.carg  = \x,r_ -> x:map(carg , r_)
MR.real  = \x,r_ -> x:map(real , r_)
MR.imag  = \x,r_ -> x:map(imag , r_)
MR.conj  = MR.conjugate
MR.rect  = \x,r_ -> x:map(rect , r_)
MR.polar = \x,r_ -> x:map(polar, r_)

MR.ceil  = \x,r_ -> x:map(ceil , r_)
MR.floor = \x,r_ -> x:map(floor, r_)
MR.frac  = \x,r_ -> x:map(frac , r_)
MR.trunc = \x,r_ -> x:map(trunc, r_)
MR.round = \x,r_ -> x:map(round, r_)

MR.abs   = \x,r_ -> x:map(abs  , r_)
MR.exp   = \x,r_ -> x:map(exp  , r_)
MR.log   = \x,r_ -> x:map(log  , r_)
MR.sqrt  = \x,r_ -> x:map(sqrt , r_)

MR.sin   = \x,r_ -> x:map(sin  , r_)
MR.cos   = \x,r_ -> x:map(cos  , r_)
MR.tan   = \x,r_ -> x:map(tan  , r_)
MR.sinh  = \x,r_ -> x:map(sinh , r_)
MR.cosh  = \x,r_ -> x:map(cosh , r_)
MR.tanh  = \x,r_ -> x:map(tanh , r_)

MR.asin  = \x,r_ -> x:map(asin , r_)
MR.acos  = \x,r_ -> x:map(acos , r_)
MR.atan  = \x,r_ -> x:map(atan , r_)
MR.asinh = \x,r_ -> x:map(asinh, r_)
MR.acosh = \x,r_ -> x:map(acosh, r_)
MR.atanh = \x,r_ -> x:map(atanh, r_)

-- generic operators ----------------------------------------------------------o

MR.unm = \x  ,r_ -> x:map (   unm, r_)
MR.mod = \x,y,r_ -> x:map2(y, mod, r_)
MR.pow = \x,y,r_ -> x:map2(y, pow, r_)

--[[ TODO
  mexp, mlog, msqrt, mpow using PadÃ© Approximants
  __eq with tol
]]

function MR.eq (x, y)
  if is_scalar(y) then
    for i=0,x:size()-1 do
      if x.data[i] ~= y then return false end
    end
    return true
  end

  if x:rows() ~= y:rows() or x:cols() ~= y:cols() then return false end
  for i=0,x:size()-1 do
    if x.data[i] ~= y.data[i] then return false end
  end
  return true
end

-- add

function MR.__radd_cpx (y, x, r)                  -- cpx + mat => cpx + vec
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_vec_addc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MR.__add (x, y, r)
  if is_number(x) then                           -- num + mat => num + vec
    r = chksiz(r,y) or matrix(y:sizes())
    _C.mad_vec_addn(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- mat + num => vec + num
    r = chksiz(r,x) or matrix(x:sizes())
    _C.mad_vec_addn(x.data, y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- mat + cpx => vec + cpx
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_vec_addc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_matrix(y) and is_matrix(x) then      -- mat + mat => vec + vec
    r = chksiz(r,x,y) or matrix(x:sizes())
    _C.mad_vec_add(x.data, y.data, r.data, r:size()) return r
  elseif is_cmatrix(y) then                      -- mat + cmat => vec + cvec
    r = chksiz(r,x,y) or cmatrix(x:sizes())
    _C.mad_cvec_addv(y.data, x.data, r.data, r:size()) return r
  elseif has_method(y, '__radd_mat') then        -- mat + ?
    return y:__radd_mat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

function MC.__radd_cpx (y, x, r)                  -- cpx + cmat => cpx + cvec
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_cvec_addc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MC.__add (x, y, r)
  if is_number(x) then                           -- num + cmat => num + cvec
    r = chksiz(r,y) or cmatrix(y:sizes())
    _C.mad_cvec_addn(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- cmat + num => cvec + num
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_cvec_addn(x.data, y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- cmat + cpx => cvec + cpx
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_cvec_addc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_matrix(y) then                       -- cmat + mat => cvec + vec
    r = chksiz(r,x,y) or cmatrix(x:sizes())
    _C.mad_cvec_addv(x.data, y.data, r.data, r:size()) return r
  elseif is_cmatrix(y) and is_cmatrix(x) then    -- cmat + cmat => cvec + cvec
    r = chksiz(r,x,y) or cmatrix(x:sizes())
    _C.mad_cvec_add(x.data, y.data, r.data, r:size()) return r
  elseif has_method(y, '__radd_cmat') then       -- cmat + ?
    return y:__radd_cmat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

-- sub

function MR.__rsub_cpx (y, x, r)                  -- cpx - mat => cpx - vec
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_vec_subc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MR.__sub (x, y, r)
  if is_number(x) then                           -- num - mat => num - vec
    r = chksiz(r,y) or matrix(y:sizes())
    _C.mad_vec_subn(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- mat - num => vec + -num
    r = chksiz(r,x) or matrix(x:sizes())
    _C.mad_vec_addn(x.data, -y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- mat - cpx => vec + -cpx
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_vec_addc_r(x.data, -y.re, -y.im, r.data, r:size()) return r
  elseif is_matrix(y) and is_matrix(x) then      -- mat - mat => vec - vec
    r = chksiz(r,x,y) or matrix(x:sizes())
    _C.mad_vec_sub(x.data, y.data, r.data, r:size()) return r
  elseif is_cmatrix(y) then                      -- mat - cmat => vec - cvec
    r = chksiz(r,x,y) or cmatrix(x:sizes())
    _C.mad_cvec_subv(y.data, x.data, r.data, r:size()) return r
  elseif has_method(y, '__rsub_mat') then        -- mat - ?
    return y:__rsub_mat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

function MC.__rsub_cpx (y, x, r)                  -- cpx - cmat => cpx - cvec
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_cvec_subc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MC.__sub (x, y, r)
  if is_number(x) then                           -- num - cmat => num - cvec
    r = chksiz(r,y) or cmatrix(y:sizes())
    _C.mad_cvec_subn(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- cmat - num => cvec + -num
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_cvec_addn(x.data, -y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- cmat - cpx => cvec + -cpx
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_cvec_addc_r(x.data, -y.re, -y.im, r.data, r:size()) return r
  elseif is_matrix(y) then                       -- cmat - mat => cvec - vec
    r = chksiz(r,x,y) or cmatrix(x:sizes())
    _C.mad_cvec_subv(x.data, y.data, r.data, r:size()) return r
  elseif is_cmatrix(y) and is_cmatrix(x) then    -- cmat - cmat => cvec - cvec
    r = chksiz(r,x,y) or cmatrix(x:sizes())
    _C.mad_cvec_sub(x.data, y.data, r.data, r:size()) return r
  elseif has_method(y, '__rsub_cmat') then       -- cmat - ?
    return y:__rsub_cmat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

-- mul

function MR.__rmul_cpx (y, x, r)                  -- cpx * mat => cpx * vec
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_vec_mulc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MR.__mul (x, y, r)
  if is_number(x) then                           -- num * mat => num * vec
    r = chksiz(r,y) or matrix(y:sizes())
    _C.mad_vec_muln(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- mat * num => vec * num
    r = chksiz(r,x) or matrix(x:sizes())
    _C.mad_vec_muln(x.data, y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- mat * cpx => vec * cpx
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_vec_mulc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_matrix(y) and is_matrix(x) then      -- mat * mat => vec * vec
    r = chksizm(r,x,y) or matrix(x:rows(), y:cols())
    _C.mad_mat_mul(x.data, y.data, r.data, r:rows(), r:cols(), x:cols()) return r
  elseif is_cmatrix(y) then                      -- mat * cmat => vec * cvec
    r = chksizm(r,x,y) or cmatrix(x:rows(), y:cols())
    _C.mad_mat_mulm(x.data, y.data, r.data, r:rows(), r:cols(), x:cols()) return r
  elseif has_method(y, '__rmul_mat') then        -- mat * ?
    return y:__rmul_mat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

function MC.__rmul_cpx (y, x, r)                  -- cpx * cmat => cpx * cvec
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_cvec_mulc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MC.__mul (x, y, r)
  if is_number(x) then                           -- num * cmat => num * cvec
    r = chksiz(r,y) or cmatrix(y:sizes())
    _C.mad_cvec_muln(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- cmat * num => cvec * num
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_cvec_muln(x.data, y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- cmat * cpx => cvec * cpx
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_cvec_mulc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_matrix(y) then                       -- cmat * mat => cvec * vec
    r = chksizm(r,x,y) or cmatrix(x:rows(), y:cols())
    _C.mad_cmat_mulm(x.data, y.data, r.data, r:rows(), r:cols(), x:cols()) return r
  elseif is_cmatrix(y) and is_cmatrix(x) then    -- cmat * cmat => cvec * cvec
    r = chksizm(r,x,y) or cmatrix(x:rows(), y:cols())
    _C.mad_cmat_mul(x.data, y.data, r.data, r:rows(), r:cols(), x:cols()) return r
  elseif has_method(y, '__rmul_cmat') then         -- cmat * ?
    return y:__rmul_cmat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

-- div

function MR.__rdiv_cpx (y, x, r, rcond_)          -- cpx / mat
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_mat_invc_r (y.data, x.re, x.im, r.data, y:rows(), y:cols(), rcond_ or -1) return r
end

function MR.__div (x, y, r, rcond_)
  if is_number(x) then                           -- num / mat
    r = chksiz(r,y) or matrix(y:sizes())
    _C.mad_mat_invn (y.data, x, r.data, y:rows(), y:cols(), rcond_ or -1) return r
  elseif is_number(y) then                       -- mat / num => vec / num
    r = chksiz(r,x) or matrix(x:sizes())
    _C.mad_vec_divn(x.data, y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- mat / cpx => vec / cpx
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_vec_divc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_matrix(y) and is_matrix(x) then      -- mat / mat => vec / vec
    r = chksizd(r,x,y) or matrix(x:rows(), y:rows())
    _C.mad_mat_div(x.data, y.data, r.data, r:rows(), r:cols(), x:cols(), rcond_ or -1) return r
  elseif is_cmatrix(y) then                      -- mat / cmat => vec / cvec
    r = chksizd(r,x,y) or cmatrix(x:rows(), y:rows())
    _C.mad_mat_divm(x.data, y.data, r.data, r:rows(), r:cols(), x:cols(), rcond_ or -1) return r
  elseif has_method(y, '__rdiv_mat') then        -- mat / ?
    return y:__rdiv_mat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

function MC.__rdiv_cpx (y, x, r, rcond_)         -- cpx / cmat
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_cmat_invc_r(y.data, x.re, x.im, r.data, y:rows(), y:cols(), rcond_ or -1)
  return r
end

function MC.__div (x, y, r, rcond_)
  if is_number(x) then                           -- num / cmat => num / cvec
    r = chksiz(r,y) or cmatrix(y:sizes())
    _C.mad_cmat_invn(y.data, x, r.data, y:rows(), y:cols(), rcond_ or -1) return r
  elseif is_number(y) then                       -- cmat / num => cvec / num
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_cvec_divn(x.data, y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- cmat / cpx => cvec / cpx
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_cvec_divc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_matrix(y) then                       -- cmat / mat => cvec / vec
    r = chksizd(r,x,y) or cmatrix(x:rows(), y:rows())
    _C.mad_cmat_divm(x.data, y.data, r.data, r:rows(), r:cols(), x:cols(), rcond_ or -1) return r
  elseif is_cmatrix(y) and is_cmatrix(x) then    -- cmat / cmat => cvec / cvec
    r = chksizd(r,x,y) or cmatrix(x:rows(), y:rows())
    _C.mad_cmat_div(x.data, y.data, r.data, r:rows(), r:cols(), x:cols(), rcond_ or -1) return r
  elseif has_method(y, '__rdiv_cmat') then       -- cmat / ?
    return y:__rdiv_cmat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

-- element wise mul and div

function MR.emul (x, y, r_)
  assert(isa_matrix(y), "matrix expected for 2nd argument")
  local r = r_ or is_matrix(x) and is_matrix(y) and matrix(x:sizes()) or cmatrix(x:sizes())
  assert(x:rows() == y:rows() and x:cols() == y:cols() and
         x:rows() == r:rows() and x:cols() == r:cols(), "incompatible matrix sizes")

  if is_matrix(x) then
    if is_matrix(y) then    -- mat .* mat => vec * vec
      _C.mad_vec_mul  (x.data, y.data, r.data, r:size())
    else                    -- mat .* cmat => cvec * vec
      _C.mad_cvec_mulv(y.data, x.data, r.data, r:size())
    end
    return r
  end

  if is_cmatrix(x) then
    if is_matrix(y) then    -- mat .* cmat => cvec * vec
      _C.mad_cvec_mulv(y.data, x.data, r.data, r:size())
    else                    -- cmat .* cmat => cvec * cvec
      _C.mad_cvec_mul (x.data, y.data, r.data, r:size())
    end
    return r
  end

  error("invalid matrix (.*) operands")
end

function MR.ediv (x, y, r_)
  assert(isa_matrix(y), "matrix expected for 2nd argument")
  local r = r_ or is_matrix(x) and is_matrix(y) and matrix(x:sizes()) or cmatrix(x:sizes())
  assert(x:rows() == y:rows() and x:cols() == y:cols() and
         x:rows() == r:rows() and x:cols() == r:cols(), "incompatible matrix sizes")

  if is_matrix(x) then
    if is_matrix(y) then    -- mat ./ mat => vec / vec
      _C.mad_vec_div (x.data, y.data, r.data, r:size())
    else                    -- mat ./ cmat => vec / cvec
      _C.mad_vec_divv(x.data, y.data, r.data, r:size())
    end
    return r
  end

  if is_cmatrix(x) then
    if is_matrix(y) then    -- mat ./ cmat => cvec / vec
      _C.mad_cvec_divv(x.data, y.data, r.data, r:size())
    else                    -- cmat ./ cmat => cvec / cvec
      _C.mad_cvec_div (x.data, y.data, r.data, r:size())
    end
    return r
  end

  error("invalid matrix (./) operands")
end

-- linear algebra -------------------------------------------------------------o

function MR.solve(a, b, rcond_)
  return b:t():div(a:t(), nil, rcond_):t()
end

function MR.svd (x)
  local nr, nc = x:sizes()
  local rs, ru, rv, info = matrix(min(nr,nc),1)

  if is_matrix(x) then
    ru, rv = matrix(nr,nr), matrix(nc,nc)
    info = _C.mad_mat_svd (x.data, ru.data, rs.data, rv.data, x:rows(), x:cols())
  else
    ru, rv = cmatrix(nr,nr), cmatrix(nc,nc)
    info = _C.mad_cmat_svd(x.data, ru.data, rs.data, rv.data, x:rows(), x:cols())
  end
  return ru, rs, rv, info
end

function MR.eigen (x)
  local nr, nc = x:sizes()
  assert(nr == nc, "matrix must be square")
  local w, vl, vr, info = cmatrix(nr, 1)

  if is_matrix(x) then
    vl, vr = matrix(nr,nr), matrix(nr,nr)
    info = _C.mad_mat_eigen (x.data, w.data, vl.data, vr.data, x:rows())
  else
    vl, vr = cmatrix(nr,nr), cmatrix(nr,nr)
    info = _C.mad_cmat_eigen(x.data, w.data, vl.data, vr.data, x:rows())
  end
  return w, vl, vr, info
end

-- FFT, convolution, correlation, covrariance ---------------------------------o

function MR.fft (x, r_)
  local nr, nc = x:sizes()
  local r = r_ or cmatrix(nr,nc)
  assert(nr == r:rows() and nc == r:cols(), "incompatible matrix sizes")

  if nr == 1 or nc == 1 then -- 1D FFT
    if is_matrix(x) then -- vec  -> cvec
      _C.mad_vec_fft (x.data, r.data, x:size())
    else             -- cvec -> cvec
      _C.mad_cvec_fft(x.data, r.data, x:size())
    end
  else                       -- 2D FFT
    if is_matrix(x) then -- mat  -> cmat
      _C.mad_mat_fft (x.data, r.data, x:rows(), x:cols())
    else             -- cmat -> cmat
      _C.mad_cmat_fft(x.data, r.data, x:rows(), x:cols())
    end
  end

  return r
end

function MR.ifft (x, r_)
  local nr, nc = x:sizes()
  local r = r_ or cmatrix(nr,nc)
  assert(nr == r:rows() and nc == r:cols(), "incompatible matrix sizes")

  if nr == 1 or nc == 1 then -- 1D FFT
    _C.mad_cvec_ifft(x.data, r.data, x:size())
  else                       -- 2D FFT
    _C.mad_cmat_ifft(x.data, r.data, x:rows(), x:cols())
  end

  return r
end

function MR.rfft (x, r_)
  assert(is_matrix(x), "matrix must be real")
  local nr, nc = x:sizes()
  local r

  if nr == 1 or nc == 1 then -- 1D FFT
    nr, nc = floor(nr/2+1), floor(nc/2+1)
    r = r_ or cmatrix(nr,nc)
    assert(nr == r:rows() and nc == r:cols(), "incompatible matrix sizes")
    _C.mad_vec_rfft(x.data, r.data, x:size())
  else                       -- 2D FFT
    nc = floor(nc/2+1)
    r = r_ or cmatrix(nr,nc)
    assert(nr == r:rows() and nc == r:cols(), "incompatible matrix sizes")
    _C.mad_mat_rfft(x.data, r.data, x:rows(), x:cols())
  end

  return r
end

function MR.irfft (x, r_) -- r_ can be the length
  assert(not r_ or is_matrix(r_), "result matrix must be real")
  local nr, nc = x:sizes()
  local r

  if nr == 1 or nc == 1 then -- 1D FFT
    nr, nc = max(1,(nr-1)*2), max(1,(nc-1)*2)
    r = r_ or matrix(nr,nc)
    assert(nr == r:rows() or nr+1 == r:rows() and
           nc == r:cols() or nc+1 == r:cols(), "incompatible matrix sizes")
    _C.mad_cvec_irfft(x.data, r.data, r:size())
  else                       -- 2D FFT
    nc = (nc-1)*2
    r = r_ or matrix(nr,nc)
    assert(nr == r:rows() and
           nc == r:cols() or nc+1 == r:cols(), "incompatible matrix sizes")
    _C.mad_cmat_irfft(x.data, r.data, r:rows(), r:cols())
  end

  return r
end

function MR.conv(x, y, r_) -- convolution theorem
  local r = r_ or x:same()
  if is_matrix(x) then -- mat
    local xf = x:rfft()
    if x == y then return xf:emul(xf      ,xf):irfft(r)
    else           return xf:emul(y:rfft(),xf):irfft(r)
    end
  else             -- cmat
    local xf = x:fft()
    if x == y then return xf:emul(xf     ,xf):ifft(r)
    else           return xf:emul(y:fft(),xf):ifft(r)
    end
  end
end

function MR.corr(x, y, r_) -- correlation theorem
  local r = r_ or x:same()
  if is_matrix(x) then -- mat
    local xf, yf = x:rfft()
    if x == y then     return xf:emul(xf:conj(  ),xf):irfft(r)
    else yf = y:rfft() return xf:emul(yf:conj(yf),xf):irfft(r)
    end
  else             -- cmat
    local xf, yf = x:fft()
    if x == y then     return xf:emul(xf:conj(  ),xf):ifft(r)
    else yf = y:fft()  return xf:emul(yf:conj(yf),xf):ifft(r)
    end
  end
end

function MR.covar(x, y, r_) -- covariance of random (row) vectors
  local xc = x:center(x:same())
  if x == y then return xc:corr(xc                , r_)
  else           return xc:corr(y:center(y:same()), r_)
  end
end

-- concatenation, conversion --------------------------------------------------o

function MR.concat (x, y, v_, r_)
  assert(isa_matrix(y), "matrix expected for 2nd argument")
  local nrx, ncx = x:sizes()
  local nry, ncy = y:sizes()
  if v_ then -- concat columns (vectical)
    local nr, nc = nrx + nry, ncx
    local r = r_ or is_matrix(x) and is_matrix(y) and matrix(nr,nc) or cmatrix(nr,nc)
    assert(ncx == ncy and nr == r:rows() and nc == r:cols(), "incompatible matrix sizes")
    local nx, ny = nrx * nc, nry * nc
    for i=0,nx-1 do r.data[i   ] = x.data[i] end
    for i=0,ny-1 do r.data[i+nx] = y.data[i] end
  else -- concat rows (horizontal)
    local nr, nc = nrx, ncx + ncy
    local r = r_ or is_matrix(x) and is_matrix(y) and matrix(nr,nc) or cmatrix(nr,nc)
    assert(nrx == nry and nr == r:rows() and nc == r:cols(), "incompatible matrix sizes")
    for i=0,nr do
      for j=0,ncx-1 do r:set0(i,j    , x:get0(i,j)) end
      for j=0,ncy-1 do r:set0(i,j+ncx, y:get0(i,j)) end
    end
  end
  return r
end

function MR.__tostring (x, sep_, lsep_)
  local nr, nc = x:sizes()
  local r, c = table.new(nr,0), table.new(nc,0)
  for i=0,nr-1 do
    for j=0,nc-1 do c[j+1] = tostring(x:get0(i,j)) end
    r[i+1] = table.concat(c, sep_ or ' ')
  end
  return table.concat(r, lsep_ or '\n')
end

function MR.__totable(x, r_)
  local nr, nc = x:sizes()
  local r = r_ or table.new(nr,0)
  assert(type(r) == 'table', "invalid argument #2 (table expected)")
  for i=0,nr-1 do
    local c = r[i+1] or table.new(nc,0)
    assert(type(c) == 'table', "invalid argument #2, (table of tables expected)")
    for j=0,nc-1 do c[j+1] = x:get0(i,j) end
    r[i+1] = c
  end
  return r
end

function MR.fromtable (x, t)
  assert(is_indexable(t), "invalid argument #1 (indexable expected)")
  local nr, nc = x:sizes()
  if is_indexable(t[1]) then
    assert(#t >= nr, "incompatible matrix-table column sizes")
    for i=0,nr-1 do
      local ti = t[i+1]
      assert(#ti >= nc, "incompatible matrix-table row sizes")
      for j=0,nc-1 do x:set0(i,j, ti[j+1]) end
    end
  else
    for i=1,nr*nc do
      x:seti(i, t[i])
    end
  end
  return x
end

-- metamethods ----------------------------------------------------------------o

MR.  unm, MR.  add, MR.  sub, MR.  mul, MR.  div, MR.  mod, MR.  pow =
MR.__unm, MR.__add, MR.__sub, MR.__mul, MR.__div, MR.__mod, MR.__pow

MC.  add, MC.  sub, MC.  mul, MC.  div =
MC.__add, MC.__sub, MC.__mul, MC.__div

MR.  eq, MR.length, MR.  concat =
MR.__eq, MR.__len , MR.__concat

local function iter (x, i)
  if i < x:size() then return i+1, x.data[i] end
end

MR.__ipairs = \s -> (iter, s, 0)

-- matrix-as-table behavior, unchecked bounds
MR.__index = \s,i -> is_number(i) and s.data[i-1] or MR[i]
MC.__index = \s,i -> is_number(i) and s.data[i-1] or MC[i]

function MR.__newindex (s, i, v)
  if is_number(i) then
    s.data[i-1] = v
  else
    error("invalid matrix member '" .. tostring(i) .. "'")
  end
end

-- matrices -------------------------------------------------------------------o

defhelp(MR)

for k,v in pairs(MR) do
  if is_nil(MC[k]) then MC[k] = v end
end

metatype( matrix_ctor_v, MR)
metatype(cmatrix_ctor_v, MC)

-- end ------------------------------------------------------------------------o
return {
  vector     = vector,
  cvector    = cvector,
  matrix     = matrix,
  cmatrix    = cmatrix,

  is_vector  = is_vector,
  is_matrix  = is_matrix,
  is_cvector = is_cvector,
  is_cmatrix = is_cmatrix,
  isa_vector = isa_vector,
  isa_matrix = isa_matrix,

--  linspace  = , -- TODO: nrange composed vector
--  logspace  = , -- TODO: nlogrange composed vector

  __help     = MR.__help
}
