--[=[
 o-----------------------------------------------------------------------------o
 |
 | Matrix module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides full set of functions and operations on real and complex matrices.
  - Vectors are column oriented matrices, i.e. implemented as [n x 1] matrices.

 o-----------------------------------------------------------------------------o
]=]

local MR, MC, MI = {}, {}, {}

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'
local istype in ffi

local type, assert, error, ipairs, tonumber, tostring_, table, string, rawequal =
      type, assert, error, ipairs, tonumber, tostring , table, string, rawequal


local _C, warn, tostring, complex, tocomplex, constant in MAD

local is_nil, is_boolean, is_logical, is_number, is_integer,
      is_string, is_range, is_table, is_complex, is_scalar,
      is_callable, is_iterable, get_metamethod                   in MAD.typeid
local ident, swap, compose, bind1st, opstr,
      unm, add, sub, mul, div, mod, pow, lbool, lnot, land, lor,
      rshift                                                     in MAD.gfunc
local fabs, cabs, carg, real, imag, conj, proj, rect, polar, ceil, floor,
      frac, trunc, round, abs, sqr, exp, log, log10, sqrt, sin, cos, tan, cot,
      sinh, cosh, tanh, coth, asin, acos, atan, acot, asinh, acosh, atanh,
      acoth, sinc, sinhc, asinc, asinhc, atan2, hypot, hypot3,
      wf, erf, erfc, erfi, erfcx, dawson,
      sign, sign1, sumsqrl, sumabsl, minabsl, maxabsl            in MAD.gmath
local rep, errorf, assertf, openfile, strsplitall,
      int2str, num2str, monotonic                                in MAD.utility
local inf, eps                                                   in constant
local min, max, random                                           in math

-- tmp for returned values
local ires = ffi.new  'idx_t[2]'
local  res = ffi.new  'num_t[2]'
local cres = ffi.new 'cnum_t[2]'

-- constants
local idx_sz = ffi.sizeof ' idx_t'
local dbl_sz = ffi.sizeof  'num_t'
local cpx_sz = ffi.sizeof 'cnum_t'

local gmm = get_metamethod

-- directions
local dir = { [0]='vec', [1]='row', [2]='col', [3]='diag',
              ['vec']=0, ['row']=1, ['col']=2, ['diag']=3 }

-- types ----------------------------------------------------------------------o

ffi.cdef 
[[ // warning: must be kept identical to C definition
struct  matrix { const ssz_t nrow, ncol;  num_t _dat[?]; };
struct cmatrix { const ssz_t nrow, ncol; cnum_t _dat[?]; };
struct imatrix { const ssz_t nrow, ncol;  idx_t _dat[?]; };
]]

local  matrix_ctor = ffi.typeof 'struct  matrix'
local cmatrix_ctor = ffi.typeof 'struct cmatrix'
local imatrix_ctor = ffi.typeof 'struct imatrix'

local  matrix_size = ffi.offsetof( matrix_ctor, '_dat')
local cmatrix_size = ffi.offsetof(cmatrix_ctor, '_dat')
local imatrix_size = ffi.offsetof(imatrix_ctor, '_dat')

local is_matrix  = \x -> istype( matrix_ctor, x)
local is_cmatrix = \x -> istype(cmatrix_ctor, x)
local is_imatrix = \x -> istype(imatrix_ctor, x)
local isa_matrix = \x -> is_matrix(x) or is_cmatrix(x)
local isy_matrix = \x -> is_matrix(x) or is_cmatrix(x) or is_imatrix(x)

local is_vector  = \x -> is_matrix (x) and (x.nrow == 1 or x.ncol == 1)
local is_cvector = \x -> is_cmatrix(x) and (x.nrow == 1 or x.ncol == 1)
local is_ivector = \x -> is_imatrix(x) and (x.nrow == 1 or x.ncol == 1)
local isa_vector = \x -> isa_matrix(x) and (x.nrow == 1 or x.ncol == 1)
local isy_vector = \x -> isy_matrix(x) and (x.nrow == 1 or x.ncol == 1)

-- allocators -----------------------------------------------------------------o

local function matrix_alloc (nr, nc)
  local len = nr*nc
  assert(len <= 2^30, "matrix is too large")
  local mat = matrix_ctor(len) -- VLA (hooked immediately before calling C)
  _C.mad_mat_reshape(mat, nr, nc)
  return mat
end

local function cmatrix_alloc (nr, nc)
  local len = nr*nc
  assert(len <= 2^29, "cmatrix is too large")
  local mat = cmatrix_ctor(len) -- VLA (hooked immediately before calling C)
  _C.mad_cmat_reshape(mat, nr, nc)
  return mat
end

local function imatrix_alloc (nr, nc)
  local len = nr*nc
  assert(len <= 2^30, "imatrix is too large")
  local mat = imatrix_ctor(len) -- VLA (hooked immediately before calling C)
  _C.mad_imat_reshape(mat, nr, nc)
  return mat
end

local function fromtable (ctor, tbl)
  local nr, nc = #tbl or 0, is_iterable(tbl[1]) and #tbl[1] or 1
  assert(nr > 0 and nc > 0, "invalid argument #1 (non-empty table expected)")
  return ctor(nr,nc):fill(tbl)
end

-- constructors ---------------------------------------------------------------o

local function matrix (nr, nc_)
  if is_table(nr) then
    return fromtable(matrix_alloc, nr)
  end
  local nc = nc_ or nr -- square
  assert(is_number(nr) and is_number(nc) and nr >= 1 and nc >= 1,
         "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)")
  return matrix_alloc(nr, nc)
end

local function cmatrix (nr, nc_)
  if is_table(nr) then
    return fromtable(cmatrix_alloc, nr)
  end
  local nc = nc_ or nr -- square
  assert(is_number(nr) and is_number(nc) and nr >= 1 and nc >= 1,
         "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)")
  return cmatrix_alloc(nr, nc)
end

local function imatrix (nr, nc_)
  if is_table(nr) then
    return fromtable(imatrix_alloc, nr)
  end
  local nc = nc_ or nr -- square
  assert(is_number(nr) and is_number(nc) and nr >= 1 and nc >= 1,
         "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)")
  return imatrix_alloc(nr, nc)
end

local  vector = \n ->  matrix(n, 1)
local cvector = \n -> cmatrix(n, 1)
local ivector = \n -> imatrix(n, 1)

-- checkers -------------------------------------------------------------------o

local function chksiz (r, x, y) -- add, sub
  assert((is_nil(r) or (r.nrow == x.nrow and r.ncol == x.ncol)) and
         (is_nil(y) or (y.nrow == x.nrow and y.ncol == x.ncol)),
         "incompatible matrix sizes")
  return r
end

local function chksizm (r, x, y) -- mul
  assert((is_nil(r) or (r.nrow == x.nrow and r.ncol == y.ncol)) and x.ncol == y.nrow,
         "incompatible matrix sizes")
  return r
end

local function chksiztm (r, x, y) -- tmul
  assert((is_nil(r) or (r.nrow == x.ncol and r.ncol == y.ncol)) and x.nrow == y.nrow,
         "incompatible matrix sizes")
  return r
end

local function chksizmt (r, x, y) -- mult
  assert((is_nil(r) or (r.nrow == x.nrow and r.ncol == y.nrow)) and x.ncol == y.ncol,
         "incompatible matrix sizes")
  return r
end

local function chksizt (r, x) -- transpose
  assert(is_nil(r) or (r.nrow == x.ncol and r.ncol == x.nrow),
         "incompatible matrix sizes")
  return r
end

-- get, set -------------------------------------------------------------------o

local idx     = \i,j,c   -> (( i-1)*c + j)
local idx_j   = \ij ,c   -> ((ij-1)%c + 1)

local geti0   = \x,i     -> x._dat[i]
local seti0   = \x,i,e   => x._dat[i]=e return x end
local geti    = \x,i     -> x._dat[i-1]
local seti    = \x,i,e   => x._dat[i-1]=e return x end
local get0    = \x,i,j   -> x._dat[ i   *x.ncol +  j   ]
local set0    = \x,i,j,e => x._dat[ i   *x.ncol +  j   ]=e return x end
local get     = \x,i,j   -> x._dat[(i-1)*x.ncol + (j-1)]
local set     = \x,i,j,e => x._dat[(i-1)*x.ncol + (j-1)]=e return x end

local geti_s  = \x,i   -> 1 <= i and i <= x.nrow*x.ncol                     and geti (x, i) or nil
local get_s   = \x,i,j -> 1 <= i and i <= x.nrow and 1 <= j and j <= x.ncol and get (x,i,j) or nil

local function idxij (ij, c)
  local j = (ij-1)%c + 1
  return (ij-j)/c + 1, j
end

local function seti_s (x, i, e)
  assert(1 <= i and i <= x.nrow*x.ncol, "index out of bounds")
  return seti(x, i, e)
end

local function set_s (x, i, j, e)
  assert(1 <= i and i <= x.nrow and 1 <= j and j <= x.ncol, "index out of bounds")
  return set(x, i, j, e)
end

MR.get  = get_s
MR.set  = set_s
MR.geti = geti_s
MR.seti = seti_s

MI.get  = get_s
MI.set  = set_s
MI.geti = geti_s
MI.seti = seti_s

-- sizes, same, copy, reshape -------------------------------------------------o

local size   = \x -> x.nrow * x.ncol -- #x
local sizes  = \x -> (x.nrow, x.ncol)
local tsizes = \x -> (x.ncol, x.nrow)

MR.size   = size
MR.sizes  = sizes
MR.tsizes = tsizes

MI.size   = MR.size
MI.sizes  = MR.sizes
MI.tsizes = MR.tsizes

MR.bytesize = \x -> dbl_sz * size(x)
MC.bytesize = \x -> cpx_sz * size(x)
MI.bytesize = \x -> idx_sz * size(x)

-- x:same()
-- x:same(e)
-- x:same(nr,nc)
-- x:same(nr,nc,e)

-- promote to matrix if e_ is not an integer and to cmatrix if e_ is a complex
function MI.__same (x, nr_, nc_, e_)
  if is_nil(nc_) then e_, nr_ = nr_, nil end
  local e, nr, nc = e_ or 0, nr_ or x.nrow, nc_ or x.ncol
  return is_integer(e) and imatrix(nr, nc) or
         is_complex(e) and cmatrix(nr, nc) or matrix(nr, nc)
end

-- promote to cmatrix if e_ is a complex
function MR.__same (x, nr_, nc_, e_)
  if is_nil(nc_) then e_, nr_ = nr_, nil end
  local e, nr, nc = e_ or 0, nr_ or x.nrow, nc_ or x.ncol
  return is_complex(e) and cmatrix(nr, nc) or matrix(nr, nc)
end

 -- promote to matrix if e_ is a number
function MC.__same (x, nr_, nc_, e_)
  if is_nil(nc_) then e_, nr_ = nr_, nil  end
  local e, nr, nc = e_ or 0i, nr_ or x.nrow, nc_ or x.ncol
  return is_number(e) and matrix(nr, nc) or cmatrix(nr, nc)
end

function MR.__copy (x, y_)
  if rawequal(x,y_) then return y_ end
  local y = chksiz(y_,x) or x:same()
  assert(is_matrix(y), "incompatible matrix type (matrix expected)")
  ffi.copy(y._dat, x._dat, x:bytesize())
  return y
end

function MC.__copy (x, y_)
  if rawequal(x,y_) then return y_ end
  local y = chksiz(y_,x) or x:same()
  assert(is_cmatrix(y), "incompatible matrix type (matrix expected)")
  ffi.copy(y._dat, x._dat, x:bytesize())
  return y
end

function MI.__copy (x, y_)
  if rawequal(x,y_) then return y_ end
  local y = chksiz(y_,x) or x:same()
  assert(is_imatrix(y), "incompatible matrix type (matrix expected)")
  ffi.copy(y._dat, x._dat, x:bytesize())
  return y
end

function MR.reshape (x, nr_, nc_)
  local nr, nc = nr_ or size(x), nc_ or 1
  assert(nr >= 1 and nc >= 1 and nr*nc <= size(x), "invalid matrix new sizes")
  _C.mad_mat_reshape(x, nr, nc)
  return x
end

function MC.reshape (x, nr_, nc_)
  local nr, nc = nr_ or size(x), nc_ or 1
  assert(nr >= 1 and nc >= 1 and nr*nc <= size(x), "invalid cmatrix new sizes")
  _C.mad_cmat_reshape(x, nr, nc)
  return x
end

function MI.reshape (x, nr_, nc_)
  local nr, nc = nr_ or size(x), nc_ or 1
  assert(nr >= 1 and nc >= 1 and nr*nc <= size(x), "invalid imatrix new sizes")
  _C.mad_imat_reshape(x, nr, nc)
  return x
end

function MR._reshapeto (x, nr, nc_)
  -- no check, user is responsible for keeping track of the real allocated size
  -- TOTALLY UNSAFE, accessing data ouside valid indexes trigs a SEGFAULT
  _C.mad_mat_reshape(x, nr, nc_ or 1)
  return x
end

function MC._reshapeto (x, nr, nc_)
  -- no check, user is responsible for keeping track of the real allocated size
  -- TOTALLY UNSAFE, accessing data ouside valid indexes trigs a SEGFAULT
  _C.mad_cmat_reshape(x, nr, nc_ or 1)
  return x
end

function MI._reshapeto (x, nr, nc_)
  -- no check, user is responsible for keeping track of the real allocated size
  -- TOTALLY UNSAFE, accessing data ouside valid indexes trigs a SEGFAULT
  _C.mad_imat_reshape(x, nr, nc_ or 1)
  return x
end

-- properties -----------------------------------------------------------------o

function MR.is_const (x, tol_)
  local tol, e = tol_ or 0, geti0(x,0)
  for i=1,size(x)-1 do
    if abs(geti0(x,i)-e) > tol then return false end
  end
  return true
end

function MR.is_diag (x, tol_)
  local tol, ii, nc = tol_ or 0, 0, x.ncol
  for i=0,size(x)-1 do
        if i == ii               then ii = ii+nc+1
    elseif abs(geti0(x,i)) > tol then return false end
  end
  return true
end

function MR.is_real (x)
  return true
end

function MC.is_real (x, tol_)
  local tol = tol_ or 0
  for i=0,size(x)-1 do
    if abs(geti0(x,i).im) > tol then return false end
  end
  return true
end

function MR.is_imag (x)
  return false
end

function MC.is_imag (x, tol_)
  local tol = tol_ or 0
  for i=0,size(x)-1 do
    if abs(geti0(x,i).re) > tol then return false end
  end
  return true
end

function MR.is_symm (x, tol_, sk_)
  if is_boolean(tol_) then sk_, tol_ = tol_, nil end -- right shift
  local tol, nr, nc = tol_ or 0, x:sizes()
  local sk = sk_ ~= true and 1 or -1
  if nr ~= nc then return false end
  for i=1,nr do
  for j=1,i  do
    if abs(get(x,i,j) - sk*get(x,j,i)) > tol then return false end
  end end
  return true
end

function MC.is_symm (x, tol_, sk_, cj_)
  if is_boolean(tol_) then sk_, cj_, tol_ = tol_, sk_, nil end -- right shift
  if sk_ == false then cj_, sk_ = sk_, nil end                 -- right shift
  local tol, nr, nc = tol_ or 0, x:sizes()
  local sk = sk_ ~= true  and 1 or -1
  local cj = cj_ ~= false and conj or ident
  if nr ~= nc then return false end
  for i=1,nr do
  for j=1,i  do
    if abs(get(x,i,j) - sk*cj(get(x,j,i))) > tol then return false end
  end end
  return true
end

function MR.is_symp (x, tol_) -- M' J M - J = symplectic deviation
  local nr, nc = x:sizes()
  if nr ~= nc or nr % 2 ~= 0 then return false end
  res[0] = tol_ or eps
  _C.mad_mat_symperr(x._dat, nil, nr, res)
  return res[0] ~= 0
end

function MC.is_symp (x, tol_) -- M' J M - J = symplectic deviation
  local nr, nc = x:sizes()
  if nr ~= nc or nr % 2 ~= 0 then return false end
  res[0] = tol_ or eps
  _C.mad_cmat_symperr(x._dat, nil, nr, res)
  return res[0] ~= 0
end

-- zeros, ones, eye, symp, circ, fill, shift, reshape (in place) --------------o

function MR.zeros (x)
  ffi.fill(x._dat, dbl_sz * size(x))
  return x
end

function MC.zeros (x)
  ffi.fill(x._dat, cpx_sz * size(x))
  return x
end

function MI.zeros (x)
  ffi.fill(x._dat, idx_sz * size(x))
  return x
end

function MR.ones (x, e_)
  local e, n = e_ or 1, size(x)
  for i=0,n-1 do seti0(x,i,e) end
  return x
end

MI.ones = MR.ones

function MR.eye (x, e_) -- zeros + diag
  x:zeros()
  local e, nr, nc = e_ or 1, x:sizes()
  local n = min(nr, nc)
  for i=0,n*nc,nc+1 do seti0(x,i,e) end
  return x
end

MI.eye = MR.eye

function MR.seq (x, e0_, d_)
  if is_string(e0_) and is_nil(d_) then d_, e0_ = e0_ end -- right shift
  local e0 = e0_ or 0
  if d_ == 'col' then
    local k, nr, nc = 1, x:sizes()
    for i=1,nr do
    for j=1,nc do seti(x,k,e0+idx(j,i,nr)) ; k=k+1 end end
  else
    for i=1,size(x) do seti(x,i,e0+i) end
  end
  return x
end

MI.seq = MR.seq

function MR.random (x, f_, ...) -- random
  assert(is_nil(f_) or is_callable(f_), "invalid argument #2 (callable expected)")
  local n, f = size(x), f_ or random
  for i=0,n-1 do seti0(x,i,f(...)) end
  return x
end

function MC.random (x, f_, ...) -- random
  assert(is_nil(f_) or is_callable(f_), "invalid argument #2 (callable expected)")
  local n, f = size(x), f_ or random
  for i=0,n-1 do seti0(x,i,complex(f(...),f(...))) end
  return x
end

MI.random = MR.random

function MR.shuffle (x) -- random permutation (Knuth shuffle)
  local n = size(x)
  for i=0,n-2 do
    local j = random(i,n-1)
    x._dat[i], x._dat[j] = x._dat[j], x._dat[i]
  end
  return x
end

MI.shuffle = MR.shuffle

function MR.symp (x) -- zeros + J
  local nr, nc = x:sizes()
  assert(nr == nc and nr % 2 == 0, "invalid argument #1 (2n matrix expected)")
  x:zeros()
  for i=1,nr-1,2 do set(x,i,i+1,1) set(x,i+1,i,-1) end
  return x
end

function MR.circ (x, v)
  local d
  if isa_vector(v) then
    d = v.nrow == 1 and 'row' or 'col'
  else
    assert(is_iterable(v), "invalid argument #2 (iterable expected)")
    if is_iterable(v[1]) then d, v = 'row', v[1] else d = 'col' end
  end
  local k, nr, nc = 0, x:sizes()
  if d == 'row' then
    for i=1,nr do
    for j=nc+2-i,nc do seti0(x,k, v[j]) k=k+1 end
    for j=1,nc+1-i  do seti0(x,k, v[j]) k=k+1 end
    end
  else
    for i=1,nr do
    for j= i,  1,-1 do seti0(x,k, v[j]) k=k+1 end
    for j=nc,i+1,-1 do seti0(x,k, v[j]) k=k+1 end
    end
  end
  return x
end

function MR.fill (x, a, p_, s_)
  local nr, nc = x:sizes()
  if is_scalar(a) then        -- scalar
    for i=0,nr*nc-1 do seti0(x,i, a) end
  elseif is_callable(a) then  -- generator
    if is_nil(p_) or is_nil(s_) then
      for i=1,nr do
      for j=1,nc do set(x,i,j, a(get(x,i,j), i,j)) end end
    else                      -- stateless iterator
      local v
      for i=0,nr*nc-1 do s_,v = a(p_,s_) ; seti0(x,i,v) end
    end
  elseif is_iterable(a) then
    if is_iterable(a[1]) then -- 2D container
      assert(#a == nr, "incompatible container size")
      for i=1,nr do
        assert(is_iterable(a[i]), "invalid container (iterable expected)")
        assertf(#a[i] == nc, "incompatible container size row %d, %d ~= %d", i, #a[i], nc)
        for j=1,nc do set(x,i,j, a[i][j]) end
      end
    else                      -- 1D container
      assert(#a == nr*nc, "incompatible container size")
      for i=1,nr*nc do seti(x,i, a[i]) end
    end
  else
    error("invalid argument #2 (scalar, callable or iterable expected)")
  end
  return x
end

MI.fill = MR.fill

function MR.roll (x, ns_, ms_)
  local nr, nc = x:sizes()
  if is_nil(ms_) and (nr == 1 or nc == 1)
  then _C.mad_vec_roll(x._dat, nr*nc, ns_ or 0)
  else _C.mad_mat_roll(x._dat, nr, nc, ns_ or 0, ms_ or 0)
  end
  return x
end

function MC.roll (x, ns_, ms_)
  local nr, nc = x:sizes()
  if is_nil(ms_) and (nr == 1 or nc == 1)
  then _C.mad_cvec_roll(x._dat, nr*nc, ns_ or 0)
  else _C.mad_cmat_roll(x._dat, nr, nc, ns_ or 0, ms_ or 0)
  end
  return x
end

function MI.roll (x, ns_, ms_)
  local nr, nc = x:sizes()
  if is_nil(ms_) and (nr == 1 or nc == 1)
  then _C.mad_ivec_roll(x._dat, nr*nc, ns_ or 0)
  else _C.mad_imat_roll(x._dat, nr, nc, ns_ or 0, ms_ or 0)
  end
  return x
end

function MR.movev (x, i, j, yi, y_) -- move x[i..j] to y[yi,yi+j-i]
  local y, yj = y_ or x, yi+j-i
  assert(i  >= 1 and j  <= size(x) and i <= j, "source indexes out of bounds")
  assert(yi >= 1 and yj <= size(y),       "destination indexes out of bounds")
  _C.mad_vec_copy(x._dat+i-1, y._dat+yi-1, j-i+1)
  return y
end

function MC.movev (x, i, j, yi, y_)
  local y, yj = y_ or x, yi+j-i
  assert(i  >= 1 and j  <= size(x) and i <= j, "source indexes out of bounds")
  assert(yi >= 1 and yj <= size(y),       "destination indexes out of bounds")
  _C.mad_cvec_copy(x._dat+i-1, y._dat+yi-1, j-i+1)
  return y
end

function MI.movev (x, i, j, yi, y_)
  local y, yj = y_ or x, yi+j-i
  assert(i  >= 1 and j  <= size(x) and i <= j, "source indexes out of bounds")
  assert(yi >= 1 and yj <= size(y),       "destination indexes out of bounds")
  _C.mad_ivec_copy(x._dat+i-1, y._dat+yi-1, j-i+1)
  return y
end

function MR.shiftv (x, ni, ns_) -- shift data >= ni by +/-ns
  local n, ns = size(x), ns_ or 1
  assert(ni >= 1 and ni <= n, "index out of bounds")
  if ns ~= 0 and ni+ns >= 1 and ni+ns <= n then
    _C.mad_vec_copy(x._dat+(ni-1), x._dat+(ni-1)+ns, n-(ni-1)-max(0,ns))
  end
  return x
end

function MC.shiftv (x, ni, ns_)
  local n, ns = size(x), ns_ or 1
  assert(ni >= 1 and ni <= n, "index out of bounds")
  if ns ~= 0 and ni+ns >= 1 and ni+ns <= n then
    _C.mad_cvec_copy(x._dat+(ni-1), x._dat+(ni-1)+ns, n-(ni-1)-max(0,ns))
  end
  return x
end

function MI.shiftv (x, ni, ns_)
  local n, ns = size(x), ns_ or 1
  assert(ni >= 1 and ni <= n, "index out of bounds")
  if ns ~= 0 and ni+ns >= 1 and ni+ns <= n then
    _C.mad_ivec_copy(x._dat+(ni-1), x._dat+(ni-1)+ns, n-(ni-1)-max(0,ns))
  end
  return x
end

-- conversion -----------------------------------------------------------------o

function MR.cplx (re_, im_, r_) -- (re,im) -> r
  local re, im = re_ or im_, im_ or re_ -- trick for checks with at least one
  assert(is_matrix(re) and is_matrix(im), "invalid argument #1 or #2 (matrix expected)")
  local r = r_ or cmatrix_alloc(re:sizes()) ; chksiz(r,re,im)
  _C.mad_vec_cplx(re_ and re_._dat, im_ and im_._dat, r._dat, size(r))
  return r
end

MC.cplx = \ -> error("invalid argument #1 (matrix expected)")
MR.reim = \ -> error("invalid argument #1 (cmatrix expected)")

function MC.reim (x, re_, im_) -- x -> (re,im)
  assert(is_nil(re_) or is_matrix(re_), "invalid argument #2 (matrix expected)")
  assert(is_nil(im_) or is_matrix(im_), "invalid argument #3 (matrix expected)")
  re_ = chksiz(re_,x) or matrix_alloc(x:sizes())
  im_ = chksiz(im_,x) or matrix_alloc(x:sizes())
  _C.mad_cvec_reim(x._dat, re_._dat, im_._dat, size(x))
  return re_, im_
end

function MR.real (x, r)
  assert(is_nil(r) or is_matrix(r), "invalid argument #2 (matrix expected)")
  r = chksiz(r,x) or matrix_alloc(x:sizes())
  _C.mad_vec_copy(x._dat, r._dat, size(x))
  return r
end

function MC.real (x, r)
  assert(is_nil(r) or is_matrix(r), "invalid argument #2 (matrix expected)")
  r = chksiz(r,x) or matrix_alloc(x:sizes())
  _C.mad_cvec_reim(x._dat, r._dat, nil, size(x))
  return r
end

function MR.imag (x, r)
  assert(is_nil(r) or is_matrix(r), "invalid argument #2 (matrix expected)")
  r = chksiz(r,x) or matrix_alloc(x:sizes())
  return r:zeros()
end

function MC.imag (x, r)
  assert(is_nil(r) or is_matrix(r), "invalid argument #2 (matrix expected)")
  r = chksiz(r,x) or matrix_alloc(x:sizes())
  _C.mad_cvec_reim(x._dat, nil, r._dat, size(x))
  return r
end

-- special ctors --------------------------------------------------------------o

function MR.vec (x)
  local nr, nc = x:sizes()
  local k, r = 1, x:same(nr*nc,1)
  for j=1,nc do
  for i=1,nr do seti(r, k, get(x,i,j)) ; k = k+1 end end
  return r
end

function MR.vech (x)
  local nr, nc = x:sizes()
  assert(nr == nc, "invalid matrix sizes (square matrix expected)")
  local k, r = 1, x:same(nr*(nc+1)/2,1)
  for j=1,nc do
  for i=j,nr do seti(r, k, get(x,i,j)) ; k = k+1 end end
  return r
end

function MR.diag (x, k_)
  local k, nr, nc = k_ or 0, x:sizes()
  assert(is_integer(k), "invalid argument #2 (integer expected)")
  if nr == 1 or nc == 1 then
    local nn = nr*nc+abs(k)
    local r = x:same(nn,nn)
    k = k < 0 and -k*nn or k
    for i=1,nr*nc do seti(r, i+k, geti(x,i)) ; k = k+nn end
    return r
  else
    local nn = min(nr,nc)-abs(k)
    local r = x:same(nn,1)
    k = k < 0 and -k*nn or k
    for i=1,nn do seti(r, i, geti(x,i+k)) ; k = k+nc end
    return r
  end
end

MI.vec  = MR.vec
MI.vech = MR.vech
MI.diag = MR.diag

-- indexing -------------------------------------------------------------------o

function MR.getij (x, ij_, ri_, rj_)
  -- single index
  if is_number(ij_) then return idxij(ij_, x.ncol) end

  -- list of indexes
  if is_nil(ij_) then ij_ = 1..size(x) end
  assert(is_iterable(ij_), "invalid argument #2 (index or iterable expected)")
  local ri, rj, nc = ri_ or ivector(#ij_), rj_ or ivector(#ij_), x.ncol
  assert(is_iterable(ri), "invalid argument #3 (iterable expected)")
  assert(is_iterable(rj), "invalid argument #4 (iterable expected)")
  for k=1,#ij_ do ri[k], rj[k] = idxij(ij_[k], nc) end
  return ri, rj, ij_
end

function MR.getidx (x, ir_, jc_, rij_)
  -- single index
  if is_number(ir_) and is_number(jc_) then return idx(ir_, jc_, x.ncol) end

  -- list of indexes
  if is_nil(ir_) then ir_ = 1..x.nrow elseif is_number(ir_) then ir_ = {ir_} end
  if is_nil(jc_) then jc_ = 1..x.ncol elseif is_number(jc_) then jc_ = {jc_} end
  assert(is_iterable(ir_), "invalid argument #2 (index or iterable expected)")
  assert(is_iterable(jc_), "invalid argument #3 (index or iterable expected)")
  local rij = rij_ or ivector(#ir_ * #jc_)
  assert(is_iterable(rij), "invalid argument #4 (iterable expected)")
  local k, nc = 1, x.ncol
  for _,i in ipairs(ir_) do
  for _,j in ipairs(jc_) do rij[k], k = idx(i,j,nc), k+1 end end
  return rij, ir_, jc_
end

function MR.getdidx (x, k_)
  local k, nr, nc = k_ or 0, x:sizes()
  assert(is_integer(k), "invalid argument #2 (integer expected)")
  assert(k >= 0 and k <= nc or -k <= nr, "diagonal index out of range")
  local ii, nn
  if k < 0
  then ii, nn = -k*nc, min(nc, nr - k)*nc
  else ii, nn =  k   , min(nr, nc - k)*nc
  end
  return 1+ii..nn..nc+1
end

MI.getij   = MR.getij
MI.getidx  = MR.getidx
MI.getdidx = MR.getdidx

-- getx, setx, swpx, insx, remx -----------------------------------------------o

function MR.getvec (x, ij, r_)
  if is_number(ij) then ij = {ij} end
  assert(is_iterable(ij), "invalid argument #2 (non-empty iterable expected)")
  local r = r_ or x:same(#ij,1)
  assert(is_iterable(r), "invalid argument #3 (iterable expected)")
  for i,ii in ipairs(ij) do r[i] = geti_s(x,ii) end
  return r
end

function MR.setvec (x, ij, y, p_, s_) -- inplace
  if is_number(ij) then ij = {ij} end
  if is_scalar(y) then y = rep(y) end
  assert(is_iterable(ij), "invalid argument #2 (iterable expected)")
  if is_nil(p_) then
    assert(is_iterable(y), "invalid argument #3 (scalar or iterable expected)")
    local ny = #y
    for i,ii in ipairs(ij) do seti_s(x,ii,y[(i-1)%ny+1]) end
  else  -- stateless iterator
    assert(is_callable(y), "invalid argument #3 (scalar or callable expected)")
    local v
    for _,ii in ipairs(ij) do s_,v = y(p_,s_) ; seti_s(x,ii,v) end
  end
  return x
end

function MR.swpvec (x, ij, ij2) -- inplace
  if is_number(ij ) then ij  = {ij } end
  if is_number(ij2) then ij2 = {ij2} end
  assert(is_iterable(ij ), "invalid argument #2 (iterable expected)")
  assert(is_iterable(ij2), "invalid argument #3 (iterable expected)")
  local n, n2 = #ij, #ij2
  for k=1,min(n,n2) do x[ij[k]], x[ij2[k]] = x[ij2[k]], x[ij[k]] end
  return x
end

function MR.remvec (x, ij) -- inplace
  if is_number(ij) then ij = {ij} end
  assert(is_iterable(ij), "invalid argument #2 (iterable expected)")
  local n = size(x)
  local k, ik = 1, {}
  for _,i in ipairs(ij) do ik[i] = true end -- collect indexes
  for i=1,n do if not ik[i] then x[k] = geti_s(x,i) ; k=k+1 end end
  return x:reshape(n-#ij,1)
end

function MR.insvec (x, ij, y) -- inplace
  if is_number(ij) then ij = {ij} end
  if is_scalar(y) then y = rep(y) end
  assert(is_iterable(ij), "invalid argument #2 (iterable expected)")
  assert(is_iterable(y) , "invalid argument #3 (scalar or iterable expected)")

  -- check if ij is monotonic
  local nx, nij, ny, ord = size(x), #ij, #y, monotonic(ij)

  -- increasing indexes, linear insertion
  if ord == 1 then
    local i, j = nx, nij
    while i >= 1 and j >= 1 do
      for k=i,ij[j]+1,-1 do x[k] = x[k-j] end
      i, j, x[ij[j]] = ij[j]-1, j-1, y[(j-1)%ny+1]
    end

  -- decreasing indexes, linear insertion
  elseif ord == -1 then
    local i, j, k = nx, 1, 1
    while i >= 1 and j <= nij do
      for k=i,ij[j]+1,-1 do x[k] = x[k-j] end
      i, j, x[ij[j]] = ij[j]-1, j+1, y[(j-1)%ny+1]
    end

  -- random or constant indexes, quadratic insertion
  else
    for j=1,nij do
      for k=nx,ij[j]+1,-1 do x[k] = x[k-1] end
      x[ij[j]] = y[(j-1)%ny+1]
    end
  end

  return x
end

function MR.getsub (x, ir_, jc_, r_)
  local ij, ir, jc = x:getidx(ir_,jc_)
  if ir and is_nil(r_) then return x:getvec(ij, x:same(#ir,#jc)) end
  if is_nil(ir_) and not (is_nil(jc_) or (isy_matrix(r_) and r_.ncol > 1)) then
    _C.mad_imat_trans(ij._dat, ij._dat, #ir, #jc)
  end
  return x:getvec(ij, r_)
end

function MR.setsub (x, ir_, jc_, y, p_, s_)
  local ij, ir, jc = x:getidx(ir_,jc_)
  if is_nil(ir_) and not (is_nil(jc_) or (isy_matrix(y) and y.ncol > 1)) then
    _C.mad_imat_trans(ij._dat, ij._dat, #ir, #jc)
  end
  return x:setvec(ij, y, p_, s_)
end

function MR.inssub (x, ir_, jc_, y)
  if is_nil(ir_) and not (is_nil(jc_) or (isy_matrix(y) and y.ncol > 1)) then
    x:t(x) ; return x:insvec(x:getidx(jc_,ir_), y):t(x)
  else
    return x:insvec(x:getidx(ir_,jc_), y)
  end
end

function MR.remsub (x, ir_, jc_)
  if ir_ then
    local nr, nc = x:sizes()
    local ij, ir, _ = x:getidx(ir_, 1..nc)
    x:remvec(ij):reshape(nr-#ir, nc)
  end
  if jc_ then
    local nr, nc = x:sizes()
    local ij, _, jc = x:getidx(1..nr, jc_)
    x:remvec(ij):reshape(nr, nc-#jc)
  end
  return x
end

function MR.swpsub (x, ir_, jc_, ir2_, jc2_) -- inplace
  return x:swpvec(x:getidx(ir_,jc_), x:getidx(ir2_,jc2_))
end

function MR.getdiag (x, k_, r_)
  if k_ and not is_number(k_) and is_nil(r_) then r_, k_ = k_, nil end
  return x:getvec(x:getdidx(k_), r_)
end

function MR.setdiag (x, y, k_, p_, s_) -- inplace
  if k_ and not is_number(k_) and is_nil(s_) then p_, s_, k_ = k_, p_, nil end
  return x:setvec(x:getdidx(k_), y, p_, s_)
end

MR.getrow = \x,ir,r_      -> x:getsub(ir,nil,r_)
MR.setrow = \x,ir,y,p_,s_ -> x:setsub(ir,nil,y,p_,s_)
MR.swprow = \x,ir,ir2     -> x:swpsub(ir,nil,ir2,nil)
MR.remrow = \x,ir         -> x:remsub(ir,nil)
MR.insrow = \x,ir,y       -> x:inssub(ir,nil,y)

MR.getcol = \x,jc,r_      -> x:getsub(nil,jc,r_)
MR.setcol = \x,jc,y,p_,s_ -> x:setsub(nil,jc,y,p_,s_)
MR.swpcol = \x,jc,jc2     -> x:swpsub(nil,jc,nil,jc2)
MR.remcol = \x,jc         -> x:remsub(nil,jc)
MR.inscol = \x,jc,y       -> isy_matrix(y) and y.ncol > 1 and
                             x:inssub(nil,jc,0):setsub(nil,jc,y) or x:inssub(nil,jc,y)

MI.getvec = MR.getvec
MI.setvec = MR.setvec
MI.swpvec = MR.swpvec
MI.remvec = MR.remvec
MI.insvec = MR.insvec

MI.getsub = MR.getsub
MI.setsub = MR.setsub
MI.swpsub = MR.swpsub
MI.remsub = MR.remsub
MI.inssub = MR.inssub

MI.getrow = MR.getrow
MI.setrow = MR.setrow
MI.swprow = MR.swprow
MI.remrow = MR.remrow
MI.insrow = MR.insrow

MI.getcol = MR.getcol
MI.setcol = MR.setcol
MI.swpcol = MR.swpcol
MI.remcol = MR.remcol
MI.inscol = MR.inscol

MI.getdiag = MR.getdiag
MI.setdiag = MR.setdiag

-- reverse --------------------------------------------------------------------o

function MR.rev (x, d_)
  local d = assert(dir[d_ or 'vec'], "invalid direction")
  _C.mad_mat_rev(x._dat, x.nrow, x.ncol, d) return x
end

function MC.rev (x, d_)
  local d = assert(dir[d_ or 'vec'], "invalid direction")
  _C.mad_cmat_rev(x._dat, x.nrow, x.ncol, d) return x
end

function MI.rev (x, d_)
  local d = assert(dir[d_ or 'vec'], "invalid direction")
  _C.mad_imat_rev(x._dat, x.nrow, x.ncol, d) return x
end

-- foreach, map, fold, scan, filter -------------------------------------------o

function MR.foreach (x, ij_, f, r_)
  if is_callable(ij_) or is_string(ij_) then f, r_, ij_ = ij_, f end -- right shift
  if is_string(f ) then f = assert(opstr[f], "invalid operator string") end
  if is_string(r_) and r_ == 'in' or ij_ and is_nil(r_) then r_ = x end
  local ij = ij_ or 1..size(x)
  assert(is_iterable(ij), "invalid argument #2 (iterable expected)")
  assert(is_callable(f ), "invalid argument #3 (callable expected)")
  if is_nil(r_) then
    for _,ii in ipairs(ij) do         f(geti_s(x,ii), ii) end
  else
    assert(is_iterable(r_), "invalid argument #4 (iterable expected)")
    for i,ii in ipairs(ij) do r_[i] = f(geti_s(x,ii), ii) end
  end
  return x
end

MI.foreach = MR.foreach

function MR.filter (x, ij_, p, r_)
  if is_callable(ij_) then p, r_, ij_ = ij_, p end -- right shift
  if is_string(r_) and r_ == 'in' or ij_ and is_nil(r_) then r_ = x end
  local ij = ij_ or 1..size(x)
  assert(is_iterable(ij), "invalid argument #2 (iterable expected)")
  assert(is_callable(p) , "invalid argument #3 (callable expected)")
  local r, ri = r_ or x:same(), is_table(r_) and {} or ivector(size(x))
  assert(is_iterable(r) , "invalid argument #4 (iterable expected)")
  local k = 1
  for _,ii in ipairs(ij) do
    local v = geti_s(x,ii)
    if p(v, ii) == true then r[k], ri[k], k = v, ii, k+1 end
  end
  if k == 1 then return {}, {} end
  if isy_matrix(r ) then r :reshape(k-1) end
  if is_imatrix(ri) then ri:reshape(k-1) end
  return r, ri
end

function MR.filter_out (x, ij_, p, r_)
  if is_callable(ij_) then p, r_, ij_ = ij_, p end -- right shift
  return x:filter(ij_,compose(lnot,p), r_)
end

MI.filter     = MR.filter
MI.filter_out = MR.filter_out

function MR.map (x, ij_, f, r_)
  if is_callable(ij_) or is_string(ij_) then f, r_, ij_ = ij_, f end -- right shift
  if is_string(f ) then f = assert(opstr[f], "invalid operator string") end
  if is_string(r_) and r_ == 'in' or ij_ and is_nil(r_) then r_ = x end
  local ij = ij_ or 1..size(x)
  assert(is_iterable(ij), "invalid argument #2 (iterable expected)")
  assert(is_callable(f ), "invalid argument #3 (callable expected)")
  if is_nil(r_) then r_ = x:same(f(x[ij[1]], ij[1])) end
  assert(is_iterable(r_), "invalid argument #4 (iterable expected)")
  for _,ii in ipairs(ij) do r_[ii] = f(geti_s(x,ii), ii) end
  return r_
end

MI.map = MR.map

function MR.map2 (x, y, ij_, f, r_)
  if is_callable(ij_) or is_string(ij_) then f, r_, ij_ = ij_, f end -- right shift
  if is_scalar(y ) then y = rep(y) end
  if is_string(f ) then f = assert(opstr[f], "invalid operator string") end
  if is_string(r_) and r_ == 'in' or ij_ and is_nil(r_) then r_ = x end
  local ij = ij_ or 1..size(x)
  assert(is_iterable(y ), "invalid argument #2 (scalar or iterable expected)")
  assert(is_iterable(ij), "invalid argument #3 (iterable expected)")
  assert(is_callable(f ), "invalid argument #4 (callable expected)")
  if is_nil(r_) then r_ = x:same(f(x[ij[1]], y[ij[1]], ij[1])) end
  assert(is_iterable(r_), "invalid argument #5 (iterable expected)")
  for _,ii in ipairs(ij) do r_[ii] = f(geti_s(x,ii), y[ii], ii) end
  return r_
end

MI.map2 = MR.map2

function MR.map3 (x, y, z, ij_, f, r_)
  if is_callable(ij_) or is_string(ij_) then f, r_, ij_ = ij_, f end -- right shift
  if is_scalar(y ) then y = rep(y) end
  if is_scalar(z ) then z = rep(z) end
  if is_string(r_) and r_ == 'in' or ij_ and is_nil(r_) then r_ = x end
  local ij = ij_ or 1..size(x)
  assert(is_iterable(y ), "invalid argument #2 (scalar or iterable expected)")
  assert(is_iterable(z ), "invalid argument #3 (scalar or iterable expected)")
  assert(is_iterable(ij), "invalid argument #4 (iterable expected)")
  assert(is_callable(f ), "invalid argument #5 (callable expected)")
  if is_nil(r_) then r_ = x:same(f(x[ij[1]], y[ij[1]], z[ij[1]], ij[1])) end
  assert(is_iterable(r_), "invalid argument #6 (iterable expected)")
  for _,ii in ipairs(ij) do r_[ii] = f(geti_s(x,ii), y[ii], z[ii], ii) end
  return r_
end

MI.map3 = MR.map3

function MR.foldl (x, f, x0_, d_, r_)
  if is_string(f  ) then f = assert(opstr[f], "invalid operator string") end
  if is_string(x0_) then                           -- case 2',4',4": shift right
    x0_, d_, r_ = nil, x0_, is_nil(r_) and d_ or r_
  elseif is_nil(r_) and not is_string(d_) then        -- case 7',3": shift right
    d_, r_ = nil, d_
  end
  assert(is_callable(f)               , "invalid argument #2 (callable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #5 (iterable expected)")
  local d, nr, nc, rr, r = d_ or 'vec', x:sizes()
  if d == 'vec' then                       -- fold x as vector, r_ is discarded
                            r  = geti(x,1)
    if not is_nil(x0_) then r  = f(x0_, r) end
    for i=2,nr*nc        do r  = f(r, geti(x,i)) end
  elseif d == 'diag' then                  -- fold x diagonal, r_ is discarded
    local n = min(nr,nc)    r  = geti(x,1)
    if not is_nil(x0_) then r  = f(x0_, r) end
    for i=2,n            do r  = f(r, get(x,i,i)) end
  elseif d == 'row' then                   -- fold x rows
    r = r_ or x:same(nr,1,is_nil(x0_) and f(x[1],x[1]) or f(x0_,x[1]))
    for i=1,nr           do rr = get(x,i,1)
    if not is_nil(x0_) then rr = f(x0_, rr) end
    for j=2,nc           do rr = f(rr, get(x,i,j)) end r[i] = rr end
  elseif d == 'col' then                   -- fold x columns
    r = r_ or x:same(1,nc,is_nil(x0_) and f(x[1],x[1]) or f(x0_,x[1]))
    for j=1,nc           do rr = get(x,1,j)
    if not is_nil(x0_) then rr = f(x0_, rr) end
    for i=2,nr           do rr = f(rr, get(x,i,j)) end r[j] = rr end
  else
    error("invalid argument #4 (string 'vec', 'diag', 'row' or 'col' expected)")
  end
  return r
end

MI.foldl = MR.foldl

function MR.foldr (x, f, x0_, d_, r_)
  if is_string(f  ) then f = assert(opstr[f], "invalid operator string") end
  if is_string(x0_) then                           -- case 2',4',4": shift right
    x0_, d_, r_ = nil, x0_, is_nil(r_) and d_ or r_
  elseif is_nil(r_) and not is_string(d_) then        -- case 7',3": shift right
    d_, r_ = nil, d_
  end
  assert(is_callable(f)               , "invalid argument #2 (callable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #5 (iterable expected)")
  local d, nr, nc, rr, r = d_ or 'vec', x:sizes()
  if d == 'vec' then                       -- fold x as vector, r_ is ignored
                             r = geti(x,nr*nc)
    if not is_nil(x0_) then  r = f(r, x0_) end
    for i=nr*nc-1,1,-1   do  r = f(geti(x,i), r) end
  elseif d == 'diag' then                  -- fold x diagonal, r_ is ignored
    local n = min(nr,nc)     r = get(x,n,n)
    if not is_nil(x0_) then  r = f(r, x0_) end
    for i=n-1,1,-1       do  r = f(get(x,i,i), r) end
  elseif d == 'row' then                   -- fold x rows
    r = r_ or x:same(nr,1,is_nil(x0_) and f(x[1],x[1]) or f(x[1],x0_))
    for i=nr  ,1,-1      do rr = get(x,i,nc)
    if not is_nil(x0_) then rr = f(rr, x0_) end
    for j=nc-1,1,-1      do rr = f(get(x,i,j), rr) end r[i] = rr end
  elseif d == 'col' then                   -- fold x columns
    r = r_ or x:same(1,nc,is_nil(x0_) and f(x[1],x[1]) or f(x[1],x0_))
    for j=nc  ,1,-1      do rr = get(x,nr,j)
    if not is_nil(x0_) then rr = f(rr, x0_) end
    for i=nr-1,1,-1      do rr = f(get(x,i,j), rr) end r[j] = rr end
  else
    error("invalid argument #4 (string 'vec', 'diag', 'row' or 'col' expected)")
  end
  return r
end

MI.foldr = MR.foldr

function MR.scanl (x, f, x0_, d_, r_)
  if is_string(f  ) then f = assert(opstr[f], "invalid operator string") end
  if is_string(x0_) then                           -- case 2',4',4": shift right
    x0_, d_, r_ = nil, x0_, is_nil(r_) and d_ or r_
  elseif is_nil(r_) and not is_string(d_) then        -- case 7',3": shift right
    d_, r_ = nil, d_
  end
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(is_callable(f)               , "invalid argument #2 (callable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #5 (iterable expected)")
  local d, nr, nc, rr, r = d_ or 'vec', x:sizes()
  r = r_ or x:same(is_nil(x0_) and f(x[1],x[1]) or f(x0_,x[1]))
  if d == 'vec' then                       -- scan x as vector
                            rr = geti(x,1)
    if not is_nil(x0_) then rr = f(x0_, rr) end    r[1] = rr
    for i=2,nr*nc        do rr = f(rr, geti(x,i))  r[i] = rr end
  elseif d == 'diag' then                  -- scan x diagonal
    local n = min(nr,nc)    rr = geti(x,1)
    if not is_nil(x0_) then rr = f(x0_, rr) end    r[1] = rr
    for i=2,n            do rr = f(rr, get(x,i,i)) r[i] = rr end
    if isy_matrix(r) then r:reshape(n) end
  elseif d == 'row' then                   -- scan x rows
    local k = 1
    for i=1,nr           do rr = get(x,i,1)
    if not is_nil(x0_) then rr = f(x0_, rr) end    r[k], k = rr, k+1
    for j=2,nc           do rr = f(rr, get(x,i,j)) r[k], k = rr, k+1 end end
  elseif d == 'col' then                   -- scan x columns
    if isy_matrix(r) and r.ncol > 1 then
      for j=1,nc           do rr = get(x,1,j)
      if not is_nil(x0_) then rr = f(x0_, rr) end    r[idx(1,j,nc)] = rr
      for i=2,nr           do rr = f(rr, get(x,i,j)) r[idx(i,j,nc)] = rr end end
    else
      local k = 1
      for j=1,nc           do rr = get(x,1,j)
      if not is_nil(x0_) then rr = f(x0_, rr) end    r[k], k = rr, k+1
      for i=2,nr           do rr = f(rr, get(x,i,j)) r[k], k = rr, k+1 end end
    end
  else
    error("invalid argument #4 (string 'vec', 'diag', 'row' or 'col' expected)")
  end
  return r
end

MI.scanl = MR.scanl

function MR.scanr (x, f, x0_, d_, r_)
  if is_string(f  ) then f = assert(opstr[f], "invalid operator string") end
  if is_string(x0_) then                           -- case 2',4',4": shift right
    x0_, d_, r_ = nil, x0_, is_nil(r_) and d_ or r_
  elseif is_nil(r_) and not is_string(d_) then        -- case 7',3": shift right
    d_, r_ = nil, d_
  end
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(is_callable(f)               , "invalid argument #2 (callable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #5 (iterable expected)")
  local d, nr, nc, rr, r = d_ or 'vec', x:sizes()
  r = r_ or x:same(is_nil(x0_) and f(x[1],x[1]) or f(x[1],x0_))
  if d == 'vec' then                       -- scan x as vector
                            rr = geti(x,nr*nc)
    if not is_nil(x0_) then rr = f(rr, x0_) end    r[nr*nc] = rr
    for i=nr*nc-1,1,-1   do rr = f(geti(x,i), rr)  r[i    ] = rr end
  elseif d == 'diag' then                  -- scan x diagonal
    local n = min(nr,nc)    rr = get(x,n,n)
    if not is_nil(x0_) then rr = f(rr, x0_) end    r[n] = rr
    for i=n-1,1,-1       do rr = f(get(x,i,i), rr) r[i] = rr end
    if isy_matrix(r) then r:reshape(n) end
  elseif d == 'row'  then                  -- scan x rows
    local k = nr*nc
    for i=nr  ,1,-1      do rr = get(x,i,nc)
    if not is_nil(x0_) then rr = f(rr, x0_) end    r[k], k = rr, k-1
    for j=nc-1,1,-1      do rr = f(get(x,i,j), rr) r[k], k = rr, k-1 end end
  elseif d == 'col' then                   -- scan x columns
    if isy_matrix(r) and r.ncol > 1 then
      for j=nc  ,1,-1      do rr = get(x,nr,j)
      if not is_nil(x0_) then rr = f(rr, x0_) end    r[idx(nr,j,nc)] = rr
      for i=nr-1,1,-1      do rr = f(get(x,i,j), rr) r[idx(i ,j,nc)] = rr end end
    else
      local k = nr*nc
      for j=nc  ,1,-1      do rr = get(x,nr,j)
      if not is_nil(x0_) then rr = f(rr, x0_) end    r[k], k = rr, k-1
      for i=nr-1,1,-1      do rr = f(get(x,i,j), rr) r[k], k = rr, k-1 end end
    end
  else
    error("invalid argument #4 (string 'vec', 'diag', 'row' or 'col' expected)")
  end
  return r
end

MI.scanr = MR.scanr

-- special maps ---------------------------------------------------------------o

MR.sqr     = \x,r_ -> x:map(sqr  , r_)
MR.abs     = \x,r_ -> x:map(abs  , r_)
MR.ceil    = \x,r_ -> x:map(ceil , r_)
MR.floor   = \x,r_ -> x:map(floor, r_)
MR.frac    = \x,r_ -> x:map(frac , r_)
MR.trunc   = \x,r_ -> x:map(trunc, r_)
MR.round   = \x,r_ -> x:map(round, r_)
MR.sign    = \x,r_ -> x:map(sign , r_)
MR.sign1   = \x,r_ -> x:map(sign1, r_)

MR.sqrt    = \x,r_ -> x:map(sqrt , r_)
MR.exp     = \x,r_ -> x:map(exp  , r_)
MR.log     = \x,r_ -> x:map(log  , r_)
MR.log10   = \x,r_ -> x:map(log10, r_)

MR.sin     = \x,r_ -> x:map(sin  , r_)
MR.cos     = \x,r_ -> x:map(cos  , r_)
MR.tan     = \x,r_ -> x:map(tan  , r_)
MR.cot     = \x,r_ -> x:map(cot  , r_)
MR.sinh    = \x,r_ -> x:map(sinh , r_)
MR.cosh    = \x,r_ -> x:map(cosh , r_)
MR.tanh    = \x,r_ -> x:map(tanh , r_)
MR.coth    = \x,r_ -> x:map(coth , r_)
MR.asin    = \x,r_ -> x:map(asin , r_)
MR.acos    = \x,r_ -> x:map(acos , r_)
MR.atan    = \x,r_ -> x:map(atan , r_)
MR.acot    = \x,r_ -> x:map(acot , r_)
MR.asinh   = \x,r_ -> x:map(asinh, r_)
MR.acosh   = \x,r_ -> x:map(acosh, r_)
MR.atanh   = \x,r_ -> x:map(atanh, r_)
MR.acoth   = \x,r_ -> x:map(acoth, r_)

MR.sinc    = \x,r_ -> x:map(sinc  , r_)
MR.sinhc   = \x,r_ -> x:map(sinhc , r_)
MR.asinc   = \x,r_ -> x:map(asinc , r_)
MR.asinhc  = \x,r_ -> x:map(asinhc, r_)

MR.wf      = \x,rtol_,r_ -> isa_matrix(rtol_) and x:map2(0, wf    , rtol_) or x:map2(rtol_ or 0, wf    , r_)
MR.erf     = \x,rtol_,r_ -> isa_matrix(rtol_) and x:map2(0, erf   , rtol_) or x:map2(rtol_ or 0, erf   , r_)
MR.erfc    = \x,rtol_,r_ -> isa_matrix(rtol_) and x:map2(0, erfc  , rtol_) or x:map2(rtol_ or 0, erfc  , r_)
MR.erfi    = \x,rtol_,r_ -> isa_matrix(rtol_) and x:map2(0, erfi  , rtol_) or x:map2(rtol_ or 0, erfi  , r_)
MR.erfcx   = \x,rtol_,r_ -> isa_matrix(rtol_) and x:map2(0, erfcx , rtol_) or x:map2(rtol_ or 0, erfcx , r_)
MR.dawson  = \x,rtol_,r_ -> isa_matrix(rtol_) and x:map2(0, dawson, rtol_) or x:map2(rtol_ or 0, dawson, r_)

MR.invsqrt = \x,v_,r_    -> isa_matrix(v_)    and x:map2(1,invsqrt, v_   ) or x:map2(v_    or 1,invsqrt, r_)

MR.conj    = \x,r_ -> x:map(conj , r_) ; MR.conjugate = MR.conj -- alias
MR.fabs    = \x,r_ -> x:map(fabs , r_)
MR.cabs    = \x,r_ -> x:map(cabs , r_)
MR.carg    = \x,r_ -> x:map(carg , r_)
MR.proj    = \x,r_ -> x:map(proj , r_)
MR.rect    = \x,r_ -> x:map(rect , r_)
MR.polar   = \x,r_ -> x:map(polar, r_)

MR.atan2   = \x,y,r_   -> x:map2(y,    atan2 , r_)
MR.hypot   = \x,y,r_   -> x:map2(y,    hypot , r_)
MR.hypot3  = \x,y,z,r_ -> x:map3(y, z, hypot3, r_)

MC.atan2   = \ error("atan2 not defined for cmatrix")

MI.abs     = \x,r_ -> x:map(abs  , r_)
MI.sqr     = \x,r_ -> x:map(sqr  , r_)
MI.sign    = \x,r_ -> x:map(sign , r_)
MI.sign1   = \x,r_ -> x:map(sign1, r_)

-- matrix function as special mfun --------------------------------------------o

MR.msqrt    = \x,r_ -> x:mfun(sqrt  , r_)
MR.mexp     = \x,r_ -> x:mfun(exp   , r_)
MR.mlog     = \x,r_ -> x:mfun(log   , r_)
MR.mlog10   = \x,r_ -> x:mfun(log10 , r_)
MR.msin     = \x,r_ -> x:mfun(sin   , r_)
MR.mcos     = \x,r_ -> x:mfun(cos   , r_)
MR.mtan     = \x,r_ -> x:mfun(tan   , r_)
MR.mcot     = \x,r_ -> x:mfun(cot   , r_)
MR.msinh    = \x,r_ -> x:mfun(sinh  , r_)
MR.mcosh    = \x,r_ -> x:mfun(cosh  , r_)
MR.mtanh    = \x,r_ -> x:mfun(tanh  , r_)
MR.mcoth    = \x,r_ -> x:mfun(coth  , r_)
MR.masin    = \x,r_ -> x:mfun(asin  , r_)
MR.macos    = \x,r_ -> x:mfun(acos  , r_)
MR.matan    = \x,r_ -> x:mfun(atan  , r_)
MR.macot    = \x,r_ -> x:mfun(acot  , r_)
MR.masinh   = \x,r_ -> x:mfun(asinh , r_)
MR.macosh   = \x,r_ -> x:mfun(acosh , r_)
MR.matanh   = \x,r_ -> x:mfun(atanh , r_)
MR.macoth   = \x,r_ -> x:mfun(acoth , r_)
MR.msinc    = \x,r_ -> x:mfun(sinc  , r_)
MR.msinhc   = \x,r_ -> x:mfun(sinhc , r_)
MR.masinc   = \x,r_ -> x:mfun(asinc , r_)
MR.masinhc  = \x,r_ -> x:mfun(asinhc, r_)

-- special folds --------------------------------------------------------------o

local all = \p -> \r,x -> lbool(land(r, p(x)))
local any = \p -> \r,x -> lbool(lor (r, p(x)))

MR.min     = \x,d_,r_ -> x:foldl(min    , nil, d_, r_)
MR.max     = \x,d_,r_ -> x:foldl(max    , nil, d_, r_)
MR.sum     = \x,d_,r_ -> x:foldl(add    , nil, d_, r_)
MR.prod    = \x,d_,r_ -> x:foldl(mul    , nil, d_, r_)
MR.sumsqr  = \x,d_,r_ -> x:foldl(sumsqrl, 0  , d_, r_)
MR.sumabs  = \x,d_,r_ -> x:foldl(sumabsl, 0  , d_, r_)
MR.minabs  = \x,d_,r_ -> x:foldl(minabsl, inf, d_, r_)
MR.maxabs  = \x,d_,r_ -> x:foldl(maxabsl, 0  , d_, r_)

MC.min     = \ error("min not defined for cmatrix")
MC.max     = \ error("max not defined for cmatrix")

MR.all   = \x,p,d_,r_ =>
              assert(is_callable(p), "invalid argument #2 (callable expected)")
              return x:foldl(all(p), true , d_, r_) end
MR.any   = \x,p,d_,r_ =>
              assert(is_callable(p), "invalid argument #2 (callable expected)")
              return x:foldl(any(p), false, d_, r_) end

MI.min, MI.max, MI.sum, MI.prod =
MR.min, MR.max, MR.sum, MR.prod

MI.sumsqr, MI.sumabs, MI.minabs, MI.maxabs, MI.all, MI.any =
MR.sumsqr, MR.sumabs, MR.minabs, MR.maxabs, MR.all, MR.any

-- special scans --------------------------------------------------------------o

-- left accumulation
MR.accmin    = \x,d_,r_ -> x:scanl(min    , nil, d_, r_)
MR.accmax    = \x,d_,r_ -> x:scanl(max    , nil, d_, r_)
MR.accsum    = \x,d_,r_ -> x:scanl(add    , nil, d_, r_)
MR.accprod   = \x,d_,r_ -> x:scanl(mul    , nil, d_, r_)
MR.accsumsqr = \x,d_,r_ -> x:scanl(sumsqrl, 0  , d_, r_)
MR.accsumabs = \x,d_,r_ -> x:scanl(sumabsl, 0  , d_, r_)
MR.accminabs = \x,d_,r_ -> x:scanl(minabsl, inf, d_, r_)
MR.accmaxabs = \x,d_,r_ -> x:scanl(maxabsl, 0  , d_, r_)

MR.accumulate = MR.accsum

MC.accmin    = \ error("accmin not defined for cmatrix")
MC.accmax    = \ error("accmax not defined for cmatrix")

-- right accumulation
MR.raccmin    = \x,d_,r_ -> x:scanr(min                  , nil, d_, r_)
MR.raccmax    = \x,d_,r_ -> x:scanr(max                  , nil, d_, r_)
MR.raccsum    = \x,d_,r_ -> x:scanr(add                  , nil, d_, r_)
MR.raccprod   = \x,d_,r_ -> x:scanr(mul                  , nil, d_, r_)
MR.raccsumsqr = \x,d_,r_ -> x:scanr(compose(sumsqrl,swap), 0  , d_, r_)
MR.raccsumabs = \x,d_,r_ -> x:scanr(compose(sumabsl,swap), 0  , d_, r_)
MR.raccminabs = \x,d_,r_ -> x:scanr(compose(minabsl,swap), inf, d_, r_)
MR.raccmaxabs = \x,d_,r_ -> x:scanr(compose(maxabsl,swap), 0  , d_, r_)

MC.raccmin    = \ error("raccmin not defined for cmatrix")
MC.raccmax    = \ error("raccmax not defined for cmatrix")

-- minmax ---------------------------------------------------------------------o

function MR.minmax (x, abs_)
  _C.mad_vec_minmax(x._dat, abs_ or false, ires, size(x))
  return x._dat[ires[0]], x._dat[ires[1]]
end

function MI.minmax (x, abs_)
  _C.mad_ivec_minmax(x._dat, abs_ or false, ires, size(x))
  return x._dat[ires[0]], x._dat[ires[1]]
end

function MC.minmax (x)
  _C.mad_cvec_minmax(x._dat, ires, size(x))
  return x._dat[ires[0]], x._dat[ires[1]]
end

function MR.iminmax (x, abs_)
  _C.mad_vec_minmax(x._dat, abs_ or false, ires, size(x))
  return ires[0]+1, ires[1]+1
end

function MI.iminmax (x, abs_)
  _C.mad_ivec_minmax(x._dat, abs_ or false, ires, size(x))
  return ires[0]+1, ires[1]+1
end

function MC.iminmax (x)
  _C.mad_cvec_minmax(x._dat, ires, size(x))
  return ires[0]+1, ires[1]+1
end

-- mean, variance -------------------------------------------------------------o

function MR.mean (x)
  return _C.mad_vec_mean(x._dat, size(x))
end

function MC.mean (x)
  _C.mad_cvec_mean_r(x._dat, cres, size(x)) ; return cres[0]
end

function MR.variance (x)
  return _C.mad_vec_var(x._dat, size(x))
end

function MC.variance (x)
  _C.mad_cvec_var_r(x._dat, cres, size(x)) ; return cres[0]
end

-- Kahan's summation, Horner's evaluation -------------------------------------o

function MR.ksum (x) -- Neumaier variant
  return _C.mad_vec_ksum(x._dat, size(x))
end

function MC.ksum (x) -- Neumaier variant
  _C.mad_cvec_ksum_r(x._dat, cres, size(x)) return cres[0]
end

function MR.kdot (x, y) -- Neumaier variant
  assert(size(x) == size(y), "incompatible matrix sizes")
  if is_cmatrix(y) then
    _C.mad_cvec_kdotv_r(y._dat, x._dat, cres, size(x)) return cres[0]
  else
    return _C.mad_vec_kdot(x._dat, y._dat, size(x))
  end
end

function MC.kdot (x, y) -- Neumaier variant
  assert(size(x) == size(y), "incompatible matrix sizes")
  if is_matrix(y) then
    _C.mad_cvec_kdotv_r(x._dat, y._dat, cres, size(x)) return cres[0]
  else
    _C.mad_cvec_kdot_r (x._dat, y._dat, cres, size(x)) return cres[0]
  end
end

function MR.eval (x, x0)
  return _C.mad_vec_eval(x._dat, x0, size(x))
end

function MC.eval (x, x0)
  _C.mad_cvec_eval_r(x._dat, x0.re, x0.im, cres, size(x)) return cres[0]
end

-- transpose, trace -----------------------------------------------------------o

function MR.transpose (x, c_, r_)
  if not is_logical(c_) and is_nil(r_) then r_, c_ = c_, nil end
  if is_string(r_) and r_ == 'in' then r_ = x end

  local nr, nc = x:sizes()
  local r = r_ or matrix_alloc(nr, nc)
  assert(is_matrix(r), "invalid argument #2 (matrix expected)")
  assert(size(r) == nr*nc, "incompatible matrix sizes")

  if not rawequal(x,r) or nr ~= 1 and nc ~= 1 then
    _C.mad_mat_trans(x._dat, r._dat, nr, nc) -- transpose
  end

  _C.mad_mat_reshape(r, nc, nr) return r
end

MR.t = MR.transpose -- alias

function MC.transpose (x, c_, r_)
  if not is_logical(c_) and is_nil(r_) then r_, c_ = c_, nil end
  if is_string(r_) and r_ == 'in' then r_ = x end

  local nr, nc = x:sizes()
  local r = r_ or cmatrix_alloc(nr, nc)
  assert(is_cmatrix(r), "invalid argument #2 (cmatrix expected)")
  assert(size(r) == nr*nc, "incompatible cmatrix sizes")

  if c_ ~= false
  then _C.mad_cmat_ctrans(x._dat, r._dat, nr, nc)  -- conjugate transpose
  else _C.mad_cmat_trans (x._dat, r._dat, nr, nc)  -- transpose (no conj.)
  end

  _C.mad_cmat_reshape(r, nc, nr) return r
end

MC.t = MC.transpose -- alias

function MI.transpose (x, r_)
  if is_string(r_) and r_ == 'in' then r_ = x end

  local nr, nc = x:sizes()
  local r = r_ or imatrix_alloc(nr, nc)
  assert(is_imatrix(r), "invalid argument #2 (imatrix expected)")
  assert(size(r) == nr*nc, "incompatible imatrix sizes")

  if not rawequal(x,r) or nr ~= 1 and nc ~= 1 then
    _C.mad_imat_trans(x._dat, r._dat, nr, nc) -- transpose
  end

  _C.mad_imat_reshape(r, nc, nr) return r
end

MI.t = MI.transpose -- alias

function MR.trace (x)
  local r, nr, nc = 0, x:sizes()
  for i=0,min(nr,nc)*nc,nc+1 do r = r + geti0(x,i) end
  return r
end

MR.tr = MR.trace -- alias

-- symplectic matrix ----------------------------------------------------------o

function MR.sympconj (x, r_) -- -J M' J = symplectic conjugate
  if is_string(r_) and r_ == 'in' then r_ = x end
  local nr, nc = x:sizes()
  assert(nr == nc and nr % 2 == 0, "invalid argument #1 (2n matrix expected)")
  local r = chksiz(r_,x) or matrix_alloc(nr,nr)
  _C.mad_mat_sympconj(x._dat, r._dat, nr)
  return r
end

MR.bar = MR.sympconj -- alias

function MC.sympconj (x, r_) -- -J M' J = symplectic conjugate
  if is_string(r_) and r_ == 'in' then r_ = x end
  local nr, nc = x:sizes()
  assert(nr == nc and nr % 2 == 0, "invalid argument #1 (2n matrix expected)")
  local r = chksiz(r_,x) or cmatrix_alloc(nr,nr)
  _C.mad_cmat_sympconj(x._dat, r._dat, nr)
  return r
end

MC.bar = MC.sympconj -- alias

function MR.symperr (x, r_) -- M' J M - J = symplectic deviation
  local nr, nc = x:sizes()
  assert(nr == nc and nr % 2 == 0, "invalid argument #1 (2n matrix expected)")
  if is_nil(r_) then
    return _C.mad_mat_symperr(x._dat, nil, nr, nil)
  else
    chksiz(r_,x)
    return _C.mad_mat_symperr(x._dat, r_._dat, nr, nil), r_
  end
end

function MC.symperr (x, r_) -- M' J M - J = symplectic deviation
  local nr, nc = x:sizes()
  assert(nr == nc and nr % 2 == 0, "invalid argument #1 (2n matrix expected)")
  if is_nil(r_) then
    return _C.mad_cmat_symperr(x._dat, nil, nr, nil)
  else
    chksiz(r_,x)
    return _C.mad_cmat_symperr(x._dat, r_._dat, nr, nil), r_
  end
end

-- inner, cross, mixed, outer -------------------------------------------------o

function MR.inner (x, y)
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  local nx, ny = size(x), size(y)
  assert(nx == ny, "incompatible vector sizes")
  if is_matrix(y)
  then return _C.mad_vec_dot   (x._dat, y._dat,       nx)
  else        _C.mad_vec_dotv_r(x._dat, y._dat, cres, nx) return cres[0]
  end
end

MR.dot = MR.inner -- alias

function MC.inner (x, y)
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  local nx, ny = size(x), size(y)
  assert(nx == ny, "incompatible vector sizes")
  if is_matrix(y)
  then _C.mad_cvec_dotv_r(x._dat, y._dat, cres, nx)
  else _C.mad_cvec_dot_r (x._dat, y._dat, cres, nx)
  end
  return cres[0]
end

MC.dot = MC.inner -- alias

function MR.outer (x, y, r_)
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  local nr, nc = size(x), size(y)
  local r = r_ or x:same(nr, nc, x[1]+y[1])
  assert(isa_matrix(r), "invalid argument #3 (matrix expected)")
  assert(r.nrow == nr and r.ncol == nc, "incompatible result matrix sizes")
  for i=0,nr-1 do
  for j=0,nc-1 do set0(r,i,j, geti0(x,i) * conj(geti0(y,j))) end end
  return r
end

function MR.cross (x, y, r_)
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  local nx, ny = size(x), size(y)
  assert(nx == ny and nx % 3 == 0, "incompatible or invalid matrix sizes")
  local r = r_ or x:same(x[1]+y[1])
  assert(isa_matrix(r), "invalid argument #3 (matrix expected)")
  assert(size(r) == nx, "incompatible result matrix sizes")
  local nc = nx == 3 and 1 or x.ncol
  local r0, r1, r2
  local i0, i1, i2 = 0, nc, 2*nc -- 1st, 2nd and 3rd rows
  for i=0,nc-1 do
    r0 = geti0(x,i1) * geti0(y,i2) - geti0(x,i2) * geti0(y,i1)
    r1 = geti0(x,i2) * geti0(y,i0) - geti0(x,i0) * geti0(y,i2)
    r2 = geti0(x,i0) * geti0(y,i1) - geti0(x,i1) * geti0(y,i0)
    seti0(r,i0,r0) ; seti0(r,i1,r1) ; seti0(r,i2,r2)
    i0, i1, i2 = i0+1, i1+1, i2+1
  end
  return r
end

function MR.mixed (x, y, z, r_)
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  assert(isa_matrix(z), "invalid argument #3 (matrix expected)")
  local nx, ny, nz = size(x), size(y), size(z)
  assert(nx == ny and nx == nz and nx % 3 == 0, "incompatible or invalid matrix sizes")
  local r0, r1, r2
  if nx == 3 then
  -- single mixed product (r_ ignored)
    r0 = conj(geti0(x,0)) * (geti0(y,1) * geti0(z,2) - geti0(y,2) * geti0(z,1))
    r1 = conj(geti0(x,1)) * (geti0(y,2) * geti0(z,0) - geti0(y,0) * geti0(z,2))
    r2 = conj(geti0(x,2)) * (geti0(y,0) * geti0(z,1) - geti0(y,1) * geti0(z,0))
    return r0+r1+r2
  end
  -- multiple mixed products
  assert(x.nrow == 3 and y.nrow == 3 and z.nrow == 3, "invalid matrix sizes")
  local nc = x.ncol
  local r = r_ or x:same(1, nc, x[1]+y[1]+z[1])
  assert(isa_matrix(r), "invalid argument #4 (matrix expected)")
  assert(size(r) == nc, "incompatible result matrix sizes")
  local i0, i1, i2 = 0, nc, 2*nc -- 1st, 2nd and 3rd rows
  for i=0,nc-1 do
    r0 = conj(geti0(x,i0)) * (geti0(y,i1) * geti0(z,i2) - geti0(y,i2) * geti0(z,i1))
    r1 = conj(geti0(x,i1)) * (geti0(y,i2) * geti0(z,i0) - geti0(y,i0) * geti0(z,i2))
    r2 = conj(geti0(x,i2)) * (geti0(y,i0) * geti0(z,i1) - geti0(y,i1) * geti0(z,i0))
    seti0(r, i, r0+r1+r2)
    i0, i1, i2 = i0+1, i1+1, i2+1
  end
  return r
end

-- norm, unit, center, angle (in place) ---------------------------------------o

function MR.norm (x)
  return _C.mad_vec_norm(x._dat, size(x))
end

function MC.norm (x)
  return _C.mad_cvec_norm(x._dat, size(x))
end

function MR.dist (x, y)
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  if is_matrix(y)
  then return _C.mad_vec_dist (x._dat, y._dat, size(x))
  else return _C.mad_vec_distv(x._dat, y._dat, size(x))
  end
end

function MC.dist (x, y)
  assert(isa_matrix(y), "invalid argument #2 (cmatrix expected)")
  if is_cmatrix(y)
  then return _C.mad_cvec_dist (x._dat, y._dat, size(x))
  else return _C.mad_cvec_distv(x._dat, y._dat, size(x))
  end
end

function MR.unit (x)
  local n = x:norm()
  assert(n ~= 0, "null matrix norm")
  _C.mad_vec_muln(x._dat, 1/n, x._dat, size(x))
  return x
end

function MC.unit (x)
  local n = x:norm()
  assert(n ~= 0, "null matrix norm")
  _C.mad_cvec_muln(x._dat, 1/n, x._dat, size(x))
  return x
end

function MR.center (x, d_) -- center vector or matrix in place
  local d = assert(dir[d_ or 'vec'], "invalid direction")
  _C.mad_mat_center(x._dat, x.nrow, x.ncol, d) return x
end

function MC.center (x, d_) -- center vector or matrix in place
  local d = assert(dir[d_ or 'vec'], "invalid direction")
  _C.mad_cmat_center(x._dat, x.nrow, x.ncol, d) return x
end

function MR.angle (x, y, n_)
  local w = x:inner(y)
  local v = x:norm() * y:norm()
  assert(v ~= 0, "null vector norm") -- convention: return pi/2 ?
  local a = acos(w / v) -- [0, pi]
  if n_ and x:mixed(y, n_) < 0 then a = -a end -- [-pi, pi]
  return a
end

-- operators ------------------------------------------------------------------o

MR.__unm  = \x,_,r_ -> x:map (   unm, r_) -- _ is dummy arg, see Lua specs.
MR.__emul = \x,y,r_ -> x:map2(y, mul, r_)
MR.__ediv = \x,y,r_ -> x:map2(y, div, r_)
MR.__emod = \x,y,r_ -> x:map2(y, mod, r_)
MR.__epow = \x,y,r_ -> x:map2(y, pow, r_)

MI.__unm, MI.__emul, MI.__ediv, MI.__emod, MI.__epow =
MR.__unm, MR.__emul, MR.__ediv, MR.__emod, MR.__epow

-- equal

function MR.__eq (x, y, tol_)
  if rawequal(x, y)         then return true  end
  if is_nil(y) or is_nil(x) then return false end
  tol_ = tol_ or 0
  assert(is_number(tol_), "invalid argument #3 (number expected)")
  if is_scalar(x) then                        -- num or cpx == mat
    x = complex(x)
    if x ~= x or abs(x.im) > tol_ then return false end
    for i=1,size(y) do
      local yi = geti(y,i)
      if yi ~= yi or abs(yi - x.re) > tol_ then return false end
    end
  elseif is_scalar(y) then                    -- mat == num or cpx
    y = complex(y)
    if y ~= y or abs(y.im) > tol_ then return false end
    for i=1,size(x) do
      local xi = geti(x,i)
      if xi ~= xi or abs(xi - y.re) > tol_ then return false end
    end
  elseif is_cmatrix(y) then                   -- mat == cmat
    if x.nrow ~= y.nrow or x.ncol ~= y.ncol then return false end
    for i=1,size(x) do
      local xi, yi = geti(x,i), geti(y,i)
      if xi ~= xi or yi ~= yi or
         abs(xi - yi.re) > tol_ or
         abs(     yi.im) > tol_ then return false end
    end
  elseif is_matrix(y) and is_matrix(x) then   -- mat == mat
    if x.nrow ~= y.nrow or x.ncol ~= y.ncol then return false end
    for i=1,size(x) do
      local xi, yi = geti(x,i), geti(y,i)
      if xi ~= xi or yi ~= yi or abs(xi - yi) > tol_ then return false end
    end
  else
    return assert(gmm(y,'__eq_mat'), "invalid 'mat == ?' operation")(x, y, tol_)
  end
  return true
end

function MC.__eq (x, y, tol_)
  if rawequal(x, y)         then return true  end
  if is_nil(x) or is_nil(y) then return false end
  tol_ = tol_ or 0
  assert(is_number(tol_), "invalid argument #3 (number expected)")
  if is_scalar(x) then                        -- num or cpx == cmat
    x = complex(x)
    if x ~= x then return false end
    for i=1,size(y) do
      local yi = geti(y,i)
      if yi ~= yi or
         abs(yi.re - x.re) > tol_ or
         abs(yi.im - x.im) > tol_ then return false end
    end
  elseif is_scalar(y) then                    -- cmat == num or cpx
    y = complex(y)
    if y ~= y then return false end
    for i=1,size(x) do
      local xi = geti(x,i)
      if xi ~= xi or
         abs(xi.re - y.re) > tol_ or
         abs(xi.im - y.im) > tol_ then return false end
    end
  elseif is_matrix(y) then                    -- cmat == mat
    if x.nrow ~= y.nrow or x.ncol ~= y.ncol then return false end
    for i=1,size(x) do
      local xi, yi = geti(x,i), geti(y,i)
      if xi ~= xi or yi ~= yi or
         abs(xi.re - yi) > tol_ or
         abs(xi.im     ) > tol_ then return false end
    end
  elseif is_cmatrix(y) and is_cmatrix(x) then -- cmat == cmat
    if x.nrow ~= y.nrow or x.ncol ~= y.ncol then return false end
    for i=1,size(x) do
      local xi, yi = geti(x,i), geti(y,i)
      if xi ~= xi or yi ~= yi or
         abs(xi.re - yi.re) > tol_ or
         abs(xi.im - yi.im) > tol_ then return false end
    end
  else
    return assert(gmm(y,'__eq_mat'), "invalid 'cmat == ?' operation")(x, y, tol_)
  end
  return true
end

function MI.__eq (x, y)
  if rawequal(x, y)         then return true  end
  if is_nil(x) or is_nil(y) then return false end
  if is_number(x) then                        -- idx == imat
    for i=1,size(y) do
      if geti(y,i) ~= x then return false end
    end
  elseif is_number(y) then                    -- imat == idx
    for i=1,size(x) do
      if geti(x,i) ~= y then return false end
    end
  elseif is_imatrix(y) and is_imatrix(x) then -- imat == imat
    if x.nrow ~= y.nrow or x.ncol ~= y.ncol then return false end
    for i=1,size(x) do
      if geti(x,i) ~= geti(y,i) then return false end
    end
  else
    return assert(gmm(y,'__eq_mat'), "invalid 'imat == ?' operation")(x, y)
  end
  return true
end

MR.__eq_cpx = MR.__eq
MC.__eq_cpx = MC.__eq

-- add (see also kadd)

function MR.__add (x, y, r)
  if is_number(x) then                           -- num + mat => num + vec
    r = chksiz(r,y) or matrix_alloc(y:sizes())
    _C.mad_vec_addn(y._dat, x, r._dat, size(r)) return r
  elseif is_number(y) then                       -- mat + num => vec + num
    r = chksiz(r,x) or matrix_alloc(x:sizes())
    _C.mad_vec_addn(x._dat, y, r._dat, size(r)) return r
  elseif is_complex(y) then                      -- mat + cpx => vec + cpx
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_vec_addc_r(x._dat, y.re, y.im, r._dat, size(r)) return r
  elseif is_cmatrix(y) then                      -- mat + cmat => vec + cvec
    r = chksiz(r,x,y) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_addv(y._dat, x._dat, r._dat, size(r)) return r
  elseif is_matrix(y) and is_matrix(x) then      -- mat + mat => vec + vec
    r = chksiz(r,x,y) or matrix_alloc(x:sizes())
    _C.mad_vec_add(x._dat, y._dat, r._dat, size(r)) return r
  else
    return assert(gmm(y,'__add_mat'), "invalid 'mat + ?' operation")(x, y, r)
  end
end

function MR.__add_cpx (x, y, r)                  -- cpx + mat => cpx + vec
  r = chksiz(r,y) or cmatrix_alloc(y:sizes())
  _C.mad_vec_addc_r(y._dat, x.re, x.im, r._dat, size(r)) return r
end

function MC.__add (x, y, r)
  if is_number(x) then                           -- num + cmat => num + cvec
    r = chksiz(r,y) or cmatrix_alloc(y:sizes())
    _C.mad_cvec_addn(y._dat, x, r._dat, size(r)) return r
  elseif is_number(y) then                       -- cmat + num => cvec + num
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_addn(x._dat, y, r._dat, size(r)) return r
  elseif is_complex(y) then                      -- cmat + cpx => cvec + cpx
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_addc_r(x._dat, y.re, y.im, r._dat, size(r)) return r
  elseif is_matrix(y) then                       -- cmat + mat => cvec + vec
    r = chksiz(r,x,y) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_addv(x._dat, y._dat, r._dat, size(r)) return r
  elseif is_cmatrix(y) and is_cmatrix(x) then    -- cmat + cmat => cvec + cvec
    r = chksiz(r,x,y) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_add(x._dat, y._dat, r._dat, size(r)) return r
  else
    return assert(gmm(y,'__add_mat'), "invalid 'cmat + ?' operation")(x, y, r)
  end
end

function MC.__add_cpx (x, y, r)                  -- cpx + cmat => cpx + cvec
  r = chksiz(r,y) or cmatrix_alloc(y:sizes())
  _C.mad_cvec_addc_r(y._dat, x.re, x.im, r._dat, size(r)) return r
end

function MI.__add (x, y, r)
  if is_number(x) then                           -- idx + imat => idx + ivec
    r = chksiz(r,y) or imatrix_alloc(y:sizes())
    _C.mad_ivec_addn(y._dat, x, r._dat, size(r)) return r
  elseif is_number(y) then                       -- imat + idx => ivec + idx
    r = chksiz(r,x) or imatrix_alloc(x:sizes())
    _C.mad_ivec_addn(x._dat, y, r._dat, size(r)) return r
  elseif is_matrix(y) and is_matrix(x) then      -- imat + imat => ivec + ivec
    r = chksiz(r,x,y) or imatrix_alloc(x:sizes())
    _C.mad_ivec_add(x._dat, y._dat, r._dat, size(r)) return r
  else
    return assert(gmm(y,'__add_mat'), "invalid 'imat + ?' operation")(x, y, r)
  end
end

-- sub (see also kadd)

function MR.__sub (x, y, r)
  if is_number(x) then                           -- num - mat => num - vec
    r = chksiz(r,y) or matrix_alloc(y:sizes())
    _C.mad_vec_subn(y._dat, x, r._dat, size(r)) return r
  elseif is_number(y) then                       -- mat - num => vec + -num
    r = chksiz(r,x) or matrix_alloc(x:sizes())
    _C.mad_vec_addn(x._dat, -y, r._dat, size(r)) return r
  elseif is_complex(y) then                      -- mat - cpx => vec + -cpx
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_vec_addc_r(x._dat, -y.re, -y.im, r._dat, size(r)) return r
  elseif is_cmatrix(y) then                      -- mat - cmat => vec - cvec
    r = chksiz(r,x,y) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_subv(y._dat, x._dat, r._dat, size(r)) return r
  elseif is_matrix(y) and is_matrix(x) then      -- mat - mat => vec - vec
    r = chksiz(r,x,y) or matrix_alloc(x:sizes())
    _C.mad_vec_sub(x._dat, y._dat, r._dat, size(r)) return r
  else
    return assert(gmm(y,'__sub_mat'), "invalid 'mat - ?' operation")(x, y, r)
  end
end

function MR.__sub_cpx (x, y, r)                  -- cpx - mat => cpx - vec
  r = chksiz(r,y) or cmatrix_alloc(y:sizes())
  _C.mad_vec_subc_r(y._dat, x.re, x.im, r._dat, size(r)) return r
end

function MC.__sub (x, y, r)
  if is_number(x) then                           -- num - cmat => num - cvec
    r = chksiz(r,y) or cmatrix_alloc(y:sizes())
    _C.mad_cvec_subn(y._dat, x, r._dat, size(r)) return r
  elseif is_number(y) then                       -- cmat - num => cvec + -num
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_addn(x._dat, -y, r._dat, size(r)) return r
  elseif is_complex(y) then                      -- cmat - cpx => cvec + -cpx
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_addc_r(x._dat, -y.re, -y.im, r._dat, size(r)) return r
  elseif is_matrix(y) then                       -- cmat - mat => cvec - vec
    r = chksiz(r,x,y) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_subv(x._dat, y._dat, r._dat, size(r)) return r
  elseif is_cmatrix(y) and is_cmatrix(x) then    -- cmat - cmat => cvec - cvec
    r = chksiz(r,x,y) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_sub(x._dat, y._dat, r._dat, size(r)) return r
  else
    return assert(gmm(y,'__sub_mat'), "invalid 'cmat - ?' operation")(x, y, r)
  end
end

function MC.__sub_cpx (x, y, r)                  -- cpx - cmat => cpx - cvec
  r = chksiz(r,y) or cmatrix_alloc(y:sizes())
  _C.mad_cvec_subc_r(y._dat, x.re, x.im, r._dat, size(r)) return r
end

function MI.__sub (x, y, r)
  if is_number(x) then                           -- idx - imat => idx - ivec
    r = chksiz(r,y) or imatrix_alloc(y:sizes())
    _C.mad_ivec_subn(y._dat, x, r._dat, size(r)) return r
  elseif is_number(y) then                       -- imat - idx => ivec + -idx
    r = chksiz(r,x) or imatrix_alloc(x:sizes())
    _C.mad_ivec_addn(x._dat, -y, r._dat, size(r)) return r
  elseif is_imatrix(y) and is_imatrix(x) then    -- imat - imat => ivec - ivec
    r = chksiz(r,x,y) or imatrix_alloc(x:sizes())
    _C.mad_ivec_sub(x._dat, y._dat, r._dat, size(r)) return r
  else
    return assert(gmm(y,'__sub_mat'), "invalid 'imat - ?' operation")(x, y, r)
  end
end

-- mul

function MR.__mul (x, y, r)
  if is_number(x) then                           -- num * mat => num * vec
    r = chksiz(r,y) or matrix_alloc(y:sizes())
    _C.mad_vec_muln(y._dat, x, r._dat, size(r)) return r
  elseif is_number(y) then                       -- mat * num => vec * num
    r = chksiz(r,x) or matrix_alloc(x:sizes())
    _C.mad_vec_muln(x._dat, y, r._dat, size(r)) return r
  elseif is_complex(y) then                      -- mat * cpx => vec * cpx
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_vec_mulc_r(x._dat, y.re, y.im, r._dat, size(r)) return r
  elseif is_cmatrix(y) then                      -- mat * cmat
    r = chksizm(r,x,y) or cmatrix_alloc(x.nrow, y.ncol)
    _C.mad_mat_mulm(x._dat, y._dat, r._dat, r.nrow, r.ncol, x.ncol) return r
  elseif is_matrix(y) and is_matrix(x) then      -- mat * mat
    r = chksizm(r,x,y) or matrix_alloc(x.nrow, y.ncol)
    _C.mad_mat_mul(x._dat, y._dat, r._dat, r.nrow, r.ncol, x.ncol) return r
  else
    return assert(gmm(y,'__mul_mat'), "invalid 'mat * ?' operation")(x, y, r)
  end
end

function MR.__mul_cpx (x, y, r)                  -- cpx * mat => cpx * vec
  r = chksiz(r,y) or cmatrix_alloc(y:sizes())
  _C.mad_vec_mulc_r(y._dat, x.re, x.im, r._dat, size(r)) return r
end

function MC.__mul (x, y, r)
  if is_number(x) then                           -- num * cmat => num * cvec
    r = chksiz(r,y) or cmatrix_alloc(y:sizes())
    _C.mad_cvec_muln(y._dat, x, r._dat, size(r)) return r
  elseif is_number(y) then                       -- cmat * num => cvec * num
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_muln(x._dat, y, r._dat, size(r)) return r
  elseif is_complex(y) then                      -- cmat * cpx => cvec * cpx
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_mulc_r(x._dat, y.re, y.im, r._dat, size(r)) return r
  elseif is_matrix(y) then                       -- cmat * mat
    r = chksizm(r,x,y) or cmatrix_alloc(x.nrow, y.ncol)
    _C.mad_cmat_mulm(x._dat, y._dat, r._dat, r.nrow, r.ncol, x.ncol) return r
  elseif is_cmatrix(y) and is_cmatrix(x) then    -- cmat * cmat
    r = chksizm(r,x,y) or cmatrix_alloc(x.nrow, y.ncol)
    _C.mad_cmat_mul(x._dat, y._dat, r._dat, r.nrow, r.ncol, x.ncol) return r
  else
    return assert(gmm(y,'__mul_mat'), "invalid 'cmat * ?' operation")(x, y, r)
  end
end

function MC.__mul_cpx (x, y, r)                  -- cpx * cmat => cpx * cvec
  r = chksiz(r,y) or cmatrix_alloc(y:sizes())
  _C.mad_cvec_mulc_r(y._dat, x.re, x.im, r._dat, size(r)) return r
end

function MI.__mul (x, y, r)
  if is_number(x) then                           -- idx * imat => idx * ivec
    r = chksiz(r,y) or imatrix_alloc(y:sizes())
    _C.mad_ivec_muln(y._dat, x, r._dat, size(r)) return r
  elseif is_number(y) then                       -- imat * idx => ivec * idx
    r = chksiz(r,x) or imatrix_alloc(x:sizes())
    _C.mad_ivec_muln(x._dat, y, r._dat, size(r)) return r
  else
    return assert(gmm(y,'__mul_mat'), "invalid 'imat * ?' operation")(x, y, r)
  end
end

-- div

MR.inv = \x,r,rcond_ -> x.div(1,x,r,rcond_)

function MR.__div (x, y, r, rcond_)
  if is_number(r) and is_nil(rcond_) then rcond_, r = r, nil end -- right shift
  local rank
  if is_number(x) then                           -- num / mat
    r = chksizt(r,y) or matrix_alloc(y:tsizes())
    rank = _C.mad_mat_invn(y._dat, x, r._dat, y.nrow, y.ncol, rcond_ or eps)
    return r, rank
  elseif is_number(y) then                       -- mat / num => vec / num
    r = chksiz(r,x) or matrix_alloc(x:sizes())
    _C.mad_vec_muln(x._dat, 1/y, r._dat, size(r)) return r
  elseif is_complex(y) then                      -- mat / cpx => vec / cpx
    r = chksiz(r,x) or cmatrix_alloc(x:sizes()) ; y = 1/y
    _C.mad_vec_mulc_r(x._dat, y.re, y.im, r._dat, size(r)) return r
  elseif is_cmatrix(y) then                      -- mat / cmat
    r = chksizmt(r,x,y) or cmatrix_alloc(x.nrow, y.nrow)
    rank = _C.mad_mat_divm(x._dat, y._dat, r._dat, r.nrow, r.ncol, x.ncol, rcond_ or eps)
    return r, rank
  elseif is_matrix(y) and is_matrix(x) then      -- mat / mat
    r = chksizmt(r,x,y) or matrix_alloc(x.nrow, y.nrow)
    rank = _C.mad_mat_div(x._dat, y._dat, r._dat, r.nrow, r.ncol, x.ncol, rcond_ or eps)
    return r, rank
  else
    return assert(gmm(y,'__div_mat'), "invalid 'mat / ?' operation")(x, y, r, rcond_)
  end
end

function MR.__div_cpx (x, y, r, rcond_)          -- cpx / mat
  if is_number(r) and is_nil(rcond_) then rcond_, r = r, nil end -- right shift
  r = chksizt(r,y) or cmatrix_alloc(y:tsizes())
  local rank = _C.mad_mat_invc_r(y._dat, x.re, x.im, r._dat, y.nrow, y.ncol, rcond_ or eps)
  return r, rank
end

function MC.__div (x, y, r, rcond_)
  if is_number(r) and is_nil(rcond_) then rcond_, r = r, nil end -- right shift
  local rank
  if is_number(x) then                           -- num / cmat
    r = chksizt(r,y) or cmatrix_alloc(y:tsizes())
    rank = _C.mad_cmat_invn(y._dat, x, r._dat, y.nrow, y.ncol, rcond_ or eps)
    return r, rank
  elseif is_number(y) then                       -- cmat / num => cvec / num
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_muln(x._dat, 1/y, r._dat, size(r)) return r
  elseif is_complex(y) then                      -- cmat / cpx => cvec / cpx
    r = chksiz(r,x) or cmatrix_alloc(x:sizes()) ; y = 1/y
    _C.mad_cvec_mulc_r(x._dat, y.re, y.im, r._dat, size(r)) return r
  elseif is_matrix(y) then                       -- cmat / mat
    r = chksizmt(r,x,y) or cmatrix_alloc(x.nrow, y.nrow)
    rank = _C.mad_cmat_divm(x._dat, y._dat, r._dat, r.nrow, r.ncol, x.ncol, rcond_ or eps)
    return r, rank
  elseif is_cmatrix(y) and is_cmatrix(x) then    -- cmat / cmat
    r = chksizmt(r,x,y) or cmatrix_alloc(x.nrow, y.nrow)
    rank = _C.mad_cmat_div(x._dat, y._dat, r._dat, r.nrow, r.ncol, x.ncol, rcond_ or eps)
    return r, rank
  else
    return assert(gmm(y,'__div_mat'), "invalid 'cmat / ?' operation")(x, y, r, rcond_)
  end
end

function MC.__div_cpx (x, y, r, rcond_)          -- cpx / cmat
  if is_number(r) and is_nil(rcond_) then rcond_, r = r, nil end -- right shift
  r = chksizt(r,y) or cmatrix_alloc(y:tsizes())
  local rank = _C.mad_cmat_invc_r(y._dat, x.re, x.im, r._dat, y.nrow, y.ncol, rcond_ or eps)
  return r, rank
end

function MI.__div (x, y, r)
  if is_number(y) then                           -- imat / idx => ivec / idx
    r = chksiz(r,x) or imatrix_alloc(x:sizes())
    _C.mad_ivec_divn(x._dat, y, r._dat, size(r)) return r
  else
    return assert(gmm(y,'__div_mat'), "invalid 'imat / ?' operation")(x, y, r)
  end
end

-- pow (for now)

function MR.__pow (x, n, r)
  assert(is_integer(n), "invalid argument #2 (integer expected)")
      if n == 0 then                        -- mat^0  => eye
    return (r or x:same()):eye()
  elseif n == 1 then                        -- mat^1  => copy
    return x:copy(r)
  elseif n == 2 then                        -- mat^2  => mat * mat
    return x:mul(x,r)
  elseif n == -1 then                       -- mat^-1 => mat:inv()
    return x:inv(r)
  elseif n == -2 then                       -- mat^-2 => mat:inv()^2
    return x:mul(x,r):inv(r)
  end

  local n, t = abs(n), n < 0 and x:inv() or x:copy()
  r = (r or x:same()):eye()

  while true do
    if n%2 == 1 then r = r:mul(t,r) end     -- r = r * t
    n = floor(n/2)
    if n == 0 then break end
    t:mul(t,t)                              -- t = t^2
  end

  return r
end

MC.__pow = MR.__pow -- fully polymorphic

-- kadd (in place)

local kmax = 100
local kr   = ffi.new(       'num_t [?]', kmax)
local krd  = ffi.new('const  num_t*[?]', kmax)
local kc   = ffi.new(      'cnum_t [?]', kmax)
local kcd  = ffi.new('const cnum_t*[?]', kmax)

function MR.kadd (r, a, x)
  assert(is_iterable(a), "invalid argument #1 (iterable expected)")
  assert(is_iterable(x), "invalid argument #2 (iterable expected)")
  local k = #x
  assert(k <= kmax, "too many matrices")
  assert(k == #a, "incompatible number of coefficients")
  assert(is_matrix(x[k]), "incompatible matrix type")
  assert(x[k].nrow == r.nrow and
         x[k].ncol == r.ncol, "incompatible matrix size")
  for i=1,k-1 do
    assert(is_matrix(x[i]), "incompatible matrix type")
    assert(x[i].nrow == x[i+1].nrow and
           x[i].ncol == x[i+1].ncol, "incompatible matrix size")
    kr[i-1], krd[i-1] = a[i], x[i]._dat
  end
  kr[k-1], krd[k-1] = a[k], x[k]._dat
  _C.mad_vec_kadd(k, kr, krd, r._dat, size(r)) return r
end

function MC.kadd (r, a, x)
  assert(is_iterable(a), "invalid argument #1 (iterable expected)")
  assert(is_iterable(x), "invalid argument #2 (iterable expected)")
  local k = #x
  assert(k <= kmax, "too many matrices")
  assert(k == #a, "incompatible number of coefficients")
  assert(is_cmatrix(x[k]), "incompatible matrix type")
  assert(x[k].nrow == r.nrow and
         x[k].ncol == r.ncol, "incompatible matrix size")
  for i=1,k-1 do
    assert(is_cmatrix(x[i]), "incompatible matrix type")
    assert(x[i].nrow == x[i+1].nrow and
           x[i].ncol == x[i+1].ncol, "incompatible matrix size")
    kc[i-1], kcd[i-1] = a[i], x[i]._dat
  end
  kc[k-1], kcd[k-1] = a[k], x[k]._dat
  _C.mad_cvec_kadd(k, kc, kcd, r._dat, size(r)) return r
end

-- tmul

function MR.tmul (x, y, r)
  if is_cmatrix(y) then                         -- mat' * cmat
    r = chksiztm(r,x,y) or cmatrix_alloc(x.ncol, y.ncol)
    _C.mad_mat_tmulm(x._dat, y._dat, r._dat, r.nrow, r.ncol, x.nrow) return r
  elseif is_matrix(y) and is_matrix(x) then     -- mat' * mat
    r = chksiztm(r,x,y) or  matrix_alloc(x.ncol, y.ncol)
    _C.mad_mat_tmul (x._dat, y._dat, r._dat, r.nrow, r.ncol, x.nrow) return r
  else                                          -- mat' * ?
    return assert(gmm(y,'__tmul_mat'), "invalid 'mat^t * ?' operation")(x, y, r)
  end
end

function MC.tmul (x, y, r)
  if is_matrix(y) then                          -- cmat' * mat
    r = chksiztm(r,x,y) or cmatrix_alloc(x.ncol, y.ncol)
    _C.mad_cmat_tmulm(x._dat, y._dat, r._dat, r.nrow, r.ncol, x.nrow) return r
  elseif is_cmatrix(x) and is_cmatrix(y) then   -- cmat' * cmat
    r = chksiztm(r,x,y) or cmatrix_alloc(x.ncol, y.ncol)
    _C.mad_cmat_tmul (x._dat, y._dat, r._dat, r.nrow, r.ncol, x.nrow) return r
  else                                          -- cmat' * ?
    return assert(gmm(y,'__tmul_mat'), "invalid 'cmat^t * ?' operation")(x, y, r)
  end
end

-- mult

function MR.mult (x, y, r)
  if is_cmatrix(y) then                         -- mat * cmat'
    r = chksizmt(r,x,y) or cmatrix_alloc(x.nrow, y.nrow)
    _C.mad_mat_multm(x._dat, y._dat, r._dat, r.nrow, r.ncol, x.ncol) return r
  elseif is_matrix(y) and is_matrix(x) then     -- mat * mat'
    r = chksizmt(r,x,y) or  matrix_alloc(x.nrow, y.nrow)
    _C.mad_mat_mult (x._dat, y._dat, r._dat, r.nrow, r.ncol, x.ncol) return r
  else                                          -- mat * ?
    return assert(gmm(y,'__mult_mat'), "invalid 'mat * ?^t' operation")(x, y, r)
  end
end

function MC.mult (x, y, r)
  if is_matrix(y) then                          -- cmat * mat'
    r = chksizmt(r,x,y) or cmatrix_alloc(x.nrow, y.nrow)
    _C.mad_cmat_multm(x._dat, y._dat, r._dat, r.nrow, r.ncol, x.ncol) return r
  elseif is_cmatrix(x) and is_cmatrix(y) then   -- cmat * cmat'
    r = chksizmt(r,x,y) or cmatrix_alloc(x.nrow, y.nrow)
    _C.mad_cmat_mult (x._dat, y._dat, r._dat, r.nrow, r.ncol, x.ncol) return r
  else                                          -- cmat * ?'
    return assert(gmm(y,'__mult_mat'), "invalid 'cmat * ?^t' operation")(x, y, r)
  end
end

-- dmul

function MR.dmul (x, y, r)
  local nr, nc = x:sizes()
  if (nr == 1 or nc == 1) and isa_matrix(y) then
    nr, nc = nr*nc, 1
    assert(nr == y.nrow, "incompatible matrix sizes")
    r = chksiz(r,y)
  elseif isa_matrix(y) then
    r = chksizm(r,x,y)
  end

  if is_cmatrix(y) then                         -- diag(mat) * cmat
    r = r or cmatrix_alloc(nr, y.ncol)
    _C.mad_mat_dmulm(x._dat, y._dat, r._dat, r.nrow, r.ncol, nc) return r
  elseif is_matrix(y) and is_matrix(x) then     -- diag(mat) * mat
    r = r or  matrix_alloc(nr, y.ncol)
    _C.mad_mat_dmul (x._dat, y._dat, r._dat, r.nrow, r.ncol, nc) return r
  else                                          -- diag(mat) * ?
    return assert(gmm(y,'__dmul_mat'), "invalid 'diag(mat) * ?' operation")(x, y, r)
  end
end

function MC.dmul (x, y, r)
  local nr, nc = x:sizes()
  if (nr == 1 or nc == 1) and isa_matrix(y) then
    nr, nc = nr*nc, 1
    assert(nr == y.nrow, "incompatible matrix sizes")
    r = chksiz(r,y)
  elseif isa_matrix(y) then
    r = chksizm(r,x,y)
  end

  if is_matrix(y) then                          -- diag(cmat) * mat
    r = r or cmatrix_alloc(nr, y.ncol)
    _C.mad_cmat_dmulm(x._dat, y._dat, r._dat, r.nrow, r.ncol, nc) return r
  elseif is_cmatrix(x) and is_cmatrix(y) then   -- diag(cmat) * cmat
    r = r or cmatrix_alloc(nr, y.ncol)
    _C.mad_cmat_dmul (x._dat, y._dat, r._dat, r.nrow, r.ncol, nc) return r
  else                                          -- diag(cmat) * ?
    return assert(gmm(y,'__dmul_mat'), "invalid 'diag(cmat) * ?' operation")(x, y, r)
  end
end

-- muld

function MR.muld (x, y, r)
  local nr, nc
  if isa_vector(y) then
    nr, nc = 1, #y
    assert(nc == x.ncol, "incompatible matrix sizes")
    r = chksiz(r,x)
  elseif isa_matrix(y) then
    nr, nc = y:sizes()
    r = chksizm(r,x,y)
  end

  if is_cmatrix(y) then                         -- mat * diag(mat)
    r = r or cmatrix_alloc(x.nrow, nc)
    _C.mad_mat_muldm(x._dat, y._dat, r._dat, r.nrow, r.ncol, nr) return r
  elseif is_matrix(y) and is_matrix(x) then     -- mat * diag(mat)
    r = r or  matrix_alloc(x.nrow, nc)
    _C.mad_mat_muld (x._dat, y._dat, r._dat, r.nrow, r.ncol, nr) return r
  else                                          -- mat * ?
    return assert(gmm(y,'__muld_mat'), "invalid 'mat * diag(?)' operation")(x, y, r)
  end
end

function MC.muld (x, y, r)
  local nr, nc
  if isa_vector(y) then
    nr, nc = 1, #y
    assert(nc == x.ncol, "incompatible matrix sizes")
    r = chksiz(r,x)
  elseif isa_matrix(y) then
    nr, nc = y:sizes()
    r = chksizm(r,x,y)
  end

  if is_matrix(y) then                          -- cmat * diag(mat)
    r = r or cmatrix_alloc(x.nrow, nc)
    _C.mad_cmat_muldm(x._dat, y._dat, r._dat, r.nrow, r.ncol, nr) return r
  elseif is_cmatrix(x) and is_cmatrix(y) then   -- cmat * diag(cmat)
    r = r or cmatrix_alloc(x.nrow, nc)
    _C.mad_cmat_muld (x._dat, y._dat, r._dat, r.nrow, r.ncol, nr) return r
  else                                          -- cmat * ?'
    return assert(gmm(y,'__muld_mat'), "invalid 'cmat * diag(?)' operation")(x, y, r)
  end
end

-- least squares solvers ------------------------------------------------------o

function MR.solve (a, b, rcond_) -- min | b - Ax | using QR or LQ
  assert(is_matrix(b), "invalid argument #2 (matrix expected)")
  local np, nr, nc = b.ncol, a:sizes()
  assert(nr == b.nrow, "incompatible matrix sizes")
  local rx = matrix_alloc(nc, np)
  local rnk = _C.mad_mat_solve(a._dat, b._dat, rx._dat, nr, nc, np, rcond_ or eps)
  return rx, rnk  -- x = b:t():div(a:t()):t()
end

function MC.solve (a, b, rcond_)
  assert(is_cmatrix(b), "invalid argument #2 (cmatrix expected)")
  local np, nr, nc = b.ncol, a:sizes()
  assert(nr == b.nrow, "incompatible cmatrix sizes")
  local rx = cmatrix_alloc(nc, np)
  local rnk = _C.mad_cmat_solve(a._dat, b._dat, rx._dat, nr, nc, np, rcond_ or eps)
  return rx, rnk
end

function MR.ssolve (a, b, rcond_) -- min | b - Ax | using SVD
  assert(is_matrix(b), "invalid argument #2 (matrix expected)")
  local np, nr, nc = b.ncol, a:sizes()
  assert(nr == b.nrow, "incompatible matrix sizes")
  local rx, rs = matrix_alloc(nc, np), matrix_alloc(min(nr,nc),1)
  local rnk = _C.mad_mat_ssolve(a._dat, b._dat, rx._dat, nr, nc, np, rcond_ or eps, rs._dat)
  return rx, rnk, rs
end

function MC.ssolve (a, b, rcond_)
  assert(is_cmatrix(b), "invalid argument #2 (cmatrix expected)")
  local np, nr, nc = b.ncol, a:sizes()
  assert(nr == b.nrow, "incompatible cmatrix sizes")
  local rx, rs = cmatrix_alloc(nc, np), matrix_alloc(min(nr,nc),1)
  local rnk = _C.mad_cmat_ssolve(a._dat, b._dat, rx._dat, nr, nc, np, rcond_ or eps, rs._dat)
  return rx, rnk, rs
end

function MR.gsolve (a, b, c, d) -- min | c - Ax | subject to Bx = d using QR or LQ
  assert(is_matrix(b), "invalid argument #2 (matrix expected)")
  assert(is_matrix(c), "invalid argument #3 (matrix expected)")
  assert(is_matrix(d), "invalid argument #4 (matrix expected)")
  local np, nr, nc = b.nrow, a:sizes()
  assert(nc == b.ncol , "incompatible matrix sizes B")
  assert(nr == size(c), "incompatible matrix sizes C")
  assert(np == size(d), "incompatible matrix sizes D")
  local rx = matrix_alloc(nc, 1)
  local info = _C.mad_mat_gsolve(a._dat, b._dat, c._dat, d._dat, rx._dat, nr, nc, np, res)
  return rx, res[0], info
end

function MC.gsolve (a, b, c, d)
  assert(is_cmatrix(b), "invalid argument #2 (cmatrix expected)")
  assert(is_cmatrix(c), "invalid argument #3 (cmatrix expected)")
  assert(is_cmatrix(d), "invalid argument #4 (cmatrix expected)")
  local np, nr, nc = b.nrow, a:sizes()
  assert(nc == b.ncol , "incompatible cmatrix sizes B")
  assert(nr == size(c), "incompatible cmatrix sizes C")
  assert(np == size(d), "incompatible cmatrix sizes D")
  local rx = cmatrix_alloc(nc, 1)
  local info = _C.mad_cmat_gsolve(a._dat, b._dat, c._dat, d._dat, rx._dat, nr, nc, np, res)
  return rx, res[0], info
end

function MR.gmsolve (a, b, d) -- min_x | y | subject to Ax + By = d using QR or LQ
  assert(is_matrix(b), "invalid argument #2 (matrix expected)")
  assert(is_matrix(d), "invalid argument #3 (matrix expected)")
  local np, nr, nc = b.ncol, a:sizes()
  assert(nr == b.nrow , "incompatible matrix sizes B")
  assert(nr == size(d), "incompatible matrix sizes D")
  local rx, ry = matrix_alloc(nc, 1), matrix_alloc(np, 1)
  local info = _C.mad_mat_gmsolve(a._dat, b._dat, d._dat, rx._dat, ry._dat, nr, nc, np)
  return rx, ry, info
end

function MC.gmsolve (a, b, d)
  assert(is_cmatrix(b), "invalid argument #2 (cmatrix expected)")
  assert(is_cmatrix(d), "invalid argument #3 (cmatrix expected)")
  local np, nr, nc = b.ncol, a:sizes()
  assert(nr == b.nrow , "incompatible cmatrix sizes B")
  assert(nr == size(d), "incompatible cmatrix sizes D")
  local rx, ry = cmatrix_alloc(nc, 1), cmatrix_alloc(np, 1)
  local info = _C.mad_cmat_gmsolve(a._dat, b._dat, d._dat, rx._dat, ry._dat, nr, nc, np)
  return rx, ry, info
end

function MR.nsolve (a, b, nc_, tol_) -- min | b - Ax | using MICADO (best kick)
  assert(is_matrix(b), "invalid argument #2 (matrix expected)")
  local nr, nc = a:sizes()
  assert(nr == size(b), "incompatible matrix sizes")
  local rx, rr = matrix_alloc(nc, 1), matrix_alloc(nr, 1) -- solutions, residues
  local nx = _C.mad_mat_nsolve(a._dat, b._dat, rx._dat, nr, nc, nc_ or 0, tol_ or eps, rr._dat)
  return rx, nx, rr
end

MC.nsolve = \ error("unsupported complex nsolve")

-- system pre-conditionning ---------------------------------------------------o

function MR.pcacnd (a, n_, rcond_)
  local nr, nc = a:sizes()
  local rs, rc = matrix_alloc(min(nr,nc),1), imatrix_alloc(1,nc)
  local nc = _C.mad_mat_pcacnd(a._dat, rc._dat, nr, nc, n_ or 0, rcond_ or eps, rs._dat)
  if nc == 0 then return nil, rs end
  _C.mad_imat_reshape(rc, 1, nc)
  return rc, rs
end

function MC.pcacnd (a, n_, rcond_)
  local nr, nc = a:sizes()
  local rs, rc = matrix_alloc(min(nr,nc),1), imatrix_alloc(1,nc)
  local nc = _C.mad_cmat_pcacnd(a._dat, rc._dat, nr, nc, n_ or 0, rcond_ or eps, rs._dat)
  if nc == 0 then return nil, rs end
  _C.mad_imat_reshape(rc, 1, nc)
  return rc, rs
end

function MR.svdcnd (a, n_, rcond_, tol_)
  local nr, nc = a:sizes()
  local rs, rc = matrix_alloc(min(nr,nc),1), imatrix_alloc(1,nc)
  local nc = _C.mad_mat_svdcnd(a._dat, rc, nr, nc, n_ or 5, rcond_ or eps, rs._dat, tol_ or 0.02)
  if nc == 0 then return nil, rs end
  _C.mad_imat_reshape(rc, 1, nc)
  return rc, rs
end

function MC.svdcnd (a, n_, rcond_, tol_)
  local nr, nc = a:sizes()
  local rs, rc = matrix_alloc(min(nr,nc),1), imatrix_alloc(1,nc)
  local nc = _C.mad_cmat_svdcnd(a._dat, rc, nr, nc, n_ or 5, rcond_ or eps, rs._dat, tol_ or 0.02)
  if nc == 0 then return nil, rs end
  _C.mad_imat_reshape(rc, 1, nc)
  return rc, rs
end

-- svd, det, eigenvalue, eigenvector, matrix functions ------------------------o

function MR.svd (x)
  local nr, nc = x:sizes()
  local rs, ru, rv = matrix_alloc(min(nr,nc),1), matrix_alloc(nr,nr), matrix_alloc(nc,nc)
  local info = _C.mad_mat_svd(x._dat, ru._dat, rs._dat, rv._dat, nr, nc)
  return rs, ru, rv, info
end

function MC.svd (x)
  local nr, nc = x:sizes()
  local rs, ru, rv = matrix_alloc(min(nr,nc),1), cmatrix_alloc(nr,nr), cmatrix_alloc(nc,nc)
  local info = _C.mad_cmat_svd(x._dat, ru._dat, rs._dat, rv._dat, nr, nc)
  return rs, ru, rv, info
end

function MR.eigen (x, vr_, vl_)
  local nr, nc = x:sizes()
  assert(nr == nc, "matrix must be square")
  assert(is_nil(vr_) or is_matrix(vr_) and vr_.nrow == nr and vr_.ncol == nc,
         "invalid argument #2 (compatible square matrix expected")
  assert(is_nil(vl_) or is_matrix(vl_) and vl_.nrow == nr and vl_.ncol == nc,
         "invalid argument #3 (compatible square matrix expected")
  local w = cmatrix_alloc(nr, 1)
  local info = _C.mad_mat_eigen(x._dat, w._dat, vl_ and vl_._dat, vr_ and vr_._dat, nr)
  return w, info, vr_, vl_
end

function MC.eigen (x, vr_, vl_)
  local nr, nc = x:sizes()
  assert(nr == nc, "matrix must be square")
  assert(is_nil(vr_) or is_cmatrix(vr_) and vr_.nrow == nr and vr_.ncol == nc,
         "invalid argument #2 (compatible square cmatrix expected")
  assert(is_nil(vl_) or is_cmatrix(vl_) and vl_.nrow == nr and vl_.ncol == nc,
         "invalid argument #3 (compatible square cmatrix expected")
  local w = cmatrix_alloc(nr, 1)
  local info = _C.mad_cmat_eigen(x._dat, w._dat, vl_ and vl_._dat, vr_ and vr_._dat, nr)
  return w, info, vr_, vl_
end

function MR.det (x)
  local nr, nc = x:sizes()
  assert(nr == nc, "matrix must be square")
  if nr == 2 then -- fast stable 2x2 case
    local w = x._dat[1]*x._dat[2]
    local e = w - x._dat[1]*x._dat[2]
    return (x._dat[0]*x._dat[3] - w) + e, 0
  end
  local info = _C.mad_mat_det(x._dat, res, nr)
  return res[0], info
end

function MC.det (x)
  local nr, nc = x:sizes()
  assert(nr == nc, "matrix must be square")
  if nr == 2 then -- fast stable 2x2 case
    local w = x._dat[1]*x._dat[2]
    local e = w - x._dat[1]*x._dat[2]
    return (x._dat[0]*x._dat[3] - w) + e, 0
  end
  local info = _C.mad_cmat_det(x._dat, cres, nr)
  return cres[0], info
end

-- https://nla-group.org/2020/09/15/a-multiprecision-derivative-free-schur-parlett-algorithm-for-computing-matrix-functions/

function MR.mfun (x, fun)
  local nr, nc = x:sizes()
  assert(nr == nc, "matrix must be square")
  -- get eigen decomposition
  local w, info, vr = x:eigen(x:same())
  if info ~= 0 then
    warn("ill-formed input matrix (unable to compute eigenvectors)")
    return nil, info
  end
  -- check rank of eigenvectors
  if vr:maxabs'row':min() <= 10 * eps or
     vr:maxabs'col':min() <= 10 * eps then
    warn("ill-formed input matrix (rank deficient eigenvectors)")
  end
  local y = (vr * w:map(fun, w):diag()) / vr
  -- convert result to real matrix if input was real
  if is_matrix(x) then
    local yr, yi = y:reim()
    if yi:norm() <= 10*eps*y:norm() then y = yr end
  end
  return y
end

-- FFT, convolution, correlation, covariance ----------------------------------o

function MR.fft (x, d_, r_)
  if is_cmatrix(d_) and is_nil(r_) then r_, d_ = d_, nil end -- right shift
  assert(dir[d_ or 'vec'], "invalid direction")
  local nr, nc = x:sizes()
  local r = r_ or cmatrix_alloc(nr,nc)
  assert(is_cmatrix(r), "invalid argument #3 (cmatrix expected)")
  if d_ == 'vec' or nr == 1 or nc == 1 then
    assert(size(r) == nr*nc, "incompatible cmatrix sizes")
    _C.mad_vec_fft(x._dat, r._dat, nr*nc)          -- 1D FFT
  elseif d_ == 'row' then
    assert(r.nrow == nr and r.ncol == nc, "incompatible cmatrix sizes")
    for i=0,nr-1 do
      _C.mad_vec_fft(x._dat+i*nc, r._dat+i*nc, nc) -- 1D FFT
    end
  elseif d_ == 'col' then
    assert(r.nrow == nr and r.ncol == nc, "incompatible cmatrix sizes")
    x = x:t()
    for i=0,nc-1 do
      _C.mad_vec_fft(x._dat+i*nr, r._dat+i*nr, nr) -- 1D FFT
    end
    r:reshape(nc, nr):t(false, r)
  else
    assert(r.nrow == nr and r.ncol == nc, "incompatible cmatrix sizes")
    _C.mad_mat_fft(x._dat, r._dat, nr, nc)         -- 2D FFT
  end
  return r
end

function MC.fft (x, d_, r_)
  if is_cmatrix(d_) and is_nil(r_) then r_, d_ = d_, nil end -- right shift
  assert(dir[d_ or 'vec'], "invalid direction")
  local nr, nc = x:sizes()
  local r = r_ or cmatrix_alloc(nr,nc)
  assert(is_cmatrix(r), "invalid argument #3 (cmatrix expected)")
  if d_ == 'vec' or nr == 1 or nc == 1 then
    assert(size(r) == nr*nc, "incompatible cmatrix sizes")
    _C.mad_cvec_fft(x._dat, r._dat, nr*nc)          -- 1D FFT
  elseif d_ == 'row' then
    assert(r.nrow == nr and r.ncol == nc, "incompatible cmatrix sizes")
    for i=0,nr-1 do
      _C.mad_cvec_fft(x._dat+i*nc, r._dat+i*nc, nc) -- 1D FFT
    end
  elseif d_ == 'col' then
    assert(r.nrow == nr and r.ncol == nc, "incompatible cmatrix sizes")
    x = x:t(false)
    for i=0,nc-1 do
      _C.mad_cvec_fft(x._dat+i*nr, r._dat+i*nr, nr) -- 1D FFT
    end
    r:reshape(nc, nr):t(false, r)
  else
    assert(r.nrow == nr and r.ncol == nc, "incompatible cmatrix sizes")
    _C.mad_cmat_fft(x._dat, r._dat, nr, nc)         -- 2D FFT
  end
  return r
end

MR.ifft = \ error("invalid argument #1 (cmatrix expected)")

function MC.ifft (x, d_, r_)
  if is_cmatrix(d_) and is_nil(r_) then r_, d_ = d_, nil end -- right shift
  assert(dir[d_ or 'vec'], "invalid direction")
  local nr, nc = x:sizes()
  local r = r_ or cmatrix_alloc(nr,nc)
  assert(is_cmatrix(r), "invalid argument #3 (cmatrix expected)")
  if d_ == 'vec' or nr == 1 or nc == 1 then
    assert(size(r) == nr*nc, "incompatible cmatrix sizes")
    _C.mad_cvec_ifft(x._dat, r._dat, nr*nc)          -- 1D FFT
  elseif d_ == 'row' then
    assert(r.nrow == nr and r.ncol == nc, "incompatible cmatrix sizes")
    for i=0,nr-1 do
      _C.mad_cvec_ifft(x._dat+i*nc, r._dat+i*nc, nc) -- 1D FFT
    end
  elseif d_ == 'col' then
    assert(r.nrow == nr and r.ncol == nc, "incompatible cmatrix sizes")
    x = x:t(false)
    for i=0,nc-1 do
      _C.mad_cvec_ifft(x._dat+i*nr, r._dat+i*nr, nr) -- 1D FFT
    end
    r:reshape(nc, nr):t(false, r)
  else
    assert(r.nrow == nr and r.ncol == nc, "incompatible cmatrix sizes")
    _C.mad_cmat_ifft(x._dat, r._dat, nr, nc)         -- 2D FFT
  end
  return r
end

function MR.rfft (x, d_, r_)
  if is_cmatrix(d_) and is_nil(r_) then r_, d_ = d_, nil end -- right shift
  assert(is_nil(r_) or is_cmatrix(r_), "invalid argument #3 (cmatrix expected)")
  assert(dir[d_ or 'vec'], "invalid direction")
  local nr, nc, r = x:sizes()
  local nr2 = max(1, floor(nr/2+1))
  local nc2 = max(1, floor(nc/2+1))
  if d_ == 'vec' or nr == 1 or nc == 1 then
    local nr2, nc2 = max(1, floor(nr*nc/2+1)), 1
    if nr == 1 and nc ~= 1 then nr2, nc2 = nc2, nr2 end
    r = r_ or cmatrix_alloc(nr2,nc2)
    assert(size(r) == nr2*nc2, "incompatible cmatrix sizes")
    _C.mad_vec_rfft(x._dat, r._dat, nr*nc)           -- 1D FFT
  elseif d_ == 'row' then
    r = r_ or cmatrix_alloc(nr,nc2)
    assert(r.nrow == nr and r.ncol == nc2, "incompatible cmatrix sizes")
    for i=0,nr-1 do
      _C.mad_vec_rfft(x._dat+i*nc, r._dat+i*nc2, nc) -- 1D FFT
    end
  elseif d_ == 'col' then
    r = r_ or cmatrix_alloc(nr2,nc)
    assert(r.nrow == nr2 and r.ncol == nc, "incompatible cmatrix sizes")
    x = x:t(false)
    for i=0,nc-1 do
      _C.mad_vec_rfft(x._dat+i*nr, r._dat+i*nr2, nr) -- 1D FFT
    end
    r:reshape(nc, nr2):t(false, r)
  else
    r = r_ or cmatrix_alloc(nr,nc2)
    assert(r.nrow == nr and r.ncol == nc2, "incompatible cmatrix sizes")
    _C.mad_mat_rfft(x._dat, r._dat, nr, nc)          -- 2D FFT
  end
  return r
end

MC.rfft  = \ error("invalid argument #1 (matrix expected)")
MR.irfft = \ error("invalid argument #1 (cmatrix expected)")

function MC.irfft (x, d_, r)
  if is_matrix(d_) and is_nil(r) then r, d_ = d_, nil end -- right shift
  assert(is_matrix(r), "invalid argument #3 (matrix expected)")
  assert(dir[d_ or 'vec'], "invalid direction")
  local nr, nc = r:sizes()
  local nr2 = max(1, floor(nr/2+1))
  local nc2 = max(1, floor(nc/2+1))
  if d_ == 'vec' or nr == 1 or nc == 1 then
    local nn = max(1, floor(nr*nc/2+1))
    assert(size(x) == nn, "incompatible matrix sizes")
    _C.mad_cvec_irfft(x._dat, r._dat, nr*nc)           -- 1D FFT
  elseif d_ == 'row' then
    assert(x.nrow == nr and x.ncol == nc2, "incompatible matrix sizes")
    for i=0,nr-1 do
      _C.mad_cvec_irfft(x._dat+i*nc2, r._dat+i*nc, nc) -- 1D FFT
    end
  elseif d_ == 'col' then
    assert(x.nrow == nr2 and x.ncol == nc, "incompatible matrix sizes")
    x = x:t(false)
    for i=0,nc-1 do
      _C.mad_cvec_irfft(x._dat+i*nr2, r._dat+i*nr, nr) -- 1D FFT
    end
    r:reshape(nc, nr):t(false, r)
  else
    assert(x.nrow == nr and x.ncol == nc2, "incompatible matrix sizes")
    _C.mad_cmat_irfft(x._dat, r._dat, nr, nc)          -- 2D FFT
  end
  return r
end

-- zero padding

function MR.zpad (x, nr, nc, d_)
  assert(dir[d_ or 'vec'], "invalid direction")
  local nxr, nxc, r = x:sizes()
      if d_ == 'vec' or nr == 1 or nc == 1 then
    r = nr == nxr and nc == nxc and x or x:same(nr,nc ):setvec(1..nxr*nxc   ,x)
  elseif d_ == 'row' then
    r =               nc == nxc and x or x:same(nxr,nc):setsub(1..nxr,1..nxc,x)
  elseif d_ == 'col' then
    r = nr == nxr               and x or x:same(nr,nxc):setsub(1..nxr,1..nxc,x)
  else    -- 2D
    r = nr == nxr and nc == nxc and x or x:same(nr,nc ):setsub(1..nxr,1..nxc,x)
  end
  return r
end

MI.zpad = MR.zpad

-- zero padding for linear convolution

local function zpadconv (x, y, d_)
  local nr, nc
  if d_ == 'vec' or isa_vector(x) and isa_vector(y)
  then nr, nc = 1                 , size(x)+ size(y)-1 ; d_ = 'vec'
  else nr, nc = x.nrow + y.nrow -1, x.ncol + y.ncol -1
  end
  local xpad = x:zpad(nr,nc,d_)
  if rawequal(x, y)
  then return xpad, xpad
  else return xpad, y:zpad(nr,nc,d_)
  end
end

 -- linear convolution (convolution theorem)

function MR.conv (x, y_, d_, r_)
  if is_string(y_) and is_nil(r_) then d_, r_, y_ = y_, d_ end -- right shift
  if is_matrix(d_) and is_nil(r_) then r_, d_ = d_ end         -- right shift
  assert(is_matrix(y_ or x), "invalid argument #2 (matrix expected)")
  local x, y = zpadconv(x, y_ or x, d_)
  local r = r_ or x:same()
  assert(is_matrix(r), "invalid argument #4 (matrix expected)")
  assert(r.nrow == x.nrow and r.ncol == x.ncol, "incompatible matrix sizes")

  local xf = x:rfft(d_)
  if rawequal(x, y)
  then return xf:emul(xf        ,xf):irfft(d_, r)
  else return xf:emul(y:rfft(d_),xf):irfft(d_, r)
  end
end

function MC.conv (x, y_, d_, r_)
  if is_string(y_)  and is_nil(r_) then d_, r_, y_ = y_, d_ end -- right shift
  if is_cmatrix(d_) and is_nil(r_) then r_, d_ = d_ end         -- right shift
  assert(is_cmatrix(y_ or x), "invalid argument #2 (cmatrix expected)")
  local x, y = zpadconv(x, y_ or x, d_)
  local r = r_ or x:same()
  assert(is_cmatrix(r), "invalid argument #4 (cmatrix expected)")
  assert(r.nrow == x.nrow and r.ncol == x.ncol, "incompatible matrix sizes")

  local xf = x:fft(d_)
  if rawequal(x, y)
  then return xf:emul(xf       ,xf):ifft(d_, r)
  else return xf:emul(y:fft(d_),xf):ifft(d_, r)
  end
end

 -- linear correlation (correlation theorem)

function MR.corr (x, y_, d_, r_)
  if is_string(y_)  and is_nil(r_) then d_, r_, y_ = y_, d_ end -- right shift
  if isa_matrix(d_) and is_nil(r_) then r_, d_ = d_ end         -- right shift
  return x:conj():rev(d_):conv(y_ or x, d_, r_)
end

-- covariance

function MR.covar (x, y_, d_, r_)
  if is_string(y_)  and is_nil(r_) then d_, r_, y_ = y_, d_ end -- right shift
  if isa_matrix(d_) and is_nil(r_) then r_, d_ = d_ end         -- right shift
  assert(isa_matrix(y_ or x), "invalid argument #2 (matrix expected)")
  local xc = x:copy():center(d_)
  if is_nil(y_) or rawequal(x, y_)
  then return xc:corr(xc                  , d_, r_)
  else return xc:corr(y_:copy():center(d_), d_, r_)
  end
end

-- NFFT -----------------------------------------------------------------------o

function MR.nfft (x, p_, r_)
  if is_cmatrix(p_) and is_nil(r_) then p_, r_ = nil, p_ end -- right shift
  local r = r_ or x:same(0i)
  assert(is_cmatrix(r), "invalid argument #3 (cmatrix expected)")
  local nr, nc = (p_ and chksiz(x,p_) or x):sizes()
  if nr == 1 or nc == 1
  then _C.mad_vec_nfft(x._dat, p_ and p_._dat, r._dat, nr*nc , size(r)) -- 1D NFFT
  else _C.mad_mat_nfft(x._dat, p_ and p_._dat, r._dat, nr, nc, size(r)) -- 2D NFFT
  end
  return r
end

function MC.nfft (x, p_, r_)
  if is_cmatrix(p_) and is_nil(r_) then p_, r_ = nil, p_ end -- right shift
  local r = r_ or x:same(0i)
  assert(is_cmatrix(r), "invalid argument #3 (cmatrix expected)")
  local nr, nc = (p_ and chksiz(x,p_) or x):sizes()
  if nr == 1 or nc == 1
  then _C.mad_cvec_nfft(x._dat, p_ and p_._dat, r._dat, nr*nc , size(r)) -- 1D NFFT
  else _C.mad_cmat_nfft(x._dat, p_ and p_._dat, r._dat, nr, nc, size(r)) -- 2D NFFT
  end
  return r
end

MR.infft = \ error("invalid argument #1 (cmatrix expected)")

function MC.infft (x, p_, r_)
  if is_cmatrix(p_) and is_nil(r_) then p_, r_ = nil, p_ end -- right shift
  local r = p_ and (chksiz(r_, p_) or p_:same(0i)) or x:same(0i)
  assert(is_cmatrix(r), "invalid argument #3 (cmatrix expected)")
  local nr, nc = r:sizes()
  if nr == 1 or nc == 1
  then _C.mad_cvec_infft(x._dat, p_ and p_._dat, r._dat, nr*nc , size(x)) -- 1D NFFT
  else _C.mad_cmat_infft(x._dat, p_ and p_._dat, r._dat, nr, nc, size(x)) -- 2D NFFT
  end
  return r
end

-- linspace, logspace ---------------------------------------------------------o

local function linspace (start, stop_, size_)
  assert(is_scalar(start) and abs(start) < inf,
         "invalid argument #1 (finite scalar expected)")
  if is_nil(stop_) then start, stop_ = 0, start end
  assert(is_scalar(stop_) and abs(stop_) < inf,
         "invalid argument #2 (finite scalar expected)")
  if is_nil(size_) then size_ = 100 else size_ = math.ceil(size_) end
  assert(is_number(size_) and size_ > 0,
         "invalid argument #3 (positive number expected)")
  local v = (is_complex(start) or is_complex(stop_)) and cvector(size_) or vector(size_)
  local step = size_ > 1 and (stop_-start)/(size_-1) or 0
  for i=0,size_-1 do seti0(v, i, start+step*i) end
  return v
end

local function logspace (start, stop_, size_)
  assert(is_number(start) and start > 0 and start < inf or
         is_complex(start) and abs(start) < inf,
        "invalid argument #1 (positive finite number expected)")
  if is_nil(stop_) then start, stop_ = 1, start end
  assert(is_number(stop_) and stop_ > 0 and stop_ < inf or
         is_complex(stop_) and abs(stop_) < inf,
         "invalid argument #2 (positive finite number expected)")
  if is_nil(size_) then size_ = 100 else size_ = math.ceil(size_) end
  assert(is_number(size_) and size_ > 0,
         "invalid argument #3 (positive number expected)")
  local v = (is_complex(start) or is_complex(stop_)) and cvector(size_) or vector(size_)
  local logstart, logstop = log(start), log(stop_)
  local logstep = size_ > 1 and (logstop-logstart)/(size_-1) or 0
  for i=0,size_-1 do seti0(v, i, exp(logstart+logstep*i)) end
  return v
end

-- concatenation, conversion --------------------------------------------------o

MR.__len = size
MI.__len = size

function MR.__concat (x, y, d_, r_)
  if isy_matrix(d_) and is_nil(r_) then r_, d_ = d_, nil end -- right shift
  assert(isy_matrix(x), "invalid argument #1 (matrix expected)")
  assert(isy_matrix(y), "invalid argument #2 (matrix expected)")
  local nrx, ncx = x:sizes()
  local nry, ncy = y:sizes()
  local d = d_ or 'row'
  if d == 'row' then                   -- concat rows (horizontal)
    local nr, nc = nrx, ncx + ncy
    assert(nrx == nry and (is_nil(r_) or nr == r_.nrow and nc == r_.ncol),
           "incompatible matrix sizes")
    local r = r_ or x:same(nr,nc,x[1]+y[1])
    for i=0,nr-1 do
      for j=0,ncx-1 do set0(r,i,j    , get0(x,i,j)) end
      for j=0,ncy-1 do set0(r,i,j+ncx, get0(y,i,j)) end
    end
    return r
  elseif d == 'col' or d == 'vec' then -- concat columns (vectical)
    local nr, nc = nrx + nry, ncx
    assert(ncx == ncy and (is_nil(r_) or nr == r_.nrow and nc == r_.ncol),
           "incompatible matrix sizes")
    local r = r_ or x:same(nr,nc,x[1]+y[1])
    local nx, ny = nrx * nc, nry * nc
    for i=0,nx-1 do seti0(r,i   , geti0(x,i)) end
    for i=0,ny-1 do seti0(r,i+nx, geti0(y,i)) end
    if d == 'vec' then r:reshape(nr*nc) end
    return r
  end
  error("invalid argument #3 (string 'vec', 'row' or 'col' expected)")
end

MI.__concat = MR.__concat

function MR.tostring (x, sep_, lsep_)
  local nr, nc = x:sizes()
  local r, c = table.new(nr,0), table.new(nc,0)
  for i=0,nr-1 do
    for j=0,nc-1 do
      c[j+1] = tostring(get0(x,i,j))
    end
    r[i+1] = table.concat(c, sep_ or ' ')
  end
  return table.concat(r, lsep_ or '\n')
end

MI.tostring = MR.tostring

function MR.totable (x, d_, r_)
  if isy_matrix(d_) and is_nil(r_) then r_, d_ = d_, nil end
  local d = d_ or 'vec'
  assert(is_string(d), "invalid argument #2 (string expected)")
  assert(is_nil(r_) or is_table(r_), "invalid argument #3 (table expected)")
  local nr, nc, r = x:sizes()
  if nc == 1 or d == 'vec' then
    r = r_ or table.new(nr*nc,0)
    for i=0,nr*nc-1 do r[i+1] = geti0(x,i) end
  else
    r = r_ or table.new(nr,0)
    for i=0,nr-1 do
      local c = r[i+1] or table.new(nc,0)
      assert(is_table(c), "invalid argument #3 (table of tables expected)")
      for j=0,nc-1 do c[j+1] = get0(x,i,j) end
      r[i+1] = c
    end
  end
  return r
end

MI.totable = MR.totable

-- I/O -----------------------------------------------------------------------o

function MR.write (x, filnam_, name_, eps_, line_, nl_)
  if is_nil(nl_) and is_string(eps_) then
    eps_, line_, nl_ = nil, eps_, line_ -- right shift
  end
  if is_number(name_) and is_nil(eps_) then
    name_, eps_ = nil, name_            -- right shift
  end

  local eps = eps_ or 0
  local lret = nl_ or '\n'
  local nsep = line_ == 'line' and ' '  or '  '
  local lsep = line_ == 'line' and ' ;' or lret
  local file = assert(openfile(filnam_, 'w', '.dat'),
                      "unable to open Matrix file in write mode")
  local nr, nc = x:sizes()
  local tostr, char, zero

      if is_cmatrix(x) then tostr, char, zero = tostring, 'i', 0i
  elseif is_imatrix(x) then tostr, char, zero = int2str , 'n', 0
  else                      tostr, char, zero = num2str , '' , 0
  end

  if name_ or not line_ then
    file:write(name_ or '', '[',nr,'x',nc,char,'] =')
  end

  file:write(lsep == '\n' and lsep or '')
  for i=0,nr-1 do
    file:write(nsep)
    for j=0,nc-1 do
      local v = get0(x,i,j)
      local s = tostr((v ~= v or abs(v) >= eps) and v or zero)
      file:write(s, j<nc-1 and nsep or '')
    end
    file:write(i<nr-1 and lsep or lret)
  end

  if is_string(filnam_) then file:close() else file:flush() end
  return x
end

MI.write = MR.write

function MR.print (x, name_, eps_, line_, nl_)
  return x:write(nil, name_, eps_, line_, nl_)
end

MI.print = MR.print

function MR.read (_, filnam_)
  local file = assert(openfile(filnam_, 'r', '.dat'),
                      "unable to open Matix file in read mode")
  local def = file:read()
  if not def then return end

  local _, _, nrs, ncs, cpx = string.find(def, "^[^[]*%[(%d+)x(%d+)(i?)%]%s*=")
  local nr, nc = tonumber(nrs), tonumber(ncs)
  local i, x, v, to, row, ncol, toval = 0, nil

      if cpx == 'i' or cpx == 'I' then x, toval = cmatrix(nr, nc), tocomplex
  elseif cpx == 'n' or cpx == 'N' then x, toval = imatrix(nr, nc), tonumber
  else                                 x, toval =  matrix(nr, nc), tonumber
  end

  -- TODO: read 'line' mode.
  for line in file:lines() do
    if i == nr then break end
    i = i+1
    row, ncol = strsplitall(line, " \t", nil, row)
    assertf(ncol == nc,
            "invalid format row %d (%d columns expected, got %d)", i, nc, ncol)

    for j=1,nc do
      v = toval(row[j])
      if is_nil(v) then
        errorf("invalid input row %d column %d (scalar expected, got '%s')",
               i, j, row[j])
      end
      x:set(i,j, v)
    end
  end
  assertf(i == nr, "invalid format (%d rows expected, got %d)", nr, i)

  if is_string(filnam_) then file:close() end
  return x
end

MI.read = MR.read

-- metamethods ----------------------------------------------------------------o

MR.unm = \x,r_ -> MR.__unm(x,nil,r_)

MI.unm = MR.unm

MR.  add, MR.  sub, MR.  mul, MR.  div, MR.  pow =
MR.__add, MR.__sub, MR.__mul, MR.__div, MR.__pow

MC.  add, MC.  sub, MC.  mul, MC.  div, MC.  pow =
MC.__add, MC.__sub, MC.__mul, MC.__div, MC.__pow

MI.  add, MI.  sub, MI.  mul, MI.  div, MI.  pow =
MI.__add, MI.__sub, MI.__mul, MI.__div, MI.__pow

MR.  eq, MR.  same, MR.  copy, MR.  concat =
MR.__eq, MR.__same, MR.__copy, MR.__concat

MC.  eq, MC.  same, MC.  copy, MC.  concat =
MC.__eq, MC.__same, MC.__copy, MC.__concat

MI.  eq, MI.  same, MI.  copy, MI.  concat =
MI.__eq, MI.__same, MI.__copy, MI.__concat

MR.  emul, MR.  ediv, MR.  emod, MR.  epow =
MR.__emul, MR.__ediv, MR.__emod, MR.__epow

MC.  emul, MC.  ediv, MC.  emod, MC.  epow =
MC.__emul, MC.__ediv, MC.__emod, MC.__epow

MI.  emul, MI.  ediv, MI.  emod, MI.  epow =
MI.__emul, MI.__ediv, MI.__emod, MI.__epow

local function iter (x, i)
  if i < size(x) then return i+1, geti0(x, i) end
end

!MR.__call  = MR.get -- dangerous to make matrix callable, see fold

MR.__ipairs = \s -> (iter, s, 0)
MC.__ipairs = MR.__ipairs
MI.__ipairs = MR.__ipairs

function MR.__index (s, i)
  if type(i) == 'number'
  then return geti_s(s, i)
  else return MR[i]
  end
end

function MC.__index (s, i)
  if type(i) == 'number'
  then return geti_s(s, i)
  else return MC[i]
  end
end

function MI.__index (s, i)
  if type(i) == 'number'
  then return geti_s(s, i)
  else return MI[i]
  end
end

function MR.__newindex (s, i, x)
  if type(i) == 'number'
  then seti_s(s, i, x)
  else error("invalid matrix member '".. tostring(i) .."'")
  end
end

function MC.__newindex (s, i, x)
  if type(i) == 'number'
  then seti_s(s, i, x)
  else error("invalid cmatrix member '".. tostring(i) .."'")
  end
end

function MI.__newindex (s, i, x)
  if type(i) == 'number'
  then seti_s(s, i, x)
  else error("invalid imatrix member '".. tostring(i) .."'")
  end
end

-- MR -> MC -------------------------------------------------------------------o

for k,v in pairs(MR) do
  if is_nil(MC[k]) then MC[k] = v end
end

-- MR only --------------------------------------------------------------------o

local MROT = require 'madl_matrot' -- rotation matrices (in place)

for k,v in pairs(MROT) do
  assert(is_nil(MR[k]), "duplicated matrix method detected (unexpected)")
  MR[k] = v
end

-- env ------------------------------------------------------------------------o

MAD.typeid.is_vector  = is_vector
MAD.typeid.is_cvector = is_cvector
MAD.typeid.is_ivector = is_ivector
MAD.typeid.isa_vector = isa_vector
MAD.typeid.isy_vector = isy_vector

MAD.typeid.is_matrix  = is_matrix
MAD.typeid.is_cmatrix = is_cmatrix
MAD.typeid.is_imatrix = is_imatrix
MAD.typeid.isa_matrix = isa_matrix
MAD.typeid.isy_matrix = isy_matrix

-- metatables -----------------------------------------------------------------o

MR.__metatable = MR
MC.__metatable = MC
MI.__metatable = MI

ffi.metatype( matrix_ctor , MR)
ffi.metatype(cmatrix_ctor , MC)
ffi.metatype(imatrix_ctor , MI)

-- end ------------------------------------------------------------------------o
return {
   vector  =  vector,
  cvector  = cvector,
  ivector  = ivector,

   matrix  =  matrix,
  cmatrix  = cmatrix,
  imatrix  = imatrix,

  linspace = linspace,
  logspace = logspace,
}
