--[=[
 o-----------------------------------------------------------------------------o
 |
 | Matrix module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides full set of functions and operations on real and complex matrices.
  - Vectors are column oriented matrices, i.e. implemented as [n x 1] matrices.

 o-----------------------------------------------------------------------------o
]=]

local MR, MC = {}, {}

-- help -----------------------------------------------------------------------o

local __help = {}
__help.matrix = [=[
NAME
  matrix, cmatrix -- real and complex vectors and matrices

SYNOPSIS
  mr1 = matrix(nrow [, ncol])          -- default ncol = nrow (square matrix)
  mr2 = matrix {{...}, ...}            -- from table (nrow length must be equal)

  mc1 = cmatrix(nrow [, ncol])         -- complex variant
  mc2 = cmatrix {{...}, ...}           -- complex variant

  vr1 = vector(nrow)                   -- vector = [nrow x 1] (column matrix)
  vr2 = vector {...}                   -- from table (column vector)

  vc1 = cvector(nrow)                  -- complex variant
  vc2 = cvector {...}                  -- complex variant

DESCRIPTION
  The module matrix implements the operators and math functions on matrices:
  is_matrix, is_cmatrix, isa_matrix, is_vector, is_cvector, isa_vector,
  nrow, ncol, size (length), sizes, tsizes,
  zeros, ones, eye, random, perm, symp, circ, fill, shift, reshape,   (in place)
  get, get0, geti, geti0, getv, getdiag, getrow, getcol, getsub,
  set, set0, seti, seti0, setv, setdiag, setrow, setcol, setsub,
  same, copy, resize, concat, tostring, totable,
  foreach, map, map2, map3, foldl, foldr, scanl, scanr, filter, mapat, mapij,

  (minus) -, +, -, *, /, %, ^, ==, #, [], ..,
  unm, add, sub, mul, tmul, mult, emul, div, ediv, mod, pow, eq,
  transpose, t, conjugate, conj, trace, tr,
  dot, inner, cross, mixed, outer, norm, distance, unit, center,

  carg, real, imag, conj, rect, polar, proj,
  ceil, floor, frac, trunc, round,
  abs, angle, exp, log, log10, sqrt,
  sin, cos, tan, sinh, cosh, tanh,
  asin, acos, atan, asinh, acosh, atanh,
  erf, tgamma, lgamma,
  min, max, sum, sumabs, sumsqr, product, all, any, filter_out,
  accmin, accmax, accsum, accumulate, accsumabs, accsumsqr, accprod,
  raccmin, raccmax, raccsum, raccsumabs, raccsumsqr, raccprod,

  rot, rotx, roty, rotz, rotxy, rotxz, rotyz, rotyx, rotzx, rotzy, rotxyz,
  torotxyz, rotzyx, rotv, torotv, rotq, torotq, rotpitch, rotyaw, rotroll,
  rotmad, torotmad,

  sympinv, symperr, symplectify,

  solve, svd, det, eigen,
  fft, ifft, rfft, irfft, nfft, infft, conv, corr, covar.

RETURN VALUES
  The constructed matrices, vectors are specialized matrices.

ERRORS
  TODO

EXAMPLES
  m1 = matrix(2,3)                    -- matrix [2 x 3]
  m2 = matrix(3)                      -- square matrix [3 x 3]
  m3 = vector(3)                      -- column vector [3 x 1]
  m4 = matrix {{1,2},{3,4},{5,6}}     -- from table [3 x 2]
  m5 = vector {1,2,3,4,5,6}           -- column vector [6 x 1] = {{1},{2},...}
  m6 = vector {{1,2,3,4,5,6}}         -- row vector [1 x 6]

  c1 = cmatrix(2,3)                   -- cmatrix [2 x 3]
  c2 = cmatrix {{1,2+2i},{3,4+2i},{5,6+2i}}
  c3 = cvector {1,2,3,4,5,6}          -- column cvector [6 x 1]
  c4 = cvector {{1,2,3,4,5,6}}        -- row cvector [1 x 6]
  c5 = c2:transpose()                 -- row cmatrix, transpose conjugate
  I6 = cmatrix(6):eye()               -- identity cmatrix [6 x 6]

SEE ALSO
  gmath, gfunc, complex
]=]
__help.vector   = __help.matrix
__help.cvector  = __help.matrix
__help.cmatrix  = __help.matrix
__help.linspace = __help.matrix
__help.logspace = __help.matrix

-- documentation --------------------------------------------------------------o

__help['matrix: 3D geometry'] = [=[
Useful relations of 3D geometry:
  inner prod:  u'.v = |u|.|v| cos(u^v)
  cross prod:  uxv = |u|.|v| sin(u^v) \vec{n}
  mixed prod:  (uxv)'.w = u'.(vxw) = det(u,v,w)
  outer prod:  u.v' = matrix
  dbl x-prod:  ux(vxw) = (u.w) v - (u.v) w
               (uxv)xw = (u.w) v - (v.w) u
  norm      :  |u| = sqrt(u'.u)
  angle     :  u^v = acos(u'.v / |u|.|v|)  in [0,pi] (or [-pi,pi] if n)
  unit      :  u / |u|
  projection:  u'.v
  projector :  I -   u.u' / u'.u
  reflector :  I - 2 u.u' / u'.u
  area      :  |uxv|
  volume    :  |(uxv)'.w|
  unitary   :  |u| = 1
  orthogonal:  u'.v = 0
  collinear :  |uxv| = 0
  coplanar  :  (uxv)'.w = 0
]=]

__help['matrix: properties'] = [=[
Useful properties of square matrix:
  symmetric :  M = M',  positive-definite:  v' M v > 0 (positive-semidef >= 0)
  hermitian :  M = M^*, complex symmetric, v^* M v > 0 (negative-def < 0)
  skew/anti :  M = -M' (skew-symmetric), M = -M^* (skew-hermitian)
  invertible:  M M^-1 = M^-1 M = I (M^-1 exists) det(M) ~=  0 (i.e. GL(n))
                                                 det(M)  = +1 (i.e. SL(n))
  normal    :  M M' = M' M
  orthogonal:  M M' = M' M = I => M^-1 = M',     det(M)  = ±1 (i.e.  O(n))
               row/col form an orthonormal basis det(M)  = +1 (i.e. SO(n))
  unitary   :  M M^* = I, complex orthogonal,   |det(M)| = +1 (i.e.  U(n))
               row/col form an orthonormal basis det(M)  = +1 (i.e. SU(n))
  symplectic:  M' J M = J => M^-1 = J^-1 M'      det(M)  = ±1 (i.e. Sp(n))
               J is the block-diagonal non-singular skew-symmetric bilinear form
               J = diag {{0,1},{-1,0}}, J^-1 = J' = -J, J^2 = -I, det(J) = +1
               symp M = {{A,B},{C,D}} <=> A'D - C'B = 1, A'C = C'A, B'D = D'B

Special cases:
  reflection:  SO(n) with det(M) = -1 and eigenvalue = {-1,1,...,1}
  rotation  :  SO(n) with det(M) = +1 (even number of reflections ->   proper)
               SO(n) with det(M) = -1 (odd  number of reflections -> improper)
  projection:  M^2 = M, oblique: A (B'A)^-1 B', orthognal: A (A'A)^-1 A',
               eigenvalue = {0,1}*
]=]

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'
local istype in ffi

local _C, tostring, complex in MAD

local is_nil, is_boolean, is_number, is_string, is_table,
      is_complex, is_scalar                                     in MAD.typeid
local ident, compose                                            in MAD.gfunc
local random, carg, real, imag, conj, norm, proj, rect, polar,
      ceil, floor, frac, trunc, round, abs, exp, log, log10, sqrt,
      sin, cos, tan, sinh, cosh, tanh, asin, acos, atan, asinh,
      acosh, atanh, erf, tgamma, lgamma, min, max, inf          in MAD.gmath
local is_callable, is_iterable, is_indexable, has_method        in MAD.concept
local unm, add, mul, mod, pow, bool, land, lor, eq, opstr       in MAD.operator
local rep                                                       in MAD.utility

-- tmp for returned values
local  res = ffi.new 'double [1]'
local cres = ffi.new 'complex[1]'

-- constants
local dbl_sz = ffi.sizeof 'double'
local cpx_sz = ffi.sizeof 'complex'

-- types ----------------------------------------------------------------------o

ffi.cdef [[
typedef struct { ssz_t nr, nc; double  data[?]; }  matrix_t;
typedef struct { ssz_t nr, nc; complex data[?]; } cmatrix_t;
]]

local matrix_ctor  = ffi.typeof 'matrix_t'
local matrix_cref  = ffi.typeof 'matrix_t&'
local cmatrix_ctor = ffi.typeof 'cmatrix_t'
local cmatrix_cref = ffi.typeof 'cmatrix_t&'

local is_matrix  = \x -> istype( matrix_ctor, x)
local is_cmatrix = \x -> istype(cmatrix_ctor, x)
local isa_matrix = \x -> is_matrix(x) or is_cmatrix(x)
local is_vector  = \x -> is_matrix(x)  and (x.nr == 1 or x.nc == 1)
local is_cvector = \x -> is_cmatrix(x) and (x.nr == 1 or x.nc == 1)
local isa_vector = \x -> isa_matrix(x) and (x.nr == 1 or x.nc == 1)

MR.is_matrix  = is_matrix
MR.is_cmatrix = is_cmatrix
MR.isa_matrix = isa_matrix
MR.is_vector  = is_vector
MR.is_cvector = is_cvector
MR.isa_vector = isa_vector

-- allocators -----------------------------------------------------------------o

local function matrix_alloc (nr, nc)
  local len, mat = nr*nc, nil
  if len <= _C.mad_alloc_threshold then
    mat = matrix_ctor(len) -- VLA
  else
    assert(len <= 2^30, "matrix too large")
    local siz = ffi.sizeof(matrix_ctor, 0) + len*dbl_sz
    local ptr = assert(_C.calloc(1,siz), "out of memory")
    mat = ffi.gc(ffi.cast(matrix_cref, ptr), _C.free)
  end
  mat.nr, mat.nc = nr, nc
  return mat
end

local function cmatrix_alloc (nr, nc)
  local len, mat = nr*nc, nil
  if len <= _C.mad_alloc_threshold/2 then
    mat = cmatrix_ctor(len) -- VLA
  else
    assert(len <= 2^29, "matrix too large")
    local siz = ffi.sizeof(cmatrix_ctor, 0) + len*cpx_sz
    local ptr = assert(_C.calloc(1,siz), "out of memory")
    mat = ffi.gc(ffi.cast(cmatrix_cref, ptr), _C.free)
  end
  mat.nr, mat.nc = nr, nc
  return mat
end

local function fromtable (ctor, tbl)
  local nr, nc = #tbl or 0, is_table(tbl[1]) and #tbl[1] or 1
  assert(nr > 0 and nc > 0, "invalid argument #1 (non-empty table expected)")
  return ctor(nr,nc):fill(tbl)
end

-- constructors ---------------------------------------------------------------o

local function matrix (nr, nc_)
  if is_table(nr) then
    return fromtable(matrix_alloc, nr)
  end
  local nc = nc_ or nr -- square
  assert(is_number(nr) and is_number(nc) and nr >= 1 and nc >= 1,
         "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)")
  return matrix_alloc(nr, nc)
end

local function cmatrix (nr, nc_)
  if is_table(nr) then
    return fromtable(cmatrix_alloc, nr)
  end
  local nc = nc_ or nr -- square
  assert(is_number(nr) and is_number(nc) and nr >= 1 and nc >= 1,
         "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)")
  return cmatrix_alloc(nr, nc)
end

local  vector = \n ->  matrix(n, 1)
local cvector = \n -> cmatrix(n, 1)

-- helpers --------------------------------------------------------------------o

local function chksiz (r, x, y) -- add, sub
  assert((is_nil(r) or (r.nr == x.nr and r.nc == x.nc)) and
         (is_nil(y) or (y.nr == x.nr and y.nc == x.nc)),
         "incompatible matrix sizes")
  return r
end

local function chksizm (r, x, y) -- mul
  assert((is_nil(r) or (r.nr == x.nr and r.nc == y.nc)) and x.nc == y.nr,
         "incompatible matrix sizes")
  return r
end

local function chksiztm (r, x, y) -- tmul
  assert((is_nil(r) or (r.nr == x.nc and r.nc == y.nc)) and x.nr == y.nr,
         "incompatible matrix sizes")
  return r
end

local function chksizmt (r, x, y) -- mult
  assert((is_nil(r) or (r.nr == x.nr and r.nc == y.nr)) and x.nc == y.nc,
         "incompatible matrix sizes")
  return r
end

local function chksizd (r, x, y) -- div
  assert((is_nil(r) or (r.nr == x.nr and r.nc == y.nr)) and x.nc == y.nc,
         "incompatible matrix sizes")
  return r
end

local function chksizt (r, x) -- transpose
  assert(is_nil(r) or (r.nr == x.nc and r.nc == x.nr),
         "incompatible matrix sizes")
  return r
end

local idx0  = \i,j,c   -> ( i   *c +  j   )
local idx   = \i,j,c   -> ((i-1)*c + (j-1))

local geti0 = \x,i     -> x.data[i]
local seti0 = \x,i,e   => x.data[i]=e return x end
local geti  = \x,i     -> x.data[i-1]
local seti  = \x,i,e   => x.data[i-1]=e return x end
local get0  = \x,i,j   -> x.data[idx0(i, j, x.nc)]
local set0  = \x,i,j,e => x.data[idx0(i, j, x.nc)]=e return x end
local get   = \x,i,j   -> x.data[idx (i, j, x.nc)]
local set   = \x,i,j,e => x.data[idx (i, j, x.nc)]=e return x end

-- get, set -------------------------------------------------------------------o

MR._geti0 = geti0
MR._seti0 = seti0
MR._geti  = geti
MR._seti  = seti
MR._get0  = get0
MR._set0  = set0
MR._get   = get
MR._set   = set

MR.geti0 = \x,i   -> 0 <= i and i <  x.nr*x.nc                     and geti0(x, i) or nil
MR.geti  = \x,i   -> 1 <= i and i <= x.nr*x.nc                     and geti (x, i) or nil
MR.get0  = \x,i,j -> 0 <= i and i <  x.nr and 0 <= j and j <  x.nc and get0(x,i,j) or nil
MR.get   = \x,i,j -> 1 <= i and i <= x.nr and 1 <= j and j <= x.nc and get (x,i,j) or nil

function MR.seti0 (x, i, e)
  assert(0 <= i and i < x.nr*x.nc, "0-index out of bounds")
  return seti0(x, i, e)
end

function MR.seti (x, i, e)
  assert(1 <= i and i <= x.nr*x.nc, "1-index out of bounds")
  return seti(x, i, e)
end

function MR.set0 (x, i, j, e)
  assert(0 <= i and i < x.nr and 0 <= j and j < x.nc, "0-index out of bounds")
  return set0(x, i, j, e)
end

function MR.set (x, i, j, e)
  assert(1 <= i and i <= x.nr and 1 <= j and j <= x.nc, "1-index out of bounds")
  return set(x, i, j, e)
end

-- size, same -----------------------------------------------------------------o

MR.nrow   = \x -> x.nr
MR.ncol   = \x -> x.nc
MR.size   = \x -> x.nr * x.nc
MR.sizes  = \x -> (x.nr, x.nc)
MR.tsizes = \x -> (x.nc, x.nr)

__help['matrix: same specification'] = [=[
parameters:
  e: element sample for type promotion, nr & nc: sizes

type promotion:
  x  matrix and e real    returns a  matrix
  x  matrix and e complex returns a cmatrix
  x cmatrix and e real    returns a cmatrix
  x cmatrix and e complex returns a cmatrix

cases:
  1)  x:same(               )
  2)  x:same( nil, nr       )
  3)  x:same( nil, nil, nc  )
  4)  x:same( nil, nr , nc  )
  5)  x:same(   e           )
  6)  x:same(   e, nr       )          --> 4) with e as nr and nr as nc, see 7'
  7)  x:same(   e, nil, nc  )
  8)  x:same(   e, nr , nc  )

cases with left shift:
  2') x:same( nr            )          <=> 5) with nr as e  (ambiguity)
  3') x:same( nc            )          <=> 5) with nc as e  (ambiguity)
  4') x:same( nr, nc        )          --> 4) valid shift
  7') x:same( e , nc        )          --> 4) with e  as nr (ambiguity)
  3") x:same( nil, nc       )          <=> 2) with nc as nr (ambiguity)
  4") x:same( nr, nil, nc   )          <=> 7) with nr as e  (ambiguity)
]=]

function MR.same (x, e_, nr_, nc_)
  if is_nil(nc_) and is_number(e_) and is_number(nr_) then -- shift right
    nr_, nc_, e_ = e_, nr_, nil
  end
  if is_nil(e_) or is_number(e_) then
    return  matrix(nr_ or x.nr, nc_ or x.nc)
  elseif is_complex(e_) then
    return cmatrix(nr_ or x.nr, nc_ or x.nc)
  else
    error("invalid argument #2 (nil or scalar expected)")
  end
end

function MC.same (x, e_, nr_, nc_)
  if is_nil(nc_) and is_number(e_) and is_number(nr_) then -- shift right
    nr_, nc_, e_ = e_, nr_, nil
  end
  -- e_ is ignored because x is a cmatrix
  return cmatrix(nr_ or x.nr, nc_ or x.nc)
end

-- copy, resize ---------------------------------------------------------------o

function MR.copy (x, y_)
  local n
  if is_nil(y_) then
    n, x, y_ = x:size(), matrix(x:sizes()), x
  else
    assert(is_matrix(y_), "invalid argument #1 (matrix expected)")
    n = min(x:size(), y_:size())
  end
  ffi.copy(x.data, y_.data, dbl_sz*n)
  return x
end

function MC.copy (x, y_)
  local n
  if is_nil(y_) then
    n, x, y_ = x:size(), cmatrix(x:sizes()), x
  else
    assert(is_cmatrix(y_), "invalid argument #1 (cmatrix expected)")
    n = min(x:size(), y_:size())
  end
  ffi.copy(x.data, y_.data, cpx_sz*n)
  return x
end

function MR.resize (x, nr, nc)
  local y
  if is_matrix(nr)
  then x, y = nr, x
  else x, y = matrix(nr,nc), x
  end

  local nr, nc = min(x:nrow(), y:nrow()), min(x:ncol(), y:ncol())
  for i=0,nr-1 do
    ffi.copy(x.data+x.nc*i, y.data+y.nc*i, dbl_sz*nc)
  end
  return x
end

function MC.resize (x, nr, nc)
  local y
  if is_cmatrix(nr)
  then x, y = nr, x
  else x, y = cmatrix(nr,nc), x
  end

  local nr, nc = min(x:nrow(), y:nrow()), min(x:ncol(), y:ncol())
  for i=0,nr-1 do
    ffi.copy(x.data+x.nc*i, y.data+y.nc*i, cpx_sz*nc)
  end
  return x
end

-- zeros, ones, eye, symp, circ, fill, shift, reshape (in place) --------------o

function MR.zeros (x)
  ffi.fill(x.data, dbl_sz * x:size())
  return x
end

function MC.zeros (x)
  ffi.fill(x.data, cpx_sz * x:size())
  return x
end

function MR.ones (x, e_)
  local e, n = e_ or 1, x:size()
  for i=0,n-1 do seti0(x,i,e) end
  return x
end

function MR.eye (x, e_) -- zeros + diag
  x:zeros()
  local e, nr, nc = e_ or 1, x:sizes()
  local n = min(nr, nc)
  for i=0,n*nc,nc+1 do seti0(x,i,e) end
  return x
end

function MR.random (x, f_, ...) -- random
  assert(is_nil(f_) or is_callable(f_), "invalid argument #2 (callable expected)")
  local n, f = x:size(), f_ or random
  for i=0,n-1 do seti0(x,i,f(...)) end
  return x
end

function MC.random (x, f_, ...) -- random
  assert(is_nil(f_) or is_callable(f_), "invalid argument #2 (callable expected)")
  local n, f = x:size(), f_ or random
  for i=0,n-1 do seti0(x,i,complex(f(...),f(...))) end
  return x
end

function MR.perm (x) -- random permutation (Knuth shuffles)
  local n = x:size()
  for i=0,n-2 do
    local j = random(i,n-1)
    x.data[i], x.data[j] = x.data[j], x.data[i]
  end
  return x
end

function MR.symp (x) -- zeros + J
  local nr, nc = x:sizes()
  assert(nr == nc and nr % 2 == 0, "invalid argument #1 (2n matrix expected)")
  x:zeros()
  for i=1,nr-1,2 do set(x,i,i+1,1) set(x,i+1,i,-1) end
  return x
end

function MR.circ (x, v)
  local d
  if isa_vector(v) then
    d = v:nrow() == 1 and 'row' or 'col'
  else
    assert(is_iterable(v), "invalid argument #2 (iterable expected)")
    if is_iterable(v[1]) then d, v = 'row', v[1] else d = 'col' end
  end
  local k, nr, nc = 0, x:sizes()
  if d == 'row' then
    for i=1,nr do
    for j=nc+2-i,nc do seti0(x,k, v[j]) k=k+1 end
    for j=1,nc+1-i  do seti0(x,k, v[j]) k=k+1 end
    end
  else
    for i=1,nr do
    for j= i,  1,-1 do seti0(x,k, v[j]) k=k+1 end
    for j=nc,i+1,-1 do seti0(x,k, v[j]) k=k+1 end
    end
  end
  return x
end

function MR.fill (x, a, p_, s_)
  local nr, nc = x:sizes()
  if is_scalar(a) then        -- scalar
    for i=0,nr*nc-1 do seti0(x,i, a) end
  elseif is_callable(a) then  -- generator
    if is_nil(p_) or is_nil(s_) then
      for i=1,nr do
      for j=1,nc do set(x,i,j, a(get(x,i,j), i,j)) end end
    else                      -- stateless iterator
      local v
      for i=0,nr*nc-1 do s_,v = a(p_,s_) ; seti0(x,i,v) end
    end
  elseif is_iterable(a) then
    if is_iterable(a[1]) then -- 2D container
      assert(#a == nr, "incompatible container size")
      for i=1,nr do
        assert(is_iterable(a[i]), "invalid container (iterable expected)")
        assert(#a[i] == nc      , "incompatible container size")
        for j=1,nc do set(x,i,j, a[i][j]) end
      end
    else                      -- 1D container
      assert(#a == nr*nc, "incompatible container size")
      for i=1,nr*nc do seti(x,i, a[i]) end
    end
  else
    error("invalid argument #2 (scalar, callable or indexable expected)")
  end
  return x
end

function MR.shift (x, ns_, ms_)
  local nr, nc = x:sizes()
  if is_nil(ms_) and (nr == 1 or nc == 1)
  then _C.mad_vec_shift(x.data, nr*nc , ns_ or 0)
  else _C.mad_mat_shift(x.data, nr, nc, ns_ or 0, ms_ or 0)
  end
  return x
end

function MC.shift (x, ns_, ms_)
  local nr, nc = x:sizes()
  if is_nil(ms_) and (nr == 1 or nc == 1)
  then _C.mad_cvec_shift(x.data, nr*nc , ns_ or 0)
  else _C.mad_cmat_shift(x.data, nr, nc, ns_ or 0, ms_ or 0)
  end
  return x
end

function MR.reshape (x, nr_, nc_)
  local nr, nc = nr_ or x:size(), nc_ or 1
  assert(nr >= 1 and nc >= 1 and nr*nc <= x:size(), "invalid matrix new sizes")
  x.nr, x.nc = nr, nc
  return x
end

function MR._reshape (x, nr_, nc_)
  -- no check, user is responsible for keeping track of the real allocated size
  -- unsafe, accessing data beyond allocated size trigs a segmentation fault
  local nr, nc = nr_ or x:size(), nc_ or 1
  assert(nr >= 1 and nc >= 1, "invalid matrix new sizes")
  x.nr, x.nc = nr, nc
  return x
end

-- getx, setx -----------------------------------------------------------------o

function MR.getv (x, ij, r_)
  if is_number(ij) then ij = {ij} end
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(is_iterable(ij)              , "invalid argument #2 (iterable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #3 (iterable expected)")
  local r = r_ or x:same(#ij,1)
  for i,ii in ipairs(ij) do r[i] = x:geti(ii) end
  return r
end

function MR.setv (x, ij, y, p_, s_)
  if is_number(ij) then ij = {ij} end
  if is_scalar(y) then y = rep(y) end
  assert(is_iterable(ij), "invalid argument #2 (iterable expected)")
  if is_nil(p_) or is_nil(s_) then
    assert(is_iterable(y), "invalid argument #3 (scalar or iterable expected)")
    local k, nk = 1, #y
    for _,ii in ipairs(ij) do x:seti(ii, y[k]) ; k=k%nk+1 end
  else  -- stateless iterator
    assert(is_callable(y), "invalid argument #3 (scalar or iterator expected)")
    local v
    for _,ii in ipairs(ij) do s_,v = y(p_,s_) ; x:seti(ii,v) end
  end
  return x
end

function MR.getdiag (x, r_)
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #2 (iterable expected)")
  local n = min(x:sizes())
  local r = r_ or x:same(n,1)
  for i=1,n do r[i] = get(x,i,i) end
  return r
end

function MR.setdiag (x, y, p_, s_)
  local n = min(x:sizes())
  if is_scalar(y) then y = rep(y) end
  if is_nil(p_) or is_nil(s_) then
    assert(is_iterable(y), "invalid argument #2 (scalar or iterable expected)")
    local k, nk = 1, #y
    for i=1,n do set(x,i,i, y[k]) ; k=k%nk+1 end
  else  -- stateless iterator
    assert(is_callable(y), "invalid argument #2 (scalar or iterator expected)")
    local v
    for i=1,n do s_,v = y(p_,s_) ; set(x,i,i, v) end
  end
  return x
end

function MR.getrow (x, ir, r_)
  if is_number(ir) then ir = {ir} end
  assert(is_iterable(ir)              , "invalid argument #2 (iterable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #3 (iterable expected)")
  local k, nc = 1, x:ncol()
  local r = r_ or x:same(#ir,nc)
  for _,i in ipairs(ir) do
  for j=1,nc do r[k] = x:get(i,j) ; k=k+1 end end
  return r
end

function MR.setrow (x, ir, y, p_, s_)
  if is_number(ir) then ir = {ir} end
  if is_scalar(y) then y = rep(y) end
  assert(is_iterable(ir), "invalid argument #2 (iterable expected)")
  if is_nil(p_) or is_nil(s_) then
    assert(is_iterable(y), "invalid argument #3 (scalar or iterable expected)")
    local k, nk = 1, #y
    for _,i in ipairs(ir) do
    for j=1,x:ncol()      do x:set(i,j, y[k]) ; k=k%nk+1 end end
  else  -- stateless iterator
    assert(is_callable(y), "invalid argument #3 (scalar or iterator expected)")
    for _,i in ipairs(ir) do local v
    for j=1,x:ncol()      do s_,v = y(p_,s_) ; x:set(i,j,v) end end
  end
  return x
end

function MR.getcol (x, jc, r_)
  if is_number(jc) then jc = {jc} end
  assert(is_iterable(jc)              , "invalid argument #2 (iterable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #3 (iterable expected)")
  local k, nr = 1, x:nrow()
  local r = r_ or x:same(nr,#jc)
  if isa_matrix(r) and r:ncol() > 1 then
    for i=1,nr            do
    for _,j in ipairs(jc) do r[k] = x:get(i,j) ; k=k+1 end end
  else
    for _,j in ipairs(jc) do
    for i=1,nr            do r[k] = x:get(i,j) ; k=k+1 end end
  end
  return r
end

function MR.setcol (x, jc, y)
  if is_number(jc) then jc = {jc} end
  if is_scalar(y) then y = rep(y) end
  assert(is_iterable(jc), "invalid argument #2 (iterable expected)")
  if isa_matrix(y) and y:ncol() > 1 then
    local k, nk = 1, #y
    for i=1,x:nrow()      do
    for _,j in ipairs(jc) do x:set(i,j, y[k]) ; k=k%nk+1 end end
  elseif is_nil(p_) or is_nil(s_) then
    assert(is_iterable(y), "invalid argument #3 (scalar or iterable expected)")
    local k, nk = 1, #y
    for _,j in ipairs(jc) do
    for i=1,x:nrow()      do x:set(i,j, y[k]) ; k=k%nk+1 end end
  else  -- stateless iterator
    assert(is_callable(y), "invalid argument #3 (scalar or iterator expected)")
    for _,j in ipairs(jc) do local v
    for i=1,x:nrow()      do s_,v = y(p_,s_) ; x:set(i,j,v) end end
  end
  return x
end

function MR.getsub (x, ir, jc, r_)
  if is_number(ir) then ir = {ir} end
  if is_number(jc) then jc = {jc} end
  assert(is_iterable(ir)              , "invalid argument #2 (iterable expected)")
  assert(is_iterable(jc)              , "invalid argument #3 (iterable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #4 (iterable expected)")
  local r, k = r_ or x:same(#ir,#jc), 1
  for _,i in ipairs(ir) do
  for _,j in ipairs(jc) do r[k] = x:get(i,j) ; k=k+1 end end
  return r
end

function MR.setsub (x, ir, jc, y, p_, s_)
  if is_number(ir) then ir = {ir} end
  if is_number(jc) then jc = {jc} end
  if is_scalar(y) then y = rep(y) end
  assert(is_iterable(ir), "invalid argument #2 (iterable expected)")
  assert(is_iterable(jc), "invalid argument #3 (iterable expected)")
  if is_nil(p_) or is_nil(s_) then
    assert(is_iterable(y), "invalid argument #4 (scalar or iterable expected)")
    local k, nk = 1, #y
    for _,i in ipairs(ir) do
    for _,j in ipairs(jc) do x:set(i,j, y[k]) ; k=k%nk+1 end end
  else  -- stateless iterator
    assert(is_callable(y), "invalid argument #4 (scalar or iterator expected)")
    for _,i in ipairs(ir) do local v
    for _,j in ipairs(jc) do s_,v = y(p_,s_) ; x:set(i,j,v) end end
  end
  return x
end

-- foreach, map, fold, scan, filter -------------------------------------------o

function MR.foreach (x, f)
  assert(is_callable(f), "invalid argument #2 (callable expected)")
  local nr, nc = x:sizes()
  for i=1,nr do
  for j=1,nc do f(get(x,i,j), i,j) end end
  return x
end

function MR.map (x, f, r_)
  if is_string(f ) then f = opstr[f] end
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(is_callable(f)               , "invalid argument #2 (callable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #3 (iterable expected)")
  local r0 = f(geti(x,1))
  assert(is_scalar(r0) or not (is_nil(r_) or isa_matrix(r_)),
                                        "invalid argument #2 (scalar function expected)")
  local r, n = r_ or x:same(r0), x:size()
  r[1] = r0
  for i=2,n do r[i] = f(geti(x,i)) end
  return r
end

function MR.map2 (x, y, f, r_)
  if is_scalar(y ) then y = rep(y) end
  if is_string(f ) then f = opstr[f] end
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(is_iterable(y)               , "invalid argument #2 (scalar or iterable expected)")
  assert(is_callable(f)               , "invalid argument #3 (callable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #4 (iterable expected)")
  local r0 = f(geti(x,1), y[1])
  assert(is_scalar(r0) or not (is_nil(r_) or isa_matrix(r_)),
                                        "invalid argument #3 (scalar function expected)")
  local r, n = r_ or x:same(r0), x:size()
  r[1] = r0
  for i=2,n do r[i] = f(geti(x,i), y[i]) end
  return r
end

function MR.map3 (x, y, z, f, r_)
  if is_scalar(y ) then y = rep(y) end
  if is_scalar(z ) then z = rep(z) end
  if is_string(f ) then f = opstr[f] end
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(is_iterable(y)               , "invalid argument #2 (scalar or iterable expected)")
  assert(is_iterable(z)               , "invalid argument #3 (scalar or iterable expected)")
  assert(is_callable(f)               , "invalid argument #4 (callable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #5 (iterable expected)")
  local r0 = f(geti(x,1), y[1], z[1])
  assert(is_scalar(r0) or not (is_nil(r_) or isa_matrix(r_)),
                                        "invalid argument #4 (scalar function expected)")
  local r, n = r_ or x:same(r0), x:size()
  r[1] = r0
  for i=2,n do r[i] = f(geti(x,i), y[i], z[i]) end
  return r
end

function MR.mapij (x, f, r_)
  if is_string(f ) then f = opstr[f] end
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(is_callable(f)               , "invalid argument #2 (callable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #3 (iterable expected)")
  local r, k, nr, nc = r_ or x:same(), 1, x:sizes()
  for i=1,nr do
  for j=1,nc do
    r[k], k = f(get(x,i,j), i,j), k+1
  end end
  return r
end

function MR.mapat (x, f, ij, r_)
  if is_string(f ) then f = opstr[f] end
  if is_number(ij) then ij = {ij} end
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(is_callable(f )              , "invalid argument #2 (callable expected)")
  assert(is_iterable(ij)              , "invalid argument #3 (iterable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #4 (iterable expected)")
  local r = r_ or x:copy()
  for _,i in ipairs(ij) do r[i] = f(x:geti(i)) end
  if is_table(r) then -- complete the fill
    for i=1,x:size() do
      if is_nil(r[i]) then r[i] = x:geti(i) end
    end
  end
  return r
end

__help['matrix: fold specification'] = [[
parameters:
  f: callable, x0: initial value, d: ['vec', 'row', 'col'], r: iterable

special values:
  f: operator string -> operator function

default:
  x0 = x[ 1] or x[., 1] or x[ 1,.] for foldl
       x[#x] or x[.,nc] or x[nr,.] for foldr
   d = 'vec'  (r_ is discarded if any)
   r = scalar ['vec'] or x:same(nr,1) ['row'] or x:same(1,nc) ['col']

cases:
  1)  x:fold( f              )
  2)  x:fold( f, nil,   d    )
  3)  x:fold( f, nil, nil, r )
  4)  x:fold( f, nil,   d, r )
  5)  x:fold( f,  x0         )
  6)  x:fold( f,  x0,   d    )
  7)  x:fold( f,  x0, nil, r )
  8)  x:fold( f,  x0,   d, r )

cases with left shift:
  2') x:fold( f, d           )         --> 2)
  3') x:fold( f, r           )         <=> 3) with r as x0 (ambiguity)
  4') x:fold( f, d, r        )         --> 4)
  7') x:fold( f, x0, r       )         --> 7)
  3") x:fold( f, nil, r      )         --> 3)
  4") x:fold( f, d, nil, r   )         --> 4)
]]

function MR.foldl (x, f, x0_, d_, r_)
  if is_string(f) then f = opstr[f] end
  if is_string(x0_) then                           -- case 2',4',4": shift right
    x0_, d_, r_ = nil, x0_, is_nil(r_) and d_ or r_
  elseif is_nil(r_) and not is_string(d_) then        -- case 7',3": shift right
    d_, r_ = nil, d_
  end
  assert(is_callable(f)               , "invalid argument #2 (callable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #5 (iterable expected)")
  local nr, nc, rr, r = x:sizes()
  if is_nil(d_) or d_ == 'vec' then    -- fold x as vector, r_ is discarded
                       r  = geti(x,1)
    if x0_ ~= nil then r  = f(x0_, r) end
    for i=2,nr*nc   do r  = f(r, geti(x,i)) end
  elseif d_ == 'row' then              -- fold x rows
    r = r_ or x:same(nr,1)
    for i=1,nr      do rr = get(x,i,1)
    if x0_ ~= nil then rr = f(x0_, rr) end
    for j=2,nc      do rr = f(rr, get(x,i,j)) end r[i] = rr end
  elseif d_ == 'col' then              -- fold x columns
    r = r_ or x:same(1,nc)
    for j=1,nc      do rr = get(x,1,j)
    if x0_ ~= nil then rr = f(x0_, rr) end
    for i=2,nr      do rr = f(rr, get(x,i,j)) end r[j] = rr end
  else
    error("invalid argument #4 (string 'vec', 'row' or 'col' expected)")
  end
  return r
end

function MR.foldr (x, f, x0_, d_, r_)
  if is_string(f) then f = opstr[f] end
  if is_string(x0_) then                           -- case 2',4',4": shift right
    x0_, d_, r_ = nil, x0_, is_nil(r_) and d_ or r_
  elseif is_nil(r_) and not is_string(d_) then        -- case 7',3": shift right
    d_, r_ = nil, d_
  end
  assert(is_callable(f)               , "invalid argument #2 (callable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #5 (iterable expected)")
  local nr, nc, rr, r = x:sizes()
  if is_nil(d_) or d_ == 'vec' then    -- fold x as vector, r_ is discarded
                          r  = geti(x,nr*nc)
    if x0_ ~= nil    then r  = f(r, x0_) end
    for i=nr*nc-1,1,-1 do r  = f(geti(x,i), r) end
  elseif d_ == 'row' then              -- fold x rows
    r = r_ or x:same(nr,1)
    for i=nr  ,1,-1    do rr = get(x,i,nc)
    if x0_ ~= nil    then rr = f(rr, x0_) end
    for j=nc-1,1,-1    do rr = f(get(x,i,j), rr) end r[i] = rr end
  elseif d_ == 'col' then              -- fold x columns
    r = r_ or x:same(1,nc)
    for j=nc  ,1,-1    do rr = get(x,nr,j)
    if x0_ ~= nil    then rr = f(rr, x0_) end
    for i=nr-1,1,-1    do rr = f(get(x,i,j), rr) end r[j] = rr end
  else
    error("invalid argument #4 (string 'vec', 'row' or 'col' expected)")
  end
  return r
end

__help['matrix: scan specification'] = [[
parameters:
  f: callable, x0: initial value, d: ['vec', 'row', 'col'], r: iterable

special values:
  f: operator string -> operator function
  r: 'in'            -> r = x

default:
  x0 = x[ 1] or x[., 1] or x[ 1,.] for scanl
       x[#x] or x[.,nc] or x[nr,.] for scanr
   d = 'vec'
   r = x:same() ['vec', row', 'col']

cases:
  1)  x:scan( f              )
  2)  x:scan( f, nil,   d    )
  3)  x:scan( f, nil, nil, r )
  4)  x:scan( f, nil,   d, r )
  5)  x:scan( f,  x0         )
  6)  x:scan( f,  x0,   d    )
  7)  x:scan( f,  x0, nil, r )
  8)  x:scan( f,  x0,   d, r )

cases with left shift:
  2') x:scan( f, d           )         --> 2)
  3') x:scan( f, r           )         <=> 3) with r as x0 (ambiguity)
  4') x:scan( f, d, r        )         --> 4)
  7') x:scan( f, x0, r       )         --> 7)
  3") x:scan( f, nil, r      )         --> 3)
  4") x:scan( f, d, nil, r   )         --> 4)
]]

function MR.scanl (x, f, x0_, d_, r_)
  if is_string(f) then f = opstr[f] end
  if is_string(x0_) then                           -- case 2',4',4": shift right
    x0_, d_, r_ = nil, x0_, is_nil(r_) and d_ or r_
  elseif is_nil(r_) and not is_string(d_) then        -- case 7',3": shift right
    d_, r_ = nil, d_
  end
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(is_callable(f)               , "invalid argument #2 (callable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #5 (iterable expected)")
  local r, nr, nc, rr = r_ or x:same(), x:sizes()
  if is_nil(d_) or d_ == 'vec' then    -- scan x as vector
                       rr = geti(x,1)
    if x0_ ~= nil then rr = f(x0_, rr) end    r[1] = rr
    for i=2,nr*nc   do rr = f(rr, geti(x,i))  r[i] = rr end
  elseif d_ == 'row' then              -- scan x rows
    local k = 1
    for i=1,nr      do rr = get(x,i,1)
    if x0_ ~= nil then rr = f(x0_, rr) end    r[k], k = rr, k+1
    for j=2,nc      do rr = f(rr, get(x,i,j)) r[k], k = rr, k+1 end end
  elseif d_ == 'col' then              -- scan x columns
    if isa_matrix(r) and r:ncol() > 1 then
      for j=1,nc      do rr = get(x,1,j)
      if x0_ ~= nil then rr = f(x0_, rr) end    r[idx(1,j,nc)+1] = rr
      for i=2,nr      do rr = f(rr, get(x,i,j)) r[idx(i,j,nc)+1] = rr end end
    else
      local k = 1
      for j=1,nc      do rr = get(x,1,j)
      if x0_ ~= nil then rr = f(x0_, rr) end    r[k], k = rr, k+1
      for i=2,nr      do rr = f(rr, get(x,i,j)) r[k], k = rr, k+1 end end
    end
  else
    error("invalid argument #4 (string 'vec', 'row' or 'col' expected)")
  end
  return r
end

function MR.scanr (x, f, x0_, d_, r_)
  if is_string(f) then f = opstr[f] end
  if is_string(x0_) then                           -- case 2',4',4": shift right
    x0_, d_, r_ = nil, x0_, is_nil(r_) and d_ or r_
  elseif is_nil(r_) and not is_string(d_) then        -- case 7',3": shift right
    d_, r_ = nil, d_
  end
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(is_callable(f)               , "invalid argument #2 (callable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #5 (iterable expected)")
  local r, nr, nc, rr = r_ or x:same(), x:sizes()
  if is_nil(d_) or d_ == 'vec' then    -- scan x as vector
                          rr = geti(x,nr*nc)
    if x0_ ~= nil    then rr = f(rr, x0_) end    r[nr*nc] = rr
    for i=nr*nc-1,1,-1 do rr = f(geti(x,i), rr)  r[i    ] = rr end
  elseif d_ == 'row'  then             -- scan x rows
    local k = nr*nc
    for i=nr  ,1,-1    do rr = get(x,i,nc)
    if x0_ ~= nil    then rr = f(rr, x0_) end    r[k], k = rr, k-1
    for j=nc-1,1,-1    do rr = f(get(x,i,j), rr) r[k], k = rr, k-1 end end
  elseif d_ == 'col' then              -- scan x columns
    if isa_matrix(r) and r:ncol() > 1 then
      for j=nc  ,1,-1    do rr = get(x,nr,j)
      if x0_ ~= nil    then rr = f(rr, x0_) end    r[idx(nr,j,nc)+1] = rr
      for i=nr-1,1,-1    do rr = f(get(x,i,j), rr) r[idx(i ,j,nc)+1] = rr end end
    else
      local k = nr*nc
      for j=nc  ,1,-1    do rr = get(x,nr,j)
      if x0_ ~= nil    then rr = f(rr, x0_) end    r[k], k = rr, k-1
      for i=nr-1,1,-1    do rr = f(get(x,i,j), rr) r[k], k = rr, k-1 end end
    end
  else
    error("invalid argument #4 (string 'vec', 'row' or 'col' expected)")
  end
  return r
end

function MR.filter (x, p, r_)
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(is_callable(p)               , "invalid argument #2 (callable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #3 (iterable expected)")
  local r, k, nr, nc = r_ or x:same(), 1, x:sizes()
  for i=1,nr do
  for j=1,nc do
    if p(get(x,i,j), i,j) == true then
      r[k], k = get(x,i,j), k+1
    end
  end end
  if isa_matrix(r) then r:reshape(k-1) end
  return r
end

-- special maps ---------------------------------------------------------------o

MR.ceil  = \x,r_ -> x:map(ceil , r_)
MR.floor = \x,r_ -> x:map(floor, r_)
MR.frac  = \x,r_ -> x:map(frac , r_)
MR.trunc = \x,r_ -> x:map(trunc, r_)
MR.round = \x,r_ -> x:map(round, r_)

MR.abs   = \x,r_ -> x:map(abs  , r_)
MR.sqrt  = \x,r_ -> x:map(sqrt , r_)
MR.exp   = \x,r_ -> x:map(exp  , r_)
MR.log   = \x,r_ -> x:map(log  , r_)
MR.log10 = \x,r_ -> x:map(log10, r_)

MR.sin   = \x,r_ -> x:map(sin  , r_)
MR.cos   = \x,r_ -> x:map(cos  , r_)
MR.tan   = \x,r_ -> x:map(tan  , r_)
MR.sinh  = \x,r_ -> x:map(sinh , r_)
MR.cosh  = \x,r_ -> x:map(cosh , r_)
MR.tanh  = \x,r_ -> x:map(tanh , r_)

MR.asin  = \x,r_ -> x:map(asin , r_)
MR.acos  = \x,r_ -> x:map(acos , r_)
MR.atan  = \x,r_ -> x:map(atan , r_)
MR.asinh = \x,r_ -> x:map(asinh, r_)
MR.acosh = \x,r_ -> x:map(acosh, r_)
MR.atanh = \x,r_ -> x:map(atanh, r_)

MR.erf   = \x,r_ -> x:map(erf   , r_)
MR.tgamma= \x,r_ -> x:map(tgamma, r_)
MR.lgamma= \x,r_ -> x:map(lgamma, r_)

MR.carg  = \x,r_ -> x:map(carg , r_)
MR.real  = \x,r_ -> x:map(real , r_)
MR.imag  = \x,r_ -> x:map(imag , r_)
MR.conj  = \x,r_ -> x:map(conj , r_)
MR.proj  = \x,r_ -> x:map(proj , r_)
MR.rect  = \x,r_ -> x:map(rect , r_)
MR.polar = \x,r_ -> x:map(polar, r_)

-- special folds --------------------------------------------------------------o

-- fct stack
local flist, fun = {}, nil  -- memoize functions because FNEW is _not_ compiled
local pushf = \f => flist[#flist+1], fun = f, f end
local popf  = \  => flist[#flist  ], fun = nil, flist[#flist-1] end

local ssqr = \r,x -> r + x*x
local sabs = \r,x -> r + abs(x)

MR.min     = \x,d_,r_ -> x:foldl(min , nil, d_, r_)
MR.max     = \x,d_,r_ -> x:foldl(max , nil, d_, r_)
MR.sum     = \x,d_,r_ -> x:foldl(add , nil, d_, r_)
MR.sumabs  = \x,d_,r_ -> x:foldl(sabs, 0  , d_, r_)
MR.sumsqr  = \x,d_,r_ -> x:foldl(ssqr, 0  , d_, r_)
MR.product = \x,d_,r_ -> x:foldl(mul , nil, d_, r_)

local all  = \r,x -> bool(land(r, fun(x)))
local any  = \r,x -> bool(lor (r, fun(x)))

function MR.all (x, p, d_, r_)
  assert(is_callable(p), "invalid argument #2 (callable expected)")
  if is_nil(d_) or d_ == 'vec' then -- process as vector with shortcut
    for i=0,x:size()-1 do
      if p(geti0(x,i)) ~= true then return false end
    end
    return true
  else
    pushf(p) ; local r = x:foldl(all, true, d_, r_) ; popf()
    return r
  end
end

function MR.any (x, p, d_, r_)
  assert(is_callable(p), "invalid argument #2 (callable expected)")
  if is_nil(d_) or d_ == 'vec' then -- process as vector with shortcut
    for i=0,x:size()-1 do
      if p(geti0(x,i)) == true then return true end
    end
    return false
  else
    pushf(p) ; local r = x:foldl(any, false, d_, r_) ; popf()
    return r
  end
end

-- special scans --------------------------------------------------------------o

local ssqr_r = \x,r -> r + x*x
local sabs_r = \x,r -> r + abs(x)

-- left accumulation
MR.accmin    = \x,d_,r_ -> x:scanl(min , nil, d_, r_)
MR.accmax    = \x,d_,r_ -> x:scanl(max , nil, d_, r_)
MR.accsum    = \x,d_,r_ -> x:scanl(add , nil, d_, r_)
MR.accsumabs = \x,d_,r_ -> x:scanl(sabs,   0, d_, r_)
MR.accsumsqr = \x,d_,r_ -> x:scanl(ssqr,   0, d_, r_)
MR.accprod   = \x,d_,r_ -> x:scanl(mul , nil, d_, r_)

MR.accumulate = MR.accsum

-- right accumulation
MR.raccmin    = \x,d_,r_ -> x:scanr(min   , nil, d_, r_)
MR.raccmax    = \x,d_,r_ -> x:scanr(max   , nil, d_, r_)
MR.raccsum    = \x,d_,r_ -> x:scanr(add   , nil, d_, r_)
MR.raccsumabs = \x,d_,r_ -> x:scanr(sabs_r,   0, d_, r_)
MR.raccsumsqr = \x,d_,r_ -> x:scanr(ssqr_r,   0, d_, r_)
MR.raccprod   = \x,d_,r_ -> x:scanr(mul   , nil, d_, r_)

-- special filters ------------------------------------------------------------o

local notf = \x -> not fun(x)

function MR.filter_out (x, p, r_)
  assert(is_callable(p), "invalid argument #2 (callable expected)")
  pushf(p) ; local r = x:filter(notf, r_) ; popf()
  return r
end

-- conjugate, transpose -------------------------------------------------------o

MR.conjugate = MR.conj

function MR.transpose (x, r_)
  if is_string(r_) and r_ == 'in' then r_ = x end
  local r = chksizt(r_,x) or matrix(x:tsizes())
  _C.mad_mat_trans(x.data, r.data, x:sizes())         -- transpose
  return r
end

MR.t = MR.transpose -- shortcut

function MC.transpose (x, r_, c_)
  if is_string(r_) and r_ == 'in' then r_ = x end
  if is_boolean(r_) and is_nil(c_) then r_, c_ = nil, r_ end
  local r = chksizt(r_,x) or cmatrix(x:tsizes())
  if c_ == false
  then _C.mad_cmat_trans (x.data, r.data, x:sizes())  -- transpose (no conj.)
  else _C.mad_cmat_ctrans(x.data, r.data, x:sizes())  -- conjugate transpose
  end
  return r
end

MC.t = MC.transpose -- shortcut

function MR.trace (x)
  local r, nr, nc = 0, x:sizes()
  local n = min(nr, nc)
  for i=0,n*nc,nc+1 do r = r + geti0(x,i) end
  return r
end

MR.tr = MR.trace -- shortcut

-- symplectic matrix ----------------------------------------------------------o

function MR.sympinv (x, r_) -- -J M' J
  if is_string(r_) and r_ == 'in' then r_ = x end
  local nr, nc = x:sizes()
  assert(nr == nc and nr % 2 == 0, "invalid argument #1 (2n matrix expected)")
  local r = chksiz(r_,x) or matrix(nr,nr)
  _C.mad_mat_sympinv(x.data, r.data, nr)
  return r
end

function MC.sympinv (x, r_) -- -J M' J
  if is_string(r_) and r_ == 'in' then r_ = x end
  local nr, nc = x:sizes()
  assert(nr == nc and nr % 2 == 0, "invalid argument #1 (2n matrix expected)")
  local r = chksiz(r_,x) or cmatrix(nr,nr)
  _C.mad_cmat_sympinv(x.data, r.data, nr)
  return r
end

function MR.symperr (x, r_) -- M' J M - J
  local nr, nc = x:sizes()
  assert(nr == nc and nr % 2 == 0, "invalid argument #1 (2n matrix expected)")
  if is_nil(r_) then
    return _C.mad_mat_symperr(x.data, nil, nr)
  end
  assert(x.data ~= r_.data, "invalid argument #2 (different matrix expected)")
  chksiz(r_,x)
  return r_, _C.mad_mat_symperr(x.data, r_.data, nr)
end

function MC.symperr (x, r_) -- M' J M - J
  local nr, nc = x:sizes()
  assert(nr == nc and nr % 2 == 0, "invalid argument #1 (2n matrix expected)")
  if is_nil(r_) then
    return _C.mad_cmat_symperr(x.data, nil, nr)
  end
  assert(x.data ~= r_.data, "invalid argument #2 (different matrix expected)")
  chksiz(r_,x)
  return r_, _C.mad_cmat_symperr(x.data, r_.data, nr)
end

-- inner, cross, mixed, outer -------------------------------------------------o

function MR.inner (x, y, r_)
  -- (x:t() * y):tr() without temporary, tr is called only if r_ == 'tr'
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  chksiz(x,y)
  local nr, nc = x:sizes()
  if nc == 1 or is_string(r_) and r_ == 'tr' then
    if is_matrix(y)
    then return _C.mad_vec_dot    (x.data, y.data,       nr*nc)
    else        _C.mad_vec_dotv_r (x.data, y.data, cres, nr*nc) return cres[0]
    end
  else
    assert(is_nil(r_) or r_:nrow() == 1 and r_:ncol() == nc,
           "incompatible matrix sizes")
    local r = r_ or x:same(y[1], 1, nc)
    if is_matrix(y)
    then _C.mad_mat_dot  (x.data, y.data, r.data, nr, nc)
    else _C.mad_mat_dotm (x.data, y.data, r.data, nr, nc)
    end
    return r
  end
end

MR.dot = MR.inner -- shortcut

function MC.inner (x, y, r_)
  -- (x:t() * y):tr() without temporary, tr is called only if r_ == 'tr'
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  chksiz(x,y)
  local nr, nc = x:sizes()
  if nc == 1 or is_string(r_) and r_ == 'tr' then
    if is_matrix(y)
    then return _C.mad_cvec_dotv_r (x.data, y.data, cres, nr*nc)
    else        _C.mad_cvec_dot_r  (x.data, y.data, cres, nr*nc)
    end
    return cres[0]
  else
    assert(is_nil(r_) or r_:nrow() == 1 and r_:ncol() == nc,
           "incompatible matrix sizes")
    local r = r_ or x:same(1, nc)
    if is_matrix(y)
    then _C.mad_cmat_dotm (x.data, y.data, r.data, nr, nc)
    else _C.mad_cmat_dot  (x.data, y.data, r.data, nr, nc)
    end
    return r
  end
end

MC.dot = MC.inner -- shortcut

function MR.outer (x, y, r_)
  -- x * y:t() without temporary
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  local nr, nc = x:nrow(), y:nrow()
  assert(x :ncol() == 1  and y :ncol() == 1 and (is_nil(r_) or
         r_:nrow() == nr and r_:ncol() == nc), "incompatible matrix sizes")
  local r = r_ or x:same(x[1]+y[1], nr, nc)
  for i=0,nr-1 do
  for j=0,nc-1 do set0(r,i,j, geti0(x,i) * conj(geti0(y,j))) end end
  return r
end

function MR.cross (x, y, r_)
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  local nr, nc = x:sizes()
  assert(nr == 3, "invalid matrix sizes")
  local r = chksiz(r_,x,y) or x:same(x[1]+y[1], 3, nc)
  local r0, r1, r2
  -- single cross product
  if nc == 1 then
    r0 = geti0(x,1) * geti0(y,2) - geti0(x,2) * geti0(y,1)
    r1 = geti0(x,2) * geti0(y,0) - geti0(x,0) * geti0(y,2)
    r2 = geti0(x,0) * geti0(y,1) - geti0(x,1) * geti0(y,0)
    seti0(r,0,r0) ; seti0(r,1,r1) ; seti0(r,2,r2)
  else
  -- multiple cross products
    local i0, i1, i2 = 0, nc, 2*nc -- 1st, 2nd and 3rd rows
    for i=0,nc-1 do
      r0 = geti0(x,i1) * geti0(y,i2) - geti0(x,i2) * geti0(y,i1)
      r1 = geti0(x,i2) * geti0(y,i0) - geti0(x,i0) * geti0(y,i2)
      r2 = geti0(x,i0) * geti0(y,i1) - geti0(x,i1) * geti0(y,i0)
      seti0(r,i0,r0) ; seti0(r,i1,r1) ; seti0(r,i2,r2)
      i0, i1, i2 = i0+1, i1+1, i2+1
    end
  end
  return r
end

function MR.mixed (x, y, z, r_)
  -- diag( (uxv)'.w ) without temporary
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  assert(isa_matrix(z), "invalid argument #3 (matrix expected)")
  local nr, nc = x:sizes()
  assert(nr == 3, "invalid matrix sizes")
  assert(nr == y:nrow() and nc == y:ncol() and
         nr == z:nrow() and nc == z:ncol(), "incompatible matrix sizes")
  if nc == 1 then
  -- single mixed product (r_ ignored)
    return conj(geti0(x,1) * geti0(y,2) - geti0(x,2) * geti0(y,1)) * geti0(z,0) +
           conj(geti0(x,2) * geti0(y,0) - geti0(x,0) * geti0(y,2)) * geti0(z,1) +
           conj(geti0(x,0) * geti0(y,1) - geti0(x,1) * geti0(y,0)) * geti0(z,2)
  end
  -- multiple mixed products
  assert(is_nil(r_) or nc == r_:nrow() and 1 == r_:ncol(),
         "incompatible result matrix sizes")
  local r = r_ or x:same(x[1]+y[1]+z[1], 1, nc)
  local i0, i1, i2 = 0, nc, 2*nc -- 1st, 2nd and 3rd rows
  for i=0,nc-1 do
    r.data[i] = conj(geti0(x,i1) * geti0(y,i2) - geti0(x,i2) * geti0(y,i1)) * geti0(z,i0) +
                conj(geti0(x,i2) * geti0(y,i0) - geti0(x,i0) * geti0(y,i2)) * geti0(z,i1) +
                conj(geti0(x,i0) * geti0(y,i1) - geti0(x,i1) * geti0(y,i0)) * geti0(z,i2)
    i0, i1, i2 = i0+1, i1+1, i2+1
  end
  return r
end

-- norm, unit, center, angle (in place) ---------------------------------------o

--[[
Matrix norms:
  L_p,q = M:foldl(\r,x r+abs(x)^p,'row',0):map(\x x^(q/p),'in'):foldl(add)^(1/q)
  L_max = M:foldl(\r,x max(r,abs(x)))
  Frobenius: sqrt( (x:t() * x):tr() )  (consistent with inner product)
  :norm() is the Frobenius norm L_2,2 without temporary
]]

function MR.norm (x)
  return _C.mad_vec_norm(x.data, x:size())
end

function MC.norm (x)
  return _C.mad_cvec_norm(x.data, x:size())
end

function MR.distance (x, y)
  assert(is_matrix(y), "invalid argument #2 (matrix expected)")
  return _C.mad_vec_dist(x.data, y.data, x:size())
end

function MC.distance (x, y)
  assert(is_cmatrix(y), "invalid argument #2 (cmatrix expected)")
  return _C.mad_cvec_dist(x.data, y.data, x:size())
end

function MR.unit (x, r_)
  if is_string(r_) and r_ == 'in' then r_ = x end
  local n = x:norm()
  assert(n ~= 0, "null matrix norm")
  local r = chksiz(r_,x) or x:same()
  _C.mad_vec_muln(x.data, 1/n, r.data, r:size())
  return r
end

function MC.unit (x, r_)
  if is_string(r_) and r_ == 'in' then r_ = x end
  local n = x:norm()
  assert(n ~= 0, "null matrix norm")
  local r = chksiz(r_,x) or x:same()
  _C.mad_cvec_muln(x.data, 1/n, r.data, r:size())
  return r
end

function MR.center (x, d_, r_) -- center vector or matrix row or col on mean
  if is_string(r_) and r_ == 'in' then r_ = x end
  local r = chksiz(r_,x) or x:same()
  if is_nil(d) or d_ == 'vec'
  then _C.mad_vec_center(x.data, r.data, x:size())
  else _C.mad_mat_center(x.data, r.data, x:nrow(), x:ncol(), d_=='col' and 2 or 1)
  end
  return r
end

function MC.center (x, d_, r_) -- center vector or matrix row or col on mean
  if is_string(r_) and r_ == 'in' then r_ = x end
  local r = chksiz(r_,x) or x:same()
  if is_nil(d) or d_ == 'vec'
  then _C.mad_cvec_center(x.data, r.data, x:size())
  else _C.mad_cmat_center(x.data, r.data, x:nrow(), x:ncol(), d_=='col' and 2 or 1)
  end
  return r
end

function MR.angle (x, y, n_)
  local w = x:inner(y)
  local v = x:norm() * y:norm()
  assert(v ~= 0, "null vector norm") -- convention: return pi/2 ?
  local a = acos(w / v) -- [0, pi]
  if n_ and x:mixed(y, n_) < 0 then a = -a end -- [-pi, pi]
  return a
end

-- operators ------------------------------------------------------------------o

MR.__unm = \x,_,r_ -> x:map (   unm, r_) -- note: _ is dummy arg, see Lua specs.
MR.__mod = \x,y,r_ -> x:map2(y, mod, r_)
MR.__pow = \x,y,r_ -> x:map2(y, pow, r_)

--[[ TODO
  mexp, mlog, msqrt, mpow using Padé Approximants
]]

-- equal

local cmp_tol = 0
local cmp_fct = \a,b -> abs(a - b) <= cmp_tol

function MR.__req_cpx (y, x, f_)                  -- cpx == mat
  if is_number(f_) then cmp_tol, f_ = f_, f_ == 0 and eq or cmp_fct end
  local f = f_ or eq
  assert(is_callable(f), "invalid argument #3 (callable expected)")
  for i=1,y:size() do
    if f(x, geti(y,i), i) ~= true then return false end
  end
  return true
end

function MR.__eq (x, y, f_)
  if is_number(f_) then cmp_tol, f_ = f_, f_ == 0 and eq or cmp_fct end
  local f = f_ or eq
  assert(is_callable(f), "invalid argument #3 (callable expected)")
  if is_number(x) then
    for i=1,y:size() do
      if f(x, geti(y,i), i) ~= true then return false end
    end
    return true
  elseif is_scalar(y) then
    for i=1,x:size() do
      if f(geti(x,i), y, i) ~= true then return false end
    end
    return true
  elseif isa_matrix(x) and isa_matrix(y) then
    if x:nrow() ~= y:nrow() or x:ncol() ~= y:ncol() then return false end
    for i=1,x:size() do
      if f(geti(x,i), geti(y,i), i) ~= true then return false end
    end
    return true
  elseif has_method(y, '__req_mat') then
    return y:__req_mat(x, f_)
  end
  error("invalid arguments (unsupported matrix operation)")
end

-- add (see also kadd)

function MR.__radd_cpx (y, x, r)                  -- cpx + mat => cpx + vec
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_vec_addc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MR.__add (x, y, r)
  if is_number(x) then                           -- num + mat => num + vec
    r = chksiz(r,y) or matrix(y:sizes())
    _C.mad_vec_addn(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- mat + num => vec + num
    r = chksiz(r,x) or matrix(x:sizes())
    _C.mad_vec_addn(x.data, y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- mat + cpx => vec + cpx
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_vec_addc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_matrix(y) and is_matrix(x) then      -- mat + mat => vec + vec
    r = chksiz(r,x,y) or matrix(x:sizes())
    _C.mad_vec_add(x.data, y.data, r.data, r:size()) return r
  elseif is_cmatrix(y) then                      -- mat + cmat => vec + cvec
    r = chksiz(r,x,y) or cmatrix(x:sizes())
    _C.mad_cvec_addv(y.data, x.data, r.data, r:size()) return r
  elseif has_method(y, '__radd_mat') then        -- mat + ?
    return y:__radd_mat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

function MC.__radd_cpx (y, x, r)                  -- cpx + cmat => cpx + cvec
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_cvec_addc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MC.__add (x, y, r)
  if is_number(x) then                           -- num + cmat => num + cvec
    r = chksiz(r,y) or cmatrix(y:sizes())
    _C.mad_cvec_addn(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- cmat + num => cvec + num
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_cvec_addn(x.data, y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- cmat + cpx => cvec + cpx
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_cvec_addc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_matrix(y) then                       -- cmat + mat => cvec + vec
    r = chksiz(r,x,y) or cmatrix(x:sizes())
    _C.mad_cvec_addv(x.data, y.data, r.data, r:size()) return r
  elseif is_cmatrix(y) and is_cmatrix(x) then    -- cmat + cmat => cvec + cvec
    r = chksiz(r,x,y) or cmatrix(x:sizes())
    _C.mad_cvec_add(x.data, y.data, r.data, r:size()) return r
  elseif has_method(y, '__radd_cmat') then       -- cmat + ?
    return y:__radd_cmat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

-- sub (see also kadd)

function MR.__rsub_cpx (y, x, r)                  -- cpx - mat => cpx - vec
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_vec_subc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MR.__sub (x, y, r)
  if is_number(x) then                           -- num - mat => num - vec
    r = chksiz(r,y) or matrix(y:sizes())
    _C.mad_vec_subn(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- mat - num => vec + -num
    r = chksiz(r,x) or matrix(x:sizes())
    _C.mad_vec_addn(x.data, -y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- mat - cpx => vec + -cpx
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_vec_addc_r(x.data, -y.re, -y.im, r.data, r:size()) return r
  elseif is_matrix(y) and is_matrix(x) then      -- mat - mat => vec - vec
    r = chksiz(r,x,y) or matrix(x:sizes())
    _C.mad_vec_sub(x.data, y.data, r.data, r:size()) return r
  elseif is_cmatrix(y) then                      -- mat - cmat => vec - cvec
    r = chksiz(r,x,y) or cmatrix(x:sizes())
    _C.mad_cvec_subv(y.data, x.data, r.data, r:size()) return r
  elseif has_method(y, '__rsub_mat') then        -- mat - ?
    return y:__rsub_mat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

function MC.__rsub_cpx (y, x, r)                  -- cpx - cmat => cpx - cvec
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_cvec_subc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MC.__sub (x, y, r)
  if is_number(x) then                           -- num - cmat => num - cvec
    r = chksiz(r,y) or cmatrix(y:sizes())
    _C.mad_cvec_subn(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- cmat - num => cvec + -num
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_cvec_addn(x.data, -y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- cmat - cpx => cvec + -cpx
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_cvec_addc_r(x.data, -y.re, -y.im, r.data, r:size()) return r
  elseif is_matrix(y) then                       -- cmat - mat => cvec - vec
    r = chksiz(r,x,y) or cmatrix(x:sizes())
    _C.mad_cvec_subv(x.data, y.data, r.data, r:size()) return r
  elseif is_cmatrix(y) and is_cmatrix(x) then    -- cmat - cmat => cvec - cvec
    r = chksiz(r,x,y) or cmatrix(x:sizes())
    _C.mad_cvec_sub(x.data, y.data, r.data, r:size()) return r
  elseif has_method(y, '__rsub_cmat') then       -- cmat - ?
    return y:__rsub_cmat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

-- mul

function MR.__rmul_cpx (y, x, r)                  -- cpx * mat => cpx * vec
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_vec_mulc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MR.__mul (x, y, r)
  if is_number(x) then                           -- num * mat => num * vec
    r = chksiz(r,y) or matrix(y:sizes())
    _C.mad_vec_muln(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- mat * num => vec * num
    r = chksiz(r,x) or matrix(x:sizes())
    _C.mad_vec_muln(x.data, y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- mat * cpx => vec * cpx
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_vec_mulc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_matrix(y) and is_matrix(x) then      -- mat * mat
    r = chksizm(r,x,y) or matrix(x:nrow(), y:ncol())
    _C.mad_mat_mul(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol()) return r
  elseif is_cmatrix(y) then                      -- mat * cmat
    r = chksizm(r,x,y) or cmatrix(x:nrow(), y:ncol())
    _C.mad_mat_mulm(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol()) return r
  elseif has_method(y, '__rmul_mat') then        -- mat * ?
    return y:__rmul_mat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

function MC.__rmul_cpx (y, x, r)                  -- cpx * cmat => cpx * cvec
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_cvec_mulc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MC.__mul (x, y, r)
  if is_number(x) then                           -- num * cmat => num * cvec
    r = chksiz(r,y) or cmatrix(y:sizes())
    _C.mad_cvec_muln(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- cmat * num => cvec * num
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_cvec_muln(x.data, y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- cmat * cpx => cvec * cpx
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_cvec_mulc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_matrix(y) then                       -- cmat * mat
    r = chksizm(r,x,y) or cmatrix(x:nrow(), y:ncol())
    _C.mad_cmat_mulm(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol()) return r
  elseif is_cmatrix(y) and is_cmatrix(x) then    -- cmat * cmat
    r = chksizm(r,x,y) or cmatrix(x:nrow(), y:ncol())
    _C.mad_cmat_mul(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol()) return r
  elseif has_method(y, '__rmul_cmat') then       -- cmat * ?
    return y:__rmul_cmat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

-- div

function MR.__rdiv_cpx (y, x, r, rcond_)          -- cpx / mat
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_mat_invc_r (y.data, x.re, x.im, r.data, y:nrow(), y:ncol(), rcond_ or -1) return r
end

function MR.__div (x, y, r, rcond_)
  if is_number(x) then                           -- num / mat
    r = chksiz(r,y) or matrix(y:sizes())
    _C.mad_mat_invn (y.data, x, r.data, y:nrow(), y:ncol(), rcond_ or -1) return r
  elseif is_number(y) then                       -- mat / num => vec / num
    r = chksiz(r,x) or matrix(x:sizes())
    _C.mad_vec_muln(x.data, 1/y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- mat / cpx => vec / cpx
    r = chksiz(r,x) or cmatrix(x:sizes()) ; y = 1/y
    _C.mad_vec_mulc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_matrix(y) and is_matrix(x) then      -- mat / mat => vec / vec
    r = chksizd(r,x,y) or matrix(x:nrow(), y:nrow())
    _C.mad_mat_div(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol(), rcond_ or -1) return r
  elseif is_cmatrix(y) then                      -- mat / cmat => vec / cvec
    r = chksizd(r,x,y) or cmatrix(x:nrow(), y:nrow())
    _C.mad_mat_divm(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol(), rcond_ or -1) return r
  elseif has_method(y, '__rdiv_mat') then        -- mat / ?
    return y:__rdiv_mat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

function MC.__rdiv_cpx (y, x, r, rcond_)         -- cpx / cmat
  r = chksiz(r,y) or cmatrix(y:sizes())
  _C.mad_cmat_invc_r(y.data, x.re, x.im, r.data, y:nrow(), y:ncol(), rcond_ or -1)
  return r
end

function MC.__div (x, y, r, rcond_)
  if is_number(x) then                           -- num / cmat => num / cvec
    r = chksiz(r,y) or cmatrix(y:sizes())
    _C.mad_cmat_invn(y.data, x, r.data, y:nrow(), y:ncol(), rcond_ or -1) return r
  elseif is_number(y) then                       -- cmat / num => cvec / num
    r = chksiz(r,x) or cmatrix(x:sizes())
    _C.mad_cvec_muln(x.data, 1/y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- cmat / cpx => cvec / cpx
    r = chksiz(r,x) or cmatrix(x:sizes()) ; y = 1/y
    _C.mad_cvec_mulc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_matrix(y) then                       -- cmat / mat => cvec / vec
    r = chksizd(r,x,y) or cmatrix(x:nrow(), y:nrow())
    _C.mad_cmat_divm(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol(), rcond_ or -1) return r
  elseif is_cmatrix(y) and is_cmatrix(x) then    -- cmat / cmat => cvec / cvec
    r = chksizd(r,x,y) or cmatrix(x:nrow(), y:nrow())
    _C.mad_cmat_div(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol(), rcond_ or -1) return r
  elseif has_method(y, '__rdiv_cmat') then       -- cmat / ?
    return y:__rdiv_cmat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

-- kadd

local kmax = 20
local kr   = ffi.new(      'double  [?]', kmax)
local kc   = ffi.new(      'complex [?]', kmax)
local krd  = ffi.new('const double* [?]', kmax)
local kcd  = ffi.new('const complex*[?]', kmax)

function MR.kadd (a, x, r)
  local n = #x
  assert(n <= kmax, "too many matrices")
  assert(is_matrix(x[n]), "incompatible matrix type")
  for i=1,n-1 do
    assert(is_matrix(x[i]), "incompatible matrix type")
    assert(x[i]:nrow() == x[i+1]:nrow() and
           x[i]:ncol() == x[i+1]:ncol(), "incompatible matrix size")
    kr[i-1], krd[i-1] = a[i], x[i].data
  end
  kr[n-1], krd[n-1] = a[n], x[n].data
  r = chksiz(r,x[1]) or matrix(x[1]:sizes())
  _C.mad_vec_kadd(n, kr, krd, r.data, r:size()) return r
end

function MC.kadd (a, x, r)
  local n = #x
  assert(n <= kmax, "too many matrices")
  assert(is_cmatrix(x[n]), "incompatible matrix type")
  for i=1,n-1 do
    assert(is_cmatrix(x[i]), "incompatible matrix type")
    assert(x[i]:nrow() == x[i+1]:nrow() and
           x[i]:ncol() == x[i+1]:ncol(), "incompatible matrix size")
    kc[i-1], kcd[i-1] = a[i], x[i].data
  end
  kc[n-1], kcd[n-1] = a[n], x[n].data
  r = chksiz(r,x[1]) or cmatrix(x[1]:sizes())
  _C.mad_cvec_kadd(n, kc, kcd, r.data, r:size()) return r
end

-- tmul

function MR.tmul (x, y, r)
  if is_matrix(y) and is_matrix(x) then         -- mat' * mat
    r = chksiztm(r,x,y) or matrix(x:ncol(), y:ncol())
    _C.mad_mat_tmul(x.data, y.data, r.data, r:nrow(), r:ncol(), x:nrow()) return r
  elseif is_cmatrix(y) then                     -- mat' * cmat
    r = chksiztm(r,x,y) or cmatrix(x:ncol(), y:ncol())
    _C.mad_mat_tmulm(x.data, y.data, r.data, r:nrow(), r:ncol(), x:nrow()) return r
  elseif has_method(y, '__rtmul_mat') then      -- mat' * ?
    return y:__rtmul_mat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

function MC.tmul (x, y, r)
  if is_matrix(y) then                          -- cmat' * mat
    r = chksiztm(r,x,y) or cmatrix(x:ncol(), y:ncol())
    _C.mad_cmat_tmulm(x.data, y.data, r.data, r:nrow(), r:ncol(), x:nrow()) return r
  elseif is_cmatrix(y) then                     -- cmat' * cmat
    r = chksiztm(r,x,y) or cmatrix(x:ncol(), y:ncol())
    _C.mad_cmat_tmul(x.data, y.data, r.data, r:nrow(), r:ncol(), x:nrow()) return r
  elseif has_method(y, '__rtmul_cmat') then     -- cmat' * ?
    return y:__rtmul_cmat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

-- mult

function MR.mult (x, y, r)
  if is_matrix(y) and is_matrix(x) then         -- mat * mat'
    r = chksizmt(r,x,y) or matrix(x:nrow(), y:nrow())
    _C.mad_mat_mult(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol()) return r
  elseif is_cmatrix(y) then                     -- mat * cmat'
    r = chksizmt(r,x,y) or cmatrix(x:nrow(), y:nrow())
    _C.mad_mat_multm(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol()) return r
  elseif has_method(y, '__rmult_mat') then      -- mat * ?'
    return y:__rmult_mat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

function MC.mult (x, y, r)
  if is_matrix(y) then                          -- cmat * mat'
    r = chksizmt(r,x,y) or cmatrix(x:nrow(), y:nrow())
    _C.mad_cmat_multm(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol()) return r
  elseif is_cmatrix(y) then                     -- cmat * cmat'
    r = chksizmt(r,x,y) or cmatrix(x:nrow(), y:nrow())
    _C.mad_cmat_mult(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol()) return r
  elseif has_method(y, '__rmult_cmat') then     -- cmat * ?'
    return y:__rmult_cmat(x, r)
  end
  error("invalid arguments (unsupported matrix operation)")
end

-- element wise mul and div

function MR.emul (x, y, r_)
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  local r = chksiz(r_,x,y) or x:same(y[1])
  if is_matrix(y)
  then _C.mad_vec_mul  (x.data, y.data, r.data, r:size())
  else _C.mad_cvec_mulv(y.data, x.data, r.data, r:size())
  end
  return r
end

function MC.emul (x, y, r_)
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  local r = chksiz(r_,x,y) or cmatrix(x:sizes())
  if is_matrix(y)
  then _C.mad_cvec_mulv(x.data, y.data, r.data, r:size())
  else _C.mad_cvec_mul (x.data, y.data, r.data, r:size())
  end
  return r
end

function MR.ediv (x, y, r_)
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  local r = chksiz(r_,x,y) or x:same(y[1])
  if is_matrix(y)
  then _C.mad_vec_div (x.data, y.data, r.data, r:size())
  else _C.mad_vec_divv(x.data, y.data, r.data, r:size())
  end
  return r
end

function MC.ediv (x, y, r_)
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  local r = chksiz(r_,x,y) or cmatrix(x:sizes())
  if is_matrix(y)
  then _C.mad_cvec_divv(x.data, y.data, r.data, r:size())
  else _C.mad_cvec_div (x.data, y.data, r.data, r:size())
  end
  return r
end

-- solver, det, svd, eigenvalue, eigenvector ----------------------------------o

function MR.solve (a, b, rcond_)
  return b:t():div(a:t(), nil, rcond_):t()
end

function MR.svd (x)
  local nr, nc = x:sizes()
  local rs, ru, rv = matrix(min(nr,nc),1), matrix(nr,nr), matrix(nc,nc)
  local info = _C.mad_mat_svd(x.data, ru.data, rs.data, rv.data, nr, nc)
  return ru, rs, rv, info
end

function MC.svd (x)
  local nr, nc = x:sizes()
  local rs, ru, rv = matrix(min(nr,nc),1), cmatrix(nr,nr), cmatrix(nc,nc)
  local info = _C.mad_cmat_svd(x.data, ru.data, rs.data, rv.data, nr, nc)
  return ru, rs, rv, info
end

function MR.det (x)
  local nr, nc = x:sizes()
  assert(nr == nc, "matrix must be square")
  local info = _C.mad_mat_det(x.data, res, nr)
  return res[0], info
end

function MC.det (x)
  local nr, nc = x:sizes()
  assert(nr == nc, "matrix must be square")
  local info = _C.mad_cmat_det(x.data, cres, nr)
  return cres[0], info
end

function MR.eigen (x)
  local nr, nc = x:sizes()
  assert(nr == nc, "matrix must be square")
  local w, vl, vr = cmatrix(nr, 1), matrix(nr,nr), matrix(nr,nr)
  local info = _C.mad_mat_eigen(x.data, w.data, vl.data, vr.data, nr)
  return w, vl, vr, info
end

function MC.eigen (x)
  local nr, nc = x:sizes()
  assert(nr == nc, "matrix must be square")
  local w, vl, vr = cmatrix(nr, 1), cmatrix(nr,nr), cmatrix(nr,nr)
  local info = _C.mad_cmat_eigen(x.data, w.data, vl.data, vr.data, nr)
  return w, vl, vr, info
end

-- FFT, convolution, correlation, covariance ----------------------------------o

function MR.fft (x, r_)
  local nr, nc = x:sizes()
  local r = chksiz(r_, x) or cmatrix(nr,nc)
  if nr == 1 or nc == 1
  then _C.mad_vec_fft(x.data, r.data, x:size())  -- 1D FFT
  else _C.mad_mat_fft(x.data, r.data, x:sizes()) -- 2D FFT
  end
  return r
end

function MC.fft (x, r_)
  local nr, nc = x:sizes()
  local r = chksiz(r_, x) or cmatrix(nr,nc)
  if nr == 1 or nc == 1
  then _C.mad_cvec_fft(x.data, r.data, x:size())  -- 1D FFT
  else _C.mad_cmat_fft(x.data, r.data, x:sizes()) -- 2D FFT
  end
  return r
end

MR.ifft = \ error("invalid argument #1 (cmatrix expected)")

function MC.ifft (x, r_)
  local nr, nc = x:sizes()
  local r = chksiz(r_, x) or cmatrix(nr,nc)
  if nr == 1 or nc == 1
  then _C.mad_cvec_ifft(x.data, r.data, x:size())  -- 1D FFT
  else _C.mad_cmat_ifft(x.data, r.data, x:sizes()) -- 2D FFT
  end
  return r
end

function MR.rfft (x, r_)
  local nr, nc, r = x:sizes()
  if nr == 1 or nc == 1 then -- 1D FFT
    nr, nc = floor(nr/2+1), floor(nc/2+1)
    r = r_ or cmatrix(nr,nc)
    assert(nr == r:nrow() and nc == r:ncol(), "incompatible matrix sizes")
    _C.mad_vec_rfft(x.data, r.data, x:size())
  else                       -- 2D FFT
    nc = floor(nc/2+1)
    r = r_ or cmatrix(nr,nc)
    assert(nr == r:nrow() and nc == r:ncol(), "incompatible matrix sizes")
    _C.mad_mat_rfft(x.data, r.data, x:sizes())
  end
  return r
end

MC.rfft  = \ error("invalid argument #1 (matrix expected)")
MR.irfft = \ error("invalid argument #1 (cmatrix expected)")

function MC.irfft (x, r)
  assert(is_matrix(r), "invalid argument #2 (matrix expected)")
  local nr, nc = r:sizes()
  if nr == 1 or nc == 1 then -- 1D FFT
    nr, nc = floor(nr/2+1), floor(nc/2+1)
    assert(nr == x:nrow() and nc == x:ncol(), "incompatible matrix sizes")
    _C.mad_cvec_irfft(x.data, r.data, r:size())
  else                       -- 2D FFT
    nc = floor(nc/2+1)
    assert(nr == x:nrow() and nc == x:ncol(), "incompatible matrix sizes")
    _C.mad_cmat_irfft(x.data, r.data, r:sizes())
  end
  return r
end

 -- convolution theorem
function MR.conv (x, y, r_)
  local r = r_ or x:same()
  local xf = x:rfft()
  if x.data == y.data
  then return xf:emul(xf      ,xf):irfft(r)
  else return xf:emul(y:rfft(),xf):irfft(r)
  end
end

function MC.conv (x, y, r_)
  local r = r_ or x:same()
  local xf = x:fft()
  if x.data == y.data
  then return xf:emul(xf     ,xf):ifft(r)
  else return xf:emul(y:fft(),xf):ifft(r)
  end
end

 -- correlation theorem
function MR.corr (x, y, r_)
  local r = r_ or x:same()
  local xf = x:rfft()
  if x.data == y.data
  then return xf:emul(xf      :conj(    ),xf):irfft(r)
  else return xf:emul(y:rfft():conj('in'),xf):irfft(r)
  end
end

function MC.corr (x, y, r_)
  local r = r_ or x:same()
  local xf = x:fft()
  if x.data == y.data
  then return xf:emul(xf     :conj(    ),xf):ifft(r)
  else return xf:emul(y:fft():conj('in'),xf):ifft(r)
  end
end

function MR.covar (x, y, d_, r_)
  local xc = x:center(x:same(), d_)
  if x.data == y.data
  then return xc:corr(xc                    , r_)
  else return xc:corr(y:center(y:same(), d_), r_)
  end
end

-- NFFT -----------------------------------------------------------------------o

--[[
  MAD.option.format="%.4g"
  m = MAD.vector{{1,2,3,4,5,6,7,8,9,10}}
  p = MAD.vector{{0,1,2,3,4,-5,-4,-3,-2,-1}}/#m       -- nodes
  =( m:nfft(p) - m:fft() ):norm()
  -- print 9.1471106157092e-14
  =( m:nfft(p):infft() - m ):norm()
  -- print 5.4711990133586e-14
  m = MAD.vector{{10,9,8,7,6,5,4,3,2,1}}
  =( m:nfft(p) - m:fft() ):norm()
  -- print 9.6563745514607e-14
  =( m:nfft(p):infft() - m ):norm()
  -- print 5.4711990133586e-14
]]
function MR.nfft (x, p_, r_)
  if is_cmatrix(p_) and is_nil(r_) then p_, r_ = nil, p_ end -- right shift
  local r = r_ or x:same(0i)
  assert(is_cmatrix(r), "invalid argument #3 (cmatrix expected)")
  local nr, nc = (p_ and chksiz(x,p_) or x):sizes()
  if nr == 1 or nc == 1
  then _C.mad_vec_nfft(x.data, p_ and p_.data, r.data, nr*nc , r:size()) -- 1D NFFT
  else _C.mad_mat_nfft(x.data, p_ and p_.data, r.data, nr, nc, r:size()) -- 2D NFFT
  end
  return r
end

function MC.nfft (x, p_, r_)
  if is_cmatrix(p_) and is_nil(r_) then p_, r_ = nil, p_ end -- right shift
  local r = r_ or x:same(0i)
  assert(is_cmatrix(r), "invalid argument #3 (cmatrix expected)")
  local nr, nc = (p_ and chksiz(x,p_) or x):sizes()
  if nr == 1 or nc == 1
  then _C.mad_cvec_nfft(x.data, p_ and p_.data, r.data, nr*nc , r:size()) -- 1D NFFT
  else _C.mad_cmat_nfft(x.data, p_ and p_.data, r.data, nr, nc, r:size()) -- 2D NFFT
  end
  return r
end

MR.infft = \ error("invalid argument #1 (cmatrix expected)")

function MC.infft (x, p_, r_)
  if is_cmatrix(p_) and is_nil(r_) then p_, r_ = nil, p_ end -- right shift
  local r = p_ and (chksiz(r_, p_) or p_:same(0i)) or x:same(0i)
  assert(is_cmatrix(r), "invalid argument #3 (cmatrix expected)")
  local nr, nc = r:sizes()
  if nr == 1 or nc == 1
  then _C.mad_cvec_infft(x.data, p_ and p_.data, r.data, nr*nc , x:size()) -- 1D NFFT
  else _C.mad_cmat_infft(x.data, p_ and p_.data, r.data, nr, nc, x:size()) -- 2D NFFT
  end
  return r
end

-- concatenation, conversion --------------------------------------------------o

MR.__len = MR.size

function MR.__concat (x, y, d_, r_)
  assert(isa_matrix(x), "invalid argument #1 (matrix expected)")
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  local nrx, ncx = x:sizes()
  local nry, ncy = y:sizes()
  local r
  if is_nil(d_) or d_ == 'vec' or d_ == 'col' then -- concat columns (vectical)
    local nr, nc = nrx + nry, ncx
    assert(ncx == ncy and (is_nil(r_) or nr == r_:nrow() and nc == r_:ncol()),
           "incompatible matrix sizes")
    local r = r_ or x:same(x[1]+y[1],nr,nc)
    local nx, ny = nrx * nc, nry * nc
    for i=0,nx-1 do seti0(r,i   , geti0(x,i)) end
    for i=0,ny-1 do seti0(r,i+nx, geti0(y,i)) end
    if d_ == 'vec' then r:reshape(nr*nc) end
    return r
  elseif d_ == 'row' then                          -- concat rows (horizontal)
    local nr, nc = nrx, ncx + ncy
    assert(nrx == nry and (is_nil(r_) or nr == r_:nrow() and nc == r_:ncol()),
           "incompatible matrix sizes")
    local r = r_ or x:same(x[1]+y[1],nr,nc)
    for i=0,nr-1 do
      for j=0,ncx-1 do set0(r,i,j    , get0(x,i,j)) end
      for j=0,ncy-1 do set0(r,i,j+ncx, get0(y,i,j)) end
    end
    return r
  end
  error("invalid argument #3 (string 'vec', row' or 'col' expected)")
end

function MR.__tostring (x, sep_, lsep_)
  local nr, nc = x:sizes()
  local r, c = table.new(nr,0), table.new(nc,0)
  for i=0,nr-1 do
    for j=0,nc-1 do
      c[j+1] = tostring(get0(x,i,j))
    end
    r[i+1] = table.concat(c, sep_ or ' ')
  end
  return table.concat(r, lsep_ or '\n')
end

function MR.__totable (x, r_)
  assert(is_nil(r_) or is_table(r_), "invalid argument #2 (table expected)")
  local nr, nc, r = x:sizes()
  if nc == 1 then
    r = r_ or table.new(nr*nc,0)
    for i=0,nr*nc-1 do r[i+1] = geti0(x,i) end
  else
    r = r_ or table.new(nr,0)
    for i=0,nr-1 do
      local c = r[i+1] or table.new(nc,0)
      assert(is_table(c), "invalid argument #2 (table of tables expected)")
      for j=0,nc-1 do c[j+1] = get0(x,i,j) end
      r[i+1] = c
    end
  end
  return r
end

local function linspace (start, stop_, size_)
  assert(is_scalar(start) and abs(start) < inf,
         "invalid argument #1 (finite scalar expected)")
  if is_nil(stop_) then start, stop_ = 0, start end
  assert(is_scalar(stop_) and abs(stop_) < inf,
         "invalid argument #2 (finite scalar expected)")
  if is_nil(size_) then size_ = 100 else size_ = math.ceil(size_) end
  assert(is_number(size_) and size_ > 0,
         "invalid argument #3 (positive number expected)")
  local v = (is_complex(start) or is_complex(stop_)) and cvector(size_) or vector(size_)
  local step = size_ > 1 and (stop_-start)/(size_-1) or 0
  for i=0,size_-1 do seti0(v, i, start+step*i) end
  return v
end

local function logspace (start, stop_, size_)
  assert(is_number(start) and start > 0 and start < inf or
         is_complex(start) and abs(start) < inf,
        "invalid argument #1 (positive finite number expected)")
  if is_nil(stop_) then start, stop_ = 1, start end
  assert(is_number(stop_) and stop_ > 0 and stop_ < inf or
         is_complex(stop_) and abs(stop_) < inf,
         "invalid argument #2 (positive finite number expected)")
  if is_nil(size_) then size_ = 100 else size_ = math.ceil(size_) end
  assert(is_number(size_) and size_ > 0,
         "invalid argument #3 (positive number expected)")
  local v = (is_complex(start) or is_complex(stop_)) and cvector(size_) or vector(size_)
  local logstart, logstop = log(start), log(stop_)
  local logstep = size_ > 1 and (logstop-logstart)/(size_-1) or 0
  for i=0,size_-1 do seti0(v, i, exp(logstart+logstep*i)) end
  return v
end

local fact_ = vector(171) -- cache

local function fact (n)
  assert(n >= 0, "invalid argument #1 (positive integer expected)")
  return n <= 170 and geti0(fact_, n) or inf
end

do -- fill on load
  local a = 1
  for i=1,170 do a = a*i ; seti0(fact_, i, a) end
  seti0(fact_, 0, 1)
end

-- metamethods ----------------------------------------------------------------o

MR.  add, MR.  sub, MR.  mul, MR.  div, MR.  mod, MR.  pow =
MR.__add, MR.__sub, MR.__mul, MR.__div, MR.__mod, MR.__pow

MR.  unm = \x,r_  -> MR.__unm(x,nil,r_)

MC.  add, MC.  sub, MC.  mul, MC.  div =
MC.__add, MC.__sub, MC.__mul, MC.__div

MR.  eq, MR.length, MR.  concat =
MR.__eq, MR.__len , MR.__concat

local function iter (x, i)
  if i < x:size() then return i+1, geti0(x, i) end
end

MR.__ipairs = \s -> (iter, s, 0)

function MR.__index (s, i)
  if is_number(i) then return s:geti(i) else return MR[i] end
end

function MC.__index (s, i)
  if is_number(i) then return s:geti(i) else return MC[i] end
end

function MR.__newindex (s, i, x)
  if is_number(i)
  then s:seti(i, x)
  else error("invalid matrix member '"..tostring(i).."'")
  end
end

-- MR -> MC -------------------------------------------------------------------o

for k,v in pairs(MR) do
  if is_nil(MC[k]) then MC[k] = v end
end

-- only MR

local MROT = require 'madl_matrot' -- rotation matrices (in place)

for k,v in pairs(MROT) do
  assert(is_nil(MR[k]), "duplicated matrix method detected (unexpected)")
  MR[k] = v
end

-- env ------------------------------------------------------------------------o

MAD.gmath.fact = fact

MAD.typeid.is_vector  = is_vector
MAD.typeid.is_matrix  = is_matrix
MAD.typeid.is_cvector = is_cvector
MAD.typeid.is_cmatrix = is_cmatrix
MAD.typeid.isa_vector = isa_vector
MAD.typeid.isa_matrix = isa_matrix

-- metatables -----------------------------------------------------------------o

ffi.metatype( matrix_ctor, MR)
ffi.metatype(cmatrix_ctor, MC)

-- end ------------------------------------------------------------------------o
return {
  vector   = vector,
  matrix   = matrix,
  cvector  = cvector,
  cmatrix  = cmatrix,
  linspace = linspace,
  logspace = logspace,

  __help   = __help,
  __check  = { vector=MR, matrix=MR, cvector=MC, cmatrix=MC },
}
