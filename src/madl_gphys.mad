--[=[
 o-----------------------------------------------------------------------------o
 |
 | Generic physics module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide useful function for physics computation.
  - For now expect 4D, 5D or 6D systems.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local vector, cvector, matrix, monomial, damap, cdamap,
      trace, warn, option, typeid                                in MAD
local assertf, errorf, printf, num2str, tbl2str, setkeys, tblcat,
      mockfile, openfile                                         in MAD.utility
local lbool                                                      in MAD.gfunc
local twopi                                                      in MAD.constant
local min, max, abs, sqrt, exp, log, sin, cos, tan, atan2,
      sinh, cosh, real, imag, cplx, fact, rangle, hypot          in MAD.gmath

local is_nil, is_boolean, is_number, is_positive, is_nonzero, is_integer,
      is_natural, is_even, is_odd, is_string, is_table, is_mappable,
      is_matrix, is_cmatrix, isa_matrix, is_vector, is_cvector,
      is_damap, is_cdamap, isa_damap, wrestrict                  in MAD.typeid

local assert, table, type =
      assert, table, type

local r4  = 1..4
local I4  = matrix(4):eye()
local I6  = matrix(6):eye()
local I56 = matrix(6):set(5,5,1):set(6,6,1)
local S4  = matrix(4):symp() -- [4x4] symplectic matrix S
local S6  = matrix(6):symp() -- [6x6] symplectic matrix S

              -- i,j,k,l, i,j,k,l, i,j,k,l, i,j,k,l,
local blkidx = { 3,1,1,3, 3,3,1,1 } --, 5,1,1,5, 5,3,3,5 } -- keep order!

-- implementation -------------------------------------------------------------o

local gphys = {
  -- tolerances
  tol = {
    dpt_tol  = 1e-12,
    pha_tol  = 1e-12,
    eig_tol  = 1e-12,
    nrm_tol  = 1e-12,
    symp_tol = 1e-12,
    cplg_tol = 1e-14,
    ofun_tol = 1e-14,
    stab_tol = 1e-16, -- below eps!
  },

  -- optical functions names (index -> name)
  ofname = {
    'alfa11', 'beta11', 'gama11', 'mu1', 'dx', 'dpx', 'Dx', 'Dpx',
    'alfa22', 'beta22', 'gama22', 'mu2', 'dy', 'dpy', 'Dy', 'Dpy',
    'alfa33', 'beta33', 'gama33', 'mu3',
  },

  -- optical functions names with coupling (index -> name)
  ofcname = {
    'alfa11', 'beta11', 'gama11', 'alfa12', 'beta12', 'gama12', 'alfa13', 'beta13', 'gama13', 'mu1', 'dx', 'dpx', 'Dx', 'Dpx',
    'alfa21', 'beta21', 'gama21', 'alfa22', 'beta22', 'gama22', 'alfa23', 'beta23', 'gama23', 'mu2', 'dy', 'dpy', 'Dy', 'Dpy',
    'alfa31', 'beta31', 'gama31', 'alfa32', 'beta32', 'gama32', 'alfa33', 'beta33', 'gama33', 'mu3',
  },

  -- optical functions names with chromatic functions (index -> name)
  ofhname = {
    'alfa11', 'beta11', 'gama11', 'mu1', 'dmu1', 'dx', 'dpx', 'Dx', 'Dpx', 'ddx', 'ddpx', 'wx', 'phix',
    'alfa22', 'beta22', 'gama22', 'mu2', 'dmu2', 'dy', 'dpy', 'Dy', 'Dpy', 'ddy', 'ddpy', 'wy', 'phiy',
    'alfa33', 'beta33', 'gama33', 'mu3', 'dmu3',
  },

  -- optical functions names with coupling and chromatic functions (index -> name)
  ofchname = {
    'alfa11', 'beta11', 'gama11', 'alfa12', 'beta12', 'gama12', 'alfa13', 'beta13', 'gama13', 'mu1', 'dmu1', 'dx', 'dpx', 'Dx', 'Dpx', 'ddx', 'ddpx', 'wx', 'phix',
    'alfa21', 'beta21', 'gama21', 'alfa22', 'beta22', 'gama22', 'alfa23', 'beta23', 'gama23', 'mu2', 'dmu2', 'dy', 'dpy', 'Dy', 'Dpy', 'ddy', 'ddpy', 'wy', 'phiy',
    'alfa31', 'beta31', 'gama31', 'alfa32', 'beta32', 'gama32', 'alfa33', 'beta33', 'gama33', 'mu3', 'dmu3',
  },

  -- optical functions names converter (e.g. from MAD-X), see also beta0
  ofcvtname = {
    -- MAD-X names
    alfx='alfa11', betx='beta11', mux='mu1', dmux='dmu1',
    alfy='alfa22', bety='beta22', muy='mu2', dmuy='dmu2',
    alfz='alfa33', betz='beta33', muz='mu3', dmuz='dmu3', -- not MAD-X

    -- other shortcut
    alfa1='alfa11', beta1='beta11',
    alfa2='alfa22', beta2='beta22',
    alfa3='alfa33', beta3='beta33',

    -- tunes, chromas
    qx='q1', dqx='dq1',
    qy='q2', dqy='dq2',
    qz='q3', dqz='dq3',
  },
}

local phystol = gphys.tol

-- particles ------------------------------------------------------------------o

local val = \a -> is_number(a) and a or nil

function gphys.par2vec (X, V_)
  local V = V_ or vector(6)
  if is_number(X) then return V:fill(X) end
  V[1], V[2] = val(X.x) or X[1] or 0, val(X.px) or X[2] or 0
  V[3], V[4] = val(X.y) or X[3] or 0, val(X.py) or X[4] or 0
  V[5], V[6] = val(X.t) or X[5] or 0, val(X.pt) or X[6] or 0
  return V
end

function gphys.vec2par (V, X_)
  local X = X_ or table.new(0,8)
  X.x, X.px = V[1], V[2]
  X.y, X.py = V[3], V[4]
  X.t, X.pt = V[5], V[6]
  return X
end

-- mtables --------------------------------------------------------------------o

 -- TODO: move to mtable or track or (new) lost

function gphys.mchklost (mtbl, ...)
  assert(typeid.is_mtable(mtbl), "invalid argument #1 (mtable expected)")
  return mtbl.lost == 0 and mtbl or nil, ...
end

local kil = { ksl  =-1,
              k0l  = 1, k1l  = 2, k2l  = 3, k3l = 4, k4l = 5, k5l = 6, k6l = 7,
              k0sl = 1, k1sl = 2, k2sl = 3, k3sl= 4, k4sl= 5, k5sl= 6, k6sl= 7 }

 -- TODO: move to mtable or sequence

function gphys.melmcol (mtbl, cols)
  assert(typeid.is_mtable(mtbl), "invalid argument #1 (mtable expected)")
  assert(is_mappable(cols)     , "invalid argument #2 (mappable expected)")
  assert(typeid.is_sequence(mtbl.__seq), "no attached sequence found")
  assert(not is_nil (mtbl.eidx ), "no elements index column 'eidx' found")
  assert(is_table(mtbl.eidx ) or is_vector(mtbl.eidx),
                "invalid index column 'eidx', (table or vector expected)")

  for k, v in pairs(cols) do
    if is_integer(k) then k = v end
    if not kil[v] then -- standard attribute
      mtbl:addcol(k, \ir =>
        local idx = mtbl.eidx[ir]
        return is_integer(idx) and mtbl.__seq[idx][v] or 0 end)

    elseif kil[v] > 0 then -- add local and integrated strengths
      local knol, kidx = string.sub(v,1,-2), kil[v]
      local knsl = string.sub(knol, -1) ~= 's' and 'knl' or 'ksl'
      mtbl:addcol(k, \ir =>
        local idx = mtbl.eidx[ir]
        if not is_integer(idx) then return 0 end -- implicit drift
        local elm = mtbl.__seq[idx]
        return (elm[knol] or 0) * elm.l + ((elm[knsl] or {})[kidx] or 0) end)
    elseif kil[v] < 0 then -- add special strengths (e.g. solenoid)
      mtbl:addcol(k, \ir =>
        local idx = mtbl.eidx[ir]
        if not is_integer(idx) then return 0 end -- implicit drift
        local elm = mtbl.__seq[idx]
        return (elm.ks or 0) * elm.l + (elm.ksi or 0) end)
    else errorf("unkown element to column generator for '%s'", tostring(v))
    end
  end

  return mtbl
end

-- mflows ---------------------------------------------------------------------o

 -- TODO: move to track

-- particles/damaps status rank: Xset/Mset/Aset/stable/unstable/singular/lost
local mrnk = {Xset=1, Mset=1, Aset=1, stable=1, unstable=2, singular=3, lost=4}
gphys.mrnk = mrnk

-- compare particles/damaps by rank then id
function gphys.mcmp (ma, mb)
  local ra, rb = mrnk[ma.status], mrnk[ma.status]
  assert(ra and rb, "unknown status detected")
  return ra == rb and ma.id < mb.id or ra < rb
end

-- sort particles/damaps, adjust npar
function gphys.msort (mflw, cmp_)
  assert(typeid.is_dynmflow(mflw),"invalid argument #1 (dynamic mflow expected)")

  mflw.npar = #mflw
  if mflw.npar > 1 then table.sort(mflw, cmp_ or gphys.mcmp) end

  -- adjust npar to the number of trackable particles
  for i=mflw.npar,1,-1 do
    if mrnk[mflw[i].status] <= mrnk.stable then mflw.npar=i break end
  end
  return mflw
end

-- checkers -------------------------------------------------------------------o

local function chksysiz (V, W)
  if not is_nil(V) then
    assert(is_matrix(V), "invalid argument #1 (matrix expected)")
    assert((V.nrow == 6 or V.nrow == 4) and V.nrow == V.ncol,
           "invalid sizes (4D/6D matrix expected)")
    if W then
      assert(is_cvector(W), "invalid argument #2 (cvector expected)")
      assert(W.nrow == V.nrow, "invalid size (4D/6D cvector expected)")
    end
  end

  return V, W
end

-- check if system is eigen using eigtol tolerance
-- check M*Vi = Wi*Vi

local eig_tol in phystol

local function is_eigsys (M, V, W, eigtol_)
  local tol = eigtol_ or eig_tol
  assert(is_positive(tol), "invalid argument #4 (positive number expected)")

  for i=2,#W,2 do
    local dW = W[i-1]-W[i]:conj()
    if not dW:eq(0, tol) then
      warn("invalid eigenvalues #%d (conjugate pair deviates by %s)",
           i-1, num2str(dW:abs()))
      return false
    end

    local Vi = cplx(V:getcol(i-1), V:getcol(i))
    local Vc = Vi:conj()
    local dV1, dV2 = M*Vi-W[i-1]*Vi, M*Vc-W[i]*Vc
    if not (dV1:eq(0, tol) and dV2:eq(0, tol)) then
      warn("invalid eigensystem #%d (M*V deviates from W*V by %s)",
           i-1, num2str(max(dV1:norm(),dV2:norm())))
      return false
    end
  end

  return true
end

gphys.is_eigsys = \V,W,M,tol -> is_eigsys(chksysiz(M,W),chksysiz(V,W), W, tol)

-- check for delta pt in one-turn map using dptol tolerance

local dpt_tol in phystol

local function has_dpt (m, dptol_)
  local tol = dptol_ or dpt_tol
  assert(is_positive(tol), "invalid argument #2 (positive number expected)")

  if is_damap(m) then
    if #m < 6 then return false end
    local i, pt = 2, m.pt
    if abs(pt:get(7) - 1) <= tol then
      while i < 7 and abs(pt:get(i)) <= tol do i = i+1 end
    end
    return i ~= 7
  elseif is_matrix(m) then
    if min(m:sizes()) < 6 then return false end
    local i = 1
    if abs(m:get(6,6) - 1) <= tol then
      while i < 6 and abs(m:get(6,i)) <= tol do i = i+1 end
    end
    return i ~= 6
  else error("invalid argument #1 (matrix or damap expected)") end
end

gphys.has_dpt = has_dpt

-- check for coupling blocks in one-turn map using cplg_tol

local cplg_tol in phystol

local function has_cpl (M, cpltol_)
  local tol = cpltol_ or cplg_tol
  assert(is_positive(tol), "invalid argument #2 (positive number expected)")

  -- check only transverse coupling
  if blkidx[1] > M.nrow then return false end
  local i,j,k,l = blkidx[1], blkidx[2], blkidx[3], blkidx[4]
  local v = max(abs(M:get(i  ,j)), abs(M:get(i  ,j+1)),
                abs(M:get(i+1,j)), abs(M:get(i+1,j+1)),
                abs(M:get(k  ,l)), abs(M:get(k  ,l+1)),
                abs(M:get(k+1,l)), abs(M:get(k+1,l+1)))
  return v >= tol
end

gphys.has_cpl = \M, tol -> has_cpl(chksysiz(M), tol)

-- helpers --------------------------------------------------------------------o

-- conversion between energy deviation and momentum or beta
-- dp = (P-P0)/P0, pt = (E-E0)/P0c
-- (1+dp)^2 = 1 + 2pt/beta + pt^2

local function dp2pt (dp, beta0)
  local _beta0 = 1/beta0
  return dp ~= 0 and sqrt((1+dp)^2 + (_beta0^2-1)) - _beta0 or 0
end

gphys.dp2pt = dp2pt

local function pt2dp (pt, beta0)
  return pt ~= 0 and sqrt(1 + 2*pt/beta0 + pt^2) - 1 or 0
end

gphys.pt2dp = pt2dp

local function pt2beta (pt, beta0)
  local _beta0 = 1/beta0
  return pt ~= 0 and (1 + (2*_beta0)*pt + pt^2) / (_beta0 + pt) or 0
end

gphys.pt2beta = pt2beta

-- eigensystem ----------------------------------------------------------------o

-- retrieve eigenvalues from pairs of eigenvectors

local function get_eigval (M, V, W)
  -- get eigenvalues Wi from eigenvectors Vi: M*Vi = Wi*Vi
  for i=2,V.nrow,2 do
    local v = cplx(V:getcol(i-1), V:getcol(i))
    W[i-1] = M:get(i-1,i-1) + M:get(i-1,i)*v:get(i,i-1)/v:get(i-1,i-1)
    W[i  ] = W[i-1]:conj()
  end
  return W
end

gphys.get_eigval = \M, V, W -> get_eigval(chksysiz(M), chksysiz(V, W))

-- stability ------------------------------------------------------------------o

-- check stability, enforce orthogonality of planes if needed

local stab_tol in phystol

local function make_stable (M)
  -- check trace stability
  for i=2,M.nrow,2 do
    local tr = abs(M:get(i-1,i-1)+M:get(i,i))
    if tr > 2 then warn("Tr(M)>2 for plane %d, unstable motion!", i/2) end
  end

  if option.dontstab then return end

  -- stabilize the one-turn-map M to avoid unstable eigenvectors in case of
  -- perfectly equal transverse tunes and no coupling. stab_tol is lower than
  -- eps, hence it will remove only numerical noise as the one-turn-map is
  -- supposed to be around the identity where eps represents both a relative
  -- and an absolute numerical error.
  for idx=1,#blkidx,4 do
    if blkidx[idx] > M.nrow then break end
    local i,j,k,l = blkidx[idx], blkidx[idx+1], blkidx[idx+2], blkidx[idx+3]
    local mx = max(abs(M:get(i  ,j)), abs(M:get(i  ,j+1)),
                   abs(M:get(i+1,j)), abs(M:get(i+1,j+1)),
                   abs(M:get(k  ,l)), abs(M:get(k  ,l+1)),
                   abs(M:get(k+1,l)), abs(M:get(k+1,l+1)))
    if mx < stab_tol then
      M:set(i  ,j,0) ; M:set(i  ,j+1,0)
      M:set(i+1,j,0) ; M:set(i+1,j+1,0)
      M:set(k  ,l,0) ; M:set(k  ,l+1,0)
      M:set(k+1,l,0) ; M:set(k+1,l+1,0)
      break
    end
  end
end

gphys.make_stable = \M -> make_stable(chksysiz(M))

-- symplectification ----------------------------------------------------------o

-- symplectifiy one-turn map M if needed
-- Algorithm described in the doctoral thesis of Liam Healey.

local symp_tol in phystol

local function make_symp (M)
  local serr = M:symperr()
  if serr <= symp_tol then return end

  trace(0, "symplectic deviation: %s", num2str(serr))

  if option.dontsymp then return end

  local n, rnk, err = max(M:sizes())
  local I, A, V = M:same():eye()

  V, rnk = (I-M):div(I+M)
  if rnk == n then
    A = (V:bar()-V)/2
    V, rnk = (I+A):div(I-A)
    if rnk == n then V:copy(M) end
  end

  if rnk < n
  then warn("symplectification failed (singular matrix, left unchanged).")
  else trace(0, "symplectified deviation: %s", num2str(M:symperr()))
  end
end

gphys.make_symp = \M -> make_symp(chksysiz(M))

-- closed form, eigen systems -------------------------------------------------o

-- closed form of M in place or in A_ (see also normal_a0)

local function closed_form (M, A_)
  local nr, nc = M:sizes()

  if nr == 4 and nc == 4 then return end
  local pt = nc >= 6 and 6 or 5

  -- close dispersion as a function of pt (multiply by beta for function of dp)
  local D4 = M:getsub(r4,pt)
  local R4 = M:getsub(r4,r4)
  local C4, rnk = (I4-R4):solve(D4) ;
  (A_ or M):setsub(r4,pt,C4)
end

gphys.closed_form = \M, A_ -> closed_form(chksysiz(M), chksysiz(A_))

-- order in place eigenvectors and eigenvalues by planes (x,px), (y,py) and
-- (t,pt), detect by horizontal, vertical, longitudinal order (MAD-NG order)

local function order_eigen (V, W)  -- default
  for i=1,V.nrow-3,2 do
    local mv, k = 0

    for j=i,V.nrow-1,2 do
      local pv = V:get(i,j  )^2 + V:get(i+1,j  )^2 + -- real part
                 V:get(i,j+1)^2 + V:get(i+1,j+1)^2   -- imag part
      if pv > mv then mv, k = pv, j end
    end

    if i ~= k then
      -- swap eigenvectors pairs (i,i+1) with (k,k+1)
      local col = {1,2,3,4}
      col[i], col[i+1] = k, k+1
      V:swpcol(col)
      -- swap eigenvalues pairs (i,i+1) with (k,k+1)
      W[i], W[i+1], W[k], W[k+1] = W[k], W[k+1], W[i], W[i+1]
    end
  end
end

gphys.order_eigen = \V, W -> order_eigen(chksysiz(V,W))

-- order in place eigenvectors and eigenvalues by planes (x,px), (y,py) and
-- (t,pt), detect by vertical, horizontal, longitudinal order (MAD-X order)

local idx_p = {3,1,5} -- vertical, horizontal, longitudinal
local idx_l = {[1]=3,[3]=1,[4]=5,[6]=3,[8]=1}

local function order_eigen_madx (V, W)  -- for comparison
  local get, set, n, idx, sel = V.get, V.set, min(V.nrow,6), {0,0}, {}

  -- collect columns with largest components for each plane
  for k=1,n/2-1 do
    local i, mv = idx_p[k], 0
    for j=1,n-1,2 do
      if not sel[j] then -- not yet selected
        local pv = get(V,i,j  )^2 + get(V,i+1,j  )^2 + -- real part
                   get(V,i,j+1)^2 + get(V,i+1,j+1)^2   -- imag part
        if pv > mv then mv, idx[k], sel[j] = pv, j, true end
      end
    end
  end
  -- last plane: remaining index
  idx[n/2] = idx_l[idx[1]+idx[2]]
  -- swap indexes: vertical, horizontal => horizontal, vertical
  idx[1], idx[2] = idx[2], idx[1]

  -- reorder eigenvectors and eigenvalues
  local Vc, Wc = V:copy(), W:copy()
  for kk,j in ipairs(idx) do
    local k = 2*kk-1
    if k ~= j then
      for i=1,n do
        set(V,i,k  , get(Vc,i,j  ))
        set(V,i,k+1, get(Vc,i,j+1))
      end
      W[k], W[k+1] = Wc[j], Wc[j+1]
    end
  end
end

gphys.order_eigen_madx = \V, W -> order_eigen_madx(chksysiz(V,W))

-- normalize in place eigenvectors such that [x,px]=1, [y,py]=1 and [t,pt]=1

local function norml_eigen (A)
  for j=2,A.ncol,2 do
    local pb = 0           -- poisson bracket (columns pair)
    for i=2,A.nrow,2 do
      pb = pb + A:get(i-1,j-1) * A:get(i,j) - A:get(i-1,j) * A:get(i,j-1)
    end
    local spb = sqrt(abs(pb))
    assertf(spb > 0, "invalid eigenvectors pair %d (unexpected [v,w]=0)", j)
    for i=1,A.nrow do      -- normalize plane (columns)
      A:set(i,j-1, A:get(i,j-1) * (spb / pb))
      A:set(i,j  , A:get(i,j  ) /  spb      )
    end
  end
end

gphys.norml_eigen = \A -> norml_eigen(chksysiz(A))

-- rephase in place the eigenvectors to obtain the Courant-Snyder form
-- i.e. A(1,2)=0 and mu1>0, A(3,4)=0 and mu2>0, A(5,6)=0 and mu3>0

local function phase_eigen (A)
  local nr, nc = A:sizes()
  local P = matrix(nc,nr):eye()

  for i=2,min(nr,nc),2 do
    local a11, a12 = A:get(i-1,i-1), A:get(i-1,i) -- mu = atan2(a12, a11) / 2pi
    local d = hypot(a11,a12)
!   if a11 < 0 then d = -d end  -- add pi (sometimes needed for comparison with PTC...)
    assertf(d > 1e-14, "invalid eigenvectors (unexpected denom |% -.16e|>0)", d)
    a11, a12 = a11/d, a12/d
    P:set(i-1,i-1,  a11) -- P = [ a11/d  -a12/d ] = [ cos a  -sin a ]
    P:set(i-1,i  , -a12) --     [ a12/d   a11/d ]   [ sin a   cos a ] = rot(a)
    P:set(i  ,i-1,  a12) -- a = angle(a11, a12)
    P:set(i  ,i  ,  a11)
  end

-- A*P=[ a11  a12 ][ a11/d  -a12/d ]=[      d (>0)                0          ]
--     [ a21  a22 ][ a12/d   a11/d ] [ (a11a21+a12a22)/d  (-a12a21+a11a22)/d ]

  return A:mul(P,A) -- A = A*P (rotate planes of A => a12=a34=0)
end

gphys.phase_eigen = \A -> phase_eigen(chksysiz(A))

-- linear normal form ---------------------------------------------------------o

-- check one-turn map linear normalisation
-- check that N = (A^-1 * R * A) [= Abar * R * A] contains only rotations

local nrm_tol in phystol

function gphys.is_normal1 (A, R, nrmtol_)
  local tol = nrmtol_ or nrm_tol
  local get, set, n = A.get, A.set, A.nrow

  -- use 'true' inverse in case of strong symplectic deviation
  local N = A:inv() * R * A

  for i = 1,n-1,2 do
    local a1 = atan2( get(N,i,i+1), get(N,i  ,i  ))
    local a2 = atan2(-get(N,i+1,i), get(N,i+1,i+1))
    if abs(a1-a2) > tol then
      warn("invalid linear normal form #%d (deviates from a pure rotation by %s)",
           i, num2str(a1-a2))
      R:print('R') ; N:print('N')
      return false
    end
    N:setsub(i..i+1, i..i+1, 0)
  end
  if not N:eq(0, tol) then
    warn("invalid linear normal form N (contains coupling terms)")
    R:print('R') ; N:print('N')
    return false
  end

  return true
end

-- linear normal form in matrix A from one-turn-map R in place ----------------o

function gphys.normal1 (R, nocheck_) -- matrix combining normal_a0 and normal_a1
  chksysiz(R)

  local fmt

  local nr, nc = R:sizes()

  -- detect rank of the system
  local dim = min(nr,nc)
  local rnk = has_dpt(R) and 6 or 4
  local R6

  -- switch to 4D
  if rnk == 4 and dim > 4 then R6, R = R, R:getsub(r4,r4) end

  -- stabilise R if needed
  make_stable(R)

  -- symplectifiy R if needed
  make_symp(R)

  -- get eigenvalues (W) and eigenvectors (Vl, Vr) of R
  local W, _, A, info = R:eigen()

  -- check that system is eigen
  if not nocheck_ then gphys.is_eigsys(A, W, R) end

  -- normalize eigen system
  norml_eigen(A)

  -- order eigenvalues and eigenvectors by planes
  order_eigen(A, W)

  -- rephase eigen vectors to Courant-Snyder form
  phase_eigen(A)

  -- check that system is a linear normal form
  if not nocheck_ then gphys.is_normal1(A, R) end

  -- back to 6D, close dispersion (5D)
  if rnk == 4 and dim > 4 then
    A, R = I6:copy():setsub(r4,r4,A), R6
    closed_form(R, A)
  end

  return A, rnk, info
end

-- linear and non-linear normal form ------------------------------------------o

local nf_id = {}
local is_nf = \a -> a.__id == nf_id

local nf_knd = {all='all', ham='gnf', gnf='gnf', anh='anh'}

local function nfana (nf, k_, m_)
  if is_damap(k_) and is_nil(m_) then m_, k_ = k_ end -- right shift

  assert(is_nf (nf), "invalid argument #1 (normal form expected)")
  assert(is_nil(k_) or nf_knd[k_]  , "invalid argument #2 (kind expected)" )
  assert(is_nil(m_) or is_damap(m_), "invalid argument #3 (damap expected)")

  local knd = nf_knd[k_ or 'all']

  local a, c, ci, nv, nn, lam, t_op in nf
  local ham, gnf, anh = {}, {}, {}
  local mono = monomial(nn)

  -- GNF and HAM
  if knd == 'gnf' or knd == 'all' then
    local g = (ci*a*c):factor_map(-1):fld2vec()
    g:cutord(-2, g) -- keep only orders 3..

    local i, v = 0
    while true do
      i, v = g:cycle(i, mono)
      if i == 0 then break; end
      local ms = mono:tostring()
      local s, p = 0, 1
      for j=2,nv,2 do
        s = s +       abs(mono[j-1]-mono[j])
        p = p * lam[j-1]^(mono[j-1]-mono[j])
      end
      gnf[#gnf+1], gnf[ms] = ms, v                    -- gnf terms
      ham[#ham+1], ham[ms] = ms, v * (1-p)            -- ham terms
    end
  end

  -- ANH and HAM (?)
  if knd == 'anh' or knd == 'all' then
    for o=2,#t_op do
      for n=1,nv,2 do
        local k, i, v = t_op[o][n], 0
        while true do
          i, v = k:cycle(i, mono)
          if i == 0 then break; end
          local ms = mono:tostring()
          local v = k:get(mono)
          anh[#anh+1], anh[ms] = ms, -v:imag()/twopi -- anh terms
        end
      end
    end
  end

  nf.ham, nf.gnf, nf.anh = ham, gnf, anh
  return nf
end

-- normal form init -------------------------------------------------

local nosave = \nf -> nf

local function nfsave (nf, a, nam)
  assert(is_nf(nf), "invalid argument #1 (normal form expected)")

  local v = is_string(a) and nf[a] or a
  assert(isa_damap(v) or isa_tpsa(v) or isa_matrix(v),
         "invalid argument #2 (damap, tpsa or matrix expected)")

  local id = option.fortid
  v:write("fort_n."..id, nam or is_string(a) and a or nil)
  option.fortid = id+1
  return nf
end

local function normal_init (m, urdt_)
  assert(is_damap(m), "invalid argument #1 (damap expected)")
  assert(is_nil(urdt_) or is_table(urdt_), "invalid argument #2 (table expected)")

  local sav  = option.fortid > 0 and nfsave or nosave
  local ndpt = not has_dpt(m)
  local ndt  = ndpt and m.t ~= nil

  -- 0 1 2  3 4    5  6  nv       nn
  -- | x px y py | t  pt | params |  6D  (nv==6 and ndpt==false -> nt=0, npt=0)
  -- | x px y py | t  pt | params |  56D (nv==6 and ndpt==true  -> nt=5, npt=6)
  -- | x px y py | pt    | params |  5D  (nv==5 and ndpt==true  -> nt=0, npt=5)
  -- | x px y py |       | params |  4D  (nv==4 and ndpt==true  -> nt=0, npt=0)

  local nf = {
   __id     = nf_id,                        -- is_nf
    sav     = sav,                          -- dump (c)damap/matrix in fort_n.N
    analyse = nfana,                        -- compute rdt, fill ham, gnf, anh

    nn   = m.__td.nn,                    -- #(variables + parameters)
    nv   = m.__td.nv,                    -- #(variables)
    nt   = ndt and 5 or 0,               -- index of t  when coasting
    npt  = ndt and 6 or ndpt and 5 or 0, -- index of pt when constant
    urdt = urdt_,                        -- user defined rdt (optional)
    x0   = m:get0(),                     -- backup orbit
    m0   = m:copy(),                     -- backup one-turn map
    m_n  = m:copy(),                     -- normalized map
    a    = nil,                          -- normalizing map (output)
    a0   = nil,                          -- map to go to fix point
    a1   = nil,                          -- map to go to CS basis
    c    = nil,                          -- map to go to phasor basis
  }

-- debug pnf
-- io.write("nv=", nf.nv, ", np=", nf.nn-nf.nv, ", nt=", nf.nt, ", npt=", nf.npt,
--          ", fortid=", option.fortid, "\n")

  return nf
end

-- closed form (fix point) = a0^-1 * m * a0 -----------------------------------o

local function normal_a0 (nf, ord_)
  if is_damap(nf) then nf = normal_init(nf) end
  assert(is_nf(nf), "invalid argument #1 (normal form expected)")

-- io.write("a0 in\n") -- debug pnf

  if option.fortid ~= 0 then io.stderr:write("closing form a0\n") end

  local nn, nv, nt, npt, m_n in nf
  local v, x, ord = m_n:copy(), m_n:same(), ord_ or 1

-- if nf.npt > 0 then -- debug pnf
--   v:print("V", true)
-- end

  nn = nv
  if npt ~= 0 then nv = 4 end                       -- process t,pt as params

  for i=1,nv    do v[i]:set(i+1,1,-1) end           -- sub id to vars
  for i=nv+1,nn do v[i]:setvar(0,i)                 -- set t,pt params to id
                   x[i]:setvar(0,i)   end
  if nt ~= 0 then  x.t :clear()       end           -- 56D coasting beam

--v:cutord(ord+1, v)                                -- keep 1st order (or more)

  local a0 = v^-1 * x                               -- closing form (all orders)

  if nt ~= 0 then                                   -- 56D coasting beam
    if (a0.pt - x.pt:setvar(0,npt)):isnul() then
      a0.t:setvar(0,nt)
    else
      local t1, m1 = v.x:same(), v.x:same()
      for i=2,nv,2 do                               -- make t symplectic
        x[i], x[i-1] = -a0[i-1], a0[i]              -- swap
        v[i], v[i-1] = x[i]:deriv(npt), x[i-1]:deriv(npt)
        t1 = t1 - m1:setvar(0,i  ) * v[i  ]         -- 1st order
                - m1:setvar(0,i-1) * v[i-1]         -- 1st order
                - 0.5*(x[i-1]*v[i] - x[i]*v[i-1])   -- 2nd order
      end
      a0.t = t1                                     -- will make t symplectic
      if a0.t:isnul() then a0.t:setvar(0,nt) end
    end
  end

  if npt ~= 0 and m_n.pt:isnul() then               -- 5D coasting beam
    m_n.pt:setvar(0,npt)                            --    with implicit pt (!)
  end

  for i=1,nv do a0[i]:set(i+1,1,1) end              -- add id to vars

  m_n:set0(0)                                       -- clear orbit

  nf.m_n = a0^-1 * m_n * a0                         -- go to fix point
  nf.a0  = a0

-- if nf.npt > 0 then -- debug pnf
--   nf.a0    :print("A0"   , true);
--  (nf.a0^-1):print("A0^-1", true);
--   nf.m_n   :print("M_n"  , true);
-- end

-- io.write("a0 out\n") -- debug pnf
end

gphys.normal_a0 = normal_a0 -- export, can be used alone

-- linear normal form = a1^-1 * a0^-1 * m * a0 * a1 ---------------------------o

local function normal_a1 (nf)
  assert(is_nf(nf), "invalid argument #1 (normal form expected)")

-- io.write("a1 in\n") -- debug pnf

  if option.fortid ~= 0 then io.stderr:write("linear normal form a1\n") end

  local nn, nv, npt, m_n, fid, fil in nf
  local M = m_n:get1()            -- retrieve one-turn map

  -- remove parameters
  local rg = npt ~= 0 and 1..4 or 1..6
  M = M:getsub(rg,rg)             -- reduce M to rank

  make_stable(M)                  -- stabilise    M if needed
  make_symp  (M)                  -- symplectifiy M if needed

  local W, _, A, info = M:eigen() -- eigenvalues (W) and right eigenvectors (A)

  norml_eigen(A)                  -- normalize eigen system
  order_eigen(A, W)               -- order eigval and eigvec by planes
  phase_eigen(A)                  -- rephase eigen vectors to CS form

  local a1 = m_n:same():eye():set1(A)

  nf.m_n = a1^-1 * m_n * a1       -- go to Courant-Snyder basis
  nf.a1  = a1

-- if nf.npt > 0 then -- debug pnf
--   nf.a1 :print("A1" , true)
--   nf.m_n:print("M_n", true)
-- end

-- io.write("a1 out\n") -- debug pnf
end

-- phasor basis = c^-1 * (a1^-1 * (a0^-1 * m * a0) * a1) * c --------o

local c_val = {[1]={0.5, 0.5; -0.5i, 0.5i}, [-1]={1, 1i; 1, -1i}}
local c_pbv = {[1]=-2i,                     [-1]=0.5i}

local function phasor (nf, inv_)
  local v, r = c_val[inv_ or 1], c_pbv[inv_ or 1]

  assert(is_nf(nf)  , "invalid argument #1 (normal form expected)")
  assert(is_table(v), "invalid argument #2 (-1 or 1 expected)")

  local npt, m_n in nf
  local c, rk = m_n:same(0i):eye(), npt ~= 0 and 4 or 6

  for i=2,rk,2 do -- 2,4,6,..
    c[i-1]:clear():set(i, 0, v[1]):set(i+1, 0, v[2]) -- c[1]
    c[i  ]:clear():set(i, 0, v[3]):set(i+1, 0, v[4]) -- c[2]
  end

  return c, r
end

gphys.phasor = phasor

local function normal_c (nf)
  assert(is_nf(nf), "invalid argument #1 (normal form expected)")

-- io.write("c in\n") -- debug pnf

  if option.fortid ~= 0 then io.stderr:write("phasor basis c\n") end

  local c , cr  = phasor(nf,  1) -- get phasor
  local ci, cir = phasor(nf, -1) -- get phasor (inverse)

  nf.m_n = ci * nf.m_n * c       -- go to phasor (phase-action) basis
  nf.c , nf.cr  = c , cr
  nf.ci, nf.cir = ci, cir

-- if nf.npt > 0 then -- debug pnf
--   nf.c  :print("C"  , true)
--   nf.m_n:print("M_n", true)
-- end

-- io.write("c out\n") -- debug pnf
end

-- full normal form (PTC) -----------------------

function gphys.normal (m, urdt_)
  assert(is_damap(m), "invalid argument #1 (damap expected)")

  -- already a normalizing form
  if m.status == 'Aset' then return nil end

  -- linear normal form -------------------------

  local nf =
  normal_init(m, urdt_)            -- one-turn map
  normal_a0(nf)                    -- closed form (fix point)
  normal_a1(nf)                    -- linear normal form (Courant-Snyder basis)

  -- stop here for order 1
  if min(m:maxord(), m:gtrunc()) == 1 then
    nf.a = nf.a0 * nf.a1
    return nf
  end

  -- phasor basis -------------------------------

  normal_c(nf)                     -- resonance basis (phase-action basis)

  -- non-linear normal form ---------------------

  local fid = option.fortid ~= 0

  if fid then io.stderr:write("non-linear normal form\n") end

  -- prepare factored Lie representation of A and N
  local nn, nv, npt, m_n, urdt, fil in nf
  local rk   = npt ~= 0 and 4 or 6
  local f_op, t_op = {m_n:same()}, {m_n:same()}
  local id   = m_n:same():eye()
  local mono = monomial(nn)

  -- linear map (only) in phasors basis
  local r1 = m_n:getord(1)                                                      ; nf:sav(r1,"r1")
  local r1i = r1^-1                                                             ; nf:sav(r1i,"r1^-1")

  -- retrieve the eigentunes (lambda)
  local lam = cvector(nv)
  for i=1,#lam do lam[i] = r1i[i]:get(i+1) end

  -- nonlinear iterations
  for n=2,m_n:maxord() do
    if fid then
      io.stderr:write("****************************************\n")
      io.stderr:write("Order ",n,", fid=", option.fortid,"\n")
    end

    -- project remaining orders on resonance basis
    local n_n = (m_n * r1i):lieexppb(t_op, -1):getord(n)                        ; nf:sav(n_n,"n_n @"..n)

-- n_n:write(io.stderr, "n_n("..n..")", true)

    -- use directly the vector field
    local f_n, t_n = n_n:same(), n_n:same() -- fun, ker

    for k=1,nv do
      if fid then
        io.stderr:write("****************************************\n")
        io.stderr:write("Field ",k,", fid=", option.fortid, "\n")
      end
      local i, v = 0

      -- select/reject resonances
      while true do
        i, v = n_n[k]:cycle(i, mono)
        if i == 0 then break; end

        local ms = mono:tostring()
        local mt = mono:totable()

        mt[k] = mt[k]-1
        local s = 0
        for j=2,rk,2 do               -- check for resonances
          s = s + abs(mt[j]-mt[j-1])
        end

        if s ~= 0 and urdt then       -- check for user resonances
          for _,r in ipairs(urdt) do  -- {{3,0,0}, {1,2,0}, {0,3,0}, etc.}
            local rs = 0
            for j=2,rk,2 do
              rs = rs + abs(abs(mt[j]-mt[j-1]) - r[j/2])
            end
            if rs == 0 then s = 0 ; break end -- keep user resonances
          end
        end

        if s ~= 0 then
          local p = 1
          for j=1,rk do p = p * lam[j]^mt[j] end
          v = v / (1-p)
          if abs(1-p) < 1e-12 then
            io.stderr:write("Warn: trying to kill ", ms, " with p = ", p:tostring(), "\n")
          end
          f_n[k]:set(mono, 1, v)
        else
          t_n[k]:set(mono, 1, v)
        end
      end -- cycle
    end -- for k

    -- save vector fields
    f_op[n], t_op[n] = f_n, t_n                                                 ; nf:sav(f_n,"f_n @"..n):sav(t_n,"t_n @"..n)
    if n == m_n:maxord() then break end

    m_n = f_n:exppb((-f_n):exppb(id) * m_n)                                     ; nf:sav(m_n, "m_n("..n..")")
  end -- for n

  -- the normalizing map A
  nf.lieex = id:lieexppb(f_op)                                                  ; nf:sav"lieex"

  nf.a = nf.a0 * nf.a1 * nf.c * nf.lieex * nf.ci                                ; nf:sav"a"
--nf.a:real():copy(m):set0(nf.x0).status = 'Aset'

--  if fid then io.stderr:write("end of normal form\n") end

  -- hook the results
  nf.lam, nf.m_n, nf.f_op, nf.t_op =
     lam,    m_n,    f_op,    t_op

  return nf
end

-- full normal form (NG) -------------------

function gphys.normal_ng (m, urdt_)
  assert(is_damap(m), "invalid argument #1 (damap expected)")

  -- already a normalizing form
  if m.status == 'Aset' then return m end

  -- linear normal form -------------------------

  if option.fortid ~= 0 then io.stderr:write("linear normal form\n") end

  local nf = normal_init(m, urdt_) ; nf:sav(nf.m_n,"m1(--)")  -- one-turn map
  normal_a0(nf)                    ; nf:sav(nf.m_n,"m1(a1)")  -- closed form
                                       :sav(nf.a0 ,"a1"    )
  normal_a1(nf)                    ; nf:sav(nf.m_n,"m1(a2)")  -- linear normal form
                                       :sav(nf.a1 ,"a2"    )

  -- stop here for order 1
  if min(m:maxord(), m:gtrunc()) == 1 then
    nf.a = nf.a0 * nf.a1
    nf.a:copy(m):set0(nf.x0).status = 'Aset'
    return m, nf
  end

  -- phasor basis -------------------------------

  if option.fortid ~= 0 then io.stderr:write("phasor basis\n") end

  normal_c(nf)                    ; nf:sav(nf.m_n,"m1(ri)") -- resonance basis
                                      :sav(nf.ci ,"ri"    )

  -- non-linear normal form ---------------------

  if option.fortid ~= 0 then io.stderr:write("non-linear normal form\n") end

  -- prepare factored Lie representation of A and N
  local nv, npt, m_n, urdt, fil in nf
  local rk            = npt ~= 0 and 4 or 6
  local mono          = monomial(nv)
  local id            = m_n:same():eye()
  local f_op, t_op    = {m_n:same()}, {m_n:same()}
  local ham, gnf, anh = {}, {}, {}

  -- linear map (only) in phasors basis
  local r1 = m_n:getord(1)
  local r1i = r1^-1              !; nf:sav(r1,"r1"):sav(r1i,"r1^-1")

  -- retrieve the eigentunes (lambda)
  local lam = cvector(nv)
  for i=1,nv do lam[i] = r1i[i]:get(i+1) end lam:write(fil, "tunes")

  -- cdamap for pseudo hamiltonian (need mo+1)
  local mo, np, po in m_n.__td

  io.stderr:write("nv=", nv, ", np=", np, ", rk=", rk, ", npt=", npt, ", #vn=", #m.__vn, "\n")

  if npt == 5 then nv, np = nv-1, np+1 end

  io.stderr:write("nv=", nv, ", np=", np, ", rk=", rk, ", npt=", npt, ", #vn=", #m.__vn, "\n")

  local tc = cdamap{nv=nv, mo=mo+1, np=np, po=po, vn=m.__vn} -- tmp for conv.
                    -- rk              np+nv-rk

  -- nonlinear iterations
  for n=2,m_n:maxord() do
    fil:write("****************************************\n")
    fil:write("Order ",n,", fid=", nf.fid,"\n")

    -- project remaining orders on resonance basis
    local n_n = (m_n * r1i):lieexppb(t_op, -1):getord(n) ; nf:sav(n_n,"n_n @"..n)

    -- compute pseudo-hamiltonian
    local g_n = n_n:convert(tc):fld2vec()                !; g_n:print("g_n @ "..n)
    local f_pb, t_pb = g_n:same(), g_n:same()
    local i, v = 0

    -- select/reject resonances
    while true do
      i, v = g_n:cycle(i, mono)
      if i == 0 then break; end

      local ms = mono:tostring()

      local s = 0
      for j=2,rk,2 do                   -- check for resonances
        s = s + abs(mono[j]-mono[j-1])
      end
      if s ~= 0 and urdt then           -- check for user resonances
        for _,r in ipairs(urdt) do      -- {{3,0,0}, {1,2,0}, {0,3,0}, etc.}
          local rs = 0
          for j=2,rk,2 do
            rs = rs + abs(abs(mono[j]-mono[j-1]) - r[j/2])
          end
          if rs == 0 then s = 0 ; break end -- keep user resonances
        end
      end

      ham[#ham+1], ham[ms] = ms, v                                            -- ham terms

      if s ~= 0 then
        local p = 1
        for j=2,rk,2 do
          p = p * lam[j-1]^(mono[j]-mono[j-1])
        end
        v = v / (1-p)
        if abs(1-p) < 1e-12 then
          io.stderr:write("Warn: killing [", ms, "] with p = ", p:tostring(), "\n")
        end
        f_pb:set(mono, 1, v)
        gnf[#gnf+1], gnf[ms] = ms, -v                                         -- gnf terms
        fil:write("gnf[",ms,"]=", gnf[ms]:tostring(), ", v=", v:tostring(), "\n")
      else
        t_pb:set(mono, 1, v)
        anh[#anh+1], anh[ms] = ms, -mono:ordpf(2)*v:imag()/twopi              -- anh terms
        fil:write("anh[",ms,"]=", num2str(anh[ms]), ", v=", v:tostring(), "\n")
      end
    end -- cycle

    -- f_pb:print("f_pb @ "..n)

    -- compute vector fields
    local f_n = tc:vec2fld(f_pb):convert(m_n:same():eye())
    local t_n = tc:vec2fld(t_pb):convert(m_n:same():eye())

    -- save vector fields
    f_op[n], t_op[n] = f_n, t_n
    if n == m_n:maxord() and nf.fid == 0 then break end

    -- kill resonances in the map
!   local m_n_1 = (-f_n):exppb(id) ; nf:sav(m_n_1, "m_n_1 @"..n)
!   local m_n_2 = m_n_1 * m_n      ; nf:sav(m_n_2, "m_n_2 @"..n)
!   local m_n_3 = f_n:exppb(m_n_2) ; nf:sav(m_n_3, "m_n_3 @"..n)
!   nf:sav(t_n,"t_n @"..n):sav(f_n,"f_n @"..n):sav(m_n,"m_n @"..n)

    m_n = f_n:exppb((-f_n):exppb(id) * m_n) ; nf:sav(m_n, "m1("..n..")")
  end -- for n

  -- the normalizing map A
  nf.lieex = id:lieexppb(f_op) !; nf:sav"lieex"

  nf.a = nf.a0 * nf.a1 * nf.c * nf.lieex * nf.ci ; nf:sav"a"
  nf.a:real():copy(m):set0(nf.x0).status = 'Aset'

  nf.fil:write("fid(a)=", nf.fid, "\n")
  nf.fil:close() ; nf.fil = nil

  -- hook the results
  nf.ham_, nf.gnf_, nf.anh, nf.lam, nf.m_n, nf.f_op, nf.t_op =
     ham ,    gnf ,    anh,    lam,    m_n,    f_op,    t_op

  return nf
end

-- beta0 block conversion -----------------------------------------------------o

local ofun_tol in phystol

local function oval (x)
  return abs(x) < ofun_tol and 0 or x
end

-- convert beta0 block (optical functions) to A (normalising form)

function gphys.bet2map (bb0, map, sav_) -- TODO: move to beta0
  assert(typeid.is_beta0(bb0), "invalid argument #1 (beta0 block expected)")
  assert(       is_damap(map), "invalid argument #2 (damap expected)")

  local rnk = bb0.rank or 4
  local cpl = bb0.cplg or nil
  local dir = bb0.sdir or 1
  local X   = (bb0.X or vector(6)):zeros()
  local A   = (bb0.A or matrix(6)):eye()

  -- normalization matrix A of the one-turn map R: N = A^-1 R A

  local get, set = A.get, A.set

  -- set orbit
  if bb0.x  then set(X,1,1, bb0.x ) end
  if bb0.px then set(X,2,1, bb0.px) end
  if bb0.y  then set(X,3,1, bb0.y ) end
  if bb0.py then set(X,4,1, bb0.py) end
  if bb0.t  then set(X,5,1, bb0.t ) end
  if bb0.pt then set(X,6,1, bb0.pt) end

  -- x plane

  local beta11 = bb0.beta11 or bb0.beta1 or bb0.betx or 1
  local alfa11 = bb0.alfa11 or bb0.alfa1 or bb0.alfx or 0
  local gama11 = bb0.gama11 or (1+alfa11^2)/beta11

  assertf(beta11 > 0, "invalid beta11=%.3fm (>0 expected)", beta11)

  local A11 = sqrt(beta11)
  local A21 = -alfa11/A11
  local A22 = sqrt(gama11 - A21^2) -- 1/A11

  set(A,1,1, A11) ; set(A,1,2,  0 ) -- Courant-Snyder form
  set(A,2,1, A21) ; set(A,2,2, A22)

  -- y plane

  local beta22 = bb0.beta22 or bb0.beta2 or bb0.bety or 1
  local alfa22 = bb0.alfa22 or bb0.alfa2 or bb0.alfy or 0
  local gama22 = bb0.gama22 or (1+alfa22^2)/beta22

  assertf(beta22 > 0, "invalid beta22=%.3fm (>0 expected)", beta22)

  local A33 = sqrt(beta22)
  local A43 = -alfa22/A33
  local A44 = sqrt(gama22 - A43^2) -- 1/A33

  set(A,3,3, A33) ; set(A,3,4,  0 ) -- Courant-Snyder form
  set(A,4,3, A43) ; set(A,4,4, A44)

  -- t plane

  local beta33 = bb0.beta33 or bb0.beta3 or bb0.betz or 0

  if beta33 ~= 0 then
    local alfa33 = bb0.alfa33 or bb0.alfa3 or bb0.alfz or 0
    local gama33 = bb0.gama33 or (1+alfa33^2)/beta33

    assertf(beta33 > 0, "invalid beta33=%.3fm (>0 expected)", beta33)

    local A55 = sqrt(beta33)
    local A65 = -alfa33/A55
    local A66 = sqrt(gama33 - A65^2) -- 1/A55

    set(A,5,5, A55) ; set(A,5,6,  0 ) -- Courant-Snyder form
    set(A,6,5, A65) ; set(A,6,6, A66)

    if rnk == 4 then rnk = 6 end
  end

  -- set dispersion

  if bb0.dx  then set(A,1,6, bb0.dx ) end
  if bb0.dpx then set(A,2,6, bb0.dpx) end
  if bb0.dy  then set(A,3,6, bb0.dy ) end
  if bb0.dpy then set(A,4,6, bb0.dpy) end

  -- backup rank and coupling

  if sav_ then bb0.rank, bb0.cplg, bb0.sdir = rnk, cpl, dir end

  -- sanity checks

  local serr, merr = (rnk >= 6 and A or A:getsub(r4,r4)):symperr(matrix(rnk))
  if serr > symp_tol then
    io.flush()
    warn("normalizing form A[%dx%d] built from beta0 block #%d is not symplectic, \z
          symperr=%.5e", rnk, rnk, bb0.id or 0, serr)
    A:print('A') ; merr:print('A_symperr')
    io.flush()
  end

  bb0.X, bb0.A, map.status = X, A, 'Aset'

  return map:setvar(X):set1(A)
end

-- fill beta0 block (optical functions) from A (normalising form) and W (tunes)

local pha_tol in phystol

function gphys.map2bet (map, rnk_, cpl_, dir_) -- TODO: move to beta0
  assert(is_damap(map), "invalid argument #1 (damap expected)")

  local bb0, ini
  if is_table(rnk_) then -- rnk_ is bb0
    ini = false
    bb0 = rnk_
    assert(typeid.is_beta0(bb0), "invalid beta0 block (not created from damap)")
  else
    ini = true
    bb0 = MAD.beta0 {rank = rnk_, cplg = cpl_, sdir = dir_ or 1}
  end

  bb0.X = map:get0(bb0.X)
  bb0.A = map:get1(bb0.A)
  local X, A in bb0
  assert(A.nrow >= 6 and A.ncol >= 6, "invalid damap size (6D+ expected)")

  local get = A.get
  local rnk = bb0.rank or has_dpt(A) and 6 or 4

  -- update rank
  bb0.rank = rnk

  -- orbits

  bb0.x  = get(X,1,1)
  bb0.px = get(X,2,1)
  bb0.y  = get(X,3,1)
  bb0.py = get(X,4,1)
  bb0.t  = get(X,5,1)
  bb0.pt = get(X,6,1)

  -- diagonal terms

  bb0.alfa11 = oval( -(get(A,1,1) * get(A,2,1) + get(A,1,2) * get(A,2,2)) )
  bb0.beta11 = oval(   get(A,1,1)^2            + get(A,1,2)^2             )
  bb0.gama11 = oval(   get(A,2,1)^2            + get(A,2,2)^2             )

  bb0.alfa22 = oval( -(get(A,3,3) * get(A,4,3) + get(A,3,4) * get(A,4,4)) )
  bb0.beta22 = oval(   get(A,3,3)^2            + get(A,3,4)^2             )
  bb0.gama22 = oval(   get(A,4,3)^2            + get(A,4,4)^2             )


  if rnk >= 6 then
    bb0.alfa33 = oval( -(get(A,5,5) * get(A,6,5) + get(A,5,6) * get(A,6,6)) )
    bb0.beta33 = oval(   get(A,5,5)^2            + get(A,5,6)^2             )
    bb0.gama33 = oval(   get(A,6,5)^2            + get(A,6,6)^2             )
  else
    bb0.alfa33, bb0.beta33, bb0.gama33 = 0, 0, 0
  end

  -- coupling terms

  if bb0.cplg then
    bb0.alfa12 = oval( -(get(A,1,3) * get(A,2,3) + get(A,1,4) * get(A,2,4)) )
    bb0.beta12 = oval(   get(A,1,3)^2            + get(A,1,4)^2             )
    bb0.gama12 = oval(   get(A,2,3)^2            + get(A,2,4)^2             )

    bb0.alfa21 = oval( -(get(A,3,1) * get(A,4,1) + get(A,3,2) * get(A,4,2)) )
    bb0.beta21 = oval(   get(A,3,1)^2            + get(A,3,2)^2             )
    bb0.gama21 = oval(   get(A,4,1)^2            + get(A,4,2)^2             )

    if rnk >= 6 then
      bb0.alfa13 = oval( -(get(A,1,5) * get(A,2,5) + get(A,1,6) * get(A,2,6)) )
      bb0.beta13 = oval(   get(A,1,5)^2            + get(A,1,6)^2             )
      bb0.gama13 = oval(   get(A,2,5)^2            + get(A,2,6)^2             )

      bb0.alfa31 = oval( -(get(A,5,1) * get(A,6,1) + get(A,5,2) * get(A,6,2)) )
      bb0.beta31 = oval(   get(A,5,1)^2            + get(A,5,2)^2             )
      bb0.gama31 = oval(   get(A,6,1)^2            + get(A,6,2)^2             )

      bb0.alfa23 = oval( -(get(A,3,5) * get(A,4,5) + get(A,3,6) * get(A,4,6)) )
      bb0.beta23 = oval(   get(A,3,5)^2            + get(A,3,6)^2             )
      bb0.gama23 = oval(   get(A,4,5)^2            + get(A,4,6)^2             )

      bb0.alfa32 = oval( -(get(A,5,3) * get(A,6,3) + get(A,5,4) * get(A,6,4)) )
      bb0.beta32 = oval(   get(A,5,3)^2            + get(A,5,4)^2             )
      bb0.gama32 = oval(   get(A,6,3)^2            + get(A,6,4)^2             )
    else
      bb0.alfa13, bb0.beta13, bb0.gama13 = 0, 0, 0
      bb0.alfa31, bb0.beta31, bb0.gama31 = 0, 0, 0
      bb0.alfa23, bb0.beta23, bb0.gama23 = 0, 0, 0
      bb0.alfa32, bb0.beta32, bb0.gama32 = 0, 0, 0
    end
  end

  -- dispersions

  if rnk >= 6 then
    local H = A*I56*A:sympconj()
    local _h66 = 1/get(H,6,6)

    bb0.dx, bb0.dpx = oval( get(H,1,6)*_h66 ), oval( get(H,2,6)*_h66 )
    bb0.dy, bb0.dpy = oval( get(H,3,6)*_h66 ), oval( get(H,4,6)*_h66 )
  else
    bb0.dx, bb0.dpx = oval( get(A,1,6) ), oval( get(A,2,6) )
    bb0.dy, bb0.dpy = oval( get(A,3,6) ), oval( get(A,4,6) )
  end

  -- ongoing (cumulated calculation)

  if ini then
    bb0.mu1, bb0.mu1_, bb0.dmu1, bb0.dmu1_ = 0, 0, 0, 0
    bb0.mu2, bb0.mu2_, bb0.dmu2, bb0.dmu2_ = 0, 0, 0, 0
    bb0.mu3, bb0.mu3_, bb0.dmu3, bb0.dmu3_ = 0, 0, 0, 0
  else
    local sdir in bb0

    -- phase advances (local)
    local mu1_ =              oval( atan2(get(A,1,2), get(A,1,1)) / twopi )
    local mu2_ =              oval( atan2(get(A,3,4), get(A,3,3)) / twopi )
    local mu3_ = rnk >= 6 and oval( atan2(get(A,5,6), get(A,5,5)) / twopi ) or 0

    if sdir*mu1_ < 0 and abs(mu1_) > pha_tol then mu1_ = sdir+mu1_ end
    if sdir*mu2_ < 0 and abs(mu2_) > pha_tol then mu2_ = sdir+mu2_ end
    if sdir*mu3_ < 0 and abs(mu3_) > pha_tol then mu3_ =     -mu3_ end

    local dmu1_, dmu2_, dmu3_ = mu1_-bb0.mu1_, mu2_-bb0.mu2_, mu3_-bb0.mu3_

    if sdir*dmu1_ < 0 and abs(dmu1_) > pha_tol then dmu1_ = sdir+dmu1_ end
    if sdir*dmu2_ < 0 and abs(dmu2_) > pha_tol then dmu2_ = sdir+dmu2_ end
    if sdir*dmu3_ < 0 and abs(dmu3_) > pha_tol then dmu3_ =     -dmu3_ end

    -- phase advances (cumulated, backup local)
    bb0.mu1, bb0.mu1_, bb0.dmu1_  = bb0.mu1+dmu1_, mu1_, dmu1_
    bb0.mu2, bb0.mu2_, bb0.dmu2_  = bb0.mu2+dmu2_, mu2_, dmu2_
    bb0.mu3, bb0.mu3_, bb0.dmu3_  = bb0.mu3+dmu3_, mu3_, dmu3_
  end

  return bb0
end

function gphys.chr2bet (bb0, fdp, dpt) -- TODO: move to beta0?
  assert(typeid.is_beta0(bb0), "invalid argument #1 (beta0 block expected)")
  assert(typeid.is_beta0(fdp), "invalid argument #2 (beta0 block expected)")
  assert(     is_nonzero(dpt), "invalid argument #3 (number ~= 0 expected expected)")

  -- phase advances vs dpt

  local dmu1_ = (fdp.dmu1_ - bb0.dmu1_) / dpt
  local dmu2_ = (fdp.dmu2_ - bb0.dmu2_) / dpt
  local dmu3_ = (fdp.dmu3_ - bb0.dmu3_) / dpt

  bb0.dmu1 = bb0.dmu1 + dmu1_
  bb0.dmu2 = bb0.dmu2 + dmu2_
  bb0.dmu3 = bb0.dmu3 + dmu3_

  -- dispersions from orbit

  bb0.Dx  = (fdp.x  - bb0.x ) / dpt
  bb0.Dy  = (fdp.y  - bb0.y ) / dpt
  bb0.Dpx = (fdp.px - bb0.px) / dpt
  bb0.Dpy = (fdp.py - bb0.py) / dpt

  -- dispersions vs dpt

  bb0.ddx  = 0.5*(fdp.dx  - bb0.dx ) / dpt
  bb0.ddy  = 0.5*(fdp.dy  - bb0.dy ) / dpt
  bb0.ddpx = 0.5*(fdp.dpx - bb0.dpx) / dpt
  bb0.ddpy = 0.5*(fdp.dpy - bb0.dpy) / dpt

  -- chromatic functions

  if bb0.beta11 then
    assertf(bb0.beta11 > 0, "invalid beta11=%.3fm (>0 expected)", bb0.beta11)

    local dbetx = (fdp.beta11 - bb0.beta11) / dpt
    local dalfx = (fdp.alfa11 - bb0.alfa11) / dpt
    local bx = dbetx / bb0.beta11
    local ax = dalfx - bb0.alfa11*bx

    bb0.wx = sqrt(ax^2 + bx^2)
    if bb0.wx > 1e-12 then
      local phix = atan2(ax, bx)
      bb0.phix_  = rangle(phix, bb0.phix_ or phix)
      bb0.phix   = bb0.phix_ / twopi
    end
  end

  if bb0.beta22 then
    assertf(bb0.beta22 > 0, "invalid beta22=%.3fm (>0 expected)", bb0.beta22)

    local dbety = (fdp.beta22 - bb0.beta22) / dpt
    local dalfy = (fdp.alfa22 - bb0.alfa22) / dpt
    local by = dbety / bb0.beta22
    local ay = dalfy - bb0.alfa22*by

    bb0.wy = sqrt(ay^2 + by^2)
    if bb0.wy > 1e-12 then
      local phiy = atan2(ay, by)
      bb0.phiy_  = rangle(phiy, bb0.phiy_ or phiy)
      bb0.phiy   = bb0.phiy_ / twopi
    end
  end
end

-- Method is implemented from SLAC-Pub-1193 where integration is
-- done explicitly and includes effect of poleface rotations

function gphys.syn2bet(bb0, mflw, elm) -- TODO: move to beta0?
  assert(typeid.is_beta0(bb0), "invalid argument #1 (beta0 block expected)")
  local el, eh, e1, e2, nmul, knl, tdir, beam in mflw

  if el == 0 or (eh == 0 and (nmul < 2 or knl[2] == 0)) then return end

  local debug in mflw
  local synch_1, synch_2, synch_3, synch_4, synch_5, synch_6, synch_8 =
              0,       0,       0,       0,       0,       0,       0

  if bb0.synch_1 == nil then
    bb0.synch_1, bb0.synch_2, bb0.synch_3, bb0.synch_4,
    bb0.synch_5, bb0.synch_6, bb0.synch_8 = 0, 0, 0, 0, 0, 0, 0
  end

  local k1   = knl[2]/el*tdir
  local te1  = tan(e1 or 0)
  local beta = beam.beta
  local dx   = bb0.dx *beta
  local dpx  = bb0.dpx*beta + dx*eh*te1

  -- global gradient combining weak focusing and dipole gradient
  -- k2 can be positive or negative and k can be real or imaginary

  if debug > 0 then
    print('Synchrotron integrals at exit of element ', elm.name, elm.kind)
    print('Input:  eh = ', eh, 'k1 = ', k1, 'e1 =', e1, 'e2 = ', e2, 'blen = ', el)
    print('        betxi = ', bb0.beta11, 'alfxi = ', bb0.alfa11, 'dxi = ', dx, 'dpxi = ', dpx)
  end

  -- propagation of dispersion at exit
  if eh ~= 0 then -- bend contribution
    local betx = bb0.beta11
    local alfx = bb0.alfa11 - betx*eh*te1
    local gamx = (1 + alfx^2) / betx

    local k2 = eh^2 + 2*k1
    local k  = sqrt(k2+0i)
    local kl = k*el
    local ckl, skl = cos(kl), sin(kl)
    local eh2, eh3 = eh^2, eh^3
    local kl2, kl3 = kl^2, kl^3
    local dx2      = real(dx*ckl + dpx*skl/k + eh*(1-ckl)/k2)
    local dispavg  = real(dx*skl/kl + dpx*(1-ckl)/(k*kl) + eh*(kl-skl)/(k2*kl))
    local curlyavg = real( gamx*dx^2 + 2*alfx*dx*dpx + betx*dpx^2
              + 2*eh*el*(-(gamx*dx + alfx*dpx)*(kl-skl)/(kl2*k)
                         +(alfx*dx + betx*dpx)*(1 -ckl)/(kl2))
            + (eh*el)^2*(  gamx*(3*kl - 4*skl + skl*ckl)/(2*k2*kl3)
                         - alfx*(1 -ckl)^2  /(k*kl3)
                         + betx*(kl-ckl*skl)/(2*kl3)) )

    synch_1 = dispavg*eh*el
    synch_2 = eh2*el
    synch_3 = abs(eh3)*el
    synch_4 = dispavg*eh*(eh2 + 2*k1)*el - eh2*(dx*te1 + dx2*tan(e2 or 0))
    synch_5 = curlyavg*abs(eh3)*el

    bb0.synch_1 = bb0.synch_1 + synch_1
    bb0.synch_2 = bb0.synch_2 + synch_2
    bb0.synch_3 = bb0.synch_3 + synch_3
    bb0.synch_4 = bb0.synch_4 + synch_4
    bb0.synch_5 = bb0.synch_5 + synch_5

    if debug > 1 then
      print(' --> ')
      print('        k2 = ', k2, '  k = ', k, 'k*l = ', kl)
      print('        alfx = ', alfx, 'dpx = ', dpx, 'gamx = ', gamx, 'dx2 = ', dx2)
      print('        dispaverage = ', dispavg, 'curlyhaverage = ', curlyavg)
    end

  elseif k1 ~= 0 then -- quad contribution (exclusive)
    local sk1 = sqrt(k1+0i)
    local u0x = real((1+sin(2*sk1*el)/(2*sk1*el))/ 2)
    local u2x = real((1-sin(2*sk1*el)/(2*sk1*el))/(2*k1))
    local u1x = real(sin(sk1*el)^2)/(k1*el)
    local dx2 = real(cos(sk1*el)*dx + dpx/sk1*sin(sk1*el))
    local dispavg = (dx+dx2)/2
    local betxavg = bb0.beta11*u0x - bb0.alfa11*u1x + bb0.gama11*u2x

    synch_6 =  k1^2*betxavg   *el
    synch_8 = (k1  *dispavg)^2*el

    bb0.synch_6 = bb0.synch_6 + synch_6
    bb0.synch_8 = bb0.synch_8 + synch_8

    if debug > 1 then
      print(' --> ')
      print('        u0x = ', u0x, 'u1x = ', u1x, 'u2x = ', u2x, 'dx2 = ', dx2)
      print('        dispaverage = ', dispavg, 'betxavg = ', betxavg)
    end
  end

  if debug > 0 then
    print('Contributions to Radiation Integrals:',
           synch_1, synch_2, synch_3, synch_4, synch_5, synch_6, synch_8)
    print('')
  end
end

-- env ------------------------------------------------------------------------o

gphys = wrestrict(setmetatable(gphys, {__tostring := "MAD.gphys"}))

-- end ------------------------------------------------------------------------o
return { gphys = gphys }
