--[=[
 o-----------------------------------------------------------------------------o
 |
 | Range module
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: A.Z. Teska, aleksandra.teska at cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides full set of functions and operations on ranges and logranges.

 o-----------------------------------------------------------------------------o
]=]

local M, Mlog = { __help = {} }, { __help = {} }

-- help -----------------------------------------------------------------------o

M.__help.self = [=[
NAME
  range, logrange -- range and logarithmic ranges

SYNOPSIS
  r1 = range (start [, stop [, step]])
  r2 = nrange(start [, stop [, npoints]])
  r3 = start..stop[..step]

  l1 = logrange (lstart [, lstop [, lstep]])
  l2 = nlogrange(lstart [, lstop [, npoints]])
  l2 = log(lstart..lstop[..lstep])

DESCRIPTION
  Ranges are defined by their start, stop (included) and step arguments. A step
  of value zero (one for logrange) or a step with opposite sign to stop-start
  lead to an empty range. The ranges can be used as stateless iterators in for
  loops (i.e. ipairs), and provide better numerical stability for non-exact
  floating point numbers. Some methods like index (i.e. []), iterators (i.e.
  ipairs) and get (segment interpolation) return nil outside the boundaries, and
  some others like value (line interpolation) don't check for boundaries.

RETURN VALUES
  The table constaining the constructors for range and logrange (argument #3 is
  step), the constructors for nrange and nlogrange (argument #3 is npoints), the
  iterators irange and ilogrange for direct use in for loops, and the functions
  is_range and is_logrange to identify the ranges object.

ERRORS
  Range, nrange, logrange and nlogrange constructors trig an error if any of the
  argument #1, #2 and #3 (if provided) are not a number.

EXAMPLES
  r01 = range(1)
  r02 = range(1,10)
  r03 = range(1,10,2)
  r04 = range(0,1.5,0.1)
  r05 = range(0,-1.5,-0.1)
  r15 = 1..10
  r16 = 1..10..2
  r17 = 0..1.5..0.1
  r18 = 0..-1.5..-0.1
  r19 = 0..1.5.. .1
  print(r05.start, r1.stop, r1.step)  -- print 0 -1.5 0.1

SEE ALSO
  None.
]=]
Mlog.__help.self = M.__help.self

-- locals ---------------------------------------------------------------------o

local new, cdef, istype, typeof, metatype in require 'ffi'
local is_number, is_nil, is_inf, defhelp  in require 'madl_utils'
local forget                              in require 'madl_gfunc'
local inf                                 in require 'madl_gmath'
local abs, ceil, floor, log, exp, max     in math

local exp_1 = exp(1)

-- ctypes are xrange and logxrange
cdef [[
  typedef struct logxrange { const double logstart, logstop, logstep; } logxrange;
]]

-- constructors ---------------------------------------------------------------o

local range    = typeof 'xrange'
local logrange = typeof 'logxrange'

-- implementation -------------------------------------------------------------o

local function value (r, x)
  return r.start + r.step*x -- N points => step = (stop-start)/(N-1)
end

local function valuelog (r, x)
  return exp(r.logstart + r.logstep*x) -- N points => step = (stop/start)^(1/(N-1))
end

local function is_range (a)
  return istype('xrange', a)
end

local function is_logrange (a)
  return istype('logxrange', a)
end

function M.range (r)
  return r.start, r.stop, r.step
end

function Mlog.range (r)
  return exp(r.logstart), exp(r.logstop), exp(r.logstep)
end

local function is_empty(start, stop, step)
  return not (step >= 0 and start <= stop or
              step <= 0 and start >= stop or false)
end

local is_emptylog = is_empty

local function get (r, x)
  local v = value(r, x)
  if x >= 0 and (r.step >= 0 and v <= r.stop or
                 r.step <  0 and v >= r.stop) then
    return v
  end
end

local function getlog (r, x)
  local v = value(r, x)
  if x >= 0 and (r.logstep >= 0 and v <= r.logstop or
                 r.logstep <  0 and v >= r.logstop) then
    return exp(v)
  end
end

local function iterincr (r, i)
  local v = value(r, i)
  if v <= r.stop then return i+1, v end
end

local function iterincrlog (r, i)
  local v = value(r, i)
  if v <= r.logstop then return i+1, exp(v) end
end

local function iterdecr (r, i)
  local v = value(r, i)
  if v >= r.stop then return i+1, v end
end

local function iterdecrlog (r, i)
  local v = value(r, i)
  if v >= r.logstop then return i+1, exp(v) end
end

local function size (start, stop, step)
  local sz = floor((stop-start)/step + 1)
  return sz < 0 and 0 or sz
end

local sizelog = size

-- alternate constructors with #steps specified

local function step (start, stop, size)
  size = ceil(size)
  if size <= 0     then return 0 end
  if size >  1     then return (stop - start) / abs(size-1) end
  if stop >= start then return (stop - start) + 1 end
  if stop <  start then return (stop - start) - 1 end
end

local function steplog (start, stop, size)
  size = ceil(size)
  if size <= 0 then return 0 end
  if size >  1 then return (stop/start)^(1/(ceil(size)-1)) else return 1 end
end

local function nrange (start, stop, size)
  if is_number(size) == false then size = 50 end
  assert(is_number(start) and is_number(stop),
         "invalid argument #1 or #2(number expected)")
  return range(start, stop, step(start, stop, size))
end

local function nlogrange (start, stop, size)
  if is_number(size) == false then size = 50 end
  assert(is_number(start) and is_number(stop),
         "invalid argument #1 or #2(number expected)")
  return logrange(start, stop, steplog(start, stop, size))
end

-- iterators

local function irange (start, stop, step)
  return ipairs(range(start, stop, step))
end

local function ilogrange (logstart, logstop, logstep)
  return ipairs(logrange(logstart, logstop, logstep))
end

-- metamethods

function M.__new (ct, start, stop, step)
  assert(is_number(start), "invalid argument #1 (number expected)")
  if stop == nil then stop = start end   -- default
  if step == nil then step = 1 end       -- default
  return new(ct, start, stop, step)
end

function Mlog.__new (ct, start, stop, step)
  assert(is_number(start) and start > 0, "invalid argument #1 (positive number expected)")
  if stop == nil then stop = start end   -- default
  if step == nil then step = exp_1 end   -- default
  assert(is_number(stop) and stop > 0, "invalid argument #2 (positive number expected)")
  assert(is_number(step) and step > 0, "invalid argument #3 (positive number expected)")
  return new(ct, log(start), log(stop), log(step))
end

function M.__index (r, a)
  if is_number(a) then return get(r, a-1) else return M[a] end
end

function Mlog.__index (r, a)
  if is_number(a) then return getlog(r, a-1) else return Mlog[a] end
end

function M.__ipairs (r)
  if r.step > 0 then
    return iterincr, r, 0
  elseif r.step < 0 then
    return iterdecr, r, 0
  end

  return forget
end

function Mlog.__ipairs (r)
  if r.step > 0 then
    return iterincrlog, r, 0
  elseif r.step < 0 then
    return iterdecrlog, r, 0
  end
  return forget
end

-- function Mlog.__ipairs (r)
--   local s = abs(r.step)
--   if s > 1 and r.start > 0 or s < 1 and r.start < 0 then
--     return iterincrlog, r, 0
--   elseif s > 1 and r.start < 0 or s < 1 and r.start > 0 then
--     return iterdecrlog, r, 0
--   end
-- end

function M.__eq (r1, r2)
  return is_range(r1) and is_range(r2) and
         r1.start == r2.start and r1.step == r2.step and r1.stop == r2.stop
end

function Mlog.__eq (r1, r2)
  return is_logrange(r1) and is_logrange(r2) and
         r1.logstart == r2.logstart and r1.logstep == r2.logstep and r1.logstop == r2.logstop
end

M.__help.is_range = [=[

NAME
  is_range, is_logrange, is_empty     -- identify ranges

SYNOPSIS
  is_range(rng)
  is_logrange(lrng)
  is_empty(start [, stop [, step]])

DESCRIPTION
  Functions used for identifing type of range.

RETURN VALUES
  is_range and is_logrange return true if their argument is a range of
  respective types. is_empty returns true for ranges with step equal to zero or
  step with opposite sign to stop-start lead of range.

EXAMPLES
  local is_range, is_logrange, log in MAD
  local is_empty in range
  print( is_range 'yes' )                     -- false
  print( is_range(0..1) )                     -- true
  print( is_logrange(log(0..1)) )             -- true

  print( is_empty(1,10,-1) )                  -- true
  print( is_empty(10,1,1)  )                  -- true
  print( is_empty(1,10,1)  )                  -- false
  print( is_empty(1,10,0)  )                  -- false

SEE ALSO
  None.
]=]
M.__help.is_logrange = M.__help.is_range
M.__help.is_empty    = M.__help.is_range

M.__help.irange = [=[

NAME
  irange, ilogrange               -- ranges interators

SYNOPSIS
  irange(start [, stop [, step]])
  ilogrange(start [, stop [, step]])

DESCRIPTION
  Functions are an equivalent of ipairs for ranges and logranges.

RETURN VALUES
  irange and ilogrange return the appropriate arguments for stateless iterators
  build from given type of range, that is the iterator function, the object and
  the pre-initial key.

EXAMPLES
  local irange, ilogrange, is_function, is_range in MAD
  local ir = {irange(1,10,1)}
  print( is_function(ir[1]) )                  -- true
  print( is_range(ir[2])    )                  -- true
  print( ir[3] == 0         )                  -- true

  for i,v in irange(1,10,2)       do print(i,v) end
  for i,v in ilogrange(1,10^6,10) do print(i,v) end

SEE ALSO
  ipairs
]=]
M.__help.ilogrange = M.__help.irange

function M.size (r)
  return size(r.start, r.stop, r.step)
end

function Mlog.size (r)
  return sizelog(r.logstart, r.logstop, r.logstep)
end

function M.is_empty (r)
  return is_empty(r.start, r.stop, r.step)
end

function Mlog.is_empty (r)
  return is_emptylog(r.logstart, r.logstop, r.logstep)
end

function M.reverse (r)
  return range(r.stop, r.start, -r.step)
end

function Mlog.reverse (r, a)
  return logrange(r.logstop, r.logstart, 1/r.logstep)
end

M.get         = get
M.value       = value
M.__len       = M.size
M.__unm       = M.reverse

Mlog.get      = getlog
Mlog.value    = valuelog
Mlog.__len    = Mlog.size
Mlog.__unm    = Mlog.reverse

function M.bounds (r)
  if r.step > 0 and r.start <= r.stop then
    return r.start, r.stop
  elseif r.step < 0 and r.start >= r.stop then
    return r.stop, r.start
  elseif r.step == 0  then
    return r.start, r.start
  end
end

function Mlog.bounds (r)
  if r.logstep > 1 and r.logstart <= r.logstop then
    return exp(r.logstart), exp(r.logstop)
  elseif r.logstep < 1 and r.logstart >= r.logstop then
    return exp(r.logstop ), exp(r.logstart)
  end
end

function M.overlap (r, s)
  local rl, rh = r:bounds()
  local sl, sh = s:bounds()
  return not (rl == nil or sl == nil or rh < sl or rl > sh)
end

M.__help.value = [=[
NAME
  value, get, index                   -- range interpolation

SYNOPSIS
  rng:value(x)
  rng:get(x)
  rng[x]

DESCRIPTION
  Functions used for interpolation of ranges.Points from value and get functions
  are iterated from 0, indexing elements starts from 1. Index and get are
  functions used for segment interpolation, they return nil outside the
  boundaries, value is used for line interpolation.

RETURN VALUES
  Function return values of given data points in range.

EXAMPLES
  local range, value, get in MAD
  local rng = range(1,10,1)
  print( rng:value(0)  )                      -- 1
  print( rng:value(9)  )                      -- 10
  print( rng:value(10) )                      -- 11
  print( rng:value(-1) )                      -- 0

  print( rng:get(0)  )                        -- 1
  print( rng:get(9)  )                        -- 10
  print( rng:get(10) )                        -- nil
  print( rng:get(-1) )                        -- nil

  print( rng[1]  )                            -- 1
  print( rng[10] )                            -- 10
  print( rng[11] )                            -- nil
  print( rng[0]  )                            -- nil

SEE ALSO
  None.
]=]
M.__help.get   = M.__help.value
M.__help.index = M.__help.value

M.__help.range = [=[
NAME
  range, bounds, overlap

SYNOPSIS
  rng:range()
  lrng:range()
  rng:bounds()
  lrng:bounds()
  rng1:overlap(rng2)
  lrng1:overlap(lrng2)

DESCRIPTION

RETURN VALUES
  range returns the values of start, stop and step of a given range. bounds
  returns the start and stop values that restrain the range, their order is
  dependand on the lead of range. overlap returns true if two ranges have at
  least one common point

EXAMPLES
  local range, nrange, logrange in MAD
  print( (1..10)             :range()  )          -- 1,10,1
  print( nrange(1,10,10)     :range()  )          -- 1,10,1
  print( logrange(1,10^6,10) :range()  )          -- 1,10^6,10
  print( range(1,10,1)       :bounds() )          -- 1,10
  print( range(10,1,-1)      :bounds() )          -- 1,10
  print( logrange(10^5,10,10):bounds() )          -- 10^5, 10
  print( (1..9)     :overlap(9..1..-1) )          -- true
  print( (-9..-1)   :overlap(0..9)     )          -- false

SEE ALSO
  None.
]=]

M.__help.bounds = M.__help.range

M.__help.equal = [=[
NAME
  ==, size, reverse, (unary) -

SYNOPSIS
  rng1 == rng2
  rng:size()
  lrng:size()
  rng:reverse()
  lrng:reverse()

DESCRIPTION

RETURN VALUES
  size returns the number of points contained in a given range. reverse returns
  range with reversed from original start-stop lead and step with opposite sign
  for ranges and 1/step for logranges. Function equal returns true only if
  compared ranges have same start, stop and step values.

EXAMPLES
  local logrange, range, nrange, log in MAD
  print( logrange(1,10^6,10)  == log(1..10^6..10))  -- true
  print( range(1,20)          ==  1..20..1       )  -- true
  print( nrange(1,20,20)      ==  1..20          )  -- true

  print( range(1,10)         :size() )              -- 10
  print( range(1,-10)        :size() )              -- 0
  print( logrange(1,10^6,10) :size() )              -- 7

  print( (1..10..0.1)         :reverse() )          -- (10..1..-0.1)
  print( range(2,20,2)        :reverse() )          -- range(20,2,-2)
  print( logrange(1,10^6,10)  :reverse() )          -- logrange(10^6,1,0.1)
  print( logrange(10^7,10,0.1):reverse() )          -- logrange(10,10^7,10)

SEE ALSO
  None.
]=]
M.__help.size     = M.__help.empty
M.__help.reversed = M.__help.empty

--[=[
-- convertion

local function convert (r, ctor)
  local size = r:size()
  local t = ctor(size,0)
  for i=1,size do
    t[i] = r.start+(i-1)*r.step
  end
  return t
end

function M.totable (r)
  return convert(r, tnew)
end

function M.tostring (r)
  if r.step == 1 then
    return string.format("%g..%g", r.start, r.stop)
  else
    return string.format("%g..%g..%g", r.start, r.stop, r.step)
  end
end

--function M.tovector (r)
--  return convert(r, vector)
--end
]=]

metatype('xrange'   , defhelp(M)   )
metatype('logxrange', defhelp(Mlog))

-------------------------------------------------------------------------------o
return {
  range       = range,
  logrange    = logrange,
  nrange      = nrange,      -- constructor with N points
  nlogrange   = nlogrange,   -- constructor with N points

  irange      = irange,      -- iterator
  ilogrange   = ilogrange,   -- iterator

  is_range    = is_range,
  is_logrange = is_logrange,

--  linspace  = nrange,      -- TODO: compose with :tovector()
--  logspace  = nlogrange,   -- TODO: compose with :tovector()

  __help      = M.__help,
}
