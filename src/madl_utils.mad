--[=[
 o-----------------------------------------------------------------------------o
 |
 | Utils module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a set of utility functions

 o-----------------------------------------------------------------------------o
]=]

local M = { __help = {} }

-- help -----------------------------------------------------------------------o

M.__help.self = [=[
NAME
  utils -- provide some utility functions

SYNOPSIS
  is_nil, is_boolean, is_number, is_string, is_function, is_table, (basic types)
  is_cdata, is_complex,
  is_nan, is_infinite, is_positive, is_negative, is_integer,   (specializations)
  is_scalar, is_rawtable,
  bnot, band, bor, bxor, bclr, bset, btst, tobit, tohex,         (bit operators)
  bool, logical_not, logical_and, logical_or, is_equal,      (logical operators)
  is_not_equal, is_lesser, is_lesser_or_equal, is_greater, is_greater_or_equal,
  lnot, land, lor, is_eq, is_ne, is_lt, is_le, is_gt, is_ge, (aliases for logop)
  unm, add, sub, mul, div, mod, pow, get, set, len, cat, call        (operators)
  is_metaname, has_metatable, get_metatable,                       (metamethods)
  has_length, is_iterable, is_mappable, is_indexable, is_callable,    (concepts)
  is_comparable, is_ordered, is_concatenable, is_stringable, is_tablable,
  is_negatable, is_addable, is_substractable, is_multiplicable, is_dividable,
  is_modulable, is_powerable, has_member, has_method, has_metamethod,
  is_same, same,                                              (types comparison)
  tostring, totable,                                                (extensions)
  option { format='%.16g' }.                                             (setup)

DESCRIPTION
  The utils module provides useful utility functions:
  - is_nil, is_boolean, is_number, is_string, is_function, is_table, is_cdata,
    and is_complex return true if the argument is of expected type,
  - is_nan and is_infinite return true if argument is not-a-number or Â±infinity,
  - is_positive and is_negative return true if argument is >0 or <0 respectively,
  - is_integer returns true if the argument is an integer number within the
    interval of [-2^52, 2^52],
  - is_scalar returns true if the argument is a number or a complex,
  - is_rawtable returns true if the argument is a table without metatable,
  - bnot, band, bor, bxor, tobit and tohex imported are from the bit module,
  - bclr, bset and btst respectively clear, set and test bit 0..31 of an int32,
  - bool, logical_not, logical_and, logical_or, is_equal, is_not_equal,
    is_lesser, is_lesser_or_equal, is_greater and is_greater_or_equal are
    functions wrapping logical operators,
  - unm, add, sub, mul, div, mod, pow, get, set, len, cat, call are functions
    wrapping other operators (i.e. -n, +, -, *, /, %, ^, [], []=, #, .., ()),
  - is_ismetaname returns true if the argument is a valid metamethod name,
  - has_metatable returns true is the argument has a metatable,
  - get_metatable is a generic version of getmetatable that works also with
    cdata,
  - has_length, is_iterable, is_mappable, is_indexable, is_callable,
    is_comparable, is_ordered, is_concatenable, is_stringable, is_tablable,
    is_negatable, is_addable, is_substractable, is_multiplicable, is_dividable,
    is_modulable, is_powerable, has_member, has_method and has_metamethod return
    true if the argument fulfills the concept requirements,
  - is_stringable and is_tablable check only if the argument supports
    respectively the __tostring and the __totable metamethods because objects
    are always stringable and tableable in MAD,
  - has_member, has_method and has_metamethod returns true if argument #1 has
    argument #2 as a member, a callable member and a meta member respectively,
  - tostring is extended to handle option.format and delegation. To let the
    print command uses this version, it must be exported to override the
    global environment one (i.e. MAD.export('tostring', true)),
  - totable support delegation for non-primary types,
  - option is a table that stores various setup.

RETURN VALUES
  Depends on the utility functions.

ERRORS
  None.

SEE ALSO
  None.
]=]

-- locals ---------------------------------------------------------------------o

local ffi, bit = require 'ffi', require 'bit'
local istype                                   in ffi
local format                                   in string
local abs, inf                                 in math
local bnot, band, bor, bxor, rol, tobit, tohex in bit
local type, getmetatable, tostring = type, getmetatable, tostring

-- implementation -------------------------------------------------------------o

-- metatables

assert(ffi.miscmap, "missing MAD extension (no cdata metatable access)")

local function get_meta (a)
  return type(a) == 'cdata' and ffi.miscmap[ -tonumber(ffi.typeof(a)) ]
         or getmetatable(a)
end

-- metamethods

local metaname = {
  -- list of metanames from lj_obj.h + __init + __exec + __totable
  '__add', '__call', '__concat', '__div', '__eq', '__exec', '__gc', '__index',
  '__init', '__ipairs', '__le', '__len', '__lt', '__metatable', '__mod',
  '__mode', '__mul', '__new', '__newindex', '__pairs', '__pow', '__sub',
  '__tostring', '__totable', '__unm',
}
for _,v in ipairs(metaname) do metaname[v] = v end -- build dictionary

-- values

local value_t = { -- list of types that cannot be modified
  ['nil'] = true, boolean = true, number = true, string = true, -- table = nil
  ['function'] = true, thread = true,
}

-- options

M.option = {

  format = "%.16g",

}

-- operators

M.operator = {

  -- bits operators
  bnot  = bnot,
  band  = band,
  bor   = bor,
  bxor  = bxor,
  tobit = tobit,
  tohex = tohex,

  bset = \x,n -> bor (x, rol( 1, n)),
  btst = \x,n -> band(x, rol( 1, n)) ~= 0,
  bclr = \x,n -> band(x, rol(-2, n)),

  -- logical operators
  bool  = \x   -> not not x,
  lnot  = \x   -> not x,
  land  = \x,y -> not not (x and y),
  lor   = \x,y -> not not (x or  y),
  is_eq = \x,y -> x == y,
  is_ne = \x,y -> x ~= y,
  is_lt = \x,y -> x <  y,
  is_le = \x,y -> x <= y,
  is_gt = \x,y -> x >  y,
  is_ge = \x,y -> x >= y,

  logical_not         = M.lnot,
  logical_and         = M.land,
  logical_or          = M.lor,
  is_equal            = M.is_eq,
  is_not_equal        = M.is_ne,
  is_lesser           = M.is_lt,
  is_lesser_or_equal  = M.is_le,
  is_greater          = M.is_gt,
  is_greater_or_equal = M.is_ge,

  -- math operators
  unm  = \x   -> -x,
  sqr  = \x   ->  x * x,
  add  = \x,y ->  x + y,
  sub  = \x,y ->  x - y,
  mul  = \x,y ->  x * y,
  div  = \x,y ->  x / y,
  mod  = \x,y ->  x % y,
  pow  = \x,y ->  x ^ y,

  -- object operators
  get  = \x,k   -> x[k],
  set  = \x,k,v => x[k]=v end,
  len  = \x     -> #x,
  cat  = \x,y   -> x..y,
  call = \x,... -> x(...),
}

M.operator.opstr = {
  ['~' ] = M.operator.unm,
  ['+' ] = M.operator.add,
  ['-' ] = M.operator.sub,
  ['*' ] = M.operator.mul,
  ['/' ] = M.operator.div,
  ['%' ] = M.operator.mod,
  ['^' ] = M.operator.pow,
  ['#' ] = M.operator.len,
  ['..'] = M.operator.cat,
  ['<' ] = M.operator.is_lt,
  ['>' ] = M.operator.is_gt,
  ['<='] = M.operator.is_le,
  ['>='] = M.operator.is_ge,
  ['~='] = M.operator.is_ne,
  ['!='] = M.operator.is_ne,
  ['=='] = M.operator.is_eq,
  ['!' ] = M.operator.lnot,
  ['&&'] = M.operator.land,
  ['||'] = M.operator.lor,
  ['!!'] = M.operator.bool,
}

-- types

local complex = ffi.typeof 'complex'

M.typeid = {

  -- primitive types
  is_nil      = \a -> type(a) == 'nil',
  is_boolean  = \a -> type(a) == 'boolean',
  is_number   = \a -> type(a) == 'number',
  is_string   = \a -> type(a) == 'string',
  is_function = \a -> type(a) == 'function',
  is_table    = \a -> type(a) == 'table',
  is_cdata    = \a -> type(a) == 'cdata',
  is_complex  = \a -> istype(complex, a),

  -- specialisations
  is_nan      = \a -> type(a) == 'number' and a ~= a,
  is_infinite = \a -> type(a) == 'number' and abs(a) == inf,
  is_finite   = \a -> type(a) == 'number' and abs(a) <  inf,
  is_positive = \a -> type(a) == 'number' and a > 0,
  is_negative = \a -> type(a) == 'number' and a < 0,
  is_integer  = \a -> type(a) == 'number' and a >= -2^52 and a <= 2^52 and (a%1) == 0,
  is_scalar   = \a -> type(a) == 'number' or  istype(complex, a),
  is_rawtable = \a -> type(a) == 'table'  and getmetatable(a) == nil,

  -- comparison
  is_same     = \a,b -> type(a) == type(b) and get_meta(a) == get_meta(b),

  -- valid metamethods names
  is_metaname = \a -> metaname[a] == a,

}

-- metamethods

M.get_metatable = get_meta

-- concepts

local is_number, is_complex, is_string, is_table, is_rawtable, is_function
      in M.typeid

local has_metamethod = function (a, f, f2)
  local mt = get_meta(a)
  return mt and (mt[f] or mt[f2]) ~= nil or false
end

M.concept = {

  is_stringable    = \a -> has_metamethod(a, '__tostring'),
  is_tablable      = \a -> has_metamethod(a, '__totable' ),

  is_callable      = \a -> is_function(a) or has_metamethod(a, '__call'  ),
  is_iterable      = \a -> is_table(a)    or has_metamethod(a, '__ipairs'),
  is_mappable      = \a -> is_table(a)    or has_metamethod(a, '__pairs' ),
  is_indexable     = \a -> is_table(a)    or has_metamethod(a, '__index' ),
  is_concatenable  = \a -> is_string(a)   or has_metamethod(a, '__concat'),
  is_negatable     = \a -> is_number(a)   or has_metamethod(a, '__unm'   ),
  is_addable       = \a -> is_number(a)   or has_metamethod(a, '__add'   ),
  is_substractable = \a -> is_number(a)   or has_metamethod(a, '__sub'   ),
  is_multiplicable = \a -> is_number(a)   or has_metamethod(a, '__mul'   ),
  is_dividable     = \a -> is_number(a)   or has_metamethod(a, '__div'   ),
  is_modulable     = \a -> is_number(a)   or has_metamethod(a, '__mod'   ),
  is_powerable     = \a -> is_number(a)   or has_metamethod(a, '__pow'   ),

  is_comparable    = \a -> is_number(a) or is_string(a) or has_metamethod(a, '__eq' ),
  is_ordered       = \a -> is_number(a) or is_string(a) or has_metamethod(a, '__le', '__lt'),

  has_length       = \a -> is_table(a)  or is_string(a) or has_metamethod(a, '__len'),
  has_metatable    = \a -> get_meta(a) ~= nil,
  has_constructor  = \a -> has_metamethod(a,'__new'),
  is_collectable   = \a -> has_metamethod(a,'__gc' ),

}

local is_indexable, is_callable in M.concept

M.concept.has_member = \a,f -> is_indexable(a) and a[f] ~= nil       or false
M.concept.has_method = \a,f -> is_indexable(a) and is_callable(a[f]) or false
M.concept.has_metamethod = has_metamethod

-- extensions

local is_stringable, is_tablable, has_method in M.concept
local option in M

local function tbl2str(t)
  if #t == 0 then return '{}' end
  local r = table.new(#t+2,0)
  r[1] = '{'
  for i=1,#t do r[i+1] = M.tostring(t[i]) end
  r[#r+1] = '}'
  return table.concat(r, ', ')
end

local function str2tbl(s)
  local r = table.new(#s,0)
  for i=1,#s do r[i] = s:sub(i,i) end
  return r
end

M.tostring = function (a, ...)
  if     is_string(a)     then return a
  elseif is_number(a)     then return string.format(option.format, a)
  elseif is_rawtable(a)   then return tbl2str(a)
  elseif is_stringable(a) then return get_meta(a).__tostring(a, ...)
  else                         return tostring(a) -- builtin
  end
end

M.totable = function (a, ...)
  if     is_table(a)    then return a
  elseif is_string(a)   then return str2tbl(a)
  elseif is_tablable(a) then return get_meta(a).__totable(a, ...)
  else                       return {a} -- encapsulate
  end
end

M.same = function (a, ...)
  if     value_t[type(a)] or is_complex(a) then return a
  elseif is_rawtable(a)                    then return {}
  elseif has_method(a, 'same')             then return a:same(...)
  end
  error("invalid argument #1 (clonable object expected)")
end

-- utilities

local is_iterable, is_mappable in M.concept

M.utility = {}

local rep_x, rep_n = {}, {}

local rep_it = \s,i => if i < s[rep_n] then return i+1, s[rep_x] end end
local rep_mt = {
  __len      = \s   -> s[rep_n],
  __index    = \s,i => if 1 <= i and i <= s[rep_n] then return s[rep_x] end end,
  __newindex = \    -> error("invalid write access to readonly object"),
  __pairs    = \s   -> (rep_it, s, 0),
  __ipairs   = \s   -> (rep_it, s, 0),
  __metatable = false,
}

M.utility.rep = function (x, n_) -- repeater
  return setmetatable({[rep_x]=x, [rep_n]=n_ or 2^30}, rep_mt)
end

M.utility.setkeys = function (tbl)
  assert(is_iterable(tbl), "invalid argument #1 (table expected)")
  for _,v in ipairs(tbl) do tbl[v] = v end
  return tbl
end

M.utility.countkeys = function (tbl)
  assert(is_mappable(tbl), "invalid argument #1 (table expected)")
  local n = 0
  for _ in pairs(tbl) do n = n+1 end
  return n
end

M.utility.defhelp = function (m, name)
  local ref = m.__help and m.__help.self
  assert(ref, "missing help for module "..tostring(m))
  for k in pairs(m) do
    if k ~= '__help' and m.__help[k] == nil then
      if name then
        io.write('defhelp: no help found for '..name..' item: ',tostring(k),'\n')
      end
      m.__help[k] = ref
    end
  end
  return m
end

-- todo help
M.__help.same          = ''
M.__help.totable       = ''
M.__help.tostring      = ''
M.__help.get_metatable = ''

M.__help.option = {
}

M.__help.operator = {
}

M.__help.typeid = {
}

M.__help.concept = {
}

M.__help.utility = {
}

M.utility.defhelp(M) -- todo: per function help -> 'utils'

-- end ------------------------------------------------------------------------o
return M
