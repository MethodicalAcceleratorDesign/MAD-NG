--[=[
 o-----------------------------------------------------------------------------o
 |
 | MAD environment (sandbox)
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Load in order all the modules of the MAD application and flatten them into
    the MAD environment for direct 1-level access using local 'in' table syntax.

 o-----------------------------------------------------------------------------o
]=]

local M = { __help = require 'madh_main' }

-- modules --------------------------------------------------------------------o

-- list of modules to import in MAD, order matters!
local modules = {
  'regex', -- from LPEG
  'gutil', 'gfunc', 'gmath', 'range', 'complex', 'matrix', -- 'tpsa',
  'object', 'constant', 'mtable', 'element', 'sequence', 'beam', -- 'mflow',
  'command', 'survey', 'track',
  'madx', -- 'plot',
}

-- constants ------------------------------------------------------------------o

local complex = require'ffi'.typeof'complex'

math.inf    = 1/0
math.nan    = 0/0
math.eps    = 2.2204460492503130e-16
math.huge   = 1.7976931348623158e+308
math.tiny   = 2.2250738585072012e-308
math.infi   = complex(0,1/0)
math.nani   = complex(0,0/0)
math.twopi  = 2*math.pi
math.degrad = 180/math.pi
math.raddeg = math.pi/180

-- locals ---------------------------------------------------------------------o

local _C    = require 'madl_cmad'
local gutil = require 'madl_gutil'

local get_metatable                              in gutil
local is_nil, is_boolean, is_string, is_rawtable in gutil.typeid
local is_mappable, is_indexable                  in gutil.concept

require 'table.new'   -- load new   in table (side effect)
require 'table.clear' -- load clear in table (side effect)

-- globals --------------------------------------------------------------------o

-- uncomment to check invalid use of globals
--local _G_mt = getmetatable(_G)
--setmetatable(_G, {
--  __index    = \_,n error("attempt to read undeclared global variable " .. n, 2),
--  __newindex = \_,n error("attempt to write to undeclared global variable " .. n, 2),
--})

-- implementation -------------------------------------------------------------o

local _hlp = {} -- hidden key

-- special MAD environment
M._C        = _C              -- C symbol access
M.env       = _M              -- M preloaded environment
M.env.arg   = arg             -- backup of arg
M[_hlp]     = {}              -- storage for help
_M          = nil

-- warning, info, trace
local ctrace = trace

trace      = \l,s -> _C.mad_trace_level >= l and ctrace(l,s)
tracelevel = \l   -> _C.mad_trace_level >= l
infolevel  = \l   -> _C.mad_info_level  >= l
warncount  = \    -> _C.mad_warn_count

info_setlevel     = \l => local lvl = _C.mad_info_level
                                      _C.mad_info_level     = l return lvl end
trace_setlevel    = \l => local lvl = _C.mad_trace_level
                                      _C.mad_trace_level    = l return lvl end
trace_setlocation = \l => local lvl = _C.mad_trace_location
                                      _C.mad_trace_location = l return lvl end

-- import

function M.import (self, a, override)
  assert(self == MAD, "invalid argument #1 (MAD expected)")
  if is_string(a) then
    local s = a
    a = require('madl_'..a) or require(a)
    assert(a ~= nil, "module not found: " .. tostring(s))
  end
  override = override or false
  assert(is_rawtable(a)      , "invalid argument #2 (raw table expected)")
  assert(is_boolean(override), "invalid argument #3 (boolean expected)"  )

  -- collect and check first (make a copy in case of error)
  local obj = {}
  for k,v in pairs(a) do
    if string.sub(k,1,2) ~= '__' then
      if tracelevel(3) then
        trace(3, string.format('import: %-25s %-25s',k,v) )
      end
      assert(is_nil(M[k]) or override == true,
             "cannot override definition for " .. tostring(k))
      obj[k] = v
    end
  end
  local hlp = {}
  if is_mappable(a.__help) then
    for k,v in pairs(a.__help) do
      assert(is_nil(M[_hlp][k]) or override == true,
             "cannot override definition for " .. tostring(k))
      hlp[k] = v
    end
  end

  -- finalize the import
  for k,v in pairs(obj) do M      [k] = v  end
  for k,v in pairs(hlp) do M[_hlp][k] = v  end
  return self
end

-- export

function M.export (self, pattern, a, override)
  assert(self == MAD, "invalid argument #1 (MAD expected)")
  if is_boolean(a) then
    override, a = a -- shift args right
  end
  pattern, a = pattern or '', a or _G -- default
  assert(is_string(pattern) or is_rawtable(pattern),
                         "invalid argument #2 (string or raw table expected)")
  assert(is_indexable(a),"invalid argument #3 (indexable expected)")

   -- record matching keys
  if is_string(pattern) then
    local lst = {}
    for k in pairs(M) do
      if is_string(k) and string.sub (k,1,2) ~= '__'
                      and string.find(k, pattern) then
        lst[#lst+1] = k
      end
    end
    pattern = lst
  end

  -- collect and check first (make a copy in case of error)
  local obj = {}
  for _,k in ipairs(pattern) do
    local v = self[k]
    if v then
      if tracelevel(3) then
        trace(3, string.format('export: %-25s %-25s',k,v) )
      end
      assert(is_nil(a[k]) or override == true,
             "cannot override definition for " .. tostring(k))
      obj[k] = v
    end
  end

  -- finalize the export
  for k,v in pairs(obj) do a[k] = v end
  return self
end

-- help

local function gethelp (a)
  local mt = get_metatable(a)
  return (mt and is_rawtable(mt.__help) and mt.__help)        -- 1st metamethod
    or (is_indexable(a) and is_rawtable(a.__help) and a.__help)   -- 2nd member
    or nil
end

function help (a, _chk)
  a = a or 'MAD'
  assert(is_string(a), "invalid argument #1 (string expected)")

  print('help known for:')
  for k,v in pairs(M[_hlp]) do
    io.write(tostring(k),"\n")
  end
  for k,v in pairs(M) do
    io.write(tostring(k),":  ")
    io.write(tostring(gethelp(v)),"\n")
  end
  print('end of known help')

  -- search for help
  local hlp
  for s in string.gmatch(a, "%s*([^.]+)%s*[.]?") do
    print(s)
    hlp = not hlp and (M[_hlp][s] or gethelp(M[s], s) or '') or hlp[s]
    if not hlp or hlp == '' then
      io.write("  No help found for '" .. a .. "'.\n")
      return
    end
  end
  io.write(hlp);

--  local dot = string.find(a, '.', 1, true)
--  local mod = dot and string.sub(a, 1, dot-1) or a
--  local fun = dot and string.sub(a, dot+1) or 'self'
--  for k,v in pairs(MAD[_hlp]) do
--    if k == mod then
--      if is_string(v) then ref, str = MAD[_hlp], v break end
--      if is_indexable(v) and v[fun] then ref, str = v, v[fun] break end
--    end
--    if not dot then
--      if is_indexable(v) and v[mod] then ref, str = v, v[mod] break end
--    end
--  end

  -- find related topics, sort items, and wrap output at 80 columns
--  local sub = {}
--  for k,v in pairs(ref) do
--    if k ~= 'self' and v ~= str and v ~= '' then
--      sub[#sub+1] = k
--    end
--  end
--  table.sort(sub)
--  local len = 2 -- tab
--  for i,v in ipairs(sub) do
--    len = len + #v + 2 -- sep
--    if len > 80 then sub[i] = '\n  '..v ; len = #v + 2 end
--  end
--  str = table.concat(sub, ', ')
--  if str ~= '' then
--    io.write("\nRelated topics:\n  ", str, '.\n')
--  end
end

function checkhelp (a)
  local ref = a.__help and a.__help.self
  assert(ref, "missing help for module "..tostring(a))
  for k in pairs(a) do
    if k ~= '__help' and a.__help[k] == nil then
      io.write('defhelp: no help found for '..a..' item: ',tostring(k),'\n')
    else
      a.__help[k] = ref
    end
  end
  return a
end

-- environment ----------------------------------------------------------------o

M.help = help

-- protect MAD environment (foolproof protection, no more)
MAD = setmetatable({},{
    __index     = M,
    __newindex := error "MAD is readonly",
    __len      := #M,
    __pairs    := pairs(M),
    __ipairs   := ipairs(M),
    __metatable = false,
  })

-- load MAD and modules
MAD:import { MAD = MAD }
for _,m in ipairs(modules) do
  MAD:import(m)
end

-- end ------------------------------------------------------------------------o
