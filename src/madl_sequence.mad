--[=[
 o-----------------------------------------------------------------------------o
 |
 | Sequence module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide sequence object to define lattices

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- locals ---------------------------------------------------------------------o

local option, warn, trace                                        in MAD
local ident, second, bind1st, bind2nd, bind2st                   in MAD.gfunc
local sub, ltrue, lfalse                                         in MAD.operator
local sequence, marker, drift, changedir, flags                  in MAD.element
local minlen, eps                                                in MAD.constant
local strtrim, strsplit, strbracket, bsearch, assertf, errorf,
      openfile                                                   in MAD.utility
local is_nil, is_boolean, is_number, is_integer, is_decimal,
      is_string, is_table, is_rawtable, is_iterable, is_mappable,
      is_callable, is_range, is_element, is_object,
      set_concept, concept                                       in MAD.typeid
local not_mappable, not_extendable, not_mutable                  in concept
local implicit, observed                                         in flags

local abs in math

local type, getmetatable, setmetatable, assert, error, rawequal =
      type, getmetatable, setmetatable, assert, error, rawequal

local ipairs, pairs, tostring, tonumber =
      ipairs, pairs, tostring, tonumber

local string, table, io =
      string, table, io

-- backup original methods and metamethods
local sequence_mt = getmetatable(sequence)
local var_get, var_val, raw_get, is_instanceOf in sequence
local seq_cpy, var_set = sequence.copy, sequence_mt.__newindex
local readonly = sequence.set_readonly

-- root object ----------------------------------------------------------------o

-- special numerical value for elements positions.
local uninitialized = -1e9
local ongoing_init  = -2e9

-- defined in elements
sequence :setvar { dir=1, l=uninitialized,
                   __dat={eidx={}, spos={}, upos={}, ds={}, algn={}, ne=0,}, }

-- identity -------------------------------------------------------------------o

local _id = {} -- identity

local function is_sequence (a)
  local mt = getmetatable(a)
  return mt ~= nil and mt.__sequ == _id
end

local function is_view (a)
  return raw_get(a, '__dat') == nil
end

-- definitions ----------------------------------------------------------------o

-- start and end markers
local mkstart = marker '$start' {} : set_readonly()
local mkend   = marker '$end'   {} : set_readonly()

-- sanity checks --------------------------------------------------------------o

local function seq_error (msg, seq, idx, elm)
  local fun = seq.debug and warn or error
  elm = elm or is_integer(idx) and is_sequence(seq) and seq[idx]
  fun(msg .. (is_object(seq) and " in sequence '" .. seq.__id .. "'" or '')
          .. (is_object(elm) and " for element '" .. elm.__id .. "'" or '')
          .. (          idx  and " at index "     .. idx             or ''), 2)
end

local function seq_poserr (typ, seq, idx, pos)
  local msg = string.format(
    "invalid %s position at s = %.6gm [%.6gm] (negative drift %.6gm)",
             typ,               seq:spos(idx), seq:upos(idx), seq:spos(idx)-pos)
  seq_error(msg, seq, idx, seq[idx])
end

local function seq_uposerr (typ, seq, idx, pos)
  local msg = string.format(
    "invalid %s position at s = %.6gm [%.6gm] (inconsistency in [spos,upos,ds] by %.6gm)",
             typ,               seq:spos(idx), seq:upos(idx),              pos)
  seq_error(msg, seq, idx, seq[idx])
end

local function seq_lenerr (typ, seq, idx, len)
  local msg = string.format(
    "invalid %s length at s = %.6gm [%.6gm] (invalid length %.6gm)",
             typ,             seq:spos(idx), seq:upos(idx), len)
  seq_error(msg, seq, idx, seq[idx])
end

local function seq_lenchg (typ, seq, idx, len)
  local msg = string.format(
    "invalid %s length at s = %.6gm (length changed by %.6gm)",
             typ,             seq:spos(idx),           len)
  seq_error(msg, seq, idx, seq[idx])
end

-- check sequence spos and elements overlapp, clear 'at' and 'from'
local function check_drift (seq, idx)
  local data, ds = seq.__dat
  assert(idx > 1 and idx < data.ne, "unexpected corrupted element index")

  ds = data.spos[idx] - (data.spos[idx-1] + data.ds[idx-1])
  if ds < -minlen then seq_poserr("element", seq, idx, data.spos[idx]-ds) end

  ds = data.spos[idx+1] - (data.spos[idx] + data.ds[idx])
  if ds < -minlen then seq_poserr("element", seq, idx, data.spos[idx]-ds) end

  data[idx].at, data[idx].from = nil, nil
end

-- check shared element
local function check_shared (seq, idx)
  local elm = seq.__dat[idx]
  if is_nil(raw_get(elm, 'l') or raw_get(elm, 'refpos')) then
    return elm.parent
  end
  seq_error("invalid shared element (l or refpos defined)", seq, idx, elm)
end

-- check sequence $start and $stop integrity
local function check_mark (seq)
  local data = seq.__dat
  local n = data.ne
      if not is_instanceOf(data[1], mkstart) then
    error("invalid sequence first element ($start marker expected)", 2)
  elseif not is_instanceOf(data[n], mkend  ) then
    error("invalid sequence last element ($end marker expected)"   , 2)
  end
end

-- check sequence spos and elements overlapp
local function check_pos (seq)
  local data = seq.__dat
  for i=1,data.ne-1 do
    local ds = data.spos[i+1] - (data.spos[i] + data.ds[i])
    if ds < -minlen then
      seq_poserr("element", seq, i, data.spos[i]-ds)
    end
  end

  for i=1,data.ne do
    local el = data[i].l
    local ds = el-data.ds[i]
    if abs(ds) >= minlen then
      seq_lenchg("element", seq, i, ds)
    end

    ds = data.upos[i]-data.spos[i]
    if ds < -minlen or ds-data.ds[i] > minlen then
      seq_uposerr("element", seq, i, ds)
    end

    if data[i].is_thin and el ~= 0 then
      seq_lenerr("thin element", seq, i, el)
    end
  end
end

-- check dictionnary of name -> idx
local function check_index (seq)
  local data = seq.__dat
  local eidx = data.eidx
  local s, e, S, E = eidx['#s'], eidx['#e'], eidx['#S'], eidx['#E']
  assert(is_number(s) and is_number(e) and is_number(S) and is_number(E),
         "unexpected reuse of #s/#e or #S/#E start/stop markers names")

  eidx['#s'], eidx['#e'], eidx['#S'], eidx['#E'] = nil

  -- check dict vs data: name -> index or table of indexes
  for en,ei in pairs(eidx) do
    if is_number(ei) then
      assert(data[ei].__id == en     , "unexpected corrupted dictionnary")
    elseif is_table(ei) then
      assert(data[ei[1]].__id == en  , "unexpected corrupted dictionnary")
      assert(ei.n             >= 2   , "unexpected corrupted dictionnary")
      for i=2,ei.n do
        assert(ei[i-1] < ei[i]       , "unexpected corrupted dictionnary")
        assert(data[ei[i]].__id == en, "unexpected corrupted dictionnary")
      end
    else
      error("unexpected corrupted dictionnary")
    end
  end

  -- check data vs dict: name -> index or table of indexes
  for i=1,data.ne do
    local ei = eidx[data[i].__id]
    if is_number(ei) then
      assert(ei == i                 , "unexpected corrupted dictionnary")
    elseif is_table(ei) then
      local ii
      for j=1,ei.n do
        if ei[j] >= i then ii = ei[j] ; break end
      end
      assert(ii == i                 , "unexpected corrupted dictionnary")
    else
      error("unexpected corrupted dictionnary")
    end
  end

  eidx['#s'], eidx['#e'], eidx['#S'], eidx['#E'] = s, e, S, E
end

local function check_sequ (seq)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(seq.dir == 1 or seq.dir == -1, "invalid direction (1 or -1 expected)")
  -- trace(2, "checking sequence '%s'", seq.name)
  check_pos  (seq)
  check_index(seq)
  check_mark (seq)
  return seq
end

-- helper for mangled names and elements indexes (same as mtable) -------------o

-- reflect indexes
local function ireflect (i, n)
  return i < 0 and n+i+1 or i
end

-- canonize index (direct)
local function index_of_idx (seq, idx)
  local n = seq.__dat.ne
  idx = ireflect(idx, n)
  return idx >= 1 and idx <= n and idx or nil
end

local index_of_fnam -- forward declaration

-- get index of ref (direct)
local function index_of_ref (seq, ref)
  local msg, idx = "invalid reference index (name or index expected)"
  if is_string(ref) then
    idx, msg = index_of_fnam(seq, ref), "invalid reference name '%s'"
  elseif is_integer(ref) then
    idx, msg = index_of_idx (seq, ref), "invalid reference index %d"
  end
  return assertf(idx, msg, ref)
end

-- get index from name [with absolute count] (direct)
local function index_of_cnam (seq, nam, cnt)
  local ei = seq.__dat.eidx[nam]
  if is_table(ei) then
    return ei[ ireflect(cnt, ei.n) ]
  elseif cnt == 1 or cnt == -1 then
    return ei
  end
end

-- get index from name [with relative count] (linear)
local function index_of_rnam (seq, nam, cnt, ref)
  local ei = seq.__dat.eidx[nam]
  if is_nil(ei) then return nil end
  local idx = index_of_ref(seq, ref)
  if is_number(ei) then
    return (cnt ==  1 and ei >= idx and ei) or
           (cnt == -1 and ei <= idx and ei) or nil
  end
  if cnt > 0 then
    for i=1,ei.n do
      if ei[i] >= idx then return ei[i+cnt-1] end
    end
  elseif cnt < 0 then
    for i=ei.n,1,-1 do
      if ei[i] <= idx then return ei[i+cnt+1] end
    end
  end
end

-- get index from s-position (binary)
local function index_of_num (seq, num, ref_, dir_)
  local data = seq.__dat
  if ref_ then num = data.upos[index_of_ref(seq,ref_)] + num end
  if num < 0 or num > seq.l then return nil end
  local idx, dir = bsearch(data.spos, num), dir_ or 1 -- num <= spos[idx]
  assert(dir == 0 or dir == 1 or dir == -1, "invalid direction (0, 1 or -1 expected)")
  if idx > 1 and num < data.spos[idx] then
    local epos = data.spos[idx-1] + data.ds[idx-1] + minlen
    if dir < 0 or num < epos then
      idx = idx-1
    elseif dir == 0 and num > epos then
      idx = idx-0.5 -- implicit drift
    end
  end
  return idx, num
end

-- get index from [mangled] name or s-position (direct or linear)
local function index_of_str (seq, str, ref_, dir_)
  local num = tonumber(str)
  if num then return index_of_num(seq, num, ref_, dir_) end
  local nam, cnt, _, bra = strbracket(str)
  cnt = is_nil(cnt) and 1 or tonumber(cnt)
  assert(is_integer(cnt) and cnt ~= 0, "invalid argument #2 (non-zero count expected)")
  if is_nil(ref_) or bra == 1 then
    return index_of_cnam(seq, nam, cnt      )
  else
    return index_of_rnam(seq, nam, cnt, ref_)
  end
end

-- get index from 'from' [mangled] name (direct or linear)
function index_of_fnam (seq, nam, ref_) -- already declared local
  assert(is_string(nam), "invalid argument #2 (string expected)")
  local nam, cnt, _, bra = strbracket(nam)
  cnt = is_nil(cnt) and 1 or tonumber(cnt)
  assert(is_integer(cnt) and cnt ~= 0, "invalid argument #2 (non-zero count expected)")
  if is_nil(ref_) or bra ~= 2 then -- need both for relative from
    return index_of_cnam(seq, nam, cnt      ), bra
  else
    return index_of_rnam(seq, nam, cnt, ref_), bra
  end
end

-- get index from element (linear)
local function index_of_elm (seq, elm, ref_, dir_)
  local nam, data = elm.__id, seq.__dat
  local ei = data.eidx[nam]
  if is_nil(ei) then return nil end
  local idx = ref_ and index_of_ref(seq, ref_) or 1
  if is_number(ei) then
    return ei >= idx and data[ei] == elm and ei or nil
  end
  local dir = dir_ or 1
  assert(dir == 1 or dir == -1, "invalid direction (1 or -1 expected)")
  if dir == 1 then
    for i=1,ei.n do
      if ei[i] >= idx and data[ei[i]] == elm then return ei[i] end
    end
  else
    for i=ei.n,1,-1 do
      if ei[i] <= idx and data[ei[i]] == elm then return ei[i] end
    end
  end
end

-- get [mangled] name from index (linear)
local function name_of_idx (seq, idx, ref_)
  local data = seq.__dat
  idx = index_of_idx(seq, idx)
  if is_nil(idx) then return nil end
  local nam = data[idx].__id
  local ei = data.eidx[nam]
  if is_number(ei) then
    assert(ei == idx, "unexpected corrupted dictionnary")
    return nam
  end

  local cnt, b1, b2 = 0
  if ref_ then
    local idx = index_of_ref(seq, ref_)
    for i=1,ei.n do
      if ei[i] < idx then cnt = cnt+1 else break end
    end
    b1, b2 = "{", "}"
  else
    b1, b2 = "[", "]"
  end

  for i=1,ei.n do
    if ei[i] == idx then
      if cnt >= i then cnt = cnt+1 end
      return string.format("%s%s%d%s", nam, b1, i-cnt, b2)
    end
  end
  error("unexpected corrupted dictionnary")
end

-- position helpers -----------------------------------------------------------o

-- forward declaration
local elem_pos

-- return user-defined position of 'from'
local function from_upos (seq, from, idx)
  local data = seq.__dat
  if data.last_from ~= from then                     -- memoized?
    local idx, bra = index_of_fnam(seq, from, idx)
    if is_nil(idx) then                              -- not found
      seq_error("invalid from of '" .. from .. "'", seq, idx)
    end
    data.last_frompos = second(elem_pos(seq, idx))
    data.last_from = bra ~= 2 and from or nil        -- memoize if not relative
  end
  return data.last_frompos                           -- upos
end

-- return user-defined position of 'refpos'
local function refpos_upos (elm, refpos, idx)
  if #elm == 0 or not is_sequence(elm) then
    -- if not is_element(elm[rpos]) then
    seq_error("invalid refpos to subelement '" .. refpos .. "'", elm, idx)
  end
  return from_upos(elm, refpos)
end

-- forward index
-- return (#elm-1)+1 because seq[idx] == sseq[2] (see copy_ssequ and sequ_pos).
local function fidx (elm)
  return is_sequence(elm) and #elm or 1
end

local function fpos (at, elen, spos, upos)
  return at and upos or spos+elen
end

-- build positions ------------------------------------------------------------o

-- return user-defined position of 'refpos'
local function refpos_pos (seq, elm, idx)
  local refpos = elm.refpos or seq.refer or 'centre'
  local rpos

      if refpos == 'entry'  then rpos = 0
  elseif refpos == 'centre' then rpos = elm.l/2
  elseif refpos == 'exit'   then rpos = elm.l
  elseif is_number(refpos)  then rpos = refpos
  else                           rpos = refpos_upos(elm, refpos, idx)
  end
  return rpos
end

-- return user-defined position of 'from'
local function from_pos (seq, elm, idx)
  local at   = elm.at
  local from = elm.from or at and (at>=0 and 'start' or 'end') or 'prev'
  local upos = at or refpos_pos(seq, elm, idx)

      if from == 'start'    then ;
  elseif from == 'prev'     then upos = upos + fpos(at, seq[idx-1].l, elem_pos(seq,idx-1        ))
  elseif from == 'next'     then upos = upos + fpos(at,       -elm.l, elem_pos(seq,idx+fidx(elm)))
  elseif from == 'end'      then upos = upos + seq.l
  elseif from == 'selected' then upos = upos + seq:upos(idx)
  elseif is_number(from)    then upos = upos + from
  else                           upos = upos + from_upos(seq,from,idx)
  end
  return upos
end

-- set s-positions at index or return element s-positions
-- already declared for forward use, *must not be local*
function elem_pos (seq, idx, elm_)
  local data = seq.__dat
  local spos = data.spos[idx]
  if is_nil(spos) then
    seq_error("invalid index or reference detected", seq, idx, elm_)
  elseif is_nil(elm_) then
    if spos >= 0 then
      return spos, data.upos[idx]
    elseif spos == ongoing_init then
      seq_error("cycling dependencies detected", seq, idx)
    elseif spos ~= uninitialized then
      seq_error("corrupted s-position detected", seq, idx)
    end
    data.spos[idx] = ongoing_init
  end

  local elm  = elm_ or data[idx]
  local upos =   from_pos(seq, elm, idx)
  local rpos = refpos_pos(seq, elm, idx)
  spos = upos - rpos

  if is_nil(elm_) then
    data.spos[idx], data.upos[idx], data.ds[idx] = spos, upos, elm.l
  end
  return spos, upos
end

-- set s-positions of elements from their sub sequence
local function sequ_pos (seq, sseq, idx, dir)
  check_mark(sseq)
  local pos = elem_pos(seq, idx, sseq)    -- shift by subsequence refpos
  local data, sdata = seq.__dat, sseq.__dat

!  if seq.dir ~= sseq.dir then -- changedir patch
!    data.spos[idx] = sdata.spos[1] + pos
!    data.upos[idx] = sdata.upos[1] + pos
!    data.ds  [idx] = sdata.ds  [1]
!    data.algn[idx] = sdata.algn[1]
!    idx = idx + 1
!  end

  local n = sdata.ne
  if dir > 0 then
    for i=1,n do
      local ix = idx-1+i
      data.spos[ix] = sdata.spos[i] + pos
      data.upos[ix] = sdata.upos[i] + pos
      data.ds  [ix] = sdata.ds  [i]
      data.algn[ix] = sdata.algn[i]
      assert(data[ix] == sdata[i], "unexpected corrupted flat sequence")
    end
  elseif dir < 0 then
    local l = sseq.l
    for i=1,n do
      local ix, ii = idx-1+i, n+1-i
      local sp, ds = sdata.spos[ii], sdata.ds[ii]
      data.spos[ix] = l - (sp + ds                      ) + pos
      data.upos[ix] = l - (sp + ds - sdata.upos[ii] + sp) + pos
      data.ds  [ix] = ds
      data.algn[ix] = sdata.algn[ii]
      assert(data[ix] == sdata[ii], "unexpected corrupted flat sequence")
    end
  else
    error("invalid direction (1 or -1 expected)")
  end

!  if seq.dir ~= sseq.dir then -- changedir patch
!    data.spos[idx+n] = sdata.spos[n] + pos
!    data.upos[idx+n] = sdata.upos[n] + pos
!    data.ds  [idx+n] = sdata.ds  [n]
!    data.algn[idx+n] = sdata.algn[n]
!    idx = idx + 1
!  end

  return idx+n
end

-- compute elements positions
local function build_pos (seq, sref)
  local data = seq.__dat
  local n, idx, pos = data.ne, 1, 0
  for i=1,n do
    if data[i].from == 'selected' then
      seq_error("invalid from='selected' detected", seq, i, data[i])
    end
    data.spos[i] = uninitialized
  end
  while idx <= n do
    local sseq = sref[idx]
    if is_nil(sseq) then     -- element
      elem_pos(seq, idx)     -- set element positions
      if data.spos[idx]-pos < -minlen then -- see check_pos
      -- if pos-minlen > data.spos[idx] then
        seq_poserr('element', seq, idx, pos)
      elseif data[idx].is_thin and data.ds[idx] ~= 0 then
        seq_lenerr("thin element", seq, idx, data[idx].l)
      end
      if data[idx].shared == true then -- shared element
        data[idx] = check_shared(seq, idx)
      end
      pos = data.spos[idx]+data.ds[idx]
      idx = idx + 1
    else                     -- subsequence
      local nidx = sequ_pos(seq, sseq, idx, sref.sdir[idx])
      if pos-minlen > data.spos[idx] then
        seq_poserr('subsequence', seq, idx, pos)
      end
      local sdata = sseq.__dat
      pos = data.spos[idx] - sdata.spos[1] + sseq.l
      idx = nidx
    end
  end
  assert(n == idx-1, "unexpected corrupted flat sequence")

  local len = data.spos[n]
  if seq.l == uninitialized then
    seq.l = len
  elseif seq.l < len then
    error("invalid sequence length "..seq.l.."m for "..seq.__id)
  end

  -- clear 'at' and 'from' of elements
  for i=1,n do data[i].at, data[i].from = nil, nil end
end

-- flatten sequence -----------------------------------------------------------o

-- copy sub sequence
local function copy_ssequ (seq, flat, sref, idx, dir)
  local data = seq.__dat
  local n = data.ne
  if n == 0 then return idx end -- view

  check_mark(seq)

  sref[idx], sref.sdir[idx] = seq, dir -- link subsequence

!  if sref.dir ~= seq.dir then -- insert changedir patch
!    idx, flat[idx] = idx+1, changedir(seq.__id.."_chdir", {})
!  end

      if dir ==  1 then
    for i=1,n do flat[idx-1+i] = data[i    ] end
  elseif dir == -1 then
    for i=1,n do flat[idx-1+i] = data[n+1-i] end
  else
    error("invalid direction (1 or -1 expected)")
  end

!  if sref.dir ~= seq.dir then
!    idx, flat[idx+n] = idx+1, flat[idx-1] -- share patch
!  end

  return idx+n
end

-- flatten lines and subsequence
local function flatten_line (line, flat, sref, idx, dir)
  local n, rep = #line, (line.__rep or 1) * dir
  if n == 0 or rep == 0 then return idx end

  local start, stop, step
  if rep < 0
  then rep, start, stop, step = -rep, n, 1, -1
  else rep, start, stop, step =  rep, 1, n,  1
  end

  for i=1,rep do
  for j=start,stop,step do
    local elm = line[j]
    if not (is_element(elm) or is_rawtable(elm)) then
      seq_error("invalid element detected", line, j)
    elseif elm.is_bline == true or is_rawtable(elm) then
      -- TODO: keep track of l, dir, refpos and refer like for sequence...
      idx = flatten_line(elm, flat, sref, idx, step)
    elseif not is_nil(sref) and is_sequence(elm) then
      idx = copy_ssequ  (elm, flat, sref, idx, step)
    else -- other elements
      idx, flat[idx] = idx+1, elm
    end
  end end
  return idx
end

-- flatten sequence
local function flatten_sequ (seq, flat, sref)
  local n, idx = seq:raw_len(), 2
  flat[1] = mkstart {at=0}
  for i=1,n do
    local elm = seq:raw_get(i)
    if not (is_element(elm) or is_rawtable(elm)) then
      seq_error("invalid element detected", seq, i)
    elseif elm.is_bline == true or is_rawtable(elm) then
      idx = flatten_line(elm, flat, sref, idx, 1)
    elseif is_sequence(elm) then
      idx = copy_ssequ  (elm, flat, sref, idx, 1)
    else -- other elements
      idx, flat[idx] = idx+1, elm
    end
  end
  flat[idx] = mkend {at= seq.l~=uninitialized and seq.l or nil}
                    :set_flags(observed)
  assert(n <= idx, "unexpected corrupted flat sequence")
end

-- dict helper ----------------------------------------------------------------o

-- build dictionnary name -> idx
local function build_idx (data)     -- must be very fast
  local eidx = data.eidx
  table.clear(eidx)                 -- reuse main storage
  for idx,elm in ipairs(data) do
    local nam = elm.__id
    local val = eidx[nam]
    if is_nil(val) then             -- none: scalar
      eidx[nam] = idx
    elseif is_number(val) then      -- one : scalar to array
      eidx[nam] = {val, idx, n=2}
    else                            -- many: append
      local n = val.n+1
      val[n], val.n = idx, n
    end
  end
end

-- build sequence -------------------------------------------------------------o

-- remove subsequence markers (if any)
local function clear_sub (seq, sref)
  if is_nil(next(sref.sdir)) then return end
  local data = seq.__dat
  local spos, upos, ds, algn, ne in data
  local j, n, nam = 2, ne
  for i=2,n-1 do
    nam = data[i].__id
    if not (nam == '$start' and is_instanceOf(data[i], mkstart) or
            nam == '$end'   and is_instanceOf(data[i], mkend))  then
      data[j], spos[j], upos[j], ds[j], algn[j], j =
      data[i], spos[i], upos[i], ds[i], algn[i], j+1
    end
  end
  data[j], spos[j], upos[j], ds[j], algn[j], data.ne =
  data[n], spos[n], upos[n], ds[n], algn[n], j
  for i=j+1,n do -- clear remaining slots
    data[i], spos[i], upos[i], ds[i], algn[i] = nil, nil, nil, nil, nil
  end
  build_idx(data)
end

-- finalize sequence
local function finish_sequ (seq)
  local data = seq.__dat

  -- clear memoization
  data.last_from    = nil
  data.last_frompos = nil

  -- $start/$end markers aliases
  local ei, ne = data.eidx, data.ne
  ei['#s'], ei['#S'] =  1,  1
  ei['#e'], ei['#E'] = ne, ne

  -- clear cycle (if any)
  seq:raw_set('__cycle', nil)

  -- sanity checks
  check_mark(seq)
  if option.debug >= 2 then check_sequ(seq) end

  -- publish sequence in MADX environment
  if option.madxenv then seq:publish(MADX, true) end
end

-- sequence init (build)
local function init_mm (seq)
  local n, owner = seq:raw_len(), raw_get(seq, 'owner')
  if n == 0 and owner ~= true then return seq end -- view

  local sref = { dir=seq.dir, sdir={} }
  local data = table.new(n+2,8)

  flatten_sequ(seq, data, sref)
  seq:clear_array()

  local ne = #data
  data.eidx = table.new(0,ne)
  data.spos = table.new(ne,0)
  data.upos = table.new(ne,0)
  data.ds   = table.new(ne,0)
  data.algn = table.new(ne,0)
  seq.__dat, data.ne = data, ne

  build_idx(data)
  build_pos(seq, sref)
  clear_sub(seq, sref)
  finish_sequ(seq)
  return seq
end

local function copy_mm (seq, name_, owner_)
  if is_nil(owner_) and is_boolean(name_) then
    owner_, name_ = name_  -- right shift
  end
  assert(not rawequal(seq, sequence), "invalid argument #1 (cannot copy 'sequence')")
  assert(is_sequence(seq)           , "invalid argument #1 (sequence expected)")
  local cpy = seq_cpy(seq,name_)
  if is_view(seq) and owner_ ~= true then return cpy end

  local data = seq.__dat
  local ne = data.ne
  local cdata = table.new(ne,5)  -- see init_mm
  cdata.eidx  = table.new(0,ne)
  cdata.spos  = table.new(ne,0)
  cdata.upos  = table.new(ne,0)
  cdata.ds    = table.new(ne,0)
  cdata.algn  = table.new(ne,0)
  cpy.__dat, cdata.ne = cdata, ne

  for i=1,ne do
    cdata[i] = data[i]:copy()
    cdata.spos[i], cdata.upos[i], cdata.ds[i], cdata.algn[i] =
     data.spos[i],  data.upos[i],  data.ds[i],  data.algn[i]
  end

  build_idx(cdata)
  finish_sequ(cpy)
  return cpy
end

-- sequence metamethods -------------------------------------------------------o

local function cnt_iter (s, i)
  i = i+1
  local ei = s.__idx[i]
  if ei then return i, s.__dat[ei] end
end

local cnt_mt = set_concept({
  __len       =\s   -> s.__idx.n,
  __index     =\s,i -> s.__dat[s.__idx[i]],
  __ipairs    =\s   -> (cnt_iter, s, 0),
  __tostring  =\s   -> string.format("sequence count: %p", s),
}, not_mappable + not_extendable + not_mutable)

-- number of elements
local function len_mm (seq)
  return seq.__dat.ne
end

-- read access precedence: element index, variable key, element name.
local function index_mm (seq, key)
  -- element index
  if type(key) == 'number' then                              -- see index_of_idx
    local data = seq.__dat
    return data[ ireflect(key, data.ne) ]
  end
  -- variable (or method)
  local var = var_get(seq, key)
  if type(var) ~= 'nil' then
    return var_val(seq, key, var)
  end
  -- element name
  local data = seq.__dat
  local idx = data.eidx[key]
  if type(idx) == 'number' then
    return data[idx]
  elseif is_table(idx) then
    return setmetatable({__idx=idx, __dat=data}, cnt_mt)
  end
  return nil
end

local function newindex_mm (seq, key, val)
  -- element index or name
  if type(key) == 'number' or seq.__dat.eidx[key] then
    error("invalid sequence write access (use replace method)")
  end
  -- variable
  var_set(seq, key, val)
end

-- readonly protection --------------------------------------------------------o

local function set_readonly (seq, set_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = raw_get(seq,'__dat')
  if data then
    set_ = set_ ~= false and true or false
    if set_ ~= seq:is_readonly() then
      data.ro = set_
    end
  end
  return readonly(seq, set_)
end

-- methods (readonly) ---------------------------------------------------------o

local function index (seq, idx)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(is_integer (idx), "invalid argument #2 (integer expected)")
  return index_of_idx(seq, idx)
end

local function name_of (seq, idx, ref_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(is_integer (idx), "invalid argument #2 (integer expected)")
  return name_of_idx(seq, idx, ref_)
end

local function index_of (seq, a, ref_, dir_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
      if is_number (a) then return index_of_num(seq, a, ref_, dir_)
  elseif is_string (a) then return index_of_str(seq, a, ref_, dir_)
  elseif is_element(a) then return index_of_elm(seq, a, ref_, dir_)
  end
  errorf("invalid argument #2 (number, string or element expected, got %s)",
          tostring(a))
end

local function range_of (seq, rng_, ref_, dir_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local start, stop, step, istart, istop, dir, doidx
  if is_nil(rng_) then
    dir = dir_ or 1
        if dir ==  1 then return 1, #seq,  1
    elseif dir == -1 then return #seq, 1, -1
    else error("invalid range direction (1 or -1 expected)")
    end
  elseif is_number(rng_) then
    start, istart = rng_, index_of_num(seq, rng_, ref_, dir_)
    stop , istop  = start, istart
  elseif is_string(rng_) then
    local s1, i2 = strsplit(rng_, "/")
    local s2 = i2 == 0 and s1 or strtrim(rng_, i2+1)
    doidx, start, stop = true, s1, s2
  elseif is_range(rng_) then
    doidx, start, stop, step = true, rng_:ranges()
    dir_ = dir_ or step
  elseif is_rawtable(rng_) then
    start, stop, ref_, dir_ = rng_[1], rng_[2] or rng_[1], ref_ or rng_[3],
                                                           dir_ or rng_[4]
    if ref_ == 'idx' then
      assert(is_integer(start) and is_integer(stop),
             "invalid argument #2 (range of integers expected)")
      istart, istop = index_of_idx(seq, start), index_of_idx(seq, stop)
    else doidx = true
    end
  else
    errorf("invalid argument #2 (number, string, table or range expected, got %s)",
           tostring(rng_))
  end
  dir = dir_ or 1
  assert(dir == 1 or dir == -1, "invalid range direction (1 or -1 expected)")
  local sstart, sstop
  if doidx then
    istart, sstart = index_of(seq, start, ref_,  dir)
    istop , sstop  = index_of(seq, stop , ref_, -dir)
  end
  if not istart then errorf("invalid range start '%s'", tostring(start)) end
  if not istop  then errorf("invalid range stop '%s'" , tostring(stop )) end
  if sstart and sstop and (istart-istop)*(sstart-sstop) < 0 then
    return nil -- empty range
  end
  return istart, istop, dir
end

local function length_of (seq, rng_, ntrn_, dir_) -- see iter
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local start, stop, dir = range_of(seq, rng_, nil, dir_)
  if is_nil(start) then return 0 end
  local siz, trn = (stop-start)*dir, ntrn_ or 1
  return 1 + siz + #seq * (trn-1 + (siz < 0 and 1 or 0))
end

-- functional methods ---------------------------------------------------------o

local pcls   = is_instanceOf
local psel   = marker.is_selected
local ptbl   = \tbl, e,_ -> tbl[e.__id]
local pnam   = \pat, e,_ -> string.match(e.__id, pat) ~= nil
local pand   = \p,p2,e,i -> p(e,i) and p2(e,i)
local ptrue  = \p,_ ,e,i -> p(e,i) and true
local pfalse = \p,_ ,e,i -> p(e,i) or false

local function foreach (seq, act, rng_, sel_, not_) -- action, range, selection, default
  local f, p

  -- foreach(sel) -> foreach(sel.action, sel)
  if is_nil(rng_) and is_rawtable(act) then
    f, rng_ = act.action, act     -- extract action + right shift
  else
    f = act
  end
  -- foreach(act,sel) -> foreach(act, sel.range, sel)
  if is_nil(sel_) and is_rawtable(rng_) and is_nil(rng_[1]) then
    rng_, sel_ = rng_.range, rng_ -- extract range  + right shift
  end

  if is_rawtable(sel_) then       -- logically and'ed selections
    if is_nil(not_) and (sel_.default == 'none' or sel_.default == true) then
      not_ = true
    end
    local op = not_ ~= true and ptrue or pfalse
    if sel_.select then
      assert(is_callable(sel_.select), "invalid select (callable expected)")
      op, p = pand, bind2st(op, sel_.select, p)
    end
    if sel_.table then
      assert(is_mappable(sel_.table), "invalid table (mappable expected)")
      op, p = pand, bind2st(op, bind1st(ptbl, sel_.table), p)
    end
    if sel_.class then
      assert(is_element(sel_.class), "invalid class (element expected)")
      op, p = pand, bind2st(op, bind2nd(pcls, sel_.class), p)
    end
    if sel_.pattern then
      assert(is_string(sel_.pattern), "invalid pattern (string expected)")
      op, p = pand, bind2st(op, bind1st(pnam, sel_.pattern), p)
    end
    if sel_.flag then
      assert(is_number(sel_.flag), "invalid flag (number expected)")
      op, p = pand, bind2st(op, bind2nd(psel, sel_.flag), p)
    end
  elseif not is_nil(sel_) then    -- build the selection
    p = is_number  (sel_) and bind2nd(psel, sel_) or
        is_string  (sel_) and bind1st(pnam, sel_) or
        is_element (sel_) and bind2nd(pcls, sel_) or
        is_mappable(sel_) and bind1st(ptbl, sel_) or
        is_callable(sel_) and sel_                or nil
  end
  if is_nil(p) then p = (not_ ~= true or rng_) and ltrue or lfalse end

  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(is_callable(f)  , "invalid argument #2 (callable expected)")
  assert(is_callable(p)  , "invalid argument #4 (callable expected)")

  if p ~= lfalse then
    for idx,elm in seq:iter(rng_) do
      if p(elm,idx) then f(elm,idx) end
    end
  end
  return seq
end

local do_select = marker.select

local function select (seq, flg_, rng_, sel_, not_)
  if is_rawtable(flg_) and is_nil(rng_) and is_nil(sel_) then
    rng_, flg_ = flg_ -- right shift
  end
  local f = bind2nd(do_select, flg_)
  return seq:foreach(f, rng_, sel_, not_)
end

local do_deselect = marker.deselect

local function deselect (seq, flg_, rng_, sel_, not_)
  if is_rawtable(flg_) and is_nil(rng_) and is_nil(sel_) then
    rng_, flg_ = flg_ -- right shift
  end
  local f = bind2nd(do_deselect, flg_)
  return seq:foreach(f, rng_, sel_, not_)
end

local do_filter = \ei,_,i => local n=ei.n+1 ; ei[n], ei.n = i, n end

local function filter (seq, rng_, sel_, not_)
  local ei = table.new(8,1)
  local f = bind1st(do_filter, ei)
  ei.n = 0
  seq:foreach(f, rng_, sel_, not_)
  local n = ei.n ; ei.n = nil
  return ei, n
end

-- methods (R/W), no dict change ----------------------------------------------o

local function move (seq, rng_, sel_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = seq.__dat
  assert(not (data.ro or seq:is_readonly()), "invalid write access to readonly sequence")

  -- collect indexes of elements to move
  local idx_m, ne = filter(seq, rng_, sel_, true)
  if ne == 0 then return end

  -- basic check...
  assert(idx_m[ne]-idx_m[1] >= ne-1, "invalid range, indexes must be increasing")

  -- remove $start/$stop markers from the list of elements to move
  if idx_m[ne] == #seq then table.remove(idx_m)    ; ne = ne-1 end
  if idx_m[1 ] == 1    then table.remove(idx_m, 1) ; ne = ne-1 end

  -- update elements positions
  for i=1,ne do data.spos[idx_m[i]] = uninitialized end
  for i=1,ne do elem_pos(seq   , idx_m[i])          end
  for i=1,ne do check_drift(seq, idx_m[i])          end

  return seq
end

local function misalign (seq, mis, rng_, sel_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = seq.__dat
  assert(not (data.ro or seq:is_readonly()), "invalid write access to readonly sequence")

  -- collect indexes of elements to misalign
  local idx_m, ne = filter(seq, rng_, sel_, true)
  if ne == 0 then return end

  -- basic check...
  assert(idx_m[ne]-idx_m[1] >= ne-1, "invalid range, indexes must be increasing")

  -- remove $start/$stop markers from the list of elements to misalign
  if idx_m[ne] == #seq then table.remove(idx_m)    ; ne = ne-1 end
  if idx_m[1 ] == 1    then table.remove(idx_m, 1) ; ne = ne-1 end

  -- set/update elements misalignment
  if is_mappable(mis) then
    if #mis == 0 then              -- same (random) misalignment for all
      for i=1,ne do
        data.algn[idx_m[i]] = {
          dx    =mis.dx     or 0, dy  =mis.dy   or 0, ds  =mis.ds   or 0,
          dtheta=mis.dtheta or 0, dphi=mis.dphi or 0, dpsi=mis.dpsi or 0
        }
      end
    else                           -- specific (random) misalignment for all
      for i=1,ne do
        local algn = mis[idx_m[i]]
        if algn then
          data.algn[idx_m[i]] = {
            dx    =algn.dx     or 0, dy  =algn.dy   or 0, ds  =algn.ds   or 0,
            dtheta=algn.dtheta or 0, dphi=algn.dphi or 0, dpsi=algn.dpsi or 0
          }
        end
      end
    end
  elseif is_callable(mis) then     -- specific (functional) misalignment for all
    for i=1,ne do
      local algn = mis(idx_m[i])
      if algn then
        data.algn[idx_m[i]] = {
          dx    =algn.dx     or 0, dy  =algn.dy   or 0, ds  =algn.ds   or 0,
          dtheta=algn.dtheta or 0, dphi=algn.dphi or 0, dpsi=algn.dpsi or 0
        }
      end
    end
  else error("invalid argument #2 (iterable or callable expected)") end

  return seq
end

-- methods (R/W, rebuild dict) ------------------------------------------------o

local function build_index (seq)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = seq.__dat
  build_idx (data)
  finish_sequ(seq)
  return seq
end

local function remove (seq, rng_, sel_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = seq.__dat
  assert(not (data.ro or seq:is_readonly()), "invalid write access to readonly sequence")

  -- collect indexes of elements to remove
  local idx_r, nr = filter(seq, rng_, sel_, true)
  if nr == 0 then return end

  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")
  assert(idx_r[ 1] > 1             , "invalid range, $start marker selected")
  assert(idx_r[nr] < data.ne       , "invalid range, $end marker selected")

  -- remove elements by decreasing indexes -- to optimize to avoid O(N^2) removal
  local dbg = option.debug > 1
  local elm_r = table.new(nr,0)
  for i=nr,1,-1 do
    local ii = idx_r[i]
    if dbg then
      io.write("seq: removing element '", data[ii].__id, "'\n")
    end
    elm_r[i] = data[ii]    -- backup
    table.remove(data     , ii)
    table.remove(data.spos, ii)
    table.remove(data.upos, ii)
    table.remove(data.ds  , ii)
    table.remove(data.algn, ii)
  end
  data.ne = data.ne - nr
  build_index(seq)
  return elm_r, idx_r
end

local function replace (seq, elm, rng_, sel_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = seq.__dat
  assert(not (data.ro or seq:is_readonly()), "invalid write access to readonly sequence")

  if is_rawtable(elm) and is_nil(rng_) and is_nil(sel_) and elm.elements then
    rng_, elm = elm, elm.elements -- extract elements + right shift
  end

  if is_element(elm) then elm = {elm} end
  assert(is_rawtable(elm), "invalid argument #2 (elements list expected)")
  local ne = #elm
  if ne == 0 then return end

  -- check for elements only
  for i=1,ne do
    if not is_element(elm[i]) then
      error("item is not an element '"..
        (is_object(elm[i]) and (elm[i].__id or '?') or type(elm[i])).."'")
    elseif is_sequence(elm[i]) then
      error("element is a sequence '"..(elm[i].__id or '?').."'")
    elseif elm[i].is_bline == true then
      error("element is a beam line '"..(elm[i].__id or '?').."'")
    end
  end

  -- collect indexes of elements to replace
  local idx_r, nr = filter(seq, rng_, sel_, true)
  if nr == 0 then return end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  local elm_r = table.new(nr,0)
  for i=1,nr do                                -- replace elements
    local ii, ie = idx_r[i], (i-1)%ne+1        -- recycle list of elements
    data[ii], elm_r[i] = elm[ie], data[ii]     -- backup
    data.spos[ii] = uninitialized
  end
  for i=1,nr do elem_pos(seq, idx_r[i]) end    -- recompute the positions
  for i=1,nr do
    local idx = idx_r[i]
    if data[idx].shared == true then           -- shared element
      data[idx] = check_shared(seq, idx)
    end
    check_drift(seq, idx)                      -- check surrounding drifts
  end

  build_index(seq)
  return elm_r, idx_r
end

local function install (seq, elm, rng_, sel_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = seq.__dat
  assert(not (data.ro or seq:is_readonly()), "invalid write access to readonly sequence")

  if is_rawtable(elm) and is_nil(rng_) and is_nil(sel_) and elm.elements then
    rng_, elm = elm, elm.elements -- extract elements + right shift
  end

  if is_element(elm) then elm = {elm} end
  assert(is_rawtable(elm), "invalid argument #2 (elements list expected)")
  local ne = #elm
  if ne == 0 then return seq end

  -- collect indexes of reference where to insert
  local idx_r, nr = filter(seq, rng_, sel_, true)
  if nr > 0 then
    assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")
  end

  -- collect elements and subsequences to install
  local ins = table.new(ne,0) -- no sref -> keep subsequence as-is
  flatten_line(elm, ins, nil, 1, 1)
  elm, ne, ins = ins, #ins -- update

  -- precompute number of elements with from='selected'
  local ns = 0
  for i=1,ne do
    if elm[i].from == 'selected' then
      if is_sequence(elm[i]) then
        error("invalid from 'selected' for sequence "..(elm[i].__id or '?'))
      end
      ns = ns+1
    end
  end

  -- precompute position of each element
  -- ne: #element to install, ns: #element with from='selected', nr: #element selected
  -- ne-ns: #element to install once, ns*nr: ns elements to install nr times
  local i, ni = 0, ne-ns + ns*nr
  local ins, spos, upos = table.new(ni,0), table.new(ni,0), table.new(ni,0)
  for ie=1,ne do
    local e = elm[ie]
    if e.from ~= 'selected' then
      i = i + 1
      ins[i], spos[i], upos[i] = e, elem_pos(seq, 2        , e)
    else for ir=1,nr do
      i = i + 1
      ins[i], spos[i], upos[i] = e, elem_pos(seq, idx_r[ir], e)
    end end
  end

  -- insert elements -- need to be optimized to avoid O(N^2) insertion
  local dbg = option.debug > 1
  for ie=1,i do
    local idx = bsearch(data.spos, spos[ie], 2, data.ne)
    if is_sequence(ins[ie]) and #ins[ie] > 2 then
      local sdata = ins[ie].__dat
      table.move(data     , idx, data.ne, idx+sdata.ne-2)
      table.move(data.spos, idx, data.ne, idx+sdata.ne-2)
      table.move(data.upos, idx, data.ne, idx+sdata.ne-2)
      table.move(data.ds  , idx, data.ne, idx+sdata.ne-2)
      table.move(data.algn, idx, data.ne, idx+sdata.ne-2)
      for j=2,sdata.ne-1 do -- see sequ_pos
        if dbg then
          io.write("seq: installing element '", sdata[j].__id, "'\n")
        end
        data     [idx+j-2] = sdata     [j]
        data.spos[idx+j-2] = sdata.spos[j]+spos[ie]
        data.upos[idx+j-2] = sdata.upos[j]+spos[ie]
        data.ds  [idx+j-2] = sdata.ds  [j]
        data.algn[idx+j-2] = sdata.algn[j]
      end
      data.ne = data.ne + sdata.ne - 2
      check_drift(seq, idx+sdata.ne - 3) -- check surrounding drifts of lst data
    else
      if dbg then
        io.write("seq: installing element '", ins[ie].__id, "'\n")
      end
      table.insert(data     , idx, ins [ie])
      table.insert(data.spos, idx, spos[ie])
      table.insert(data.upos, idx, upos[ie])
      table.insert(data.ds  , idx, ins [ie].l)
      table.insert(data.algn, idx, nil)
      data.ne = data.ne + 1
      if data[idx].shared == true then   -- shared element
        data[idx] = check_shared(seq, idx)
      end
      check_drift(seq, idx)              -- check surrounding drifts
    end
  end

  build_index(seq)
  return seq
end

-- special --------------------------------------------------------------------o

local function publish (seq, env, keeporig_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(is_mappable(env), "invalid argument #2 (mappable expected)")
  if not keeporig_ then
    for _,elm in ipairs(seq) do env[elm.name] = elm end
    return seq
  end

  local wrn
  if env == MADX or is_instanceOf(env, MADX) then
    wrn, env.option.warn = env.option.warn, false
  end
  local data = seq.__dat
  for idx,elm in ipairs(seq) do
    local nam = elm.__id
    if is_element(env[nam]) then data[idx] = env[nam] else env[nam] = elm end
  end
  if wrn ~= nil then env.option.warn = wrn end
  return seq
end

local function reflect (seq, nam_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local nam = nam_ or seq.__id..'_rev'
  return sequence(nam, { -seq })
end

local function cycle (seq, a)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(index_of(seq, a), "invalid argument #2 (valid reference expected)")
  assert(not seq:is_readonly(), "invalid write access to readonly sequence")
  seq:raw_set('__cycle', a)
  return seq
end

local function share (seq1, seq2)
  assert(is_sequence(seq1), "invalid argument #1 (sequence expected)")
  assert(is_sequence(seq2), "invalid argument #2 (sequence expected)")
  check_mark(seq1) check_mark(seq2)
  local data1 = seq1.__dat
  local data2 = seq2.__dat
  assert(not (data1.ro or seq1:is_readonly()), "invalid write access to readonly sequence")
  assert(not (data2.ro or seq2:is_readonly()), "invalid write access to readonly sequence")

  local elm_r, idx_r, nr = {}, {}, 1
  for i=2,data1.ne-1 do
    local nam = data1[i].__id -- share by (unique) name
    local i1, i2 = data1.eidx[nam], data2.eidx[nam]
    if is_integer(i1) and is_integer(i2) then -- element name is unique in both sequences
      local e1, e2 = data1[i1], data2[i2]
      if e1 ~= e2 then
        assert(e1.__id == nam and e2.__id == nam, "unexpected corrupted dictionnary")
        local ds1 = data1.upos[i1]-data1.spos[i1]
        local ds2 = data2.upos[i2]-data2.spos[i2]
        assert(abs(e1.l-e2.l) < minlen, "incompatible shared elements (lengths differ)")
        assert(abs(ds1 -ds2 ) < minlen, "incompatible shared elements (upos-spos differ)")
        -- update arrays
        data2[i2], elm_r[nr], idx_r[nr], nr = e1, e2, i2, nr+1
      end
    end
  end
  finish_sequ(seq1) finish_sequ(seq2)
  return elm_r, idx_r
end

local function unique (seq, fmt_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  if is_string(fmt_) then fmt_ = bind1st(string.format, fmt_) end
  assert(is_nil(fmt_) or is_callable(fmt_), "invalid argument #2 (callable expected)")
  local data, lst = seq.__dat, table.new(0,100)
  assert(not (data.ro or seq:is_readonly()), "invalid write access to readonly sequence")

  for en,ei in pairs(data.eidx) do
    if is_table(ei) then
      table.clear(lst)
      for i=1,ei.n do
        local idx = ei[i]
        local elm = data[idx]
        lst[elm] = (lst[elm] or 0)+1
      end
      for i=1,ei.n do
        local idx, nam = ei[i]
        local elm = data[idx]
        if fmt_ then
          nam = fmt_(elm.__id, i, idx)
          if data.eidx[nam] ~= nil then
            error("cannot rename uniquely element '"..nam.."' (already in use)")
          end
          data.eidx[nam] = idx
        end
        if lst[elm] > 1 then
          data[idx] = elm(nam,{})    -- replaced by unique child
        elseif fmt_ then
          elm.__id = nam             -- override with unique name
        end
      end
      if fmt_ then data.eidx[en] = nil end
    end
  end
  finish_sequ(seq)
  return seq
end

-- iterators ------------------------------------------------------------------o

local function niliter (state, i)
  return nil
end

local function fwditer (state, i)
  local soff in state

  if i == state.stop then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end

  if i < state.ne then
    i = i+1
  else
    i, state.soff = 1, soff+state.seq_l
    soff = state.soff
  end

  return i, state.data[i], state.spos[i]+soff, state.ds[i]
end

local function bwditer (state, i)
  local soff in state

  if i == state.stop then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end

  if i > 1 then
    i = i-1
  else
    i, state.soff = state.ne, soff+state.seq_l
    soff = state.soff
  end

  local ds = state.ds[i]
  return i, state.data[i], state.spos[i]+ds-soff, -ds
end

---

local function fwdsiter (state, i)
  local data, spos, ds, soff, elm_i in state

  if i == state.stop and not elm_i then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end

  if i == state.ne then
    i, soff = 1, state.seq_l+soff
    state.soff = soff
    return i, data[i], spos[i]+soff, ds[i]
  end

  if elm_i then -- last elm was an implicit drift => not current one
    i = i+1
    state.elm_i = false
    return i, data[i], spos[i]+soff, ds[i]
  end

  local dl = (spos[i+1]-spos[i]) - ds[i]
  if dl < minlen then      -- implicit drift is too small, discard
    i = i+1
    return i, data[i], spos[i]+soff, ds[i]
  else                     -- update implicit drift
    state.elm_i = true
    state.elm_l = dl
    state.elm_s = 'drift__'..i
    return i, state.dft, (spos[i]+ds[i])+soff, dl
  end
end

local function bwdsiter (state, i)
  local data, spos, ds, soff, elm_i in state

  if i == state.stop and not elm_i then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end

  if i == 1 then
    i, soff = state.ne, state.seq_l+soff
    state.soff = soff
    return i, data[i], spos[i]+ds[i]-soff, -ds[i]
  end

  if elm_i then -- last elm was an implicit drift => not current one
    i = i-1
    state.elm_i = false
    return i, data[i], spos[i]+ds[i]-soff, -ds[i]
  end

  local dl = (spos[i]-spos[i-1]) - ds[i-1]
  if dl < minlen then                  -- implicit drift is too small
    i = i-1
    return i, data[i], spos[i]+ds[i]-soff, -ds[i]
  else                                 -- update implicit drift
    state.elm_i = true
    state.elm_l = dl
    state.elm_s = 'drift__'..i
    return i, state.dft, spos[i]-soff, -dl
  end
end

---

local function iter (seq, rng_, ntrn_, dir_)
  local nturn, dir = ntrn_ or 1
  assert(is_sequence(seq)                ,"invalid argument #1 (sequence expected)")
  assert(is_integer(nturn) and nturn > 0 ,"invalid argument #3 (integer >1 expected)")

  if #seq == 0 then return niliter end

  local data, start, stop = seq.__dat
  if is_nil(rng_) then
    local idx1, idxn = 1, data.ne
    dir = dir_ or 1
    if dir < 0 then idx1, idxn = idxn, idx1 end
    if is_nil(seq.__cycle) then
      start, stop = idx1, idxn
    else
      start = assert(index_of(seq, seq.__cycle), "invalid cycle reference")
      stop  = start == idx1 and idxn or start-dir
    end
  else
    start, stop, dir = range_of(seq, rng_, nil, dir_)
    if is_nil(start) then return niliter end
  end
  if start == stop+dir then nturn = nturn+1 end

  assert(dir == 1 or dir == -1, "invalid argument #4 (1 or -1 expected)")

  local soff = dir > 0 and -data.spos[start] or data.spos[start]+data.ds[start]
  return dir > 0 and fwditer or bwditer, {
    data=data, spos=data.spos, ds=data.ds, ne=data.ne, soff=soff, dir=dir,
    seq=seq, seq_l=seq.l, elm_i=true, elm_l=0, elm_s='', stop=stop, turn=nturn-1,
    dft=0}, start-dir
end

local function siter (seq, rng_, ntrn_, dir_)
  local iter, state, start = iter(seq, rng_, ntrn_, dir_)
  if iter == niliter then return iter end
  -- implicit drift (reused)
  state.dft = drift { l := state.elm_l, name := state.elm_s }
                    :set_flags(implicit) :set_readonly()
  if start == state.stop then state.turn = state.turn-1 end
  local dir = dir_ or state.dir
  return dir < 0 and bwdsiter or fwdsiter, state, start
end

-- flags ----------------------------------------------------------------------o

local function save_flags (seq, flgs_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = seq.__dat
  local flgs = flgs_ or table.new(data.ne,0)
  for i=1,data.ne do flgs[i] = data[i]:get_flags() end
  return flgs
end

local function restore_flags (seq, flgs)
  assert(is_sequence(seq ), "invalid argument #1 (sequence expected)")
  assert(is_iterable(flgs), "invalid argument #2 (iterable expected)")
  local data = seq.__dat
  for i=1,data.ne do data[i]:clear_flags(-1):set_flags(flgs[i]) end
end

-- I/O ------------------------------------------------------------------------o

-- dump seq positions
local function dumpseq (seq, filnam_)
  local res = table.new(#seq,0)

  -- header
  res[1] = 'sequence: ' .. seq.__id .. ', ' ..
           'l=' .. (seq.l == uninitialized and 'uninitialized' or seq.l)
  res[2] = 'idx  kind          name                    l          dl       \z
            spos       upos    uds'
  -- elements
  seq:foreach \e,i =>
    local ds, uds = seq:ds(i), seq:upos(i)-seq:spos(i)
    local dl = ds-e.l
    res[#res+1] = string.format('%03d  %-14s%-20s%9.3f%8.3g%s%11.3f%11.3f%8.3f%s',
                  i, e.kind, e.__id, e.l, dl, abs(dl) > eps and '*' or ' ',
                  seq:spos(i), seq:upos(i), uds, (uds<0 or uds>ds) and '*' or '')
    end

  -- return result as a string
  if filnam_ == '-' then return table.concat(res, '\n') end

  -- dump to file
  local file = openfile(filnam_, 'w', '.dat')
  for _,s in ipairs(res) do file:write(s,'\n') end
  if is_string(filnam_) then file:close() else file:flush() end

  return seq
end

-- members --------------------------------------------------------------------o

sequence :set_methods {
  -- elem, spos, upos, ds, canonical index
  elem          = \s,i -> s.__dat     [i],
  spos          = \s,i -> s.__dat.spos[i],
  upos          = \s,i -> s.__dat.upos[i],
  ds            = \s,i -> s.__dat.ds  [i],
  align         = \s,i -> s.__dat.algn[i],
  index         = index,

  -- elements manipulation
--  getelm       = get_elm,
--  addelm       = add_elm,
--  setelm       = set_elm,
--  remelm       = rem_elm,
--  inselm       = ins_elm,

  -- sequence-like methods
  name_of       = name_of,
  index_of      = index_of,
  range_of      = range_of,
  length_of     = length_of,

  foreach       = foreach,
  select        = select,
  deselect      = deselect,
  filter        = filter,

  install       = install,
  remove        = remove,
  replace       = replace,
  move          = move,
  misalign      = misalign,

  reflect       = reflect,
  cycle         = cycle,
  share         = share,
  unique        = unique,

  iter          = iter,
  siter         = siter,

  -- read/write/dump
  read         := error("NYI", 2), -- TODO (possible?)
  write        := error("NYI", 2), -- TODO (useful?)
  dumpseq       = dumpseq,

  -- publish elements in an environment
  publish       = publish,

  -- duplicate
  copy          = copy_mm,

  -- ownership
  is_view       = is_view,

  -- flags
  save_flags    = save_flags,
  restore_flags = restore_flags,

  -- readonly
  set_readonly  = set_readonly,

  -- for debugging
  check_sequ    = check_sequ,

  -- disabled method
  is_selected  := error("invalid sequence operation", 2),

} :set_metamethods ({
  __sequ        = _id,
  __init        = init_mm,
  __copy        = copy_mm,
  __len         = len_mm,
  __index       = index_mm,
  __newindex    = newindex_mm,
-- __pairs      = pairs_mm , default from object
  __ipairs      = \s -> ipairs(s.__dat),
}, true) :set_readonly()

-- env ------------------------------------------------------------------------o

MAD.typeid.is_sequence = is_sequence

-- end -------------------------------------------------------------------------
return { sequence = sequence }

--[=[ TODO?
SEQUENCE DISPLAY

local function show_fields(t, lst)
  local a, k, s
  lst = lst or sequence_fields
  for _,v in ipairs(lst) do
    if is_list(v) then k, s = v[1], v[2] else k, s = v, v end
    a = t[k]
    if a then io.write(', ', s, '= ', tostring(a)) end
  end
end

function M:show(disp)
  io.write("sequence '", self.__id,"' { ")
  show_list(self, disp)
  io.write(' }\n')
  for _,v in ipairs(self) do v:show(disp) end
  io.write('endsequence\n')
end

function M:show_madx(disp)
  io.write("'", self.__id, "': sequence, ")
  show_list(self, disp)
  io.write(';\n')
  for _,v in ipairs(self) do v:show_madx(disp) end
  io.write('endsequence;\n')
end
--]=]
