--[=[
 o-----------------------------------------------------------------------------o
 |
 | Sequence module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide sequence object to define lattices

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- locals ---------------------------------------------------------------------o

local option, warn, trace, gfunc                                 in MAD
local ident, second, bind1st, bind2nd, bind2st, ltrue, lfalse,
      sub, opstr                                                 in MAD.gfunc
local sequence, marker, drift, changedir, flags                  in MAD.element
local minlen, eps                                                in MAD.constant
local strtrim, strsplit, strbracket, bsearch, assertf, errorf,
      openfile, lst2tbl                                          in MAD.utility
local is_nil, is_boolean, is_number, is_integer, is_nznatural,
      is_index, is_string, is_table, is_rawtable, is_iterable,
      is_mappable, is_callable, is_range, is_element, is_object,
      set_concept, concept                                       in MAD.typeid
local not_mappable, not_extendable, not_mutable                  in concept
local implicit, observed                                         in flags

local abs, min, modf in math

local type, getmetatable, setmetatable, assert, error, rawequal =
      type, getmetatable, setmetatable, assert, error, rawequal

local ipairs, pairs, tostring, tonumber =
      ipairs, pairs, tostring, tonumber

local string, table, io =
      string, table, io

-- backup original methods and metamethods
local sequence_mt = getmetatable(sequence)
local var_get, var_val, is_instanceOf in sequence
local seq_cpy, var_set = sequence.copy, sequence_mt.__newindex

-- root object ----------------------------------------------------------------o

-- special numerical value for elements positions.
local uninitialized = -1e9
local ongoing_init  = -2e9

-- defined in elements
sequence :setvar { dir=1, l=uninitialized,
           __dat={eidx={}, spos={}, upos={}, ds={}, algn={}, elgn={}, ne=0,}, }

-- identity -------------------------------------------------------------------o

local _id = {} -- identity

local function is_sequence (a)
  local mt = getmetatable(a)
  return mt ~= nil and mt.__sequ == _id
end

-- definitions ----------------------------------------------------------------o

-- start and end markers
local mkstart = marker '$start' {} :set_readonly()
local mkend   = marker '$end'   {} :set_readonly()

-- sanity checks --------------------------------------------------------------o

local function seq_error (msg, seq, idx, elm)
  local fun = seq.debug and warn or error
  elm = elm or is_integer(idx) and is_sequence(seq) and seq[idx]
  fun(msg .. (is_object(seq) and " in sequence '" .. seq.name .. "'" or '')
          .. (is_object(elm) and " for element '" .. elm.name .. "'" or '')
          .. (          idx  and " at index "     .. idx             or ''), 2)
end

local function seq_poserr (typ, seq, idx, pos)
  local msg = string.format(
    "invalid %s position at s = %.6gm [%.6gm] (negative drift %.6gm)",
             typ,               seq:spos(idx), seq:upos(idx), seq:spos(idx)-pos)
  seq_error(msg, seq, idx, seq[idx])
end

local function seq_uposerr (typ, seq, idx, pos)
  local msg = string.format(
    "invalid %s position at s = %.6gm [%.6gm] (inconsistency in [spos,upos,ds] by %.6gm)",
             typ,               seq:spos(idx), seq:upos(idx),              pos)
  seq_error(msg, seq, idx, seq[idx])
end

local function seq_lenerr (typ, seq, idx, len)
  local msg = string.format(
    "invalid %s length at s = %.6gm [%.6gm] (invalid length %.6gm)",
             typ,             seq:spos(idx), seq:upos(idx), len)
  seq_error(msg, seq, idx, seq[idx])
end

local function seq_lenchg (typ, seq, idx, len)
  local msg = string.format(
    "invalid %s length at s = %.6gm (length changed by %.6gm)",
             typ,             seq:spos(idx),           len)
  seq_error(msg, seq, idx, seq[idx])
end

-- check sequence spos and elements overlapp, [clear 'at' and 'from']
local function check_drift (seq, idx)
  local data, minlen, ds = seq.__dat, seq.minlen or minlen
  assert(idx > 1 and idx < data.ne, "unexpected corrupted element index")

  ds = data.spos[idx] - (data.spos[idx-1] + data.ds[idx-1])
  if ds < -minlen then seq_poserr("element", seq, idx, data.spos[idx]-ds) end

  ds = data.spos[idx+1] - (data.spos[idx] + data.ds[idx])
  if ds < -minlen then seq_poserr("element", seq, idx, data.spos[idx]-ds) end
end

-- check shared element
local function check_shared (seq, idx)
  local elm = seq.__dat[idx]
  if is_nil(elm:raw_get'l') then return elm.parent end
  seq_error("invalid shared element (l defined)", seq, idx, elm)
end

-- check sequence $start and $stop integrity
local function check_mark (seq)
  local data = seq.__dat
  local n = data.ne
      if not is_instanceOf(data[1], mkstart) then
    error("invalid sequence first element ($start marker expected)", 2)
  elseif not is_instanceOf(data[n], mkend  ) then
    error("invalid sequence last element ($end marker expected)"   , 2)
  end
end

-- check sequence spos and elements overlapp
local function check_pos (seq)
  local data, minlen = seq.__dat, seq.minlen or minlen
  for i=1,data.ne-1 do
    local ds = data.spos[i+1] - (data.spos[i] + data.ds[i])
    if ds < -minlen then
      seq_poserr("element", seq, i, data.spos[i]-ds)
    end
  end

  for i=1,data.ne do
    local el = data[i].l
    local ds = el-data.ds[i]
    if abs(ds) >= minlen then
      seq_lenchg("element", seq, i, ds)
    end

    ds = data.upos[i]-data.spos[i]
    if ds < -minlen or ds-data.ds[i] > minlen then
      seq_uposerr("element", seq, i, ds)
    end

    if data[i].is_thin and el ~= 0 then
      seq_lenerr("thin element", seq, i, el)
    end
  end
end

-- check dictionnary of name -> idx
local function check_index (seq)
  local data = seq.__dat
  local eidx = data.eidx
  local s, e, S, E = eidx['#s'], eidx['#e'], eidx['#S'], eidx['#E']
  assert(is_number(s) and is_number(e) and is_number(S) and is_number(E),
         "unexpected reuse of #s/#e or #S/#E start/stop markers names")

  eidx['#s'], eidx['#e'], eidx['#S'], eidx['#E'] = nil

  -- check dict vs data: name -> index or table of indexes
  for en,ei in pairs(eidx) do
    if is_number(ei) then
      assert(data[ei].name == en     , "unexpected corrupted dictionnary")
    elseif is_table(ei) then
      assert(data[ei[1]].name == en  , "unexpected corrupted dictionnary")
      assert(ei.n             >= 2   , "unexpected corrupted dictionnary")
      for i=2,ei.n do
        assert(ei[i-1] < ei[i]       , "unexpected corrupted dictionnary")
        assert(data[ei[i]].name == en, "unexpected corrupted dictionnary")
      end
    else
      error("unexpected corrupted dictionnary")
    end
  end

  -- check data vs dict: name -> index or table of indexes
  for i=1,data.ne do
    local ei = eidx[data[i].name]
    if is_number(ei) then
      assert(ei == i                 , "unexpected corrupted dictionnary")
    elseif is_table(ei) then
      local ii
      for j=1,ei.n do
        if ei[j] >= i then ii = ei[j] ; break end
      end
      assert(ii == i                 , "unexpected corrupted dictionnary")
    else
      error("unexpected corrupted dictionnary")
    end
  end

  eidx['#s'], eidx['#e'], eidx['#S'], eidx['#E'] = s, e, S, E
end

local function check_sequ (seq)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(seq.dir == 1 or seq.dir == -1, "invalid direction (1 or -1 expected)")
  -- trace(2, "checking sequence '%s'", seq.name)
  check_pos  (seq)
  check_index(seq)
  check_mark (seq)
  return seq
end

-- helper for mangled names and elements indexes (same as mtable) -------------o

-- reflect indexes
local function ireflect (i, n)
  return i < 0 and n+i+1 or i
end

-- canonize index (direct)
local function index_of_idx (seq, idx)
  local n = seq.__dat.ne
  idx = ireflect(idx, n)
  return idx >= 1 and idx <= n and idx or nil
end

local index_of_fnam -- forward declaration

-- get index of ref (direct)
local function index_of_ref (seq, ref)
  local msg, idx = "invalid reference index (name or index expected)"
  if is_string(ref) then
    idx, msg = index_of_fnam(seq, ref), "invalid reference name '%s'"
  elseif is_integer(ref) then
    idx, msg = index_of_idx (seq, ref), "invalid reference index %d"
  end
  return assertf(idx, msg, ref)
end

-- get index from name [with absolute count] (direct)
local function index_of_cnam (seq, nam, cnt)
  local ei = seq.__dat.eidx[nam]
  if is_table(ei) then
    return ei[ ireflect(cnt, ei.n) ]
  elseif cnt == 1 or cnt == -1 then
    return ei
  end
end

-- get index from name [with relative count] (linear)
local function index_of_rnam (seq, nam, cnt, ref)
  local ei = seq.__dat.eidx[nam]
  if is_nil(ei) then return nil end
  local idx = index_of_ref(seq, ref)
  if is_number(ei) then
    return (cnt ==  1 and ei >= idx and ei) or
           (cnt == -1 and ei <= idx and ei) or nil
  end
  if cnt > 0 then
    for i=1,ei.n do
      if ei[i] >= idx then return ei[i+cnt-1] end
    end
  elseif cnt < 0 then
    for i=ei.n,1,-1 do
      if ei[i] <= idx then return ei[i+cnt+1] end
    end
  end
end

-- get index from s-position (binary)
local function index_of_num (seq, num, ref_, dir_)
  local data, minlen = seq.__dat, seq.minlen or minlen
  if ref_ then num = num + data.upos[index_of_ref(seq,ref_)] end
  if num < 0 or num > seq.l then return nil end
  local idx, dir = bsearch(data.spos, num), dir_ or 1 -- num <= spos[idx]
  assert(dir == 1 or dir == -1 or dir == 0, "invalid direction (0, 1 or -1 expected)")
  if idx > 1 and num < data.spos[idx] then
    local epos = data.spos[idx-1] + data.ds[idx-1] + minlen
    if dir < 0 or num < epos then
      idx = idx-1
    elseif dir == 0 and num > epos then
      idx = idx-0.5 -- implicit drift
    end
  end
  return idx, num
end

-- get index from [mangled] name or s-position (direct or linear)
local function index_of_str (seq, str, ref_, dir_)
  local num = tonumber(str)
  if num then return index_of_num(seq, num, ref_, dir_) end
  local nam, cnt, _, bra = strbracket(str)
  cnt = is_nil(cnt) and 1 or tonumber(cnt)
  assert(is_index(cnt), "invalid argument #2 (non-zero count expected)")
  if is_nil(ref_) or bra == 1 then
    return index_of_cnam(seq, nam, cnt      )
  else
    return index_of_rnam(seq, nam, cnt, ref_)
  end
end

-- get index from 'from' [mangled] name (direct or linear)
function index_of_fnam (seq, nam, ref_) -- already declared local
  assert(is_string(nam), "invalid argument #2 (string expected)")
  local nam, cnt, _, bra = strbracket(nam)
  cnt = is_nil(cnt) and 1 or tonumber(cnt)
  assert(is_index(cnt), "invalid argument #2 (non-zero count expected)")
  if is_nil(ref_) or bra ~= 2 then -- need both for relative from
    return index_of_cnam(seq, nam, cnt      ), bra
  else
    return index_of_rnam(seq, nam, cnt, ref_), bra
  end
end

-- get index from element (linear)
local function index_of_elm (seq, elm, ref_, dir_)
  local nam, data = elm.name, seq.__dat
  local ei = data.eidx[nam]
  if is_nil(ei) then return nil end
  local idx = ref_ and index_of_ref(seq, ref_) or 1
  if is_number(ei) then
    return ei >= idx and data[ei] == elm and ei or nil
  end
  local dir = dir_ or 1
  assert(dir == 1 or dir == -1, "invalid direction (1 or -1 expected)")
  if dir == 1 then
    for i=1,ei.n do
      if ei[i] >= idx and data[ei[i]] == elm then return ei[i] end
    end
  else
    for i=ei.n,1,-1 do
      if ei[i] <= idx and data[ei[i]] == elm then return ei[i] end
    end
  end
end

-- get [mangled] name from index (linear)
local function name_of_idx (seq, idx, ref_)
  local data = seq.__dat
  idx = index_of_idx(seq, idx)
  if is_nil(idx) then return nil end
  local nam = data[idx].name
  local ei = data.eidx[nam]
  if is_number(ei) then
    assert(ei == idx, "unexpected corrupted dictionnary")
    return tostring(nam)
  end

  local cnt, b1, b2 = 0
  if ref_ then
    local idx = index_of_ref(seq, ref_)
    for i=1,ei.n do
      if ei[i] < idx then cnt = cnt+1 else break end
    end
    b1, b2 = "{", "}"
  else
    b1, b2 = "[", "]"
  end

  for i=1,ei.n do
    if ei[i] == idx then
      if cnt >= i then cnt = cnt+1 end
      return string.format("%s%s%d%s", tostring(nam), b1, i-cnt, b2)
    end
  end
  error("unexpected corrupted dictionnary")
end

-- position helpers -----------------------------------------------------------o

-- forward declaration
local elem_pos

-- return user-defined position of 'from'
local function from_upos (seq, from, idx)
  local data = seq.__dat
  if data.last_from ~= from then                     -- memoized?
    local idx, bra = index_of_fnam(seq, from, idx)
    if is_nil(idx) then                              -- not found
      seq_error("invalid from of '" .. from .. "'", seq, idx)
    end
    data.last_frompos = second(elem_pos(seq, idx))
    data.last_from = bra ~= 2 and from or nil        -- memoize if not relative
  end
  return data.last_frompos                           -- upos
end

-- return user-defined position of 'refpos'
local function refpos_upos (elm, refpos, idx)
  if #elm == 0 or not is_sequence(elm) then
    -- if not is_element(elm[rpos]) then
    seq_error("invalid refpos to subelement '" .. refpos .. "'", elm, idx)
  end
  return from_upos(elm, refpos)
end

-- forward index
-- return (#elm-1)+1 because seq[idx] == sseq[2] (see copy_ssequ and sequ_pos).
local function fidx (elm)
  return is_sequence(elm) and #elm or 1
end

local function fpos (at, elen, spos, upos)
  return at and upos or spos+elen
end

-- build positions ------------------------------------------------------------o

-- return user-defined position of 'refpos'
local function refpos_pos (seq, elm, idx)
  local refpos = elm.refpos or seq.refer or 'centre'
  local rpos

      if refpos == 'entry'  then rpos = 0
  elseif refpos == 'centre' then rpos = elm.l/2
  elseif refpos == 'exit'   then rpos = elm.l
  elseif is_number(refpos)  then rpos = refpos
  else                           rpos = refpos_upos(elm, refpos, idx)
  end
  return rpos
end

-- return user-defined position of 'from'
local function from_pos (seq, elm, idx)
  local at   = elm.at
  local from = elm.from or at and (at>=0 and 'start' or 'end') or 'prev'
  local upos = at or refpos_pos(seq, elm, idx)

      if from == 'start'    then ;
  elseif from == 'prev'     then upos = upos + elem_pos(seq,idx-1        ) + seq[idx-1].l -- + fpos(at, seq[idx-1].l, elem_pos(seq,idx-1        ))
  elseif from == 'next'     then upos = upos + elem_pos(seq,idx+fidx(elm))                -- + fpos(at,       -elm.l, elem_pos(seq,idx+fidx(elm)))
  elseif from == 'end'      then upos = upos + seq.l
  elseif from == 'selected' then upos = upos + seq:upos(idx)
  elseif is_number(from)    then upos = upos + from
  else                           upos = upos + from_upos(seq,from,idx)
  end
  return upos
end

-- set s-positions at index or return element s-positions
-- already declared for forward use, *must not be local*
function elem_pos (seq, idx, elm_)
  local data = seq.__dat
  local spos = data.spos[idx]
  if is_nil(spos) then
    seq_error("invalid index or reference detected", seq, idx, elm_)
  elseif is_nil(elm_) then
    if spos >= 0 then
      return spos, data.upos[idx]
    elseif spos == ongoing_init then
      seq_error("cycling dependencies detected", seq, idx)
    elseif spos ~= uninitialized then
      seq_error("corrupted s-position detected", seq, idx)
    end
    data.spos[idx] = ongoing_init
  end

  local elm  = elm_ or data[idx]
  local upos =   from_pos(seq, elm, idx)
  local rpos = refpos_pos(seq, elm, idx)
  spos = upos - rpos

  if is_nil(elm_) then
    data.spos[idx], data.upos[idx], data.ds[idx] = spos, upos, elm.l
  end
  return spos, upos
end

-- set s-positions of elements from their sub sequence
local function sequ_pos (seq, sseq, idx, dir)
  check_mark(sseq)
  local pos = elem_pos(seq, idx, sseq)    -- shift by subsequence refpos
  local data, sdata = seq.__dat, sseq.__dat

!  if seq.dir ~= sseq.dir then -- changedir patch
!    data.spos[idx] = sdata.spos[1] + pos
!    data.upos[idx] = sdata.upos[1] + pos
!    data.ds  [idx] = sdata.ds  [1]
!    data.algn[idx] = sdata.algn[1]
!    data.elgn[idx] = sdata.elgn[1]
!    idx = idx + 1
!  end

  local n = sdata.ne
  if dir > 0 then
    for i=1,n do
      local ix = idx-1+i
      data.spos[ix] = sdata.spos[i] + pos
      data.upos[ix] = sdata.upos[i] + pos
      data.ds  [ix] = sdata.ds  [i]
      data.algn[ix] = sdata.algn[i]
      data.elgn[ix] = sdata.elgn[i]
      assert(data[ix] == sdata[i], "unexpected corrupted flat sequence")
    end
  elseif dir < 0 then
    local l = sseq.l
    for i=1,n do
      local ix, ii = idx-1+i, n+1-i
      local sp, ds = sdata.spos[ii], sdata.ds[ii]
      data.spos[ix] = l - (sp + ds                      ) + pos
      data.upos[ix] = l - (sp + ds - sdata.upos[ii] + sp) + pos
      data.ds  [ix] = ds
      data.algn[ix] = sdata.algn[ii]
      data.elgn[ix] = sdata.elgn[ii]
      assert(data[ix] == sdata[ii], "unexpected corrupted flat sequence")
    end
  else
    error("invalid direction (1 or -1 expected)")
  end

!  if seq.dir ~= sseq.dir then -- changedir patch
!    data.spos[idx+n] = sdata.spos[n] + pos
!    data.upos[idx+n] = sdata.upos[n] + pos
!    data.ds  [idx+n] = sdata.ds  [n]
!    data.algn[idx+n] = sdata.algn[n]
!    data.elgn[idx+n] = sdata.elgn[n]
!    idx = idx + 1
!  end

  return idx+n
end

-- compute elements positions
local function build_pos (seq, sref)
  local data, minlen = seq.__dat, seq.minlen or minlen
  local n, idx, pos = data.ne, 1, 0
  for i=1,n do
    if data[i].from == 'selected' then
      seq_error("invalid from='selected' detected", seq, i, data[i])
    end
    data.spos[i] = uninitialized
  end
  while idx <= n do
    local sseq = sref[idx]
    if is_nil(sseq) then     -- element
      elem_pos(seq, idx)     -- set element positions
      if pos-minlen > data.spos[idx] then
      -- if data.spos[idx]-pos < -minlen then -- see check_pos
        seq_poserr('element', seq, idx, pos)
      elseif data[idx].is_thin and data.ds[idx] ~= 0 then
        seq_lenerr("thin element", seq, idx, data[idx].l)
      end
      if data[idx].shared == true then -- shared element
        data[idx] = check_shared(seq, idx)
      end
      pos = data.spos[idx]+data.ds[idx]
      idx = idx + 1
    else                     -- subsequence
      local nidx = sequ_pos(seq, sseq, idx, sref.sdir[idx])
      if pos-minlen > data.spos[idx] then
        seq_poserr('subsequence', seq, idx, pos)
      end
      local sdata = sseq.__dat
      pos = data.spos[idx] - sdata.spos[1] + sseq.l
      idx = nidx
    end
  end
  assert(n == idx-1, "unexpected corrupted flat sequence")

  local len = data.spos[n]
  if seq.l == uninitialized then
    seq.l = len
  elseif seq.l < len then
    error("invalid sequence length "..seq.l.."m for "..seq.name)
  end
end

-- flatten sequence -----------------------------------------------------------o

-- copy sub sequence
local function copy_ssequ (seq, flat, sref, idx, dir)
  local data = seq.__dat
  local n = data.ne

  check_mark(seq)

  sref[idx], sref.sdir[idx] = seq, dir -- link subsequence

!  if sref.dir ~= seq.dir then -- insert changedir patch
!    idx, flat[idx] = idx+1, changedir(seq.name.."_chdir", {})
!  end

      if dir ==  1 then
    for i=1,n do flat[idx-1+i] = data[i    ] end
  elseif dir == -1 then
    for i=1,n do flat[idx-1+i] = data[n+1-i] end
  else
    error("invalid direction (1 or -1 expected)")
  end

!  if sref.dir ~= seq.dir then
!    idx, flat[idx+n] = idx+1, flat[idx-1] -- share patch
!  end

  return idx+n
end

-- flatten lines and subsequence
local function flatten_line (line, flat, sref, idx, dir)
  local n, rep = #line, (line.__rep or 1) * dir
  if n == 0 or rep == 0 then return idx end

  local start, stop, step
  if rep < 0
  then rep, start, stop, step = -rep, n, 1, -1
  else rep, start, stop, step =  rep, 1, n,  1
  end

  for i=1,rep do
  for j=start,stop,step do
    local elm = line[j]
    if not (is_element(elm) or is_rawtable(elm)) then
      seq_error("invalid element detected", line, j)
    elseif elm.kind == 'bline' or is_rawtable(elm) then
      -- TODO: keep track of l, dir, refpos and refer like for sequence...
      idx = flatten_line(elm, flat, sref, idx, step)
    elseif not is_nil(sref) and is_sequence(elm) then
      idx = copy_ssequ  (elm, flat, sref, idx, step)
    else -- other elements
      idx, flat[idx] = idx+1, elm
    end
  end end
  return idx
end

-- flatten sequence
local function flatten_sequ (seq, flat, sref)
  local n, idx = seq:raw_len(), 2
  flat[1] = mkstart {at=0}

  for i=1,n do
    local elm = seq:var_get(i)
    if not (is_element(elm) or is_rawtable(elm)) then
      seq_error("invalid element detected", seq, i)
    elseif elm.kind == 'bline' or is_rawtable(elm) then
      idx = flatten_line(elm, flat, sref, idx, 1)
    elseif is_sequence(elm) then
      idx = copy_ssequ  (elm, flat, sref, idx, 1)
    else -- other elements
      idx, flat[idx] = idx+1, elm
    end
  end
  flat[idx] = mkend {at= seq.l~=uninitialized and seq.l or nil}
                    :set_flags(observed)
  assert(n <= idx, "unexpected corrupted flat sequence")
end

-- dict helper ----------------------------------------------------------------o

-- build dictionnary name -> idx
local function build_idx (data)     -- must be very fast
  local eidx = data.eidx
  table.clear(eidx)                 -- reuse main storage
  for idx,elm in ipairs(data) do
    local nam = elm.name
    local val = eidx[nam]
    if is_nil(val) then             -- none: scalar
      eidx[nam] = idx
    elseif is_number(val) then      -- one : scalar to array
      eidx[nam] = {val, idx, n=2}
    else                            -- many: append
      local n = val.n+1
      val[n], val.n = idx, n
    end
  end
end

-- build sequence -------------------------------------------------------------o

-- remove subsequence markers (if any)
local function clear_sub (seq, sref)
  if is_nil(next(sref.sdir)) then return end
  local data = seq.__dat
  local spos, upos, ds, algn, elgn, ne in data
  local j, n, nam = 2, ne
  for i=2,n-1 do
    nam = data[i].name
    if not (nam == '$start' and is_instanceOf(data[i], mkstart) or
            nam == '$end'   and is_instanceOf(data[i], mkend))  then
      data[j], spos[j], upos[j], ds[j], algn[j], elgn[j], j =
      data[i], spos[i], upos[i], ds[i], algn[i], elgn[i], j+1
    end
  end
  data[j], spos[j], upos[j], ds[j], algn[j], elgn[j], data.ne =
  data[n], spos[n], upos[n], ds[n], algn[n], elgn[n], j
  for i=j+1,n do -- clear remaining slots
    data[i], spos[i], upos[i], ds[i], algn[i], elgn[i] =
        nil,     nil,     nil,   nil,     nil,     nil
  end
  build_idx(data)
end

-- finalize sequence
local function fini_sequ (seq)
  local data = seq.__dat

  -- clear memoization
  data.last_from    = nil
  data.last_frompos = nil

  -- $start/$end markers aliases
  local ei, ne = data.eidx, data.ne
  ei['#s'], ei['#S'] =  1,  1
  ei['#e'], ei['#E'] = ne, ne

  -- sanity checks
  check_mark(seq)
  if option.debug >= 2 then check_sequ(seq) end
end

-- sequence init (build)
local function init_mm (seq)
  local n = seq:raw_len()

  -- check if sequence needs __dat
  if n == 0 and is_nil(seq:raw_get'l') then return seq end

  local sref = { dir=seq.dir, sdir={} }
  local data = table.new(n+2,8)

  -- flatten subsequences
  flatten_sequ(seq, data, sref)
  seq:clear_array()

  local ne  = #data
  data.eidx = table.new(0,ne)
  data.spos = table.new(ne,0)
  data.upos = table.new(ne,0)
  data.ds   = table.new(ne,0)
  data.algn = table.new(ne,0)
  data.elgn = table.new(ne,0)
  data.ne   = ne
  seq.__dat = data

  -- set minlen to 1e-6 [m] for MAD-X compatibility
  if option.madxenv then seq.minlen = 1e-6 end

  build_idx(data)
  build_pos(seq, sref)
  clear_sub(seq, sref)
  fini_sequ(seq)

  -- publish sequence elements in MADX environment
  if option.madxenv then seq:publish(MADX, true) end

  return seq
end

local function copy_mm (seq, name_)
  assert(not rawequal(seq, sequence), "invalid argument #1 (cannot copy 'sequence')")
  assert(is_sequence(seq)           , "invalid argument #1 (sequence expected)")
  local cpy = seq_cpy(seq,name_)

  -- check if copy needs to be further processed
  if seq:is_view() then return cpy end

  local data = seq.__dat
  local ne   = data.ne
  local cdat = table.new(ne,8)  -- see init_mm
  cdat.eidx  = table.new(0,ne)
  cdat.spos  = table.new(ne,0)
  cdat.upos  = table.new(ne,0)
  cdat.ds    = table.new(ne,0)
  cdat.algn  = table.new(ne,0)
  cdat.elgn  = table.new(ne,0)
  cdat.ne    = ne
  cpy.__dat  = cdat

  for i=1,ne do
    cdat[i] = data[i]:copy()
    cdat.spos[i], cdat.upos[i], cdat.ds[i], cdat.algn[i], cdat.elgn[i] =
    data.spos[i], data.upos[i], data.ds[i], data.algn[i], data.elgn[i]
  end

  build_idx(cdat)
  fini_sequ(cpy)
  return cpy
end

-- sequence metamethods -------------------------------------------------------o

local function cnt_iter (s, i)
  i = i+1
  local ei = s.__idx[i]
  if ei then return i, s.__dat[ei] end
end

local cnt_mt = set_concept({
  __len       =\s   -> s.__idx.n,
  __index     =\s,i -> s.__dat[s.__idx[i]],
  __ipairs    =\s   -> (cnt_iter, s, 0),
  __tostring  =\s   -> string.format("sequence count: %p", s),
}, not_mappable + not_extendable + not_mutable)

-- number of elements
local function len_mm (seq)
  return seq.__dat.ne
end

-- read access precedence: element index, variable key, element name.
local function index_mm (seq, key)
  -- element index
  if type(key) == 'number' then                              -- see index_of_idx
    local data = seq.__dat
    return data[ ireflect(key, data.ne) ]
  end
  -- variable (or method)
  local var = var_get(seq, key)
  if type(var) ~= 'nil' then
    return var_val(seq, key, var)
  end
  -- element name
  local data = seq.__dat
  local idx = data.eidx[key]
  if type(idx) == 'number' then
    return data[idx]
  elseif is_table(idx) then
    return setmetatable({__idx=idx, __dat=data, __slf=seq}, cnt_mt)
  end
  return nil
end

local function newindex_mm (seq, key, val)
  -- element index or name
  if type(key) == 'number' or seq.__dat.eidx[key] then
    error("invalid sequence write access (use replace method)")
  end
  -- variable
  var_set(seq, key, val)
end

-- methods (readonly) ---------------------------------------------------------o

local function is_view (seq)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  return is_nil(seq:raw_get'__dat')
end

local function index (seq, idx)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(is_integer (idx), "invalid argument #2 (integer expected)")
  return index_of_idx(seq, idx)
end

local function name_of (seq, idx, ref_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(is_integer (idx), "invalid argument #2 (integer expected)")
  return name_of_idx(seq, idx, ref_)
end

local function index_of (seq, a, ref_, dir_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
      if is_number (a) then return index_of_num(seq, a, ref_, dir_)
  elseif is_string (a) then return index_of_str(seq, a, ref_, dir_)
  elseif is_element(a) then return index_of_elm(seq, a, ref_, dir_)
  end
  errorf("invalid argument #2 (number, string or element expected, got %s)",
          tostring(a))
end

local function range_of (seq, rng_, ref_, dir_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local start, stop, step, istart, istop, sstart, sstop, dir, doidx
  if is_nil(rng_) then
    dir = dir_ or 1
        if dir ==  1 then return 1, #seq,  1
    elseif dir == -1 then return #seq, 1, -1 end
  elseif is_number(rng_) then
    start, istart = rng_, index_of_num(seq, rng_, ref_, dir_)
    stop , istop  = start, istart
  elseif is_string(rng_) then
    local s1, i2 = strsplit(rng_, "/")
    local s2 = i2 == 0 and s1 or strtrim(rng_, i2+1)
    doidx, start, stop = true, s1, s2
  elseif is_range(rng_) then
    doidx, start, stop, step = true, rng_:ranges()
    dir_ = dir_ or step
  elseif is_rawtable(rng_) then
    doidx, start, stop, ref_, dir_ = true, rng_[1], rng_[2] or rng_[1],
                                     ref_ or rng_[3],  dir_ or rng_[4]
    if ref_ == 'idx' then
      assert(is_integer(start) and is_integer(stop),
             "invalid argument #2 (range of integers expected)")
      istart, istop = index_of_idx(seq, start), index_of_idx(seq, stop)
      doidx = false
    end
  else
    errorf("invalid argument #2 (number, string, table or range expected, got %s)",
           tostring(rng_))
  end
  dir = dir_ or 1
  if dir ~= 1 and dir ~= -1 then
    errorf("invalid range direction '%s' (1 or -1 expected)", tostring(dir))
  end
  if doidx then
    istart, sstart = index_of(seq, start, ref_,  dir)
    istop , sstop  = index_of(seq, stop , ref_, -dir)
  end
  if not istart then errorf("invalid range start '%s'", tostring(start)) end
  if not istop  then errorf("invalid range stop '%s'" , tostring(stop )) end
  if sstart and sstop and (istart-istop)*(sstart-sstop) < 0 then
    return nil -- empty range
  end
  return istart, istop, dir
end

local function length_of (seq, rng_, ntrn_, dir_) -- see iter
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local start, stop, dir = range_of(seq, rng_, nil, dir_)
  if is_nil(start) then return 0 end
  local siz, trn = (stop-start)*dir, ntrn_ or 1
  return 1 + siz + #seq * (trn-1 + (siz < 0 and 1 or 0))
end

-- functional methods ---------------------------------------------------------o

local pcls   = is_instanceOf
local psel   = marker.is_selected
local ptbl   = \tbl, e,_ -> tbl[e.name]
local pnam   = \pat, e,_ -> string.find(e.name, pat) ~= nil
local pand   = \p,p2,e,i -> p(e,i) and p2(e,i)
local ptrue  = \p,_ ,e,i -> p(e,i) and true
local pfalse = \p,_ ,e,i -> p(e,i) or false

local l2t = \l -> not is_table(l) and {[l]=true} or is_nil(l[1]) and l or lst2tbl(l)

local function foreach (seq, act, rng_, sel_, not_) -- action, range, selection, default
  -- foreach(sel) -> foreach(sel.action, sel)
  if is_nil(rng_) and is_rawtable(act) then
    act, rng_ = act.action, act     -- extract action + right shift
  end
  -- foreach(act,sel) -> foreach(act, sel.range, sel)
  if is_nil(sel_) and is_rawtable(rng_) and is_nil(rng_[1]) then
    rng_, sel_ = rng_.range, rng_ -- extract range + right shift
  end

  local p, subelm
  if is_rawtable(sel_) then       -- logically and'ed selections
    if is_nil(not_) and (sel_.default == 'none' or sel_.default == true) then
      not_ = true
    end
    local op = not_ ~= true and ptrue or pfalse
    if sel_.select ~= nil then
      assert(is_callable(sel_.select), "invalid select (callable expected)")
      op, p = pand, bind2st(op, sel_.select, p)
    end
    if sel_.list ~= nil then
      op, p = pand, bind2st(op, bind1st(ptbl, l2t(sel_.list)), p)
    end
    if sel_.table ~= nil then
      op, p = pand, bind2st(op, bind1st(ptbl, l2t(sel_.table)), p)
    end
    if sel_.class ~= nil then
      assert(is_element(sel_.class), "invalid class (element expected)")
      op, p = pand, bind2st(op, bind2nd(pcls, sel_.class), p)
    end
    if sel_.pattern ~= nil then
      assert(is_string(sel_.pattern), "invalid pattern (string expected)")
      op, p = pand, bind2st(op, bind1st(pnam, sel_.pattern), p)
    end
    if sel_.flag ~= nil then
      assert(is_number(sel_.flag), "invalid flag (number expected)")
      op, p = pand, bind2st(op, bind2nd(psel, sel_.flag), p)
    end
    if sel_.subelem ~= nil then
      assert(is_boolean(sel_.subelem), "invalid subelem (boolean expected)")
      subelm = sel_.subelem
    end
  elseif not is_nil(sel_) then    -- build the selection
    if  is_boolean (sel_) then subelm = sel_ else
    p = is_number  (sel_) and bind2nd(psel, sel_)      or
        is_string  (sel_) and bind1st(pnam, sel_)      or
        is_element (sel_) and bind2nd(pcls, sel_)      or
        is_callable(sel_) and sel_                     or
        is_mappable(sel_) and bind1st(ptbl, l2t(sel_)) or nil end
  end
  if is_nil(p) then p = (not_ ~= true or rng_) and ltrue or lfalse end

  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(is_callable(act), "invalid argument #2 (callable expected)")
  assert(is_callable(p)  , "invalid argument #4 (callable expected)")

  if p ~= lfalse then
    if not subelm
    then for ei,elm in seq:iter(rng_) do if p(elm,ei) then act(elm,ei) end end
    else for ei,elm in seq:iter(rng_) do if p(elm,ei) then act(elm,ei) end
      if #elm > 0 then
        for si=1,#elm do if p(elm[si],si,ei) then act(elm[si],si,ei) end end
      end
    end end
  end
  return seq
end

local function select (seq, flg_, rng_, sel_, not_)
  if is_rawtable(flg_) and is_nil(rng_) then
    rng_, flg_ = flg_ -- right shift
  end
  local act = bind2nd(marker.select, flg_)
  return seq:foreach(act, rng_, sel_, not_)
end

local function deselect (seq, flg_, rng_, sel_, not_)
  if is_rawtable(flg_) and is_nil(rng_) then
    rng_, flg_ = flg_ -- right shift
  end
  local act = bind2nd(marker.deselect, flg_)
  return seq:foreach(act, rng_, sel_, not_)
end

local do_filter = \ei,el,i,mi =>
  local n=ei.n+1 ; ei[n], ei.n = mi and mi+el.sat or i, n end

-- return the list of indexes of selected elements
-- fractional part is the "sat" of sub-elements.
local function filter (seq, rng_, sel_, not_)
  local ei = table.new(8,1)
  local act = bind1st(do_filter, ei)
  ei.n = 0
  seq:foreach(act, rng_, sel_, not_)
  local n = ei.n ; ei.n = nil
  return ei, n
end

 -- local helper to remove sub-elements from ei returned by filter
local function rmsubelm (ei, ne)
  local n = 0
  for i=1,ne do
    if not is_index(ei[i]) then table.remove(ei, i) ; n = n+1 end
  end
  return ne-n
end

-- methods (R/W), no dict change ----------------------------------------------o

local function misalign (seq, knd_, mis, rng_, sel_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  if not is_string(knd_) and is_nil(sel_) then
    knd_, mis, rng_, sel_ = nil, knd_, mis, rng_ -- right shift
  end
  local knd = knd_ or 'error'
  assert(knd == 'error' or knd == 'place',
                           "invalid argument #2 (misalignment kind expected)")
  local data = knd == 'error' and seq.__dat.elgn or seq.__dat.algn

  -- collect indexes of elements to misalign
  local idx_m, ne = filter(seq, rng_, sel_)
  ne = rmsubelm(idx_m, ne) -- sub-elements cannot be misaligned vs sequence
  if ne == 0 then return seq end

  -- basic check...
  assert(idx_m[ne]-idx_m[1] >= ne-1, "invalid range, indexes must be increasing")

  -- remove $start/$stop markers from the list of elements to misalign
  if idx_m[ne] == #seq then table.remove(idx_m)    ; ne = ne-1 end
  if idx_m[1 ] == 1    then table.remove(idx_m, 1) ; ne = ne-1 end

  -- set/update elements misalignment
  if is_callable(mis) then     -- specific (functional) misalignment for all
    for i=1,ne do
      local algn = mis(idx_m[i])
      if algn then
        data[idx_m[i]] = {
          dx    =algn.dx    , dy  =algn.dy  , ds  =algn.ds,
          dtheta=algn.dtheta, dphi=algn.dphi, dpsi=algn.dpsi
        }
      end
    end
  elseif is_mappable(mis) then
    if #mis == 0 then              -- same (random) misalignment for all
      for i=1,ne do
        data[idx_m[i]] = {
          dx    =mis.dx    , dy  =mis.dy  , ds  =mis.ds,
          dtheta=mis.dtheta, dphi=mis.dphi, dpsi=mis.dpsi
        }
      end
    else                           -- specific (random) misalignment for all
      for i=1,ne do
        local algn = mis[idx_m[i]]
        if algn then
          data[idx_m[i]] = {
            dx    =algn.dx    , dy  =algn.dy  , ds  =algn.ds,
            dtheta=algn.dtheta, dphi=algn.dphi, dpsi=algn.dpsi
          }
        end
      end
    end
  else error("invalid argument #3 (iterable or callable expected)") end

  return seq
end

local function move (seq, rng_, sel_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = seq.__dat

  -- collect indexes of elements to move
  local idx_m, ne = filter(seq, rng_, sel_, true)
  ne = rmsubelm(idx_m, ne) -- sub-elements cannot be moved inside sequence
  if ne == 0 then return end

  -- basic check...
  assert(idx_m[ne]-idx_m[1] >= ne-1, "invalid range, indexes must be increasing")

  -- remove $start/$stop markers from the list of elements to move
  if idx_m[ne] == #seq then table.remove(idx_m)    ; ne = ne-1 end
  if idx_m[1 ] == 1    then table.remove(idx_m, 1) ; ne = ne-1 end

  -- update elements positions
  for i=1,ne do data.spos[idx_m[i]] = uninitialized end
  for i=1,ne do elem_pos(seq   , idx_m[i])          end
  for i=1,ne do check_drift(seq, idx_m[i])          end

  return seq
end

-- methods (R/W, rebuild dict) ------------------------------------------------o

local function build_index (seq)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = seq.__dat
  build_idx (data)
  fini_sequ(seq)
  return seq
end

local function update (seq)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  build_pos(seq, {}) -- update elem positions (some "l", "at" or "from" changed)
  if option.debug >= 2 then check_sequ(seq) end -- sanity checks
  return seq
end

local function remove (seq, rng_, sel_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = seq.__dat

  -- collect indexes of elements to remove
  local idx_r, nr = filter(seq, rng_, sel_, true)
  if nr == 0 then return end

  -- basic check...
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- remove $start/$stop markers from the list of elements to remove
  if idx_r[nr] == #seq then table.remove(idx_r)     ; nr = nr-1 end
  if idx_r[ 1] == 1    then table.remove(idx_r, 1 ) ; nr = nr-1 end

  -- remove elements by decreasing indexes -- to optimize to avoid O(N^2) removal
  local dbg, ne = option.debug > 1, 0
  local elm_r = table.new(nr,0)
  for i=nr,1,-1 do
    if is_index(idx_r[i]) then
      local ii = idx_r[i]
      if dbg then
        io.write("seq: removing element '", data[ii].name, "'\n")
      end
      elm_r[i], ne = data[ii], ne+1
      table.remove(data     , ii)
      table.remove(data.spos, ii)
      table.remove(data.upos, ii)
      table.remove(data.ds  , ii)
      table.remove(data.algn, ii)
      table.remove(data.elgn, ii)
    else
      local ii, sat = modf(idx_r[i])
      if dbg then
        io.write("seq: removing sub-element in '", data[ii].name, "' at '", sat, "'\n")
      end
      elm_r[i] = data[ii]:remove_sat(sat)
    end
  end
  data.ne = data.ne - ne
  build_index(seq)
  return elm_r, idx_r
end

local function replace (seq, elm, rng_, sel_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = seq.__dat

  if is_rawtable(elm) and is_nil(rng_) and is_nil(sel_) and elm.elements then
    rng_, elm = elm, elm.elements -- extract elements + right shift
  end

  if is_element(elm) then elm = {elm} end
  assert(is_rawtable(elm), "invalid argument #2 (elements list expected)")
  local ne = #elm
  if ne == 0 then return end

  -- check for elements only
  for i=1,ne do
    if not is_element(elm[i]) then
      error("item is not an element '"..
        (is_object(elm[i]) and (elm[i].name or '?') or type(elm[i])).."'")
    elseif is_sequence(elm[i]) then
      error("element is a sequence '"..(elm[i].name or '?').."'")
    elseif elm[i].kind == 'bline' then
      error("element is a beam line '"..(elm[i].name or '?').."'")
    end
  end

  -- collect indexes of elements to replace
  local idx_r, nr = filter(seq, rng_, sel_, true)
  if nr == 0 then return end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")
  assert(idx_r[ 1] > 1             , "invalid range, $start marker selected")
  assert(idx_r[nr] < #seq          , "invalid range, $end marker selected")

  local dbg = option.debug > 1
  local elm_r = table.new(nr,0)
  for i=1,nr do                                -- replace elements
    local ie = (i-1)%ne+1                      -- recycle list of elements
    if is_index(idx_r[i]) then
      local ii = idx_r[i]
      if dbg then
        io.write("seq: relacing element '", data[ii].name, "'\n")
      end
      elm_r[i], data[ii], data.spos[ii] = data[ii], elm[ie], uninitialized
    else
      local ii, sat = modf(idx_r[i])
      if dbg then
        io.write("seq: relacing sub-element in '", data[ii].name, "' at '", sat, "'\n")
      end
      elm[ie].sat = sat ; elm_r[i] = data[ii]:replace_at(elm[ie])
    end
  end
  nr = rmsubelm(idx_r, nr)                     -- remove the sub-elements
  for i=1,nr do elem_pos(seq, idx_r[i]) end    -- recompute the positions
  for i=1,nr do
    local idx = idx_r[i]
    if data[idx].shared == true then           -- shared element
      data[idx] = check_shared(seq, idx)
    end
    check_drift(seq, idx)                      -- check surrounding drifts
  end

  build_index(seq)
  return elm_r, idx_r
end

local function in_elem (seq, idx, spos)
  local data = seq.__dat
  return spos > data.spos[idx] and spos < data.spos[idx]+data.ds[idx]
end

local function install (seq, elm, rng_, sel_, cmp_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = seq.__dat

  if is_rawtable(elm) and is_nil(rng_) and is_nil(sel_) and elm.elements then
    rng_, elm = elm, elm.elements -- extract elements + right shift
  end

  if is_element(elm) then elm = {elm} end
  assert(is_rawtable(elm), "invalid argument #2 (elements list expected)")
  local ne = #elm
  if ne == 0 then return seq end

  -- inject subelements
  local subelm = elm.subelem

  -- collect indexes of reference where to insert
  local idx_r, nr = filter(seq, rng_, sel_, true)
  nr = rmsubelm(idx_r, nr) -- sub-elements cannot be selected
  if nr > 0 then
    assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")
  end

  -- collect elements and subsequences to install
  local ins = table.new(ne,0) -- no sref -> keep subsequence as-is
  flatten_line(elm, ins, nil, 1, 1)
  elm, ne, ins = ins, #ins -- update

  -- precompute number of elements with from='selected'
  local ns = 0
  for i=1,ne do
    if elm[i].from == 'selected' then
      if is_sequence(elm[i]) then
        error("invalid from 'selected' for sequence "..(elm[i].name or '?'))
      end
      ns = ns+1
    end
  end

  -- precompute position of each element
  -- ne: #element to install, ns: #element with from='selected', nr: #element selected
  -- ne-ns: #element to install once, ns*nr: ns elements to install nr times
  local i, ni = 0, ne-ns + ns*nr
  local ins, spos, upos = table.new(ni,0), table.new(ni,0), table.new(ni,0)
  for ie=1,ne do
    local e = elm[ie]
    if e.from ~= 'selected' then
      i = i + 1
      ins[i], spos[i], upos[i] = e, elem_pos(seq, 2        , e)
    else for ir=1,nr do
      i = i + 1
      ins[i], spos[i], upos[i] = e, elem_pos(seq, idx_r[ir], e)
    end end
  end

  -- insert elements -- need to be optimized to avoid O(N^2) insertion
  -- WARNING: elements at exact same positions must be inserted in user-order.
  local dbg, shf = option.debug > 1, 0
  local cmp = is_string(cmp_) and opstr[cmp_] or cmp_ or gfunc.lt
  assert(is_callable(cmp), "invalid argument #5 (callable expected)")
  if cmp(0,0) then shf = 1 end

  for ie=1,i do
    local idx = bsearch(data.spos, spos[ie], cmp, 1+shf, data.ne-1+shf)
    if is_sequence(ins[ie]) and #ins[ie] > 2 then      -- insert sub-sequence
      local sdata = ins[ie].__dat
      table.move(data     , idx, data.ne, idx+sdata.ne-2)
      table.move(data.spos, idx, data.ne, idx+sdata.ne-2)
      table.move(data.upos, idx, data.ne, idx+sdata.ne-2)
      table.move(data.ds  , idx, data.ne, idx+sdata.ne-2)
      table.move(data.algn, idx, data.ne, idx+sdata.ne-2)
      table.move(data.elgn, idx, data.ne, idx+sdata.ne-2)
      for j=2,sdata.ne-1 do -- see sequ_pos
        if dbg then
          io.write("seq: installing element '", sdata[j].name, "'\n")
        end
        data     [idx+j-2] = sdata     [j]
        data.spos[idx+j-2] = sdata.spos[j]+spos[ie]
        data.upos[idx+j-2] = sdata.upos[j]+spos[ie]
        data.ds  [idx+j-2] = sdata.ds  [j]
        data.algn[idx+j-2] = sdata.algn[j]
        data.elgn[idx+j-2] = sdata.elgn[j]
      end
      data.ne = data.ne + sdata.ne - 2
      check_drift(seq, idx+sdata.ne - 3) -- check surrounding drifts of lst
    elseif subelm and in_elem(seq, idx, spos[ie]) then -- insert sub-element
      if dbg then
        io.write("seq: installing sub-element '", ins[ie].name, "' at 'sat')\n")
      end
      local elm, sat = data[idx], 0
      if data.ds[idx] > 0 then sat = (spos[ie]-data.spos[idx])/data.ds[idx] end
      ins[ie].sat = sat ; elm:insert_sat(ins[ie]) -- check neg. dft or overlap ok?
    else                                               -- insert element
      if dbg then
        io.write("seq: installing element '", ins[ie].name, "'\n")
      end
      table.insert(data     , idx, ins [ie])
      table.insert(data.spos, idx, spos[ie])
      table.insert(data.upos, idx, upos[ie])
      table.insert(data.ds  , idx, ins [ie].l)
      table.insert(data.algn, idx, nil)
      table.insert(data.elgn, idx, nil)
      data.ne = data.ne + 1
      if data[idx].shared == true then   -- shared element
        data[idx] = check_shared(seq, idx)
      end
      check_drift(seq, idx)              -- check surrounding drifts
    end
  end

  build_index(seq)
  return seq
end

-- special --------------------------------------------------------------------o

local function publish (seq, env, keeporig_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(is_mappable(env), "invalid argument #2 (mappable expected)")
  local data, wrn = seq.__dat
  if env == MADX or is_instanceOf(env, MADX) then
    wrn, env.option.warn = env.option.warn, false
  end

  if not keeporig_ then
    for idx,elm in ipairs(data) do env[elm.name] = elm end
  else
    for idx,elm in ipairs(data) do
      local nam = elm.name
      if is_element(env[nam]) then data[idx] = env[nam] else env[nam] = elm end
    end
  end

  if wrn ~= nil then env.option.warn = wrn end
  return seq
end

local function reflect (seq, nam_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local nam = nam_ or seq.name..'_rev'
  return sequence(nam, { -seq })
end

local function cycle (seq, a)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(not seq:is_readonly(), "invalid write access to readonly sequence")
  if a then
    local idx = index_of(seq, a)
    assert(idx, "invalid argument #2 (valid reference expected)")
    assert(is_instanceOf(seq:elem(idx), marker),
                "invalid argument #2 (invalid reference to non-marker)")
  end
  seq:raw_set('__cycle', a)
  return seq
end

local function share (seq1, seq2)
  assert(is_sequence(seq1), "invalid argument #1 (sequence expected)")
  assert(is_sequence(seq2), "invalid argument #2 (sequence expected)")
  check_mark(seq1) check_mark(seq2)
  local data1, data2 = seq1.__dat, seq2.__dat

  local minlen = min(seq1.minlen or minlen, seq2.minlen or minlen)
  local elm_r, idx_r, nr = {}, {}, 1
  for i=2,data1.ne-1 do
    local nam = data1[i].name -- share by (unique) name
    local i1, i2 = data1.eidx[nam], data2.eidx[nam]
    if is_index(i1) and is_index(i2) then -- element name is unique in both sequences
      local e1, e2 = data1[i1], data2[i2]
      if e1 ~= e2 then
        assert(e1.name == nam and e2.name == nam, "unexpected corrupted dictionnary")
        local ds1 = data1.upos[i1]-data1.spos[i1]
        local ds2 = data2.upos[i2]-data2.spos[i2]
        assert(abs(e1.l-e2.l) < minlen, "incompatible shared elements (lengths differ)")
        assert(abs(ds1 -ds2 ) < minlen, "incompatible shared elements (upos-spos differ)")
        -- update arrays
        data2[i2], elm_r[nr], idx_r[nr], nr = e1, e2, i2, nr+1
      end
    end
  end
  fini_sequ(seq1) fini_sequ(seq2)
  return elm_r, idx_r
end

local function unique (seq, fmt_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  if is_string(fmt_) then fmt_ = bind1st(string.format, fmt_) end
  assert(is_nil(fmt_) or is_callable(fmt_), "invalid argument #2 (callable expected)")
  local data, lst = seq.__dat, table.new(0,100)

  for en,ei in pairs(data.eidx) do
    if is_table(ei) then
      table.clear(lst)
      for i=1,ei.n do
        local idx = ei[i]
        local elm = data[idx]
        lst[elm] = (lst[elm] or 0)+1
      end
      for i=1,ei.n do
        local idx, nam = ei[i]
        local elm = data[idx]
        if fmt_ then
          nam = fmt_(elm.name, i, idx)
          if data.eidx[nam] ~= nil then
            error("cannot rename uniquely element '"..nam.."' (already in use)")
          end
          data.eidx[nam] = idx
        end
        if lst[elm] > 1 then
          data[idx] = elm(nam,{})    -- replaced by unique child
        elseif fmt_ then
          elm.name = nam             -- override with unique name
        end
      end
      if fmt_ then data.eidx[en] = nil end
    end
  end
  fini_sequ(seq)
  return seq
end

-- iterators ------------------------------------------------------------------o

local function niliter (state, i)
  return nil
end

local function fwditer (state, i)
  local soff in state

  if i == state.stop then
    if state.turn == 0 then
      if not state.cycle then return nil end
      state.cycle = false
    else
      state.turn = state.turn-1
    end
  end

  if i < state.ne then
    i = i+1
  else
    i, state.soff = 1, soff+state.seq_l
    soff = state.soff
  end

  return i, state.data[i], state.spos[i]+soff, state.ds[i]
end

local function bwditer (state, i)
  local soff in state

  if i == state.stop then
    if state.turn == 0 then
      if not state.cycle then return nil end
      state.cycle = false
    else
      state.turn = state.turn-1
    end
  end

  if i > 1 then
    i = i-1
  else
    i, state.soff = state.ne, soff+state.seq_l
    soff = state.soff
  end

  local ds = state.ds[i]
  return i, state.data[i], state.spos[i]+ds-soff, -ds
end

---

local function fwdsiter (state, i)
  local data, spos, ds, soff, isdft in state

  if i == state.stop and not isdft then
    if state.turn == 0 then
      if not state.cycle then return nil end
      state.cycle = false
    else
      state.turn = state.turn-1
    end
  end

  if i == state.ne then
    i, soff = 1, state.seq_l+soff
    state.soff = soff
    return i, data[i], spos[i]+soff, ds[i]
  end

  local dl = isdft and 0 or (spos[i+1]-spos[i]) - ds[i]

  if dl <= state.minlen then  -- not implicit drift or too small (discard)
    i = i+1
    state.isdft = false
    return i, data[i], spos[i]+soff, ds[i]
  else                        -- update implicit drift
    state.isdft = true
    state.dft_l = dl
    state.dft_s = 'drift__'..i
    return i, state.dft, (spos[i]+ds[i])+soff, dl
  end
end

local function bwdsiter (state, i)
  local data, spos, ds, soff, isdft in state

  if i == state.stop and not isdft then
    if state.turn == 0 then
      if not state.cycle then return nil end
      state.cycle = false
    else
      state.turn = state.turn-1
    end
  end

  if i == 1 then
    i, soff = state.ne, state.seq_l+soff
    state.soff = soff
    return i, data[i], spos[i]+ds[i]-soff, -ds[i]
  end

  local dl = isdft and 0 or (spos[i]-spos[i-1]) - ds[i-1]

  if dl <= state.minlen then  -- not implicit drift or too small (discard)
    i = i-1
    state.isdft = false
    return i, data[i], spos[i]+ds[i]-soff, -ds[i]
  else                        -- update implicit drift
    state.isdft = true
    state.dft_l = dl
    state.dft_s = 'drift__'..i
    return i, state.dft, spos[i]-soff, -dl
  end
end

---

local function iter (seq, rng_, ntrn_, dir_)
  local nturn, dir = ntrn_ or 1
  assert(is_sequence(seq)   , "invalid argument #1 (sequence expected)")
  assert(is_nznatural(nturn), "invalid argument #3 (natural > 0 expected)")

  if #seq == 0 then return niliter end

  local data, start, stop, cycle = seq.__dat
  if is_nil(rng_) then
    local idx1, idxn = 1, data.ne
    dir = dir_ or 1
    if dir < 0 then idx1, idxn = idxn, idx1 end
    if is_nil(seq.__cycle) then
      start, stop = idx1, idxn
    else
      start = assert(index_of(seq, seq.__cycle), "invalid cycle reference")
      stop  = start == idx1 and idxn or start
      cycle = true
    end
  else
    start, stop, dir = range_of(seq, rng_, nil, dir_)
    if is_nil(start) then return niliter end
  end
  if start == stop+dir then nturn = nturn+1 end

  assert(dir == 1 or dir == -1, "invalid argument #4 (1 or -1 expected)")

  local soff = dir > 0 and -data.spos[start] or data.spos[start]+data.ds[start]
  return dir > 0 and fwditer or bwditer, {
    data=data, spos=data.spos, ds=data.ds, ne=data.ne, soff=soff, dir=dir,
    seq=seq, seq_l=seq.l, stop=stop, cycle=cycle, turn=nturn-1}, start-dir
end

local function siter (seq, rng_, ntrn_, dir_)
  local iter, state, start = iter(seq, rng_, ntrn_, dir_)
  if iter == niliter then return iter end
  -- implicit drift (reused)
  state.minlen = seq.minlen or minlen
  state.isdft  = true ; state.dft_l = 0 ; state.dft_s = ''
  state.dft    = drift { l := state.dft_l, name := state.dft_s }
                       :set_flags(implicit) :set_readonly()
  if start == state.stop then state.turn = state.turn-1 end
  local dir = dir_ or state.dir
  return dir < 0 and bwdsiter or fwdsiter, state, start
end

-- flags ----------------------------------------------------------------------o

local function save_flags (seq, flgs_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = seq.__dat
  local flgs = flgs_ or table.new(data.ne,0)
  for i=1,data.ne do flgs[i] = data[i]:get_flags() end
  return flgs
end

local function restore_flags (seq, flgs)
  assert(is_sequence(seq ), "invalid argument #1 (sequence expected)")
  assert(is_iterable(flgs), "invalid argument #2 (iterable expected)")
  local data = seq.__dat
  for i=1,data.ne do data[i]:clear_flags(-1):set_flags(flgs[i]) end
end

-- I/O ------------------------------------------------------------------------o

-- dump seq positions
local function dumpseq (seq, filnam_, info_)
  if is_boolean(filnam_) and is_nil(info_) then
    info_, filnam_ = filnam_ -- right shift
  end
  local res, eal0 = table.new(#seq,0)

  -- header
  res[1] = 'sequence: ' .. seq.name .. ', ' ..
           'l=' .. (seq.l == uninitialized and 'uninitialized' or seq.l)
  res[2] = 'idx  kind          name                    l          dl       \z
            spos       upos    uds'
  if info_ then
    eal0 = {dx=0, dy=0, ds=0, dtheta=0, dphi=0, dpsi=0}
    res[2] = res[2] .. '       dx         dy         ds         \z
                               dtheta     dphi       dpsi'
  end

  -- elements
  seq:foreach \e,i =>
    local ds, uds = seq:ds(i), seq:upos(i)-seq:spos(i)
    local dl = ds-e.l
    res[#res+1] = string.format('%03d  %-14s%-20s%9.3f%8.3g%s%11.3f%11.3f%8.3f%s',
                  i, e.kind, e.name, e.l, dl, abs(dl) > eps and '*' or ' ',
                  seq:spos(i), seq:upos(i), uds, (uds<0 or uds>ds) and '*' or '')
    if info_ then
      local eal = seq:align(i) or eal0
      res[#res] = res[#res] ..
                  string.format('%11.4f%11.4f%11.4f%11.4f%11.4f%11.4f',
                    eal.dx, eal.dy, eal.ds, eal.dtheta, eal.dphi, eal.dpsi)
    end
  end

  -- return result as a string
  if filnam_ == '-' then return table.concat(res, '\n') end

  -- dump to file
  local file = assert(openfile(filnam_, 'w', '.dat'),
                      "unable to open SeqDump file in write mode")
  for _,s in ipairs(res) do file:write(s,'\n') end
  if is_string(filnam_) then file:close() else file:flush() end

  return seq
end

-- members --------------------------------------------------------------------o

sequence :set_methods {
  -- elem, spos, upos, ds, canonical index
  elem          = \s,i -> is_index(i) and s.__dat     [i] or nil,
  spos          = \s,i -> is_index(i) and s.__dat.spos[i] or nil,
  upos          = \s,i -> is_index(i) and s.__dat.upos[i] or nil,
  ds            = \s,i -> is_index(i) and s.__dat.ds  [i] or nil,
  align         = \s,i -> is_index(i) and s.__dat.algn[i] or nil,
  ealign        = \s,i -> is_index(i) and s.__dat.elgn[i] or nil,
  index         = index,

  -- elements manipulation
--  getelm       = get_elm,
--  addelm       = add_elm,
--  setelm       = set_elm,
--  remelm       = rem_elm,
--  inselm       = ins_elm,

  -- sequence-like methods
  name_of       = name_of,
  index_of      = index_of,
  range_of      = range_of,
  length_of     = length_of,

  foreach       = foreach,
  select        = select,
  deselect      = deselect,
  filter        = filter,

  install       = install,
  remove        = remove,
  replace       = replace,
  move          = move,
  update        = update,
  misalign      = misalign,

  reflect       = reflect,
  cycle         = cycle,
  share         = share,
  unique        = unique,

  iter          = iter,
  siter         = siter,

  -- read/write/dump
  read         := error("NYI", 2), -- TODO (possible?)
  write        := error("NYI", 2), -- TODO (useful?)
  dumpseq       = dumpseq,

  -- publish elements in an environment
  publish       = publish,

  -- duplicate
  copy          = copy_mm,

  -- ownership
  is_view       = is_view,

  -- flags
  save_flags    = save_flags,
  restore_flags = restore_flags,

  -- for debugging
  check_sequ    = check_sequ,

  -- disabled method
  is_selected  := error("invalid sequence operation", 2),

} :set_metamethods {
  __sequ        = _id,
  __init        = init_mm,
  __copy        = copy_mm,
  __len         = len_mm,
  __index       = index_mm,
  __newindex    = newindex_mm,
-- __ipairs     = ipairs_mm , default from object
-- __pairs      = pairs_mm  , default from object
} :set_readonly()

-- env ------------------------------------------------------------------------o

MAD.typeid.is_sequence = is_sequence

-- end -------------------------------------------------------------------------
return { sequence = sequence }
