--[=[
 o-----------------------------------------------------------------------------o
 |
 | Generic math module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Extends math module and provides object-oriented dispatch to math functions.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'
local complex = ffi.typeof 'complex'

local _C, option                                                 in MAD
local nan, twopi                                                 in MAD.constant
local first, second                                              in MAD.gfunc
local is_nan, is_nil, is_number, is_positive, wrestrict,
      set_concept, concept                                       in MAD.typeid
local not_mappable, not_extendable, not_mutable                  in concept

local abs, acos, asin, atan, atan2, ceil, cos, cosh, exp, floor,
      log, log10, max, min, modf, pow, random, randomseed,
      sin, sinh, sqrt, tan, tanh, pi                             in math

-- t={}; for k in pairs(math) do t[#t+1]=k end;
-- table.sort(t); print(table.concat(t,', '))

local type, getmetatable, setmetatable, assert, debug =
      type, getmetatable, setmetatable, assert, debug

-- number metatable -----------------------------------------------------------o

assert(is_nil(getmetatable(0)), "metatable for number type is already set")

debug.setmetatable(0, {
  __index = {
    __emul = \x,y,r_ -> y.__emul(x,y,r_),
    __ediv = \x,y,r_ -> y.__ediv(x,y,r_),
    __emod = \x,y,r_ -> y.__emod(x,y,r_),
    __epow = \x,y,r_ -> y.__epow(x,y,r_),
  },
})

-- helper ---------------------------------------------------------------------o

local sign  = \x -> x == x and _C.mad_num_sign (x) or x   -- return 0, ±1 or NaN
local sign1 = \x -> x == x and _C.mad_num_sign1(x) or x   -- return    ±1 or NaN

-- check for potential bug in round function
assert(is_nan(_C.round(nan))              , "round does not preserve NaN")
assert(_C.round(0x1.fffffffffffffp-2) == 0, "round bug near 0.5 detected")

-- alternate correct definition
-- round = \x -> x <= -0.5 and ceil (x-0.5) or
--               x >=  0.5 and floor(x+0.5) or sign1(x)*0.0 -- ±0, keep sign

-- implementation -------------------------------------------------------------o

local gmath = {

  -- generic operators
  unm      = \x   ->  -x,
  sqr      = \x   -> x * x,
  inv      = \x   -> 1 / x,
  add      = \x,y -> x + y,
  sub      = \x,y -> x - y,
  mul      = \x,y -> x * y,
  div      = \x,y -> x / y,
  mod      = \x,y -> x % y,
  pow      = \x,y -> x ^ y,
  emul     = \x,y,_r -> x:__emul(y,r_), -- .*
  ediv     = \x,y,_r -> x:__ediv(y,r_), -- ./
  emod     = \x,y,_r -> x:__emod(y,r_), -- .%
  epow     = \x,y,_r -> x:__epow(y,r_), -- .^

  -- generic functions
  abs      = \x -> type(x) == "number" and abs     (x)     or x:abs    (),
  ceil     = \x -> type(x) == "number" and ceil    (x)     or x:ceil   (),
  floor    = \x -> type(x) == "number" and floor   (x)     or x:floor  (),
  frac     = \x -> type(x) == "number" and second(modf(x)) or x:frac   (),
  trunc    = \x -> type(x) == "number" and modf    (x)     or x:trunc  (),
  round    = \x -> type(x) == "number" and _C.round(x)     or x:round  (),
  sign     = \x -> type(x) == "number" and sign    (x)     or x:sign   (),
  sign1    = \x -> type(x) == "number" and sign1   (x)     or x:sign1  (),
           
  unit     = \x -> type(x) == "number" and x/abs   (x)     or x:unit   (),
  sqrt     = \x -> type(x) == "number" and sqrt    (x)     or x:sqrt   (),
  exp      = \x -> type(x) == "number" and exp     (x)     or x:exp    (),
  log      = \x -> type(x) == "number" and log     (x)     or x:log    (),
  log10    = \x -> type(x) == "number" and log10   (x)     or x:log10  (),
  
  sin      = \x -> type(x) == "number" and sin     (x)     or x:sin    (),
  cos      = \x -> type(x) == "number" and cos     (x)     or x:cos    (),
  tan      = \x -> type(x) == "number" and tan     (x)     or x:tan    (),
  cot      = \x -> type(x) == "number" and 1/tan   (x)     or x:cot    (),
  sinh     = \x -> type(x) == "number" and sinh    (x)     or x:sinh   (),
  cosh     = \x -> type(x) == "number" and cosh    (x)     or x:cosh   (),
  tanh     = \x -> type(x) == "number" and tanh    (x)     or x:tanh   (),
  coth     = \x -> type(x) == "number" and 1/tanh  (x)     or x:coth   (),
  asin     = \x -> type(x) == "number" and asin    (x)     or x:asin   (),
  acos     = \x -> type(x) == "number" and acos    (x)     or x:acos   (),
  atan     = \x -> type(x) == "number" and atan    (x)     or x:atan   (),
  acot     = \x -> type(x) == "number" and atan  (1/x)     or x:acot   (),
  asinh    = \x -> type(x) == "number" and _C.asinh(x)     or x:asinh  (),
  acosh    = \x -> type(x) == "number" and _C.acosh(x)     or x:acosh  (),
  atanh    = \x -> type(x) == "number" and _C.atanh(x)     or x:atanh  (),
  acoth    = \x -> type(x) == "number" and _C.atanh(1/x)   or x:acoth  (),
             
  sinc     = \x -> type(x) == "number" and _C.mad_num_sinc  (x) or x:sinc  (),
  sinhc    = \x -> type(x) == "number" and _C.mad_num_sinhc (x) or x:sinhc (),
  asinc    = \x -> type(x) == "number" and _C.mad_num_asinc (x) or x:asinc (),
  asinhc   = \x -> type(x) == "number" and _C.mad_num_asinhc(x) or x:asinhc(),
            
  invsqrt  = \x,v_ -> type(x) == "number" and (v_ or 1)/sqrt(x) or x:invsqrt(v_),
  powi     = \x,n  -> type(x) == "number" and _C.mad_num_powi(x,n) or x:powi(n),

  -- generic functions with 2+ arguments
  atan2    = \x,y   -> type(x) == "number" and atan2(x,y)                or x:atan2(y),
  hypot    = \x,y   -> type(x) == "number" and _C.hypot(x,y)             or x:hypot(y),
  hypot3   = \x,y,z -> type(x) == "number" and _C.hypot(x,_C.hypot(y,z)) or x:hypot3(y,z),

  tgamma   = \x,tol -> type(x) == "number" and _C.tgamma(x) or x:tgamma(tol),
  lgamma   = \x,tol -> type(x) == "number" and _C.lgamma(x) or x:lgamma(tol),

  -- Faddeeva based functions
  wf       = \x,tol -> type(x) == "number" and _C.mad_num_wf    (x) or x:wf    (tol),
  erf      = \x,tol -> type(x) == "number" and _C.mad_num_erf   (x) or x:erf   (tol),
  erfc     = \x,tol -> type(x) == "number" and _C.mad_num_erfc  (x) or x:erfc  (tol),
  erfi     = \x,tol -> type(x) == "number" and _C.mad_num_erfi  (x) or x:erfi  (tol),
  erfcx    = \x,tol -> type(x) == "number" and _C.mad_num_erfcx (x) or x:erfcx (tol),
  dawson   = \x,tol -> type(x) == "number" and _C.mad_num_dawson(x) or x:dawson(tol),

  -- complex generic functions
  real     = \x -> type(x) == "number" and x                               or x:real(),
  imag     = \x -> type(x) == "number" and 0                               or x:imag(),
  conj     = \x -> type(x) == "number" and x                               or x:conj(),
  cabs     = \x -> type(x) == "number" and abs(x)                          or x:cabs(),
  carg     = \x -> type(x) == "number" and (x>=0 and 0 or x<0 and pi or x) or x:carg(),
  proj     = \x -> type(x) == "number" and (x+0i):proj()                   or x:proj(),
  rect     = \x -> type(x) == "number" and x                               or x:rect(),
  polar    = \x -> type(x) == "number" and abs(x)+(x>=0 and 0 or x<0 and pi or x)*1i or x:polar(),

  -- build complex types from two real types
  cplx     = \x,y -> type(x) == "number" and complex(x,y) or x and x:cplx(y) or y.cplx(x,y),
  -- return two real types from complex types
  reim     = \z   -> (z:real(), z:imag()),

  -- segment vs arc vs cord conversion
  rangle   = 'set below',
  cord2arc = 'set below',
  arc2cord = 'set below',
  len2cord = 'set below',
  cord2len = 'set below',
  len2arc  = 'set below',
  arc2len  = 'set below',

  -- some function useful for folding
  sumsqr   = 'set below',
  sumabs   = 'set below',
  minabs   = 'set below',
  maxabs   = 'set below',
  sumysqr  = 'set below',
  sumyabs  = 'set below',
  minyabs  = 'set below',
  maxyabs  = 'set below',
  sumxsqr  = 'set below',
  sumxabs  = 'set below',
  minxabs  = 'set below',
  maxxabs  = 'set below',

  -- non-generic functions
  fact     = \n -> _C.mad_num_fact(n),
  invfact  = \n -> _C.mad_num_invfact(n),

  -- default uniform RNG
  random     = random,
  randomseed = randomseed,
}

--[[
l_arc  = A*R
l_arc  = l_cord/sinc(A/2)
l_cord = 2*R*sin(A/2)
l_cord = sinc(A/2)*l_arc
]]

do -- extra functions that relies on gmath itself
  local abs, round, sinc in gmath

  gmath.rangle   = \a,r -> a + twopi * round((r - a) / twopi)  -- (util:proxim)
  gmath.cord2arc = \l,a -> l /  sinc(0.5*a)
  gmath.arc2cord = \l,a -> l *  sinc(0.5*a)
  gmath.len2cord = \l,a -> l /  cos(a)
  gmath.cord2len = \l,a -> l *  cos(a)
  gmath.len2arc  = \l,a -> l / (sinc(0.5*a)*cos(a))
  gmath.arc2len  = \l,a -> l *  sinc(0.5*a)*cos(a)

  -- map2
  gmath.sumsqr   = \x,y -> x*x + y*y
  gmath.sumabs   = \x,y -> abs(x) + abs(y)
  gmath.minabs   = \x,y -> min(abs(x),abs(y))
  gmath.maxabs   = \x,y -> max(abs(x),abs(y))
  -- fold left
  gmath.sumysqr  = \x,y -> x + y*y
  gmath.sumyabs  = \x,y -> x + abs(y)
  gmath.minyabs  = \x,y -> min(x,abs(y))
  gmath.maxyabs  = \x,y -> max(x,abs(y))
  -- fold right
  gmath.sumxsqr  = \x,y -> x*x + y
  gmath.sumxabs  = \x,y -> abs(x) + y
  gmath.minxabs  = \x,y -> min(abs(x),y)
  gmath.maxxabs  = \x,y -> max(abs(x),y)
end

-- random number generators ---------------------------------------------------o

local istype in ffi

-- MAD XoShiRo256** -- see mad_num.c
-- generates 64 pseudo-random bits in [0,ULLONG_MAX].
-- generates 52 pseudo-random bits in [0,1).
-- single stream full period is 2^256.
-- support 2^128 jumps of period 2^128 to create multiple independent streams.

ffi.cdef [[
struct prng_state {
  u64_t s[4];
  num_t x;
};
]]

-- MAD-X generator -- see mad_num.c

ffi.cdef [[
struct xrng_state {
  int s[55];
  idx_t n;
  num_t x;
};
]]

local prng_ctor = ffi.typeof 'struct prng_state'
local prng_sz   = ffi.sizeof 'struct prng_state'
local xrng_ctor = ffi.typeof 'struct xrng_state'
local xrng_sz   = ffi.sizeof 'struct xrng_state'

local is_randgen  = \a -> istype(prng_ctor, a)
local is_xrandgen = \a -> istype(xrng_ctor, a)
local is_arandgen = \a -> istype(prng_ctor, a) or istype(xrng_ctor, a)

local randjump  = \r    => _C.mad_num_randjump (r)         r.x = nan return r end
local randseed  = \r,x  => _C.mad_num_randseed (r, x or 0) r.x = nan return r end
local xrandseed = \r,x  => _C.mad_num_xrandseed(r, x or 0) r.x = nan return r end

local gref = randseed(prng_ctor()) -- reference generator
local grng = randseed(prng_ctor()) -- global    generator

local function randnew ()
  local rng = prng_ctor()
  ffi.copy(rng, gref, prng_sz)
  return rng:randjump()
end

local function xrandnew ()
  return xrng_ctor():randseed(123456789)
end

local function randset (rng_)
  local rng = grng
  if rng_ then
    assert(is_arandgen(rng_), "invalid argument #1 (randgen expected)")
    grng = rng_
  end
  return rng
end

local function rand (rng)
  return _C.mad_num_rand(rng)
end

local function randi (rng)
  return _C.mad_num_randi(rng)
end

local function xrand (rng)
  return _C.mad_num_xrand(rng)
end

local function xrandi (rng)
  return _C.mad_num_xrandi(rng)
end

-- Box-Muller transformation (Marsaglia's polar form)
-- generates pseudo-random gaussian numbers (pairs of, cached)
local function randn (rng)
  local x1, x2, w
  if rng.x == rng.x then
    x1, rng.x = rng.x, nan
    return x1
  end
  repeat
    x1 = 2*rng:rand() - 1
    x2 = 2*rng:rand() - 1
    w = x1*x1 + x2*x2
  until w < 1
  w = sqrt( -2 * log(w) / w )
  rng.x = x2*w
  return x1*w
end

-- Truncated normal distribution (TODO: use direct formula for cut < ~0.7)
local function randtn (rng, cut_)
  if is_nil(cut_) then return rng:randn() end
  assert(is_number(cut_), "invalid argument #2 (number expected)")
  local c, r = abs(cut_)
  repeat r = rng:randn() until abs(r) <= c
  return r
end

-- Inverse transform sampling (for 'small' lamdba in O(lambda))
-- Discrete Univariate Distributions, L. Devroye, p505
local function randp (rng, lmb_)
  local lmb = lmb_ or 1
  assert(is_positive(lmb) and lmb < 30,
         "invalid argument #2 (0 < lambda < 30 expected)")
  local x, p = 0, exp(-lmb)
  local s, u = p, rng:rand()
  while u > s do
    x = x + 1
    p = p * lmb/x
    s = s + p
  end
  return x
end

-- RNG as an infinite stream
local function iter (rng, i)
  return i+1, rng:rand()
end

local prng_mt = set_concept({
  __index = {
    rand     = rand,
    randi    = randi,
    randn    = randn,
    randp    = randp,
    randtn   = randtn,
    randseed = randseed,
  },
  __ipairs   = \r -> (iter, r, 0),
  __tostring = \r -> string.format("RNG: %p", r),
}, not_mappable + not_extendable + not_mutable)

ffi.metatype('struct prng_state', prng_mt)

local xrng_mt = set_concept({
  __index = {
    rand     = xrand,
    randi    = xrandi,
    randn    = \r -> first(randn(r),randn(r)), -- MADX discard even trials...
    randp    = randp,
    randtn   = randtn,
    randseed = xrandseed,
  },
  __ipairs   = \r -> (iter, r, 0),
  __tostring = \r -> string.format("XRNG: %p", r),
}, not_mappable + not_extendable + not_mutable)

ffi.metatype('struct xrng_state', xrng_mt)

-- gmath ----------------------------------------------------------------------o

gmath.randnew  = randnew
gmath.xrandnew = xrandnew
gmath.randset  = randset

gmath.rand  = \rng_ -> ((rng_ or grng):rand ())
gmath.randi = \rng_ -> ((rng_ or grng):randi())
gmath.randn = \rng_ -> ((rng_ or grng):randn())

function gmath.randtn (rng_, cut_)
  if is_number(rng_) then cut_, rng_ = rng_, nil end -- right shift
  return (rng_ or grng):randtn(cut_)
end

function gmath.randp (rng_, lmb_)
  if is_number(rng_) then lmb_, rng_ = rng_, nil end -- right shift
  return (rng_ or grng):randp(lmb_)
end

function gmath.randseed (rng_, seed)
  if is_number(rng_) then seed, rng_ = rng_, nil end -- right shift
  return (rng_ or grng):randseed(seed)
end

-- env ------------------------------------------------------------------------o

MAD.typeid.is_randgen  = is_randgen
MAD.typeid.is_xrandgen = is_xrandgen
MAD.typeid.is_arandgen = is_arandgen

gmath = wrestrict(setmetatable(gmath, {__tostring := "MAD.gmath"}))

-- end ------------------------------------------------------------------------o
return { gmath = gmath }
