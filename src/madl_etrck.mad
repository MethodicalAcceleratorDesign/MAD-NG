--[=[
 o-----------------------------------------------------------------------------o
 |
 | Track element methods (loaded by track)
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

--[=[
Notes about directions and quantities:
  edir: element direction affects curvatures (edir = seq.dir).
  sdir: track direction s affects lengths    (sdir = cmd.dir).
  tdir: time direction t  affects angles     (tdir = edir x sdir).
  bdir: beam direction    affects strengths  (bdir = edir x sdir x chg).
--]=]

-- locals ---------------------------------------------------------------------o

local element, damap, symint, option, warn, _C                  in MAD
local is_number, is_function                                    in MAD.typeid
local fnil, fcut, ftst, bind3rd                                 in MAD.gfunc
local fact, arc2cord, sqrt, sin, cos, atan2                     in MAD.gmath
local assertf, errorf                                           in MAD.utility
local minlen, minang, minstr, clight, mu0, twopi, pi_2          in MAD.constant
local is_implicit                                               in element.drift

local type = type

local abs, max in math -- ensure that abs will not work on GTPSA.

-- redefine abs for this module (only!)
local abs = \a -> type(a) == "number" and abs(a) or abs(a:get0())

-- constants
local minvolt = 1e-6

local getanbnr in require("madl_curvmul")

-- integrator schemes ---------------------------------------------------------o

local thinonly, thickonly, driftonly, DKD, TKT, KMK                in MAD.symint

-- dynamic maps ---------------------------------------------------------------o

-- straight elements (DKD)
local strex_drift, strex_kick             , strex_fringe           in MAD.dynmap
local              strex_kickhs                                    in MAD.dynmap

-- curved elements (DKD)
local curex_drift, curex_kick             , curex_fringe           in MAD.dynmap

-- sbend (TKT)
local sbend_thick,  sbend_kick            , dipeg_fringe           in MAD.dynmap

-- rbend (TKT)
local rbend_thick,  rbend_kick                                     in MAD.dynmap

-- quadrupole (TKT)
local quad_thick , quad_kick , quad_kick_ ,
      quad_thicks, quad_kicks, quad_kicks_,
      quad_thickh, quad_kickh, quad_kickh_                         in MAD.dynmap

-- solenoid (TKT)
local solen_thick                         , solen_fringe           in MAD.dynmap

-- electrostatic separator
local esept_thick                                                  in MAD.dynmap

-- non-linear elliptical lens
local nllens_kick                                                  in MAD.dynmap

-- rfcavity
local rfcav_kick, rfcav_kickn             , rfcav_fringe           in MAD.dynmap

-- beambeam
local bbeam_kick, bbeam_kick6D                                     in MAD.dynmap

-- wire
local wire_kick                                                    in MAD.dynmap

-- generic linear map and damap
local linm_thin, genm_thick                                        in MAD.dynmap

-- patches
local xrotation, yrotation, srotation, translate,
      changeref, changedir, changenrj, misalign, tilt              in MAD.dynmap

-- fringe flags
local fringe                                                       in MAD.dynmap

-- dynamic maps in C ----------------------------------------------------------o

local ffi = require 'ffi'

ffi.cdef [[
enum { nmul_max=22, snm_max=(nmul_max+1)*(nmul_max+2)/2 };

struct cflw_r { // must be identical to def in mad_dynmap.cpp with M=par_t !!
  str_t name;
  int dbg;

  // beam
  num_t pc, beta, betgam;
  int charge;

  // directions, path
  int sdir, edir, pdir, T, Tbak;

// start of polymorphic section

  // element data
  num_t el, eld, elc, lrad;
  num_t eh, ehd, ang, mang;

  // quad, solenoid, multipole, esptum, rfcav, sine & cosine
  num_t k1, ks, volt, freq, lag, sa, ca;
  int nbsl;

  // fringes
  int frng, fmax;
  num_t e, h, a, fint, hgap, f1, f2;

  // patches, misalignments & tilt
  bool  rot, trn;
  num_t dx,   dy,   ds;
  num_t dthe, dphi, dpsi, tlt;

  // multipoles
  int   nmul;
  num_t knl[nmul_max];
  num_t ksl[nmul_max];

  // curved multipoles
  int   snm;
  num_t bfx[snm_max];
  num_t bfy[snm_max];

  // particles
  int    npar;
  num_t **par;
};

struct cflw_t { // must be identical to def in mad_dynmap.cpp with M=map_t !!
  str_t name;
  int dbg;

  // beam
  num_t pc, beta, betgam;
  int charge;

  // directions, path
  int sdir, edir, pdir, T, Tbak;

// start of polymorphic section

  // element data
  num_t el, eld, elc, lrad;
  num_t eh, ehd, ang, mang;

  // quad, solenoid, multipole, esptum, rfcav, sine & cosine
  num_t k1, ks, volt, freq, lag, sa, ca;
  int nbsl;

  // fringes
  int frng, fmax;
  num_t e, h, a, fint, hgap, f1, f2;

  // patches, misalignments & tilt
  bool  rot, trn;
  num_t dx,   dy,   ds;
  num_t dthe, dphi, dpsi, tlt;

  // multipoles
  int   nmul;
  num_t knl[nmul_max];
  num_t ksl[nmul_max];

  // curved multipoles
  int   snm;
  num_t bfx[snm_max];
  num_t bfy[snm_max];

  // damaps
  int      npar;
  tpsa_t* **par;
};

struct cflw_p { // must be identical to def in mad_dynmap.cpp with M=prm_t !!
  str_t name;   //           and the prms_list in track must be consistent !!
  int dbg;

  // beam
  num_t pc, beta, betgam;
  int charge;

  // directions, path
  int sdir, edir, pdir, T, Tbak;

// start of polymorphic section

  // element data
  tpsa_t *el, *eld, *elc, *lrad;
  tpsa_t *eh, *ehd, *ang, *mang;

  // quad, solenoid, multipole, esptum, rfcav, sine & cosine
  tpsa_t *k1, *ks, *volt, *freq, *lag, *sa, *ca;
  int nbsl;

  // fringes
  int frng, fmax;
  tpsa_t *e, *h, *a, *fint, *hgap, *f1, *f2;

  // patches, misalignments & tilt
  bool  rot, trn;
  tpsa_t *dx,   *dy,   *ds;
  tpsa_t *dthe, *dphi, *dpsi, *tlt;

  // multipoles
  int    nmul;
  tpsa_t *knl[nmul_max];
  tpsa_t *ksl[nmul_max];

  // curved multipoles
  int     snm;
  tpsa_t *bfx[snm_max];
  tpsa_t *bfy[snm_max];

  // parametric damaps
  int      npar;
  tpsa_t* **par;
};

union cflw_x {
  struct cflw_r rflw;
  struct cflw_t tflw;
  struct cflw_p pflw;
};

extern const size_t mad_cflw_rsize;
extern const size_t mad_cflw_tsize;
extern const size_t mad_cflw_psize;
extern const size_t mad_cflw_xsize;
]]

local msg = "FFI/C %s is not consistent with C/C++ %s from mad_dynmap.cpp"

assertf(ffi.sizeof("struct cflw_r") == _C.mad_cflw_rsize, msg, "struct cflw_r", "struct cflw<par_t>")
assertf(ffi.sizeof("struct cflw_t") == _C.mad_cflw_tsize, msg, "struct cflw_t", "struct cflw<map_t>")
assertf(ffi.sizeof("struct cflw_p") == _C.mad_cflw_psize, msg, "struct cflw_p", "struct cflw<prm_t>")
assertf(ffi.sizeof("union  cflw_x") == _C.mad_cflw_xsize, msg, "union cflw_x", "union cflw_x")

local txflw  = { r = 'rflw' , t = 'tflw' , T = 'tflw' , p = 'pflw'  }
local txflw_ = { r = 'rflw_', t = 'tflw_', T = 'tflw_', p = 'pflw_' }
local  xflw  = \m,c_ -> assert(m[txflw [c_ or m.cmap]], "invalid cmap")
local  xflw_ = \m,c_ -> assert(m[txflw_[c_ or m.cmap]], "invalid cmap")

local function xcpy (a, b)
      if type(a) == "number" then return b
  elseif type(b) == "number" then _C.mad_tpsa_setval(a,b) return a
  else                            _C.mad_tpsa_copy  (b,a) return a
  end
end

local maps = {
  r = { -- real, not used
    [strex_drift ] = _C.mad_trk_strex_drift_r ,
    [strex_kick  ] = _C.mad_trk_strex_kick_r  ,
    [strex_kickhs] = _C.mad_trk_strex_kickhs_r,
    [strex_fringe] = _C.mad_trk_strex_fringe_r,
    [curex_drift ] = _C.mad_trk_curex_drift_r ,
    [curex_kick  ] = _C.mad_trk_curex_kick_r  ,
    [curex_fringe] = _C.mad_trk_curex_fringe_r,
    [sbend_thick ] = _C.mad_trk_sbend_thick_r ,
    [sbend_kick  ] = _C.mad_trk_sbend_kick_r  ,
    [dipeg_fringe] =            dipeg_fringe  ,
    [rbend_thick ] = _C.mad_trk_rbend_thick_r ,
    [rbend_kick  ] = _C.mad_trk_rbend_kick_r  ,
    [quad_thick  ] = _C.mad_trk_quad_thick_r  ,
    [quad_thicks ] = _C.mad_trk_quad_thicks_r ,
    [quad_thickh ] = _C.mad_trk_quad_thickh_r ,
    [quad_kick   ] = _C.mad_trk_quad_kick_r   ,
    [quad_kicks  ] = _C.mad_trk_quad_kicks_r  ,
    [quad_kickh  ] = _C.mad_trk_quad_kickh_r  ,
    [quad_kick_  ] = _C.mad_trk_quad_kick__r  ,
    [quad_kicks_ ] = _C.mad_trk_quad_kicks__r ,
    [quad_kickh_ ] = _C.mad_trk_quad_kickh__r ,
    [solen_thick ] = _C.mad_trk_solen_thick_r ,
    [solen_fringe] =            solen_fringe  ,
    [rfcav_kick  ] = _C.mad_trk_rfcav_kick_r  ,
    [rfcav_kickn ] = _C.mad_trk_rfcav_kickn_r ,
    [rfcav_fringe] = _C.mad_trk_rfcav_fringe_r,
    [esept_thick ] = _C.mad_trk_esept_thick_r ,
    [nllens_kick ] =            nllens_kick   ,
    [bbeam_kick  ] =            bbeam_kick    ,
    [bbeam_kick6D] =            bbeam_kick6D  ,
    [wire_kick   ] =            wire_kick     ,
    [genm_thick  ] =            genm_thick    ,
    [xrotation   ] = _C.mad_trk_xrotation_r   ,
    [yrotation   ] = _C.mad_trk_yrotation_r   ,
    [srotation   ] = _C.mad_trk_srotation_r   ,
    [translate   ] = _C.mad_trk_translate_r   ,
    [changeref   ] = _C.mad_trk_changeref_r   ,
    [changedir   ] =            changedir     ,
    [changenrj   ] =            changenrj     ,
    [misalign    ] = _C.mad_trk_misalign_r    ,
    [tilt        ] = _C.mad_trk_tilt_r        ,
    [fnil        ] =            fnil          ,
  },
  t = { -- tpsa
    [strex_drift ] = _C.mad_trk_strex_drift_t ,
    [strex_kick  ] = _C.mad_trk_strex_kick_t  ,
    [strex_kickhs] = _C.mad_trk_strex_kickhs_t,
    [strex_fringe] = _C.mad_trk_strex_fringe_t,
    [curex_drift ] = _C.mad_trk_curex_drift_t ,
    [curex_kick  ] = _C.mad_trk_curex_kick_t  ,
    [curex_fringe] = _C.mad_trk_curex_fringe_t,
    [sbend_thick ] = _C.mad_trk_sbend_thick_t ,
    [sbend_kick  ] = _C.mad_trk_sbend_kick_t  ,
    [dipeg_fringe] =            dipeg_fringe  ,
    [rbend_thick ] = _C.mad_trk_rbend_thick_t ,
    [rbend_kick  ] = _C.mad_trk_rbend_kick_t  ,
    [quad_thick  ] = _C.mad_trk_quad_thick_t  ,
    [quad_thicks ] = _C.mad_trk_quad_thicks_t ,
    [quad_thickh ] = _C.mad_trk_quad_thickh_t ,
    [quad_kick   ] = _C.mad_trk_quad_kick_t   ,
    [quad_kicks  ] = _C.mad_trk_quad_kicks_t  ,
    [quad_kickh  ] = _C.mad_trk_quad_kickh_t  ,
    [quad_kick_  ] = _C.mad_trk_quad_kick__t  ,
    [quad_kicks_ ] = _C.mad_trk_quad_kicks__t ,
    [quad_kickh_ ] = _C.mad_trk_quad_kickh__t ,
    [solen_thick ] = _C.mad_trk_solen_thick_t ,
    [solen_fringe] =            solen_fringe  ,
    [rfcav_kick  ] = _C.mad_trk_rfcav_kick_t  ,
    [rfcav_kickn ] = _C.mad_trk_rfcav_kickn_t ,
    [rfcav_fringe] = _C.mad_trk_rfcav_fringe_t,
    [esept_thick ] = _C.mad_trk_esept_thick_t ,
    [nllens_kick ] =            nllens_kick   ,
    [bbeam_kick  ] =            bbeam_kick    ,
    [bbeam_kick6D] =            bbeam_kick6D  ,
    [wire_kick   ] =            wire_kick     ,
    [genm_thick  ] =            genm_thick    ,
    [xrotation   ] = _C.mad_trk_xrotation_t   ,
    [yrotation   ] = _C.mad_trk_yrotation_t   ,
    [srotation   ] = _C.mad_trk_srotation_t   ,
    [translate   ] = _C.mad_trk_translate_t   ,
    [changeref   ] = _C.mad_trk_changeref_t   ,
    [changedir   ] =            changedir     ,
    [changenrj   ] =            changenrj     ,
    [misalign    ] = _C.mad_trk_misalign_t    ,
    [tilt        ] = _C.mad_trk_tilt_t        ,
    [fnil        ] =            fnil          ,
  },
  p = { -- parametric tpsa
    [strex_drift ] = _C.mad_trk_strex_drift_p ,
    [strex_kick  ] = _C.mad_trk_strex_kick_p  ,
    [strex_kickhs] = _C.mad_trk_strex_kickhs_p,
    [strex_fringe] = _C.mad_trk_strex_fringe_p,
    [curex_drift ] = _C.mad_trk_curex_drift_p ,
    [curex_kick  ] = _C.mad_trk_curex_kick_p  ,
    [curex_fringe] = _C.mad_trk_curex_fringe_p,
    [sbend_thick ] = _C.mad_trk_sbend_thick_p ,
    [sbend_kick  ] = _C.mad_trk_sbend_kick_p  ,
    [dipeg_fringe] =            dipeg_fringe  ,
    [rbend_thick ] = _C.mad_trk_rbend_thick_p ,
    [rbend_kick  ] = _C.mad_trk_rbend_kick_p  ,
    [quad_thick  ] = _C.mad_trk_quad_thick_p  ,
    [quad_thicks ] = _C.mad_trk_quad_thicks_p ,
    [quad_thickh ] = _C.mad_trk_quad_thickh_p ,
    [quad_kick   ] = _C.mad_trk_quad_kick_p   ,
    [quad_kicks  ] = _C.mad_trk_quad_kicks_p  ,
    [quad_kickh  ] = _C.mad_trk_quad_kickh_p  ,
    [quad_kick_  ] = _C.mad_trk_quad_kick__p  ,
    [quad_kicks_ ] = _C.mad_trk_quad_kicks__p ,
    [quad_kickh_ ] = _C.mad_trk_quad_kickh__p ,
    [solen_thick ] = _C.mad_trk_solen_thick_p ,
    [solen_fringe] =            solen_fringe  ,
    [rfcav_kick  ] = _C.mad_trk_rfcav_kick_p  ,
    [rfcav_kickn ] = _C.mad_trk_rfcav_kickn_p ,
    [rfcav_fringe] = _C.mad_trk_rfcav_fringe_p,
    [esept_thick ] = _C.mad_trk_esept_thick_p ,
    [nllens_kick ] =            nllens_kick   ,
    [bbeam_kick  ] =            bbeam_kick    ,
    [bbeam_kick6D] =            bbeam_kick6D  ,
    [wire_kick   ] =            wire_kick     ,
    [genm_thick  ] =            genm_thick    ,
    [xrotation   ] = _C.mad_trk_xrotation_p   ,
    [yrotation   ] = _C.mad_trk_yrotation_p   ,
    [srotation   ] = _C.mad_trk_srotation_p   ,
    [translate   ] = _C.mad_trk_translate_p   ,
    [changeref   ] = _C.mad_trk_changeref_p   ,
    [changedir   ] =            changedir     ,
    [changenrj   ] =            changenrj     ,
    [misalign    ] = _C.mad_trk_misalign_p    ,
    [tilt        ] = _C.mad_trk_tilt_p        ,
    [fnil        ] =            fnil          ,
  },
}

maps.T = maps.t -- alias for non-parametric maps

-- multipoles -----------------------------------------------------------------o

local nsnm = \snm -> snm > 0 and (snm+1)*(snm+2)/2 or 0 -- see snm_max above

local function get_mult (elm, m, n) -- copy multipoles from elem to mflw
  local knl, ksl, dknl, dksl in elm

  m.nmul = max(#knl, #ksl, #dknl, #dksl, n or 0)

  for i=1,m.nmul do
    m.knl[i] = ((knl[i] or 0) + (dknl[i] or 0)) / fact(i-1)
    m.ksl[i] = ((ksl[i] or 0) + (dksl[i] or 0)) / fact(i-1)
  end
end

local function adj_mult (m) -- adjust multipoles in mflw
  local knl, ksl, nmul in m
  m.nmul = 0

  for i=nmul,1,-1 do
    if abs(knl[i])+abs(ksl[i]) > 0 then m.nmul = i ; break end
  end

  if m.cmap == 't' then
    for i=1,m.nmul do
      if not (is_number(knl[i]) and is_number(ksl[i])) then
        m.cmap = 'p' ; break
      end
    end
  end
end

local function cpy_mult (m) -- copy multipoles from mflw to cflw
  local c = xflw(m)
  c.nmul = m.nmul
  c.snm  = m.snm

  if m.nmul <= 2 then -- always set/clear bends & quads multipoles
    c.knl[0] = xcpy(c.knl[0], 0)
    c.ksl[0] = xcpy(c.ksl[0], 0)
    c.knl[1] = xcpy(c.knl[1], 0)
    c.ksl[1] = xcpy(c.ksl[1], 0)
  end

  for i=1,m.nmul do
    c.knl[i-1] = xcpy(c.knl[i-1], m.knl[i])
    c.ksl[i-1] = xcpy(c.ksl[i-1], m.ksl[i])
  end

  for i=1,nsnm(m.snm) do
    c.bfx[i-1] = xcpy(c.bfx[i-1], m.bfx[i])
    c.bfy[i-1] = xcpy(c.bfy[i-1], m.bfy[i])
  end
end

-- collect tilt, misalignment, fringe -----------------------------------------o

local function get_tilt (e, m)
  local tlt = e.tilt
  if abs(tlt) < minang then tlt = 0
  elseif m.cmap and not is_number(tlt) then m.cmap = 'p' end
  m.tlt = tlt
  return m.tlt
end

local function get_algn (e, m)
  local al = e.misalign or  m.sequ:align (m.eidx)
  local el = m.misalign and m.sequ:ealign(m.eidx) or nil

  if not (al or el) then m.algn = nil ; return nil end

  local dx, dy, ds, dthe, dphi, dpsi = 0, 0, 0, 0, 0, 0

  if al then -- element abolute/permanent misalignments
    dx, dthe = dx+(al.dx or 0), dthe+(al.dtheta or 0) -- horizontal/azimutal
    dy, dphi = dy+(al.dy or 0), dphi+(al.dphi   or 0) -- vertical/elevation
    ds, dpsi = ds+(al.ds or 0), dpsi+(al.dpsi   or 0) -- longitudinal/roll
  end

  if el then -- element relative/error misalignments
    dx, dthe = dx+(el.dx or 0), dthe+(el.dtheta or 0) -- horizontal/azimutal
    dy, dphi = dy+(el.dy or 0), dphi+(el.dphi   or 0) -- vertical/elevation
    ds, dpsi = ds+(el.ds or 0), dpsi+(el.dpsi   or 0) -- longitudinal/roll
  end

  local trn = abs(dx  )+abs(dy  )+abs(ds  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then m.algn = nil ; return nil end

  if m.cmap == 't' and not (
    is_number(dx  ) and is_number(dy  ) and is_number(ds  )  and
    is_number(dthe) and is_number(dphi) and is_number(dpsi)) then
    m.cmap = 'p'
  end

  m.algn = {trn=trn,rot=rot,dx=dx,dy=dy,ds=ds,dthe=dthe,dphi=dphi,dpsi=dpsi}
  return m.algn
end

local function get_frng (e, m, f)
  if not (m.cmap and e.is_thick) then return true end

  local frng, fmax, fken, fkex, e1, e2, h1, h2, fint, fintx, hgap, f1, f2 =
           0,    0,false,false,  0,  0,  0,  0,    0,     0,    0,  0,  0

  frng = fcut(m.fringe, e.fringe)

  if frng ~= 0 then
    fken = e.kill_ent_fringe
    fkex = e.kill_exi_fringe
  end

  e1, e2 = (m.e1 or e.e1), (m.e2 or e.e2)
  h1, h2 = (m.h1 or e.h1), (m.h2 or e.h2)

  if ftst(frng, fringe.bend) then
    fint, hgap = e.fint, e.hgap
    fintx      = e.fintx or fint
  end

  if ftst(frng, fringe.mult) then
    fmax = e.frngmax or m.frngmax
  end

  if ftst(frng, fringe.qsad) then
    f1, f2 = e.f1, e.f2
  end

  if m.cmap == 't' and not (
    is_number(e1)   and is_number(e2)    and is_number(h1)   and is_number(h2) and
    is_number(fint) and is_number(fintx) and is_number(hgap) and
    is_number(f1)   and is_number(f2)) then
    m.cmap = 'p'
  end

  m.frng = {frng=frng, fmax=fmax, fken=fken, fkex=fkex, f1=f1, f2=f2,
            e1=e1, e2=e2, h1=h1, h2=h2, fint=fint, fintx=fintx, hgap=hgap}
  return m.frng
end

-- helpers --------------------------------------------------------------------o

local function ctilt (elm, m, dir)
  if not m.cmap then
    return tilt(elm, m, dir)
  end

  if dir == m.sdir then -- copy only once
    local c = xflw(m)
    c.tlt = xcpy(c.tlt, m.tlt)
  end

  maps[m.cmap][tilt](xflw_(m), dir)
end

local function cmisalign (elm, m, dir)
  if not m.cmap then
    return misalign(elm, m, dir)
  end

  if dir == m.sdir then -- copy only once
    local a = m.algn
    local c = xflw(m)
    c.trn  = a.trn
    c.rot  = a.rot
    c.dx   = xcpy(c.dx  , a.dx   )
    c.dy   = xcpy(c.dy  , a.dy   )
    c.ds   = xcpy(c.ds  , a.ds   )
    c.dthe = xcpy(c.dthe, a.dthe )
    c.dphi = xcpy(c.dphi, a.dphi )
    c.dpsi = xcpy(c.dpsi, a.dpsi )
  end

  maps[m.cmap][misalign](xflw_(m), dir)
end

local function cfringe (elm, m, dir, frng)
  if not m.cmap or is_function(maps[m.cmap][frng]) then
    return frng(elm, m, dir)
  end

  local f = m.frng
  local c = xflw(m)
  local a = m.pdir == dir and f.e2 - f.e1 or 0

  if dir == m.sdir then -- copy only once
    c.fmax = f.fmax
    c.hgap = xcpy(c.hgap, f.hgap)
    c.f1   = xcpy(c.f1  , f.f1  )
    c.f2   = xcpy(c.f2  , f.f2  )
  end

  if dir == 1 then -- copy on "entry" side
    c.frng = f.fken and 0 or f.frng
    c.e    = xcpy(c.e   , f.e1  )
    c.h    = xcpy(c.h   , f.h1  )
    c.a    = xcpy(c.a   ,   a   )
    c.fint = xcpy(c.fint, f.fint)
  else                  -- copy on "exit" side
    c.frng = f.fkex and 0 or f.frng
    c.e    = xcpy(c.e   , f.e2   )
    c.h    = xcpy(c.h   , f.h2   )
    c.a    = xcpy(c.a   ,   a    )
    c.fint = xcpy(c.fint, f.fintx)
  end

  maps[m.cmap][frng](xflw_(m), dir)
end

-- element tracking -----------------------------------------------------------o

local slc_fwd = {-1, -3, -4, -2}
local slc_bwd = {-2, -4, -3, -1}

local function trackone (elm, m, inter, thick_or_thin)
  local sdir, atentry, atexit in m
  local slc = slc_fwd

  if sdir < 0 then
    atentry, atexit, slc = atexit, atentry, slc_bwd
  end

  if m.cmap then
    thick_or_thin = maps[m.cmap][thick_or_thin]
    xflw(m).name = elm.name
  end

  m:xflw (false)
  atentry(elm, m,  sdir, slc[1])
  inter  (elm, m,  sdir, thick_or_thin)
  atexit (elm, m, -sdir, slc[4])
  m:xflw (true)

  m.xflw = fnil
  if m.cmap == 'p' then m.cmap = 't' end
end

local function trackelm (elm, m, inter, thick, thin, fringe)
  local sdir, atentry, atexit in m
  local tlt = get_tilt(elm, m)
  local alg = get_algn(elm, m)
  local frg = get_frng(elm, m, fringe)
  local rot = tlt ~= 0 and ctilt     or fnil
  local mis = alg      and cmisalign or fnil
  local fng = frg      and cfringe   or fnil
  local slc = slc_fwd

  if sdir < 0 then
    atentry, atexit, slc = atexit, atentry, slc_bwd
  end

  if m.cmap then
    local cmap = maps[m.cmap]
    if not (is_function(cmap[thick]) or is_function(cmap[thin])) then
      thick, thin = cmap[thick], cmap[thin] -- ensure consistency
    end
    xflw(m).name = elm.name
  end

  m:xflw (false)
  atentry(elm, m,  sdir, slc[1])
  mis    (elm, m,  sdir)
  rot    (elm, m,  sdir)
  atentry(elm, m,  sdir, slc[2])
  fng    (elm, m,  sdir, fringe)
  inter  (elm, m,  sdir, thick, thin)
  fng    (elm, m, -sdir, fringe)
  atexit (elm, m, -sdir, slc[3])
  rot    (elm, m, -sdir)
  mis    (elm, m, -sdir)
  atexit (elm, m, -sdir, slc[4])
  m:xflw (true)

  m.tlt, m.algn, m.frng, m.xflw = 0, nil, nil, fnil
  if m.cmap == 'p' then m.cmap = 't' end
end

local function tracksub (elm, m, inter, thick, thin, fringe)
  if m.eidx == 0 then
    errorf("invalid subelement track %s (contain subelements)", elm.name)
  end

  local eidx, sdir, atentry, atexit, __sdat in m
  local tlt = get_tilt(elm, m)
  local alg = get_algn(elm, m)
  local frg = get_frng(elm, m, fringe)
  local rot = tlt ~= 0 and ctilt     or fnil
  local mis = alg      and cmisalign or fnil
  local fng = frg      and cfringe   or fnil
  local slc  = slc_fwd
  m.eidx = 0

  if sdir < 0 then
    atentry, atexit, slc = atexit, atentry, slc_bwd
  end

  if m.cmap then
    local cmap = map[m.cmap]
    if not (is_function(cmap[thick]) or is_function(cmap[thin])) then
      thick, thin = cmap[thick], cmap[thin] -- ensure consistency
    end
    xflw(m).name = elm.name
  end

  m:xflw (false)
  atentry(elm, m, sdir, slc[1])
  mis    (elm, m, sdir)
  rot    (elm, m, sdir)
  atentry(elm, m, sdir, slc[2])
  fng    (elm, m, sdir, fringe)

  if sdir > 0 then
    local at, lw = 0
    for i=1,#elm do
      at, lw = elm[i].sat, elm[i].sat - at
      if abs(lw) >= minlen then -- body step
        inter(elm, m, lw, thick, thin)
      end
      __sdat.clw = at
      elm[i]:track(__sdat)
      at = at + elm[i].l/m.el
    end
    lw = 1 - at
    if abs(lw) >= minlen then  -- last body step
      inter(elm, m, lw, thick, thin)
    end

  else -- backtrack (sdir < 0)
    local at, lw = 1
    for i=#elm,1,-1 do
      local sat = elm[i].sat + elm[i].l/m.el
      at, lw = sat, at - sat
      if abs(lw) >= minlen then -- body step
        inter(elm, m, -lw, thick, thin)
      end
      __sdat.clw = at
      elm[i]:track(__sdat)
      at = at - elm[i].l/m.el
    end
    lw = at
    if abs(lw) >= minlen then -- first body step
      inter(elm, m, -lw, thick, thin)
    end
  end

  fng    (elm, m, -sdir, fringe)
  atexit (elm, m, -sdir, slc[3])
  rot    (elm, m, -sdir)
  mis    (elm, m, -sdir)
  atexit (elm, m, -sdir, slc[4])
  m:xflw (true)

  m.tlt, m.algn, m.frng, m.xflw, m.eidx = 0, nil, nil, fnil, eidx
  if m.cmap == 'p' then m.cmap = 't' end
end

-- kinds ----------------------------------------------------------------------o

local function track_slink (elm, m)
  local update = elm:var_get'update'
  if update then update(elm, m) end -- update damap

  if elm.sequence then
    m:change_si(elm.sequence, elm.range, elm.nturn, elm.dir)
    return "restart_si"
  end
end

local function track_marker (elm, m)
  trackone(elm, m, thinonly, fnil)
end

local function xflw_rot (m, clr)
  if not clr then
    local c = xflw(m)
    c.ang = xcpy(c.ang, m.ang)
  end
end

local function track_rotation (elm, m, rot)
  m.ang = elm.angle

  if m.cmap then
    if not is_number(m.ang) then m.cmap = 'p' end
    m.xflw = xflw_rot
  end

  trackone(elm, m, thinonly, rot)
end

local function xflw_trn (m, clr)
  if not clr then
    local c = xflw(m)
    c.dx = xcpy(c.dx, m.dx)
    c.dy = xcpy(c.dy, m.dy)
    c.ds = xcpy(c.ds, m.ds)
  end
end

local function track_translate (elm, m)
  m.dx, m.dy, m.ds = elm.dx, elm.dy, elm.ds

  if m.cmap then
    if m.cmap == 't' and not (
       is_number(m.dx) and is_number(m.dy) and is_number(m.ds)) then
      m.cmap = 'p'
    end
    m.xflw = xflw_trn
  end

  trackone(elm, m, thinonly, translate)
end

local function xflw_cref (m, clr)
  if not clr then
    local c = xflw(m)
    c.dx   = xcpy(c.dx  , m.dx  )
    c.dy   = xcpy(c.dy  , m.dy  )
    c.ds   = xcpy(c.ds  , m.ds  )
    c.dthe = xcpy(c.dthe, m.dthe)
    c.dphi = xcpy(c.dphi, m.dphi)
    c.dpsi = xcpy(c.dpsi, m.dpsi)
  end
end

local function track_changeref (elm, m)
  m.dx  , m.dy  , m.ds   = elm.dx    , elm.dy  , elm.ds
  m.dthe, m.dphi, m.dpsi = elm.dtheta, elm.dphi, elm.dpsi

  if m.cmap then
    if m.cmap == 't' and not (
       is_number(m.dx)   and is_number(m.dy)   and is_number(m.ds)    and
       is_number(m.dthe) and is_number(m.dphi) and is_number(m.dpsi)) then
      m.cmap = 'p'
    end
    m.xflw = xflw_cref
  end

  trackone(elm, m, thinonly, changeref)
end

local function xflw_dft (m, clr)
  if not clr then
    local c = xflw(m)
    c.el = xcpy(c.el, m.el)
  end
end

local function track_drift (elm, m)
  m.el = elm.l

  if m.cmap then
    if not is_number(m.el) then m.cmap = 'p' end
    m.xflw = xflw_dft
  end

  if is_implicit(elm) then
    local inter = m.implicit and thickonly or driftonly
    trackone(elm, m, inter, strex_drift)
  else
    local inter = m.el >= minlen and thickonly or driftonly
    local track = #elm == 0 and trackelm or tracksub
    track(elm, m, inter, strex_drift, fnil, fnil)
  end
end

local function xflw_mult (m, clr)
  local c = xflw(m)
  if not clr then
    c.lrad = xcpy(c.lrad, m.lrad)
    c.ks   = xcpy(c.ks  , m.ks or 0)
    cpy_mult(m)
  else
    c.ks   = xcpy(c.ks  , 0)
  end
end

local function track_multipole (elm, m)
  get_mult(elm, m, 1) ; adj_mult(m)

  if m.nmul == 0 and abs(elm.ksi) < minstr then
    return track_marker(elm, m)
  end

  local ksi, lrad in elm
  local knl, ksl in m

  if lrad == 0 and abs(ksi) > 0 then
    errorf("thin solenoid '%s' defines strength with zero lrad", elm.name)
  end

  m.lrad, m.ksi = lrad, ksi or 0

  local kick = strex_kick
  if abs(knl[1]) + abs(ksl[1]) + abs(m.ksi) >= minstr then
    m.ks = m.ksi/(m.lrad > 0 and m.lrad or 1)
    kick = strex_kickhs
  end

  if m.cmap then
    if m.cmap == 't' and not (is_number(ksi) and is_number(lrad)) then
      m.cmap = 'p'
    end
    m.xflw = xflw_mult
  end

  trackelm(elm, m, thinonly, kick, nil, fnil)
  m.ks = nil
end

local track_strexgen -- fwd decl

local function xflw_sbend (m, clr)
  local c = xflw(m)
  if not clr then
    c.eh   = xcpy(c.eh  , m.eh  )
    c.el   = xcpy(c.el  , m.el  )
    c.mang = xcpy(c.mang, m.mang)
    cpy_mult(m)
  else
    c.snm  = 0
    c.eh   = xcpy(c.eh  , 0)
    c.e    = xcpy(c.e   , 0)
    c.mang = xcpy(c.mang, 0)
  end
end

local function track_sbend (elm, m, e1_, e2_)
  get_mult(elm, m, 3)

  local nmul, knl, ksl, bfx, bfy in m
  local l, angle, k0, k0s, k1, k1s, k2, k2s in elm

  if l < minlen then
    errorf("invalid sbend '%s' length=%.4e [m] (>0 expected)", elm.name, l)
  end

  knl[1], ksl[1] = knl[1]+k0*l  , ksl[1]+k0s*l
  knl[2], ksl[2] = knl[2]+k1*l  , ksl[2]+k1s*l
  knl[3], ksl[3] = knl[3]+k2*l/2, ksl[3]+k2s*l/2
  m.el, m.eh = l, angle/l
  m.e1, m.e2 = (e1_ or elm.e1), (e2_ or elm.e2)
  m.mang     = angle

  if abs(angle) < minang then
    m.eh, m.e1, m.e2, m.mang = 0, nil, nil, nil
    return track_strexgen(elm, m)
  end

  local model  = elm.model   or m.model
  local method = elm.method  or m.method
  local snmul  = elm.secnmul or m.secnmul or -1
  local inter, thick, kick

  -- enforce small angle numerical stability
  if abs(m.eh) < 1e-6 then model, method = 'DKD', max(method,4) end

  m.snm = snmul ; adj_mult(m) ; getanbnr(m)

  if model == 'DKD' then                          -- curved thin
    inter, thick, kick = DKD[method], curex_drift , curex_kick
  elseif m.nmul == 1 and ksl[1] == 0 and not m.ptcmodel then -- curved thick only
    inter, thick, kick = thickonly  , sbend_thick , fnil
  else                                            -- curved thick
    inter, thick, kick = TKT[method], sbend_thick , sbend_kick
  end

  if m.cmap then
    if m.cmap == 't' and not (
      is_number(m.eh) and is_number(m.e1) and is_number(m.e2)) then
      m.cmap = 'p'
    end
    m.xflw = xflw_sbend
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, kick, curex_fringe)
  m.eh, m.e1, m.e2, m.mang, m.snm = 0, nil, nil, nil, 0
end

local function xflw_rbend (m, clr)
  local c = xflw(m)
  if not clr then
    c.pdir = m.pdir or 0
    c.el   = xcpy(c.el  , m.el  )
    c.eld  = xcpy(c.eld , m.eld )
    c.ehd  = xcpy(c.ehd , m.ehd )
    c.elc  = xcpy(c.elc , m.elc )
    c.mang = xcpy(c.mang, m.mang)
    cpy_mult(m)
  else
    c.pdir = 0
    c.eld  = xcpy(c.eld, 0)
    c.ehd  = xcpy(c.ehd, 0)
    c.e    = xcpy(c.e  , 0)
  end
end

local function track_rbend (elm, m)
  local angle, e1, e2, true_rbend in elm

  if not true_rbend then                                                      -- checked
    return track_sbend(elm, m, e1+angle/2, e2+angle/2)
  end

  get_mult(elm, m, 3)                                                         -- checked

  local nmul, knl, ksl in m
  local l, k0, k0s, k1, k1s, k2, k2s in elm

  if l < minlen then
    errorf("invalid rbend '%s' length=%.4e [m] (>0 expected)", elm.name, l)
  end

  m.eld  = l
  m.elc  = arc2cord(m.eld, angle)
  m.mang = angle

  if is_number(e1) and abs(e1) > twopi then e1 = false end
  if is_number(e2) and abs(e2) > twopi then e2 = false end

  if e1 and e2 then                                                           -- Straight
    m.e1, m.e2, m.pdir = e1+angle/2, e2+angle/2, nil
    m.el = m.elc
  elseif e1 then                                                              -- True parallel with exit patch
    m.e1, m.e2, m.pdir = e1, angle - e1, -1
    m.el = m.elc * cos(angle/2 - e1)
  elseif e2 then                                                              -- True parallel with entry patch
    m.e1, m.e2, m.pdir = angle - e2, e2,  1
    m.el = m.elc * cos(angle/2 - e2)
  else errorf("True parallel rbend '%s' must set e1 or e2", elm.name)
  end

  l = m.el
  m.ehd = angle/m.eld                                                         -- Must be divided by eld.

  if l < minlen then
    errorf("invalid rbend angle (or pole face) '%s' giving length=%.4e [m] (>0 expected)", elm.name, l)
  end

  knl[1], ksl[1] = knl[1]+k0*l  , ksl[1]+k0s*l
  knl[2], ksl[2] = knl[2]+k1*l  , ksl[2]+k1s*l
  knl[3], ksl[3] = knl[3]+k2*l/2, ksl[3]+k2s*l/2

  adj_mult(m)

  local model  = elm.model  or m.model
  local method = elm.method or m.method
  local inter, thick, kick

  -- enforce small angle numerical stability
  if abs(m.ehd) < 1e-6 then model, method = 'DKD', max(method,4) end

  if model == 'DKD' then
    inter, thick, kick = DKD[method], strex_drift, strex_kick
  elseif m.nmul == 1 and ksl[1] == 0 and not m.ptcmodel then
    inter, thick, kick = thickonly  , rbend_thick , fnil
  else
    inter, thick, kick = TKT[method], rbend_thick, rbend_kick
  end

  if m.cmap then
    if m.cmap == 't' and not (
      is_number(m.ehd) and is_number(m.e1) and is_number(m.e2)) then
      m.cmap = 'p'
    end
    m.xflw = xflw_rbend
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, kick, strex_fringe)
  m.e1, m.e2, m.elc, m.eld, m.ehd, m.pdir = nil, nil, nil, nil, nil, nil
end

local function xflw_quad (m, clr)
  local c = xflw(m)
  if not clr then
    c.el = xcpy(c.el, m.el     )
    c.eh = xcpy(c.eh, m.eh     )
    c.k1 = xcpy(c.k1, m.k1 or 0)
    c.ca = xcpy(c.ca, m.ca or 0)
    c.sa = xcpy(c.sa, m.sa or 0)
    cpy_mult(m)
  else
    c.eh = xcpy(c.eh, 0)
    c.k1 = xcpy(c.k1, 0)
  end
end

local function track_quadrupole (elm, m)
  get_mult(elm, m, 2)

  local nmul, knl, ksl, ptcmodel in m
  local l, angle, k0, k0s, k1, k1s in elm

  if l == 0 and abs(k1)+abs(k1s)+abs(k0)+abs(k0s) > 0 then
    warn("quadrupole '%s' defines strength with zero length", elm.name)
  end

  knl[1], ksl[1] = knl[1]+k0*l, ksl[1]+k0s*l
  knl[2], ksl[2] = knl[2]+k1*l, ksl[2]+k1s*l
  m.el = l

  adj_mult(m)

  local model  = elm.model  or m.model
  local method = elm.method or m.method
  local no_k1  = abs(knl[2]) < minstr
  local no_k1s = abs(ksl[2]) < minstr
  local no_ang = abs(angle)  < minang
  local no_tlt = ptcmodel and not no_k1s and (abs(knl[1]) > minstr or nmul > 2 or elm.fringe > 0)
  local inter  = ptcmodel and method > 2 and KMK[method] or TKT[method]
  local thick, kick

  if model == 'DKD' or no_k1 and no_k1s and no_ang then
    inter, thick, kick = DKD[method], strex_drift, strex_kick
  elseif no_k1s and no_ang or no_tlt then       -- normal thick
    m.k1 = knl[2]/l
    thick, kick = quad_thick, ptcmodel and quad_kick_ or quad_kick
  elseif no_ang then                            -- skew thick
    local a = -0.5*atan2(ksl[2], knl[2])
    m.k1, m.ca, m.sa = sqrt(knl[2]^2 + ksl[2]^2)/l, cos(a), sin(a)
    thick, kick = quad_thicks, ptcmodel and quad_kicks_ or quad_kicks
  else                                          -- combined thick            -- unchecked
    m.eh = angle/l
    thick, kick = quad_thickh, ptcmodel and quad_kickh_ or quad_kickh
  end

  if m.cmap then
    if m.cmap == 't' and not (is_number(angle) and is_number(l)) then
      m.cmap = 'p'
    end
    m.xflw = xflw_quad
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, kick, strex_fringe)
  m.eh, m.k1, m.ca, m.sa = 0, nil, nil, nil
end

-- straigth magnets (-rbend -quad -solenoid)

local function xflw_strex (m, clr)
  local c = xflw(m)
  if not clr then
    c.el = xcpy(c.el, m.el     )
    c.k1 = xcpy(c.k1, m.k1 or 0)
    cpy_mult(m)
  else
    c.k1 = xcpy(c.k1, 0)
  end
end

function track_strexgen (elm, m, ptc_, mth_) -- see fwd decl
  local l in elm
  m.el = l

  adj_mult(m)

  local model  = elm.model  or m.model
  local method = elm.method or mth_ or m.method
  local inter, thick, kick, fringe

  if l < minlen then
    inter, thick, kick, fringe = thinonly, strex_kick, fnil, fnil
  elseif not ptc_ then
    inter, thick, kick, fringe = DKD[method], strex_drift, strex_kick, strex_fringe
  else
    m.k1 = m.knl[2]/l
    inter = method > 2 and KMK[method] or TKT[method]
    thick, kick, fringe = quad_thick, quad_kick_, strex_fringe
  end

  if m.cmap then
    if not is_number(m.el) then m.cmap = 'p' end
    m.xflw = xflw_strex
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, kick, fringe)
  m.k1 = nil
end

local function track_sextupole (elm, m)
  get_mult(elm, m, 3)

  local nmul, knl, ksl in m
  local l, k2, k2s in elm

  if l == 0 and abs(k2)+abs(k2s) > 0 then
    warn("sextupole '%s' defines strength with zero length", elm.name)
  end

  knl[3] = knl[3]+k2 *l/2
  ksl[3] = ksl[3]+k2s*l/2

  track_strexgen (elm, m, m.ptcmodel)
end

local function track_octupole (elm, m)
  get_mult(elm, m, 4)

  local nmul, knl, ksl in m
  local l, k3, k3s in elm

  if l == 0 and abs(k3)+abs(k3s) > 0 then
    warn("octupole '%s' defines strength with zero length", elm.name)
  end

  knl[4] = knl[4]+k3 *l/6
  ksl[4] = ksl[4]+k3s*l/6

  track_strexgen (elm, m, m.ptcmodel)
end

local function track_decapole (elm, m)
  get_mult(elm, m, 5)

  local nmul, knl, ksl in m
  local l, k4, k4s in elm

  if l == 0 and abs(k4)+abs(k4s) > 0 then
    warn("decapole '%s' defines strength with zero length", elm.name)
  end

  knl[5] = knl[5]+k4 *l/24
  ksl[5] = ksl[5]+k4s*l/24

  track_strexgen (elm, m)
end

local function track_dodecapole (elm, m)
  get_mult(elm, m, 6)

  local nmul, knl, ksl in m
  local l, k5, k5s in elm

  if l == 0 and abs(k5)+abs(k5s) > 0 then
    warn("dodecapole '%s' defines strength with zero length", elm.name)
  end

  knl[6] = knl[6]+k5 *l/120
  ksl[6] = ksl[6]+k5s*l/120

  track_strexgen (elm, m)
end

-- kickers (straigth magnets)

local function track_kickgen (elm, m, hk, vk)
  get_mult(elm, m, 2)

  local nmul, knl, ksl, ptcmodel in m
  local method = ptcmodel == false and 2 or nil -- false=MADX

  knl[1] = knl[1] - hk
  ksl[1] = ksl[1] + vk

  track_strexgen (elm, m, ptcmodel, method)
end

local function track_tkicker (elm, m, hk_, vk_)
  track_kickgen(elm, m, elm.hkick, elm.vkick)
end

local function track_kicker (elm, m)
  track_kickgen(elm, m, elm.hkick+elm.chkck, elm.vkick+elm.cvkck)
end

local function track_hkicker (elm, m)
  track_kickgen(elm, m, elm.kick+elm.chkck, 0)
end

local function track_vkicker (elm, m)
  track_kickgen(elm, m, 0, elm.kick+elm.cvkck)
end

-- solenoid

local function xflw_sol (m, clr)
  local c = xflw(m)
  if not clr then
    c.el = xcpy(c.el, m.el     )
    c.ks = xcpy(c.ks, m.ks or 0)
    cpy_mult(m)
  else
    c.ks = xcpy(c.ks, 0)
  end
end

local function track_solenoid (elm, m)
  get_mult(elm, m) ; adj_mult(m)

  local l, ks, ksi, lrad in elm
  local model = elm.model or m.model

  if l == 0 and abs(ks) > 0 then
    warn("solenoid '%s' defines strength with zero length", elm.name)
  end

  if l < minlen then
    if model == "DKD" and lrad > minlen then
      return track_multipole(elm, m)
    end
    errorf("invalid solenoid '%s' length=%.4e [m] (>0 expected)", elm.name, l)
  end

  m.el = l

  local ksi = ksi + ks*l
  local no_ksi = abs(ksi) < minstr
  local method = elm.method or m.method
  local thick, kick, fringe

  if no_ksi then
    thick, kick, fringe = strex_drift, strex_kick , strex_fringe
  else
    m.ks = ksi/l
    thick, kick, fringe = solen_thick, strex_kick, elm.new_fringe and solen_fringe or strex_fringe
  end

  if m.cmap then
    if m.cmap == 't' and not (is_number(l) and is_number(ksi)) then
      m.cmap = 'p'
    end
    m.xflw = xflw_sol
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, DKD[method], thick, kick, fringe)
  m.ks = nil
end

-- eseptum

local function xflw_esep (m, clr)
  local c = xflw(m)
  if not clr then
    c.el   = xcpy(c.el  , m.el       )
    c.volt = xcpy(c.volt, m.volt or 0)
    c.ca   = xcpy(c.ca  , m.ca   or 0)
    c.sa   = xcpy(c.sa  , m.sa   or 0)
    cpy_mult(m)
  else
    c.volt = xcpy(c.volt, 0)
  end
end

local function track_eseptum (elm, m)
  get_mult(elm, m) ; adj_mult(m)

  local l, ex, ey, exl, eyl in elm

  if l == 0 and abs(ex)+abs(ey) > 0 then
    warn("eseptum '%s' defines strength with zero length", elm.name)
  end

  m.el = l

  local exl = exl + ex*l
  local eyl = eyl + ey*l
  local volt = sqrt(exl^2 + eyl^2)/l
  local thick

  if abs(volt) < minvolt then
    thick = strex_drift
  else
    local a = -atan2(eyl, exl)
    m.volt, m.ca, m.sa = volt*1e-3, cos(a), sin(a)
    thick = esept_thick
  end

  if m.cmap then
    if m.cmap == 't' and not (is_number(l) and is_number(volt)) then
      m.cmap = 'p'
    end
    m.xflw = xflw_esep
  end

  local inter = m.nmul == 0 and thickonly or KMK[elm.method or m.method]
  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, strex_kick, strex_fringe)
  m.volt = nil
end

-- rf cavities

local function xflw_cav (m, clr)
  local c = xflw(m)
  if not clr then
    c.nbsl = m.nbsl
    c.Tbak = m.Tbak
    c.el   = xcpy(c.el  , m.el  )
    c.volt = xcpy(c.volt, m.volt)
    c.freq = xcpy(c.freq, m.freq)
    c.lag  = xcpy(c.lag , m.lag )
    cpy_mult(m)
  else
    c.volt = xcpy(c.volt, 0)
    c.freq = xcpy(c.freq, 0)
  end
end

local function track_rfcavgen (elm, m, crab)
  local l, volt, freq, lag, harmon, n_bessel in elm
  local nocav in m

  adj_mult(m)

  m.el   = l
  m.volt = (crab or nocav) and 0 or volt*1e-3
  m.lag  = lag*twopi - (crab and pi_2 or 0)
  m.freq, m.nbsl = freq*1e6, n_bessel
  if m.freq == 0 then
    m.freq = harmon*clight*m.beam.beta/m.sequ.l
  end
  if m.freq <= 0 and abs(m.volt) ~= 0 then
    errorf("invalid rfcavity '%s' frequency =%.4e [MHz] (>0 or harmon expected)",
            elm.name, m.freq)
  end

  m.Tbak = elm.no_cavity_totalpath and -2 or -1

  local inter  = l < minlen and thinonly or DKD[elm.method or m.method]
  local kick   = m.nmul+m.nbsl == 0 and rfcav_kick or rfcav_kickn
  local thick  = l < minlen and kick or strex_drift
  local fringe = l < minlen and fnil or rfcav_fringe

  if m.cmap then
    if m.cmap == 't' and not (is_number(l) and
      is_number(volt) and is_number(m.freq) and is_number(lag)) then
      m.cmap = 'p'
    end
    m.xflw = xflw_cav
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, kick, fringe)
  m.volt, m.freq = nil, nil
end

local function track_rfcavity (elm, m)
  get_mult      (elm, m)
  track_rfcavgen(elm, m)
end

local function track_rfmcavity (elm, m)
  get_mult      (elm, m)
  track_rfcavgen(elm, m)
end

local function track_crabcavity (elm, m)
  get_mult      (elm, m, 1)
  local l, volt in elm
  m.knl[1] = m.knl[1] + volt*l*1e-3
  track_rfcavgen(elm, m, true)
end

-- wire element

local function track_wire (elm, m)
  local l, l_phy, l_int, current, xma, yma, dpx, dpy in elm

  m.el         = l
  m.dpx, m.dpy = dpx, dpy
  m.xma        = is_number(xma  )   and {xma  }   or xma
  m.yma        = is_number(yma  )   and {yma  }   or yma
  m.l_int      = is_number(l_int)   and {l_int}   or l_int
  m.l_phy      = is_number(l_phy)   and {l_phy}   or l_phy
  m.current    = is_number(current) and {current} or current
  m.nwire      = #m.current

  local model  = elm.model  or m.model
  local method = elm.method or m.method
  local inter, thick, kick

  if l < minlen then
    inter, thick, kick = thinonly, wire_kick, fnil
  elseif current == 0 then
    inter, thick, kick = thickonly, strex_drift, fnil
  else
    inter, thick, kick = DKD[method], strex_drift, wire_kick
  end

  if m.cmap and current == 0 then -- strex_drift cmap only
    if not is_number(l) then m.cmap = 'p' end
    m.xflw = xflw_dft
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, kick, fnil)
  m.xma, m.yma, m.dpx, m.dpy = nil, nil, nil, nil
end

local function track_bbeam (elm, m)
  if not elm.enabled then return track_marker(elm, m) end

  local kick = elm.bb6D and bbeam_kick6D or bbeam_kick
  trackelm(elm, m, thinonly, kick, fnil, fnil)
end

local function track_nllens (elm, m)
  if not elm.enabled then return track_marker(elm, m) end

  trackelm(elm, m, thinonly, nllens_kick, fnil, fnil)
end

-- linmap element

local function track_linmap (elm, m)
  local sdir, edir, cmap in m
  local l, lrad, angle in elm

  m.el, m.lrad, m.eh = l*sdir, lrad*sdir, angle/l*edir

  trackelm(elm, m, thinonly, linm_thin, fnil, fnil)
  m.eh = 0
end

-- genmap element

local function track_genmap (elm, m)
  get_mult(elm, m) ; adj_mult(m)

  local sdir, edir, nmul, cmap in m
  local l, lrad, angle in elm

  m.el, m.lrad, m.eh = l*sdir, lrad*sdir, angle/l*edir

  if nmul > 0 and abs(angle) >= minang then
    m.snm = elm.secnmul or m.secnmul or -1 ; getanbnr(m)
  end

  local inter  = nmul == 0  and thickonly or KMK[elm.method or m.method]
  local kick   = nmul == 0  and fnil or abs(angle) < minang and strex_kick   or curex_kick
  local fringe = l < minlen and fnil or abs(angle) < minang and strex_fringe or curex_fringe

  trackelm(elm, m, inter, genm_thick, kick, fringe)
  m.eh, m.snm = 0, 0
end

-- load maps into elements ----------------------------------------------------o

local _nyi = \e ->
  errorf("tracking element %s of kind %s with length %s not yet implemented",
          e.name, e.kind, e.l)

local E = element

-- warning: set_methods overides must be consistent with survey and element.

-- element kinds
E.drift_element :set_methods {track = track_drift}

-- special elements
E.marker     :set_methods {track = track_marker}     -- cloned in sequence
E.slink      :set_methods {track = track_slink }

-- thick elements
E.sbend      :set_methods {track = track_sbend     } -- curved  , k0!, k0s, k1, k1s, k2, k2s
E.rbend      :set_methods {track = track_rbend     } -- straight, k0!, k0s, k1, k1s, k2, k2s
E.quadrupole :set_methods {track = track_quadrupole} -- straight, k0, k1!, k0s, k1s, k2, k2s
E.sextupole  :set_methods {track = track_sextupole } -- straight, k2, k2s
E.octupole   :set_methods {track = track_octupole  } -- straight, k3, k3s
E.decapole   :set_methods {track = track_decapole  } -- straight, k4, k4s
E.dodecapole :set_methods {track = track_dodecapole} -- straight, k5, k5s
E.solenoid   :set_methods {track = track_solenoid  } -- straight, ks, ksi
E.rfcavity   :set_methods {track = track_rfcavity  } -- straight, volt, freq!, lag, harmon
E.rfmultipole:set_methods {track = track_rfmcavity } -- straight, volt, freq!, lag, harmon, mult, phas
E.crabcavity :set_methods {track = track_crabcavity} -- straight, volt, freq!, lag, harmon, mult, phas

E.wire       :set_methods {track = track_wire   }    -- straight
E.wiggler    :set_methods {track = _nyi         }    -- straight
E.elseparator:set_methods {track = track_eseptum}    -- straight

E.tkicker    :set_methods {track = track_tkicker}    -- straight, hkick, vkick
E.kicker     :set_methods {track = track_kicker }    -- straight, hkick, vkick
E.hkicker    :set_methods {track = track_hkicker}    -- straight,  kick
E.vkicker    :set_methods {track = track_vkicker}    -- straight,  kick

-- thin elements
E.multipole  :set_methods {track = track_multipole}  -- thin
E.beambeam   :set_methods {track = track_bbeam    }  -- thin
E.nllens     :set_methods {track = track_nllens   }  -- thin
E.linmap     :set_methods {track = track_linmap   }  -- thick line segment
E.genmap     :set_methods {track = track_genmap   }  -- straight or curved, damap, update

-- patches
E.changeref  :set_methods {track = track_changeref}
E.translate  :set_methods {track = track_translate}
E.xrotation  :set_methods {track = \e,m -> track_rotation(e,m,xrotation)}
E.yrotation  :set_methods {track = \e,m -> track_rotation(e,m,yrotation)}
E.srotation  :set_methods {track = \e,m -> track_rotation(e,m,srotation)}
E.changenrj  :set_methods {track = \e,m -> trackone(e,m,thinonly,changenrj)}
E.changedir  :set_methods {track = \e,m -> trackone(e,m,thinonly,changedir)}

-- end ------------------------------------------------------------------------o
