--[=[
 o-----------------------------------------------------------------------------o
 |
 | Track element methods (loaded by track)
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

--[=[
Notes about directions and quantities:
  edir: element direction affects curvatures (edir = seq.dir).
  sdir: track direction s affects lengths    (sdir = cmd.dir).
  tdir: time direction t  affects angles     (tdir = edir x sdir).
  bdir: beam direction    affects strengths  (bdir = edir x sdir x chg).
--]=]

-- locals ---------------------------------------------------------------------o

local element, damap, symint, option, warn, _C                  in MAD
local is_number, is_function                                    in MAD.typeid
local fnil, fcut, ftst, bind3rd                                 in MAD.gfunc
local fact, arc2cord, sqrt, sin, cos, atan2                     in MAD.gmath
local assertf, errorf                                           in MAD.utility
local minlen, minang, minstr, clight, twopi, pi_2               in MAD.constant
local is_implicit                                               in element.drift

local type = type

local abs, max in math -- ensure that abs will not work on GTPSA.

-- redefine abs for this module (only!)
local abs = \a -> type(a) == "number" and abs(a) or abs(a:get0())

-- constants
local minvolt = 1e-6

local getanbnr in require("madl_curvmul")

-- integrator schemes ---------------------------------------------------------o

local thinonly, thickonly, driftonly, DKD, TKT, KMK                in MAD.symint

-- dynamic maps ---------------------------------------------------------------o

-- straight elements (DKD)
local strex_drift, strex_kick             , strex_fringe           in MAD.dynmap
local              strex_kickhs                                    in MAD.dynmap

-- curved elements (DKD)
local curex_drift, curex_kick             , curex_fringe           in MAD.dynmap

-- sbend (TKT)
local sbend_thick,  sbend_kick            , dipeg_fringe           in MAD.dynmap

-- rbend (TKT)
local rbend_thick,  rbend_kick                                     in MAD.dynmap

-- quadrupole (TKT)
local quad_thick , quad_kick , quad_kick_ ,
      quad_thicks, quad_kicks, quad_kicks_,
      quad_thickh, quad_kickh, quad_kickh_                         in MAD.dynmap

-- solenoid (TKT)
local solen_thick                         , solen_fringe           in MAD.dynmap

-- electrostatic separator
local esept_thick                                                  in MAD.dynmap

-- non-linear elliptical lens
local nllens_kick                                                  in MAD.dynmap

-- rfcavity
local rfcav_kick, rfcav_kickn             , rfcav_fringe           in MAD.dynmap

-- beambeam
local bbeam_kick, bbeam_kick6D                                     in MAD.dynmap

-- generic damap
local genm_thick                                                   in MAD.dynmap

-- patches
local xrotation, yrotation, srotation, translate,
      changeref, changedir, changenrj, misalign, tilt              in MAD.dynmap

-- fringe flags
local fringe                                                       in MAD.dynmap

-- dynamic maps in C ----------------------------------------------------------o

local ffi = require 'ffi'

ffi.cdef [[
enum { nmul_max=22, snm_max=(nmul_max+1)*(nmul_max+2)/2 };

struct cflw_r { // must be identical to def in mad_dynmap.cpp with M=par_t !!
  str_t name;
  int dbg;

  // element data
  num_t el, eld, elc, lrad;
  num_t eh, ang, mang;

  // beam
  num_t pc, beta, betgam;
  int charge;

  // directions, path
  int sdir, edir, pdir, T, Tbak;

  // quad, solenoid, multipole, esptum, rfcav, sine & cosine
  num_t k1, ks, volt, freq, lag, sa, ca;
  int nbsl;

  // fringes
  int frng, fmax;
  num_t e, h, a, fint, hgap, f1, f2;

  // patches, misalignments & tilt
  bool  rot, trn;
  num_t dx,   dy,   ds;
  num_t dthe, dphi, dpsi, tlt;

  // multipoles
  int   nmul;
  num_t knl[nmul_max];
  num_t ksl[nmul_max];

  // curved multipoles
  int   snm;
  num_t bfx[snm_max];
  num_t bfy[snm_max];

  // particles
  int    npar;
  num_t **par;
};

struct cflw_t { // must be identical to def in mad_dynmap.cpp with M=map_t !!
  str_t name;
  int dbg;

  // element data
  num_t el, eld, elc, lrad;
  num_t eh, ang, mang;

  // beam
  num_t pc, beta, betgam;
  int charge;

  // directions, path
  int sdir, edir, pdir, T, Tbak;

  // quad, solenoid, multipole, esptum, rfcav, sine & cosine
  num_t k1, ks, volt, freq, lag, sa, ca;
  int nbsl;

  // fringes
  int frng, fmax;
  num_t e, h, a, fint, hgap, f1, f2;

  // patches, misalignments & tilt
  bool  rot, trn;
  num_t dx,   dy,   ds;
  num_t dthe, dphi, dpsi, tlt;

  // multipoles
  int   nmul;
  num_t knl[nmul_max];
  num_t ksl[nmul_max];

  // curved multipoles
  int   snm;
  num_t bfx[snm_max];
  num_t bfy[snm_max];

  // damaps
  int      npar;
  tpsa_t* **par;
};

struct cflw_p { // must be identical to def in mad_dynmap.cpp with M=prm_t !!
  str_t name;
  int dbg;

  // element data
  tpsa_t *el, *eld, *elc, *lrad;
  tpsa_t *eh, *ang, *mang;

  // beam
  num_t pc, beta, betgam;
  int charge;

  // directions, path
  int sdir, edir, pdir, T, Tbak;

  // quad, solenoid, multipole, esptum, rfcav, sine & cosine
  tpsa_t *k1, *ks, *volt, *freq, *lag, *sa, *ca;
  int nbsl;

  // fringes
  int frng, fmax;
  tpsa_t *e, *h, *a, *fint, *hgap, *f1, *f2;

  // patches, misalignments & tilt
  bool  rot, trn;
  tpsa_t *dx,   *dy,   *ds;
  tpsa_t *dthe, *dphi, *dpsi, *tlt;

  // multipoles
  int    nmul;
  tpsa_t *knl[nmul_max];
  tpsa_t *ksl[nmul_max];

  // curved multipoles
  int     snm;
  tpsa_t *bfx[snm_max];
  tpsa_t *bfy[snm_max];

  // parametric damaps
  int      npar;
  tpsa_t* **par;
};

union mflw_ {
  struct cflw_r rflw;
  struct cflw_t tflw;
  struct cflw_p pflw;
};

extern const size_t mad_cflw_rsize;
extern const size_t mad_cflw_tsize;
extern const size_t mad_cflw_psize;
extern const size_t mad_cflw_size;
]]

local msg = "FFI/C %s is not consistent with C/C++ %s from mad_dynmap.cpp"

assertf(ffi.sizeof("struct cflw_r") == _C.mad_cflw_rsize, msg, "struct cflw_r", "struct cflw<par_t>")
assertf(ffi.sizeof("struct cflw_t") == _C.mad_cflw_tsize, msg, "struct cflw_t", "struct cflw<map_t>")
assertf(ffi.sizeof("struct cflw_p") == _C.mad_cflw_psize, msg, "struct cflw_p", "struct cflw<prm_t>")
assertf(ffi.sizeof("union mflw_"  ) == _C.mad_cflw_size , msg, "union  mflw_" , "union  mflw_"      )

local txflw  = { r = 'rflw' , t = 'tflw' , p = 'pflw'  }
local txflw_ = { r = 'rflw_', t = 'tflw_', p = 'pflw_' }
local  xflw  = \m -> m[txflw [m.cmap]]
local  xflw_ = \m -> m[txflw_[m.cmap]]

local function xcpy (a, b)
      if is_number(a) then return b
  elseif is_number(b) then _C.mad_tpsa_setval(a,b) return a
  else                     _C.mad_tpsa_copy  (b,a) return a
  end
end

local map = {
  r = { -- not used
    [strex_drift ] = _C.mad_trk_strex_drift_r ,
    [strex_kick  ] = _C.mad_trk_strex_kick_r  ,
    [strex_kickhs] = _C.mad_trk_strex_kickhs_r,
    [strex_fringe] = _C.mad_trk_strex_fringe_r,
    [curex_drift ] = _C.mad_trk_curex_drift_r ,
    [curex_kick  ] = _C.mad_trk_curex_kick_r  ,
    [curex_fringe] = _C.mad_trk_curex_fringe_r,
    [sbend_thick ] = _C.mad_trk_sbend_thick_r ,
    [sbend_kick  ] = _C.mad_trk_sbend_kick_r  ,
    [dipeg_fringe] =            dipeg_fringe  ,
    [rbend_thick ] = _C.mad_trk_rbend_thick_r ,
    [rbend_kick  ] = _C.mad_trk_rbend_kick_r  ,
    [quad_thick  ] = _C.mad_trk_quad_thick_r  ,
    [quad_thicks ] = _C.mad_trk_quad_thicks_r ,
    [quad_thickh ] = _C.mad_trk_quad_thickh_r ,
    [quad_kick   ] = _C.mad_trk_quad_kick_r   ,
    [quad_kicks  ] = _C.mad_trk_quad_kicks_r  ,
    [quad_kickh  ] = _C.mad_trk_quad_kickh_r  ,
    [quad_kick_  ] = _C.mad_trk_quad_kick__r  ,
    [quad_kicks_ ] = _C.mad_trk_quad_kicks__r ,
    [quad_kickh_ ] = _C.mad_trk_quad_kickh__r ,
    [solen_thick ] = _C.mad_trk_solen_thick_r ,
    [solen_fringe] =            solen_fringe  ,
    [rfcav_kick  ] = _C.mad_trk_rfcav_kick_r  ,
    [rfcav_kickn ] = _C.mad_trk_rfcav_kickn_r ,
    [rfcav_fringe] = _C.mad_trk_rfcav_fringe_r,
    [esept_thick ] = _C.mad_trk_esept_thick_r ,
    [nllens_kick ] =            nllens_kick   ,
    [bbeam_kick  ] =            bbeam_kick    ,
    [bbeam_kick6D] =            bbeam_kick6D  ,
    [genm_thick  ] =            genm_thick    ,
    [xrotation   ] = _C.mad_trk_xrotation_r   ,
    [yrotation   ] = _C.mad_trk_yrotation_r   ,
    [srotation   ] = _C.mad_trk_srotation_r   ,
    [translate   ] = _C.mad_trk_translate_r   ,
    [changeref   ] = _C.mad_trk_changeref_r   ,
    [changedir   ] =            changedir     ,
    [changenrj   ] =            changenrj     ,
    [misalign    ] = _C.mad_trk_misalign_r    ,
    [tilt        ] = _C.mad_trk_tilt_r        ,
    [fnil        ] = _C.mad_trk_fnil          ,
  },
  t = {
    [strex_drift ] = _C.mad_trk_strex_drift_t ,
    [strex_kick  ] = _C.mad_trk_strex_kick_t  ,
    [strex_kickhs] = _C.mad_trk_strex_kickhs_t,
    [strex_fringe] = _C.mad_trk_strex_fringe_t,
    [curex_drift ] = _C.mad_trk_curex_drift_t ,
    [curex_kick  ] = _C.mad_trk_curex_kick_t  ,
    [curex_fringe] = _C.mad_trk_curex_fringe_t,
    [sbend_thick ] = _C.mad_trk_sbend_thick_t ,
    [sbend_kick  ] = _C.mad_trk_sbend_kick_t  ,
    [dipeg_fringe] =            dipeg_fringe  ,
    [rbend_thick ] = _C.mad_trk_rbend_thick_t ,
    [rbend_kick  ] = _C.mad_trk_rbend_kick_t  ,
    [quad_thick  ] = _C.mad_trk_quad_thick_t  ,
    [quad_thicks ] = _C.mad_trk_quad_thicks_t ,
    [quad_thickh ] = _C.mad_trk_quad_thickh_t ,
    [quad_kick   ] = _C.mad_trk_quad_kick_t   ,
    [quad_kicks  ] = _C.mad_trk_quad_kicks_t  ,
    [quad_kickh  ] = _C.mad_trk_quad_kickh_t  ,
    [quad_kick_  ] = _C.mad_trk_quad_kick__t  ,
    [quad_kicks_ ] = _C.mad_trk_quad_kicks__t ,
    [quad_kickh_ ] = _C.mad_trk_quad_kickh__t ,
    [solen_thick ] = _C.mad_trk_solen_thick_t ,
    [solen_fringe] =            solen_fringe  ,
    [rfcav_kick  ] = _C.mad_trk_rfcav_kick_t  ,
    [rfcav_kickn ] = _C.mad_trk_rfcav_kickn_t ,
    [rfcav_fringe] = _C.mad_trk_rfcav_fringe_t,
    [esept_thick ] = _C.mad_trk_esept_thick_t ,
    [nllens_kick ] =            nllens_kick   ,
    [bbeam_kick  ] =            bbeam_kick    ,
    [bbeam_kick6D] =            bbeam_kick6D  ,
    [genm_thick  ] =            genm_thick    ,
    [xrotation   ] = _C.mad_trk_xrotation_t   ,
    [yrotation   ] = _C.mad_trk_yrotation_t   ,
    [srotation   ] = _C.mad_trk_srotation_t   ,
    [translate   ] = _C.mad_trk_translate_t   ,
    [changeref   ] = _C.mad_trk_changeref_t   ,
    [changedir   ] =            changedir     ,
    [changenrj   ] =            changenrj     ,
    [misalign    ] = _C.mad_trk_misalign_t    ,
    [tilt        ] = _C.mad_trk_tilt_t        ,
    [fnil        ] = _C.mad_trk_fnil          ,
  },
  p = {
    [strex_drift ] = _C.mad_trk_strex_drift_p ,
    [strex_kick  ] = _C.mad_trk_strex_kick_p  ,
    [strex_kickhs] = _C.mad_trk_strex_kickhs_p,
    [strex_fringe] = _C.mad_trk_strex_fringe_p,
    [curex_drift ] = _C.mad_trk_curex_drift_p ,
    [curex_kick  ] = _C.mad_trk_curex_kick_p  ,
    [curex_fringe] = _C.mad_trk_curex_fringe_p,
    [sbend_thick ] = _C.mad_trk_sbend_thick_p ,
    [sbend_kick  ] = _C.mad_trk_sbend_kick_p  ,
    [dipeg_fringe] =            dipeg_fringe  ,
    [rbend_thick ] = _C.mad_trk_rbend_thick_p ,
    [rbend_kick  ] = _C.mad_trk_rbend_kick_p  ,
    [quad_thick  ] = _C.mad_trk_quad_thick_p  ,
    [quad_thicks ] = _C.mad_trk_quad_thicks_p ,
    [quad_thickh ] = _C.mad_trk_quad_thickh_p ,
    [quad_kick   ] = _C.mad_trk_quad_kick_p   ,
    [quad_kicks  ] = _C.mad_trk_quad_kicks_p  ,
    [quad_kickh  ] = _C.mad_trk_quad_kickh_p  ,
    [quad_kick_  ] = _C.mad_trk_quad_kick__p  ,
    [quad_kicks_ ] = _C.mad_trk_quad_kicks__p ,
    [quad_kickh_ ] = _C.mad_trk_quad_kickh__p ,
    [solen_thick ] = _C.mad_trk_solen_thick_p ,
    [solen_fringe] =            solen_fringe  ,
    [rfcav_kick  ] = _C.mad_trk_rfcav_kick_p  ,
    [rfcav_kickn ] = _C.mad_trk_rfcav_kickn_p ,
    [rfcav_fringe] = _C.mad_trk_rfcav_fringe_p,
    [esept_thick ] = _C.mad_trk_esept_thick_p ,
    [nllens_kick ] =            nllens_kick   ,
    [bbeam_kick  ] =            bbeam_kick    ,
    [bbeam_kick6D] =            bbeam_kick6D  ,
    [genm_thick  ] =            genm_thick    ,
    [xrotation   ] = _C.mad_trk_xrotation_p   ,
    [yrotation   ] = _C.mad_trk_yrotation_p   ,
    [srotation   ] = _C.mad_trk_srotation_p   ,
    [translate   ] = _C.mad_trk_translate_p   ,
    [changeref   ] = _C.mad_trk_changeref_p   ,
    [changedir   ] =            changedir     ,
    [changenrj   ] =            changenrj     ,
    [misalign    ] = _C.mad_trk_misalign_p    ,
    [tilt        ] = _C.mad_trk_tilt_p        ,
    [fnil        ] = _C.mad_trk_fnil          ,
  },
}

-- strengths and phases -------------------------------------------------------o

local nsnm = \snm -> ((snm+1)*(snm+2)/2) -- see snm_max above

local function cpy_mult (m)
  local c = xflw(m)
  c.nmul = m.nmul
  c.snm  = m.snm

  c.knl[0] = xcpy(c.knl[0], 0)
  c.ksl[0] = xcpy(c.ksl[0], 0)
  c.knl[1] = xcpy(c.knl[1], 0)
  c.ksl[1] = xcpy(c.ksl[1], 0)

  for i=1,c.nmul do
    c.knl[i-1] = xcpy(c.knl[i-1], m.knl[i])
    c.ksl[i-1] = xcpy(c.ksl[i-1], m.ksl[i])
  end

  if c.snm > 0 then
    for i=1,nsnm(c.snm) do
      c.bfx[i-1] = xcpy(c.bfx[i-1], m.bfx[i])
      c.bfy[i-1] = xcpy(c.bfy[i-1], m.bfy[i])
    end  
  end
end

local function adj_mult (m)
  local knl, ksl, nmul in m
  m.nmul = 0

  for i=nmul,1,-1 do
    if abs(knl[i])+abs(ksl[i]) > 0 then m.nmul = i ; break end
  end

  if m.dapo > 0 then
    for i=m.nmul,1,-1 do
      if not (is_number(knl[i]) and is_number(ksl[i])) then
        m.cmap = 'p' ; break
      end
    end
  end
end

local function get_mult (elm, m, n)
  local knl, ksl, dknl, dksl in elm

  m.nmul = max(#knl, #ksl, #dknl, #dksl, n or 0)

  for i=1,m.nmul do
    m.knl[i] = ((knl[i] or 0) + (dknl[i] or 0)) / fact(i-1)
    m.ksl[i] = ((ksl[i] or 0) + (dksl[i] or 0)) / fact(i-1)
  end
end

-- misalignments --------------------------------------------------------------o

local function get_algn (e, m)
  local al = e.misalign or  m.sequ:align (m.eidx)
  local el = m.misalign and m.sequ:ealign(m.eidx) or nil

  if not (al or el) then return nil end

  local dx, dy, ds, dthe, dphi, dpsi = 0, 0, 0, 0, 0, 0

  if al then -- element abolute/permanent misalignments
    dx, dthe = dx+(al.dx or 0), dthe+(al.dtheta or 0) -- horizontal/azimutal
    dy, dphi = dy+(al.dy or 0), dphi+(al.dphi   or 0) -- vertical/elevation
    ds, dpsi = ds+(al.ds or 0), dpsi+(al.dpsi   or 0) -- longitudinal/roll
  end

  if el then -- element relative/error misalignments
    dx, dthe = dx+(el.dx or 0), dthe+(el.dtheta or 0) -- horizontal/azimutal
    dy, dphi = dy+(el.dy or 0), dphi+(el.dphi   or 0) -- vertical/elevation
    ds, dpsi = ds+(el.ds or 0), dpsi+(el.dpsi   or 0) -- longitudinal/roll
  end

  local trn = abs(dx  )+abs(dy  )+abs(ds  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return nil end

  if m.cmap then
    local c = xflw(m)
    c.trn  = trn
    c.rot  = rot
    c.dx   = xcpy(c.dx  , dx   )
    c.dy   = xcpy(c.dy  , dy   )
    c.ds   = xcpy(c.ds  , ds   )
    c.dthe = xcpy(c.dthe, dthe )
    c.dphi = xcpy(c.dphi, dphi )
    c.dpsi = xcpy(c.dpsi, dpsi )
    c.tlt  = xcpy(c.tlt , m.tlt)
  end

  return {trn=trn, rot=rot, dx=dx, dy=dy, ds=ds, dthe=dthe, dphi=dphi, dpsi=dpsi}
end

-- helpers --------------------------------------------------------------------o

local function crot (elm, m, dir)
  if m.cmap then
    local c = xflw(m)
    c.tlt = xcpy(c.tlt, m.tlt)
    map[m.cmap][tilt](xflw_(m), dir)
  else
    tilt(elm, m, dir)
  end
end

local function cmisalign (elm, m, dir)
  if m.cmap then
    map[m.cmap][misalign](xflw_(m), dir)
  else
    misalign(elm, m, dir)
  end
end

local function cfringe (elm, m, dir, frng)
  local fun = map[m.cmap][frng]
  if is_function(fun) then return frng(elm, m, dir) end

  local frng, fmax, e, h, a, fint, hgap, f1, f2 =
           0,    0, 0, 0, 0,    0,    0,  0, 0

  if not (dir ==  1 and elm.kill_ent_fringe or
          dir == -1 and elm.kill_exi_fringe) then
    frng = fcut(m.fringe, elm.fringe)
  end

  local e1, e2 = (m.e1 or elm.e1), (m.e2 or elm.e2)
  if dir == 1 then e, h = e1, elm.h1
  else             e, h = e2, elm.h2
  end
  a =  m.pdir == dir and e2 - e1 or 0

  if ftst(frng, fringe.bend) then
    fint, hgap = (dir == -1 and elm.fintx) or elm.fint, elm.hgap
  end

  if ftst(frng, fringe.mult) then
    fmax = elm.frngmax or m.frngmax
  end

  if ftst(frng, fringe.qsad) then
    f1, f2 = elm.f1, elm.f2
  end

  if m.cmap then
    local c = xflw(m)
    c.frng = frng
    c.fmax = fmax
    c.fint = xcpy(c.fint, fint)
    c.hgap = xcpy(c.hgap, hgap)
    c.e    = xcpy(c.e   , e   )
    c.h    = xcpy(c.h   , h   )
    c.a    = xcpy(c.a   , a   )
    c.f1   = xcpy(c.f1  , f1  )
    c.f2   = xcpy(c.f2  , f2  )
  end

  return fun(xflw_(m), dir)
end

-- element tracking -----------------------------------------------------------o

local function trackone (elm, m, inter, thick_or_thin)
  local sdir, atentry, atexit in m

  if m.cmap then
    local cmap = map[m.cmap]
    thick_or_thin = cmap[thick_or_thin]
    if is_function(thick_or_thin) then m.pmap = true end
    xflw(m).name = elm.name
  end

  atentry(elm, m,  sdir, -1)
  inter  (elm, m,  sdir, thick_or_thin)
  atexit (elm, m, -sdir, -2)

  m.pmap = false
  if m.cmap == 'p' then m.cmap = 't' end
end

local function trackelm (elm, m, inter, thick, thin, fringe)
  local sdir, atentry, atexit in m
  local tlt  = elm.tilt ; m.tlt = tlt
  local algn = get_algn(elm, m) ; m.algn = algn
  local mis  = algn and cmisalign or fnil
  local rot  = abs(tlt) >= minang and crot or fnil
  local fng  = fringe

  if m.cmap then
    local cmap = map[m.cmap]
    thick, thin, fng = cmap[thick], cmap[thin], fng ~= fnil and cfringe or fng
    if is_function(thick) or is_function(thin) then m.pmap = true end
    local c = xflw(m)
    c.name = elm.name
    c.tlt = xcpy(c.tlt, tlt)
  end

  atentry(elm, m,  sdir, -1)
  mis    (elm, m,  sdir)
  rot    (elm, m,  sdir)
  atentry(elm, m,  sdir, -3)
  fng    (elm, m,  sdir, fringe)
  inter  (elm, m,  sdir, thick, thin)
  fng    (elm, m, -sdir, fringe)
  atexit (elm, m, -sdir, -4)
  rot    (elm, m, -sdir)
  mis    (elm, m, -sdir)
  atexit (elm, m, -sdir, -2)

  m.pmap, m.algn = false, nil
  if m.cmap == 'p' then m.cmap = 't' end
end

local function tracksub (elm, m, inter, thick, thin, fringe)
  if m.eidx == 0 then
    errorf("invalid subelement track %s (contain subelements)", elm.name)
  end

  local eidx, sdir, atentry, atexit, __sdat in m
  local tlt  = elm.tilt ; m.tlt = tlt
  local algn = get_algn(elm, m) ; m.algn = algn
  local mis  = algn and cmisalign or fnil
  local rot  = abs(tlt) >= minang and crot or fnil
  local fng  = fringe
  m.eidx = 0

  if m.cmap then
    local cmap = map[m.cmap]
    thick, thin, fng = cmap[thick], cmap[thin], fng ~= fnil and cfringe or fng
    if is_function(thick) or is_function(thin) then m.pmap = true end
    local c = xflw(m)
    c.name = elm.name
    c.tlt = xcpy(c.tlt, tlt)
  end

  atentry(elm, m, sdir, -1)
  mis    (elm, m, sdir)
  rot    (elm, m, sdir)
  atentry(elm, m, sdir, -3)
  fng    (elm, m, sdir, fringe)

  if sdir > 0 then
    local at, lw = 0
    for i=1,#elm do
      at, lw = elm[i].sat, elm[i].sat - at
      if abs(lw) >= minlen then -- body step
        inter(elm, m, lw, thick, thin)
      end
      __sdat.clw = at
      elm[i]:track(__sdat)
      at = at + elm[i].l/m.el
    end
    lw = 1 - at
    if abs(lw) >= minlen then  -- last body step
      inter(elm, m, lw, thick, thin)
    end

  else -- backtrack (sdir < 0)
    local at, lw = 1
    for i=#elm,1,-1 do
      local sat = elm[i].sat + elm[i].l/m.el
      at, lw = sat, at - sat
      if abs(lw) >= minlen then -- body step
        inter(elm, m, -lw, thick, thin)
      end
      __sdat.clw = at
      elm[i]:track(__sdat)
      at = at - elm[i].l/m.el
    end
    lw = at
    if abs(lw) >= minlen then -- first body step
      inter(elm, m, -lw, thick, thin)
    end
  end

  fng   (elm, m, -sdir, fringe)
  atexit(elm, m, -sdir, -4)
  rot   (elm, m, -sdir)
  mis   (elm, m, -sdir)
  atexit(elm, m, -sdir, -2)

  m.pmap, m.algn, m.eidx = false, nil, eidx
  if m.cmap == 'p' then m.cmap = 't' end
end

-- kinds ----------------------------------------------------------------------o

local function track_slink (elm, m)
  local update = elm:var_get'update'
  if update then update(elm, m) end -- update damap

  if elm.sequence then
    m:change_si(elm.sequence, elm.range, elm.nturn, elm.dir)
    return "restart_si"
  end
end

local function track_marker (elm, m)
  trackone(elm, m, thinonly, fnil)
end

local function track_rotation (elm, m, rot)
  m.ang = elm.angle

  if m.cmap then
    local c = xflw(m)
    c.ang = xcpy(c.ang, m.ang)
  end

  trackone(elm, m, thinonly, rot)
end

local function track_translate (elm, m)
  m.dx, m.dy, m.ds = elm.dx, elm.dy, elm.ds

  if m.cmap then
    local c = xflw(m)
    c.dx = xcpy(c.dx, m.dx)
    c.dy = xcpy(c.dy, m.dy)
    c.ds = xcpy(c.ds, m.ds)
  end

  trackone(elm, m, thinonly, translate)
end

local function track_changeref (elm, m)
  m.dx  , m.dy  , m.ds   = elm.dx    , elm.dy  , elm.ds
  m.dthe, m.dphi, m.dpsi = elm.dtheta, elm.dphi, elm.dpsi

  if m.cmap then
    local c = xflw(m)
    c.dx   = xcpy(c.dx  , m.dx  )
    c.dy   = xcpy(c.dy  , m.dy  )
    c.ds   = xcpy(c.ds  , m.ds  )
    c.dthe = xcpy(c.dthe, m.dthe)
    c.dphi = xcpy(c.dphi, m.dphi)
    c.dpsi = xcpy(c.dpsi, m.dpsi)
  end

  trackone(elm, m, thinonly, changeref)
end

local function track_drift (elm, m)
  m.el = elm.l

  if m.cmap then
    if not is_number(m.el) then m.cmap = 'p' end
    local c = xflw(m)
    c.el = xcpy(c.el, m.el)
  end

  if is_implicit(elm) then
    local inter = m.implicit and thickonly or driftonly
    trackone(elm, m, inter, strex_drift)
  else
    local inter = m.el >= minlen and thickonly or driftonly
    local track = #elm == 0 and trackelm or tracksub
    track(elm, m, inter, strex_drift, fnil, fnil)
  end
end

local function track_multipole (elm, m)
  get_mult(elm, m, 1) ; adj_mult(m)

  if m.nmul == 0 and abs(elm.ksi) < minstr then return track_marker(elm, m) end

  local ksi, lrad in elm
  local knl, ksl in m

  if lrad == 0 and abs(ksi) > 0 then
    errorf("thin solenoid '%s' defines strength with zero lrad", elm.name)
  end

  if not (is_number(ksi) and is_number(lrad)) then m.cmap = 'p' end

  m.lrad, m.ksi = lrad, ksi or 0

  local kick = strex_kick
  if abs(knl[1]) + abs(ksl[1]) + abs(m.ksi) >= minstr then
    kick = strex_kickhs
  end

  if m.cmap then
    if not (is_number(ksi) and is_number(lrad)) then m.cmap = 'p' end
    local c = xflw(m)
    c.lrad = xcpy(c.lrad, m.lrad                        )
    c.ks   = xcpy(c.ks  , m.ksi/(lrad > 0 and lrad or 1))
    cpy_mult(m)
  end

  trackelm(elm, m, thinonly, kick, nil, fnil)
end

local function track_bbeam (elm, m)
  if not elm.enabled then return track_marker(elm, m) end

  if m.cmap then
    -- TODO: not yet implemented
  end

  local kick = elm.bb6D and bbeam_kick6D or bbeam_kick
  trackelm(elm, m, thinonly, kick)
end

local function track_nllens (elm, m)
  if not elm.enabled then return track_marker(elm, m) end

  if m.cmap then
    -- TODO: not yet implemented
  end

  trackelm(elm, m, thinonly, nllens_kick)
end

local function track_sbend (elm, m, e1_, e2_)
  get_mult(elm, m, 3)

  local nmul, knl, ksl, bfx, bfy in m
  local l, angle, k0, k0s, k1, k1s, k2, k2s in elm

  if l < minlen then
    errorf("invalid sbend '%s' length=%.4e [m] (>0 expected)", elm.name, l)
  end
  if abs(angle) < minang then
    errorf("invalid sbend '%s' angle=%.4e [rad] (~=0 expected)", elm.name, angle)
  end

  knl[1], ksl[1] = knl[1]+k0*l  , ksl[1]+k0s*l
  knl[2], ksl[2] = knl[2]+k1*l  , ksl[2]+k1s*l
  knl[3], ksl[3] = knl[3]+k2*l/2, ksl[3]+k2s*l/2
  m.el, m.eh = l, angle/l
  m.e1, m.e2 = (e1_ or elm.e1), (e2_ or elm.e2)
  m.mang     = angle

  local model  = elm.model   or m.model
  local method = elm.method  or m.method
  local snmul  = elm.secnmul or m.secnmul or -1
  local inter, thick, kick

  m.snm = snmul

  adj_mult(m) ; getanbnr(m)

  if model == 'DKD' then                          -- curved thin
    inter, thick, kick = DKD[method], curex_drift , curex_kick
  elseif m.nmul == 1 and ksl[1] == 0 and not m.ptcmodel then -- curved thick only
    inter, thick, kick = thickonly  , sbend_thick , fnil
  else -- if abs(knl[2]) < minstr then            -- curved thick
    inter, thick, kick = TKT[method], sbend_thick , sbend_kick
  end
  m.mang = angle

  if m.cmap then
    if m.dapo > 0 and not (is_number(m.eh) and is_number(m.e1) and is_number(m.e2)) then
      m.cmap = 'p'
    end
    local c = xflw(m)
    c.eh   = xcpy(c.eh  , m.eh  )
    c.el   = xcpy(c.el  , m.el  )
    c.mang = xcpy(c.mang, m.mang)
    cpy_mult(m)
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, kick, curex_fringe)
  m.e1, m.e2, m.snm = nil, nil, 0
end

local function track_rbend (elm, m)
  local angle, e1, e2, true_rbend in elm

  if not true_rbend then                                                      -- checked
    return track_sbend(elm, m, e1+angle/2, e2+angle/2)
  end

  get_mult(elm, m, 3)                                                         -- checked

  local nmul, knl, ksl, ptcmodel in m
  local l, k0, k0s, k1, k1s, k2, k2s in elm

  if l < minlen then
    errorf("invalid rbend '%s' length=%.4e [m] (>0 expected)", elm.name, l)
  end

  if is_number(e1) and abs(e1) > twopi then e1 = false end
  if is_number(e2) and abs(e2) > twopi then e2 = false end

  m.eld  = l
  m.elc  = arc2cord(m.eld, angle)
  m.mang = angle

  if e1 and e2 then                                                           -- Straight
    m.e1, m.e2, m.pdir = e1+angle/2, e2+angle/2, nil
    m.el = m.elc
  elseif e1 then                                                              -- True parallel with exit patch
    m.e1, m.e2, m.pdir = e1, angle - e1, -1
    m.el = m.elc * cos(angle/2 - e1)
  elseif e2 then                                                              -- True parallel with entry patch
    m.e1, m.e2, m.pdir = angle - e2, e2,  1
    m.el = m.elc * cos(angle/2 - e2)
  else errorf("True parallel rbend '%s' must set e1 or e2", elm.name)
  end

  l = m.el
  m.eh = angle/m.eld                                                          -- Must be divided by eld.

  if l < minlen then
    errorf("invalid rbend angle (or pole face) '%s' giving length=%.4e [m] (>0 expected)", elm.name, l)
  end

  knl[1], ksl[1] = knl[1]+k0*l  , ksl[1]+k0s*l
  knl[2], ksl[2] = knl[2]+k1*l  , ksl[2]+k1s*l
  knl[3], ksl[3] = knl[3]+k2*l/2, ksl[3]+k2s*l/2

  adj_mult(m)

  local model  = elm.model  or m.model
  local method = elm.method or m.method
  local inter, thick, kick

  if model == 'DKD' then
    inter, thick, kick = DKD[method], strex_drift, strex_kick
  elseif m.nmul == 1 and ksl[1] == 0 and not ptcmodel then
    inter, thick, kick = thickonly  , rbend_thick , fnil
  else
    inter, thick, kick = TKT[method], rbend_thick, rbend_kick
  end
  m.mang = angle

  if m.cmap then
    if m.dapo > 0 and not (is_number(m.eh) and is_number(m.e1) and is_number(m.e2)) then
      m.cmap = 'p'
    end
    local c = xflw(m)
    c.pdir = m.pdir or 0
    c.eh   = xcpy(c.eh  , m.eh  )
    c.el   = xcpy(c.el  , m.el  )
    c.eld  = xcpy(c.eld , m.eld )
    c.elc  = xcpy(c.elc , m.elc )
    c.mang = xcpy(c.mang, m.mang)
    cpy_mult(m)
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, kick, strex_fringe)
  m.e1, m.e2, m.eld, m.pdir = nil, nil, nil, nil

  if m.cmap then
    local c = xflw(m)
    c.pdir = 0
    c.eld = xcpy(c.eld, 0)
  end
end

local function track_quadrupole (elm, m)
  get_mult(elm, m, 2)

  local nmul, knl, ksl, ptcmodel in m
  local l, angle, k0, k0s, k1, k1s in elm

  if l == 0 and abs(k1)+abs(k1s)+abs(k0)+abs(k0s) > 0 then
    warn("quadrupole '%s' defines strength with zero length", elm.name)
  end

  knl[1], ksl[1] = knl[1]+k0*l, ksl[1]+k0s*l
  knl[2], ksl[2] = knl[2]+k1*l, ksl[2]+k1s*l
  m.el, m.eh = l, 0

  adj_mult(m)

  local model  = elm.model  or m.model
  local method = elm.method or m.method
  local no_k1  = abs(knl[2]) < minstr
  local no_k1s = abs(ksl[2]) < minstr 
  local no_ang = abs(angle)  < minang
  local no_tlt = ptcmodel and not no_k1s and (abs(knl[1]) > minstr or nmul > 2 or elm.fringe > 0)
  local inter  = ptcmodel and method > 2 and KMK[method] or TKT[method]
  local thick, kick

  if model == 'DKD' or no_k1 and no_k1s and no_ang then
    inter, thick, kick = DKD[method], strex_drift, strex_kick
  elseif no_k1s and no_ang or no_tlt then       -- normal thick
    m.k1 = knl[2]/l
    thick, kick = quad_thick, ptcmodel and quad_kick_ or quad_kick
  elseif no_ang then                            -- skew thick
    local a = -0.5*atan2(ksl[2], knl[2])
    m.k1, m.ca, m.sa = sqrt(knl[2]^2 + ksl[2]^2)/l, cos(a), sin(a)
    thick, kick = quad_thicks, ptcmodel and quad_kicks_ or quad_kicks
  else                                          -- combined thick            -- unchecked
    m.eh = angle/l
    thick, kick = quad_thickh, ptcmodel and quad_kickh_ or quad_kickh
  end

  if m.cmap then
    if not (is_number(angle) and is_number(l)) then m.cmap = 'p' end
    local c = xflw(m)
    c.el = xcpy(c.el, m.el     )
    c.eh = xcpy(c.eh, m.eh     )
    c.k1 = xcpy(c.k1, m.k1 or 0)
    c.ca = xcpy(c.ca, m.ca or 0)
    c.sa = xcpy(c.sa, m.sa or 0)
    cpy_mult(m)
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, kick, strex_fringe)
end

-- straigth magnets (-rbend -quad -solenoid)

local function track_strexgen (elm, m, ptc_, mth_)
  local l in elm
  m.el, m.eh = l, 0

  adj_mult(m)

  local model  = elm.model  or m.model
  local method = elm.method or mth_ or m.method
  local inter, thick, kick, fringe

  if l < minlen then
    inter, thick, kick, fringe = thinonly, strex_kick, fnil, fnil
  elseif model == 'DKD' or not ptc_ then
    inter, thick, kick, fringe = DKD[method], strex_drift, strex_kick, strex_fringe
  else
    m.k1 = m.knl[2]/l
    inter = method > 2 and KMK[method] or TKT[method]
    thick, kick, fringe = quad_thick, quad_kick_, strex_fringe
  end

  if m.cmap then
    if not is_number(m.el) then m.cmap = 'p' end
    local c = xflw(m)
    c.eh = xcpy(c.eh, 0        )
    c.el = xcpy(c.el, m.el     )
    c.k1 = xcpy(c.k1, m.k1 or 0)
    cpy_mult(m)
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, kick, fringe)
end

local function track_sextupole (elm, m)
  get_mult(elm, m, 3)

  local nmul, knl, ksl in m
  local l, k2, k2s in elm

  if l == 0 and abs(k2)+abs(k2s) > 0 then
    warn("sextupole '%s' defines strength with zero length", elm.name)
  end

  knl[3] = knl[3]+k2 *l/2
  ksl[3] = ksl[3]+k2s*l/2

  track_strexgen (elm, m, m.ptcmodel)
end

local function track_octupole (elm, m)
  get_mult(elm, m, 4)

  local nmul, knl, ksl in m
  local l, k3, k3s in elm

  if l == 0 and abs(k3)+abs(k3s) > 0 then
    warn("octupole '%s' defines strength with zero length", elm.name)
  end

  knl[4] = knl[4]+k3 *l/6
  ksl[4] = ksl[4]+k3s*l/6

  track_strexgen (elm, m, m.ptcmodel)
end

local function track_decapole (elm, m)
  get_mult(elm, m, 5)

  local nmul, knl, ksl in m
  local l, k4, k4s in elm

  if l == 0 and abs(k4)+abs(k4s) > 0 then
    warn("decapole '%s' defines strength with zero length", elm.name)
  end

  knl[5] = knl[5]+k4 *l/24
  ksl[5] = ksl[5]+k4s*l/24

  track_strexgen (elm, m)
end

local function track_dodecapole (elm, m)
  get_mult(elm, m, 6)

  local nmul, knl, ksl in m
  local l, k5, k5s in elm

  if l == 0 and abs(k5)+abs(k5s) > 0 then
    warn("dodecapole '%s' defines strength with zero length", elm.name)
  end

  knl[6] = knl[6]+k5 *l/120
  ksl[6] = ksl[6]+k5s*l/120

  track_strexgen (elm, m)
end

-- kickers (straigth magnets)

local function track_kickgen (elm, m, hk, vk)
  get_mult(elm, m, 2)

  local nmul, knl, ksl, ptcmodel in m
  local method = not ptcmodel and 2 or nil

  knl[1] = knl[1] - hk
  ksl[1] = ksl[1] + vk

  track_strexgen (elm, m, ptcmodel, method)
end

local function track_tkicker (elm, m, hk_, vk_)
  track_kickgen(elm, m, elm.hkick, elm.vkick)
end

local function track_kicker (elm, m)
  track_kickgen(elm, m, elm.hkick+elm.chkick, elm.vkick+elm.cvkick)
end

local function track_hkicker (elm, m)
  track_kickgen(elm, m, elm.kick+elm.chkick, 0)
end

local function track_vkicker (elm, m)
  track_kickgen(elm, m, 0, elm.kick+elm.cvkick)
end

-- solenoid

local function track_solenoid (elm, m)
  get_mult(elm, m) ; adj_mult(m)

  local l, ks, ksi, lrad in elm
  local model = elm.model or m.model

  if l == 0 and abs(ks) > 0 then
    warn("solenoid '%s' defines strength with zero length", elm.name)
  end

  if l < minlen then
    if model == "DKD" and lrad > minlen then
      return track_multipole(elm, m)
    end
    errorf("invalid solenoid '%s' length=%.4e [m] (>0 expected)", elm.name, l)
  end

  m.el, m.eh = l, 0

  local ksi = ksi + ks*l
  local no_ksi = abs(ksi) < minstr
  local method = elm.method or m.method
  local thick, kick, fringe

  if no_ksi then
    thick, kick, fringe = strex_drift, strex_kick , strex_fringe
  else
    m.ks = ksi/l
    thick, kick, fringe = solen_thick, strex_kick, elm.new_fringe and solen_fringe or strex_fringe
  end

  if m.cmap then
    if not (is_number(l) and is_number(ksi)) then m.cmap = 'p' end
    local c = xflw(m)
    c.el = xcpy(c.el, m.el     )
    c.eh = xcpy(c.eh, m.eh     )
    c.ks = xcpy(c.ks, m.ks or 0)
    cpy_mult(m)
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, DKD[method], thick, kick, fringe)
end

-- eseptum

local function track_eseptum (elm, m)
  get_mult(elm, m) ; adj_mult(m)

  local l, ex, ey, exl, eyl in elm

  if l == 0 and abs(ex)+abs(ey) > 0 then
    warn("eseptum '%s' defines strength with zero length", elm.name)
  end

  m.el, m.eh = l, 0

  local exl = exl + ex*l
  local eyl = eyl + ey*l
  local volt = sqrt(exl^2 + eyl^2)/l
  local thick

  if abs(volt) < minvolt then
    thick = strex_drift
  else
    local a = -atan2(eyl, exl)
    m.volt, m.ca, m.sa = volt*1e-3, cos(a), sin(a)
    thick = esept_thick
  end

  if m.cmap then
    if not (is_number(l) and is_number(volt)) then m.cmap = 'p' end
    local c = xflw(m)
    c.el   = xcpy(c.el  , m.el       )
    c.eh   = xcpy(c.eh  , m.eh       )
    c.volt = xcpy(c.volt, m.volt or 0)
    c.ca   = xcpy(c.ca  , m.ca   or 0)
    c.sa   = xcpy(c.sa  , m.sa   or 0)
    cpy_mult(m)
  end

  local inter = m.nmul == 0 and thickonly or KMK[elm.method or m.method]
  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, strex_kick, strex_fringe)
end

-- rf cavities

local function track_rfcavgen (elm, m, crab)
  local l, volt, freq, lag, harmon, n_bessel in elm

  m.el, m.eh = l, 0

  adj_mult(m)

  m.volt, m.lag = crab and 0 or volt*1e-3, lag*twopi - (crab and pi_2 or 0)
  m.freq, m.nbsl= freq*1e6, n_bessel
  if m.freq == 0 then
    m.freq = harmon*clight*m.beam.beta/m.sequ.l
  end
  if m.freq <= 0 and abs(m.volt) ~= 0 then
    errorf("invalid rfcavity '%s' frequency =%.4e [MHz] (>0 or harmon expected)",
            elm.name, m.freq)
  end

  local inter  = l < minlen and thinonly or DKD[elm.method or m.method]
  local kick   = m.nmul+m.nbsl == 0 and rfcav_kick or rfcav_kickn
  local thick  = l < minlen and kick or strex_drift
  local fringe = l < minlen and fnil or rfcav_fringe

  if m.cmap then
    if m.dapo > 0 and not (is_number(volt) and is_number(m.freq) and
      is_number(lag) and is_number(l)) then m.cmap = 'p' end
    local c = xflw(m)
    c.nbsl = m.nbsl
    c.Tbak = elm.no_cavity_totalpath and -2 or -1
    c.el   = xcpy(c.el  , m.el  )
    c.eh   = xcpy(c.eh  , m.eh  )
    c.volt = xcpy(c.volt, m.volt)
    c.freq = xcpy(c.freq, m.freq)
    c.lag  = xcpy(c.lag , m.lag )
    cpy_mult(m)
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, kick, fringe)
end

local function track_rfcavity (elm, m)
  get_mult      (elm, m)
  track_rfcavgen(elm, m)
end

local function track_rfmcavity (elm, m)
  get_mult      (elm, m)
  track_rfcavgen(elm, m)
end

local function track_crabcavity (elm, m)
  get_mult      (elm, m, 1)
  local l, volt in elm
  m.knl[1] = m.knl[1] + volt*l*1e-3
  track_rfcavgen(elm, m, true)
end

-- genmap element

local function track_genmap (elm, m)
  get_mult(elm, m) ; adj_mult(m)

  local sdir, edir in m
  local l, lrad, angle in elm

  m.el, m.lrad, m.eh = l*sdir, lrad*sdir, angle/l*edir

  m.pmap = true -- prevent C/C++ maps

  local inter  = KMK[elm.method or m.method]
  local kick   = m.nmul == 0 and fnil or abs(angle) < minang and strex_kick   or curex_kick
  local fringe = l < minlen  and fnil or abs(angle) < minang and strex_fringe or curex_fringe

  local track  = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, genm_thick, kick, fringe)
end

-- load maps into elements ----------------------------------------------------o

local _nyi = \e ->
  errorf("tracking element %s of kind %s with length %s not yet implemented",
          e.name, e.kind, e.l)

local E = element

-- warning: set_methods overides must be consistent with survey and element.

-- element kinds
E.drift_element :set_methods {track = track_drift}

-- special elements
E.marker     :set_methods {track = track_marker}     -- cloned in sequence
E.slink      :set_methods {track = track_slink }

-- thick elements
E.sbend      :set_methods {track = track_sbend     } -- curved  , k0!, k0s, k1, k1s, k2, k2s
E.rbend      :set_methods {track = track_rbend     } -- straight, k0!, k0s, k1, k1s, k2, k2s
E.quadrupole :set_methods {track = track_quadrupole} -- straight, k0, k1!, k0s, k1s, k2, k2s
E.sextupole  :set_methods {track = track_sextupole } -- straight, k2, k2s
E.octupole   :set_methods {track = track_octupole  } -- straight, k3, k3s
E.decapole   :set_methods {track = track_decapole  } -- straight, k4, k4s
E.dodecapole :set_methods {track = track_dodecapole} -- straight, k5, k5s
E.solenoid   :set_methods {track = track_solenoid  } -- straight, ks, ksi
E.rfcavity   :set_methods {track = track_rfcavity  } -- straight, volt, freq!, lag, harmon
E.rfmultipole:set_methods {track = track_rfmcavity } -- straight, volt, freq!, lag, harmon, mult, phas
E.crabcavity :set_methods {track = track_crabcavity} -- straight, volt, freq!, lag, harmon, mult, phas

E.wiggler    :set_methods {track = _nyi         }    -- straight
E.elseparator:set_methods {track = track_eseptum}    -- straight

E.tkicker    :set_methods {track = track_tkicker}    -- straight, hkick, vkick
E.kicker     :set_methods {track = track_kicker }    -- straight, hkick, vkick
E.hkicker    :set_methods {track = track_hkicker}    -- straight,  kick
E.vkicker    :set_methods {track = track_vkicker}    -- straight,  kick

-- thin elements
E.multipole  :set_methods {track = track_multipole}  -- thin
E.beambeam   :set_methods {track = track_bbeam    }  -- thin
E.nllens     :set_methods {track = track_nllens   }  -- thin
E.genmap     :set_methods {track = track_genmap   }  -- straight or curved, damap, update

-- patches
E.changeref  :set_methods {track = track_changeref}
E.translate  :set_methods {track = track_translate}
E.xrotation  :set_methods {track = \e,m -> track_rotation(e,m,xrotation)}
E.yrotation  :set_methods {track = \e,m -> track_rotation(e,m,yrotation)}
E.srotation  :set_methods {track = \e,m -> track_rotation(e,m,srotation)}
E.changenrj  :set_methods {track = \e,m -> trackone(e,m,thinonly,changenrj)}
E.changedir  :set_methods {track = \e,m -> trackone(e,m,thinonly,changedir)}

-- end ------------------------------------------------------------------------o
