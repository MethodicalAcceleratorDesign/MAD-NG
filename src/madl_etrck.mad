--[=[
 o-----------------------------------------------------------------------------o
 |
 | Track element methods (loaded by track)
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

--[=[
Notes about directions and quantities:
  edir: element direction affects curvatures (edir = seq.dir).
  sdir: track direction s affects lengths    (sdir = cmd.dir).
  tdir: time direction t  affects angles     (tdir = edir x sdir).
  bdir: beam direction    affects strengths  (bdir = edir x sdir x chg).
--]=]

-- locals ---------------------------------------------------------------------o

local element, damap, symint, option, warn, _C                  in MAD
local is_number, is_function                                    in MAD.typeid
local fnil, fcut, ftst, bind3rd                                 in MAD.gfunc
local fact, arc2cord, sqrt, sin, cos, atan2                     in MAD.gmath
local assertf, errorf                                           in MAD.utility
local minlen, minang, minstr, clight, twopi, pi_2               in MAD.constant
local is_implicit                                               in element.drift

local type = type

local abs, max in math -- ensure that abs will not work on GTPSA.

-- redefine abs for this module (only!)
local abs = \a -> type(a) == "number" and abs(a) or abs(a:get0())

-- constants
local minvolt = 1e-6

local getanbnr in require("madl_curvmul")

-- integrator schemes ---------------------------------------------------------o

local thinonly, thickonly, driftonly, DKD, TKT, KMK                in MAD.symint

-- dynamic maps ---------------------------------------------------------------o

-- straight elements (DKD)
local strex_drift, strex_kick             , strex_fringe           in MAD.dynmap
local              strex_kickhs                                    in MAD.dynmap

-- curved elements (DKD)
local curex_drift, curex_kick             , curex_fringe           in MAD.dynmap

-- sbend (TKT)
local sbend_thick,  sbend_kick            , dipeg_fringe           in MAD.dynmap

-- rbend (TKT)
local rbend_thick,  rbend_kick                                     in MAD.dynmap

-- quadrupole (TKT)
local quad_thick , quad_kick , quad_kick_ ,
      quad_thicks, quad_kicks, quad_kicks_,
      quad_thickh, quad_kickh, quad_kickh_                         in MAD.dynmap

-- solenoid (TKT)
local solen_thick                         , solen_fringe           in MAD.dynmap

-- electrostatic separator
local esept_thick                                                  in MAD.dynmap

-- non-linear elliptical lens
local nllens_kick                                                  in MAD.dynmap

-- rfcavity
local rfcav_kick, rfcav_kickn             , rfcav_fringe           in MAD.dynmap

-- beambeam
local bbeam_kick, bbeam_kick6D                                     in MAD.dynmap

-- generic damap
local genm_thick                                                   in MAD.dynmap

-- patches
local xrotation, yrotation, srotation, translate,
      changeref, changedir, changenrj, misalign                    in MAD.dynmap

-- fringe flags
local fringe                                                       in MAD.dynmap

-- dynamic maps in C ----------------------------------------------------------o

local ffi = require 'ffi'

ffi.cdef [[
enum { nmul_max=22, snm_max=(nmul_max+1)*(nmul_max+2)/2 };

struct cflw_r { // must be identical to def in mad_dynmap.cpp !!
  str_t name;
  int dbg;

  // element data
  num_t el, eld, elc, lrad;
  num_t eh, ang, mang;

  // beam
  num_t pc, beta, betgam;
  int charge;

  // directions, path
  int sdir, edir, pdir, T, Tbak;

  // quad, solenoid, multipole, esptum, rfcav
  num_t k1, ks, volt, freq, lag;
  int nbsl;

  // fringes
  int frng, fmax;
  num_t e, h, a;
  num_t fint, hgap, f1, f2;

  // angles
  num_t ca, sa, tlt;

  // multipoles
  int   nmul;
  num_t knl[nmul_max];
  num_t ksl[nmul_max];

  // curved multipoles
  int   snm;
  num_t bfx[snm_max];
  num_t bfy[snm_max];

  // patches
  num_t dx,   dy,   ds;
  num_t dthe, dphi, dpsi;

  // misalign
  struct {
    bool  rot, trn;
    num_t dx,   dy,   ds;
    num_t dthe, dphi, dpsi;
  } algn;

  // particles
  int    npar;
  num_t **par;
};

struct cflw_t { // must be identical to def in mad_dynmap.cpp !!
  str_t name;
  int dbg;

  // element data
  num_t el, eld, elc, lrad;
  num_t eh, ang, mang;

  // beam
  num_t pc, beta, betgam;
  int charge;

  // directions, path
  int sdir, edir, pdir, T, Tbak;

  // quad, solenoid, multipole, esptum, rfcav
  num_t k1, ks, volt, freq, lag;
  int nbsl;

  // fringes
  int frng, fmax;
  num_t e, h, a;
  num_t fint, hgap, f1, f2;

  // angles
  num_t ca, sa, tlt;

  // multipoles
  int   nmul;
  num_t knl[nmul_max];
  num_t ksl[nmul_max];

  // curved multipoles
  int   snm;
  num_t bfx[snm_max];
  num_t bfy[snm_max];

  // patches
  num_t dx,   dy,   ds;
  num_t dthe, dphi, dpsi;

  // misalign
  struct {
    bool  rot, trn;
    num_t dx,   dy,   ds;
    num_t dthe, dphi, dpsi;
  } algn;

  // damaps
  int      npar;
  tpsa_t* **par;
};

struct cflw_p { // must be identical to def in mad_dynmap.cpp !!
  str_t name;
  int dbg;

  // element data
  tpsa_t *el, *eld, *elc, *lrad;
  tpsa_t *eh, *ang, *mang;

  // beam
  num_t pc, beta, betgam;
  int charge;

  // directions, path
  int sdir, edir, pdir, T, Tbak;

  // quad, solenoid, multipole, esptum, rfcav
  tpsa_t *k1, *ks, *volt, *freq, *lag;
  int nbsl;

  // fringes
  int frng, fmax;
  tpsa_t *e, *h, *a;
  num_t fint, hgap, f1, f2;

  // angles
  tpsa_t *ca, *sa, *tlt;

  // multipoles
  int    nmul;
  tpsa_t *knl[nmul_max];
  tpsa_t *ksl[nmul_max];

  // curved multipoles
  int     snm;
  tpsa_t *bfx[snm_max];
  tpsa_t *bfy[snm_max];

  // patches
  tpsa_t *dx,   *dy,   *ds;
  tpsa_t *dthe, *dphi, *dpsi;

  // misalign
  struct {
    bool  rot, trn;
    num_t dx,   dy,   ds;
    num_t dthe, dphi, dpsi;
  } algn;

  // parametric damaps
  int      npar;
  tpsa_t* **par;
};

union mflw_ {
  struct cflw_r rflw;
  struct cflw_t tflw;
  struct cflw_p pflw;
};

extern const size_t mad_cflw_rsize;
extern const size_t mad_cflw_tsize;
extern const size_t mad_cflw_psize;
extern const size_t mad_cflw_size;
]]

local msg = "FFI/C %s is not consistent with C/C++ %s from mad_dynmap.cpp"

assertf(ffi.sizeof("struct cflw_r") == _C.mad_cflw_rsize, msg, "struct cflw_r", "struct cflw<par_t>")
assertf(ffi.sizeof("struct cflw_t") == _C.mad_cflw_tsize, msg, "struct cflw_t", "struct cflw<map_t>")
assertf(ffi.sizeof("struct cflw_p") == _C.mad_cflw_psize, msg, "struct cflw_p", "struct cflw<prm_t>")
assertf(ffi.sizeof("union mflw_"  ) == _C.mad_cflw_size , msg, "union  mflw_" , "union  mflw_"      )

local map = {
  r = { -- not used
    [strex_drift ] = _C.mad_trk_strex_drift_r ,
    [strex_kick  ] = _C.mad_trk_strex_kick_r  ,
    [strex_kickhs] = _C.mad_trk_strex_kickhs_r,
    [strex_fringe] = _C.mad_trk_strex_fringe_r,
    [curex_drift ] = _C.mad_trk_curex_drift_r ,
    [curex_kick  ] = _C.mad_trk_curex_kick_r  ,
    [curex_fringe] = _C.mad_trk_curex_fringe_r,
    [sbend_thick ] = _C.mad_trk_sbend_thick_r ,
    [sbend_kick  ] = _C.mad_trk_sbend_kick_r  ,
    [dipeg_fringe] =            dipeg_fringe  ,
    [rbend_thick ] = _C.mad_trk_rbend_thick_r ,
    [rbend_kick  ] = _C.mad_trk_rbend_kick_r  ,
    [quad_thick  ] = _C.mad_trk_quad_thick_r  ,
    [quad_thicks ] = _C.mad_trk_quad_thicks_r ,
    [quad_thickh ] = _C.mad_trk_quad_thickh_r ,
    [quad_kick   ] = _C.mad_trk_quad_kick_r   ,
    [quad_kicks  ] = _C.mad_trk_quad_kicks_r  ,
    [quad_kickh  ] = _C.mad_trk_quad_kickh_r  ,
    [quad_kick_  ] = _C.mad_trk_quad_kick__r  ,
    [quad_kicks_ ] = _C.mad_trk_quad_kicks__r ,
    [quad_kickh_ ] = _C.mad_trk_quad_kickh__r ,
    [solen_thick ] = _C.mad_trk_solen_thick_r ,
    [solen_fringe] =            solen_fringe  ,
    [rfcav_kick  ] = _C.mad_trk_rfcav_kick_r  ,
    [rfcav_kickn ] = _C.mad_trk_rfcav_kickn_r ,
    [rfcav_fringe] = _C.mad_trk_rfcav_fringe_r,
    [esept_thick ] = _C.mad_trk_esept_thick_r ,
    [nllens_kick ] =            nllens_kick   ,
    [bbeam_kick  ] =            bbeam_kick    ,
    [bbeam_kick6D] =            bbeam_kick6D  ,
    [genm_thick  ] =            genm_thick    ,
    [xrotation   ] = _C.mad_trk_xrotation_r   ,
    [yrotation   ] = _C.mad_trk_yrotation_r   ,
    [srotation   ] = _C.mad_trk_srotation_r   ,
    [translate   ] = _C.mad_trk_translate_r   ,
    [changeref   ] = _C.mad_trk_changeref_r   ,
    [changedir   ] =            changedir     ,
    [changenrj   ] =            changenrj     ,
    [misalign    ] = _C.mad_trk_misalign_r    ,
    [fnil        ] = _C.mad_trk_fnil          ,
  },
  t = {
    [strex_drift ] = _C.mad_trk_strex_drift_t ,
    [strex_kick  ] = _C.mad_trk_strex_kick_t  ,
    [strex_kickhs] = _C.mad_trk_strex_kickhs_t,
    [strex_fringe] = _C.mad_trk_strex_fringe_t,
    [curex_drift ] = _C.mad_trk_curex_drift_t ,
    [curex_kick  ] = _C.mad_trk_curex_kick_t  ,
    [curex_fringe] = _C.mad_trk_curex_fringe_t,
    [sbend_thick ] = _C.mad_trk_sbend_thick_t ,
    [sbend_kick  ] = _C.mad_trk_sbend_kick_t  ,
    [dipeg_fringe] =            dipeg_fringe  ,
    [rbend_thick ] = _C.mad_trk_rbend_thick_t ,
    [rbend_kick  ] = _C.mad_trk_rbend_kick_t  ,
    [quad_thick  ] = _C.mad_trk_quad_thick_t  ,
    [quad_thicks ] = _C.mad_trk_quad_thicks_t ,
    [quad_thickh ] = _C.mad_trk_quad_thickh_t ,
    [quad_kick   ] = _C.mad_trk_quad_kick_t   ,
    [quad_kicks  ] = _C.mad_trk_quad_kicks_t  ,
    [quad_kickh  ] = _C.mad_trk_quad_kickh_t  ,
    [quad_kick_  ] = _C.mad_trk_quad_kick__t  ,
    [quad_kicks_ ] = _C.mad_trk_quad_kicks__t ,
    [quad_kickh_ ] = _C.mad_trk_quad_kickh__t ,
    [solen_thick ] = _C.mad_trk_solen_thick_t ,
    [solen_fringe] =            solen_fringe  ,
    [rfcav_kick  ] = _C.mad_trk_rfcav_kick_t  ,
    [rfcav_kickn ] = _C.mad_trk_rfcav_kickn_t ,
    [rfcav_fringe] = _C.mad_trk_rfcav_fringe_t,
    [esept_thick ] = _C.mad_trk_esept_thick_t ,
    [nllens_kick ] =            nllens_kick   ,
    [bbeam_kick  ] =            bbeam_kick    ,
    [bbeam_kick6D] =            bbeam_kick6D  ,
    [genm_thick  ] =            genm_thick    ,
    [xrotation   ] = _C.mad_trk_xrotation_t   ,
    [yrotation   ] = _C.mad_trk_yrotation_t   ,
    [srotation   ] = _C.mad_trk_srotation_t   ,
    [translate   ] = _C.mad_trk_translate_t   ,
    [changeref   ] = _C.mad_trk_changeref_t   ,
    [changedir   ] =            changedir     ,
    [changenrj   ] =            changenrj     ,
    [misalign    ] = _C.mad_trk_misalign_t    ,
    [fnil        ] = _C.mad_trk_fnil          ,
  },
  p = {
    [strex_drift ] = _C.mad_trk_strex_drift_p ,
    [strex_kick  ] = _C.mad_trk_strex_kick_p  ,
    [strex_kickhs] = _C.mad_trk_strex_kickhs_p,
    [strex_fringe] = _C.mad_trk_strex_fringe_p,
    [curex_drift ] = _C.mad_trk_curex_drift_p ,
    [curex_kick  ] = _C.mad_trk_curex_kick_p  ,
    [curex_fringe] = _C.mad_trk_curex_fringe_p,
    [sbend_thick ] = _C.mad_trk_sbend_thick_p ,
    [sbend_kick  ] = _C.mad_trk_sbend_kick_p  ,
    [dipeg_fringe] =            dipeg_fringe  ,
    [rbend_thick ] = _C.mad_trk_rbend_thick_p ,
    [rbend_kick  ] = _C.mad_trk_rbend_kick_p  ,
    [quad_thick  ] = _C.mad_trk_quad_thick_p  ,
    [quad_thicks ] = _C.mad_trk_quad_thicks_p ,
    [quad_thickh ] = _C.mad_trk_quad_thickh_p ,
    [quad_kick   ] = _C.mad_trk_quad_kick_p   ,
    [quad_kicks  ] = _C.mad_trk_quad_kicks_p  ,
    [quad_kickh  ] = _C.mad_trk_quad_kickh_p  ,
    [quad_kick_  ] = _C.mad_trk_quad_kick__p  ,
    [quad_kicks_ ] = _C.mad_trk_quad_kicks__p ,
    [quad_kickh_ ] = _C.mad_trk_quad_kickh__p ,
    [solen_thick ] = _C.mad_trk_solen_thick_p ,
    [solen_fringe] =            solen_fringe  ,
    [rfcav_kick  ] = _C.mad_trk_rfcav_kick_p  ,
    [rfcav_kickn ] = _C.mad_trk_rfcav_kickn_p ,
    [rfcav_fringe] = _C.mad_trk_rfcav_fringe_p,
    [esept_thick ] = _C.mad_trk_esept_thick_p ,
    [nllens_kick ] =            nllens_kick   ,
    [bbeam_kick  ] =            bbeam_kick    ,
    [bbeam_kick6D] =            bbeam_kick6D  ,
    [genm_thick  ] =            genm_thick    ,
    [xrotation   ] = _C.mad_trk_xrotation_p   ,
    [yrotation   ] = _C.mad_trk_yrotation_p   ,
    [srotation   ] = _C.mad_trk_srotation_p   ,
    [translate   ] = _C.mad_trk_translate_p   ,
    [changeref   ] = _C.mad_trk_changeref_p   ,
    [changedir   ] =            changedir     ,
    [changenrj   ] =            changenrj     ,
    [misalign    ] = _C.mad_trk_misalign_p    ,
    [fnil        ] = _C.mad_trk_fnil          ,
  },
}

-- strengths and phases -------------------------------------------------------o

local function cpy_mult (m)
  local c = m.cflw
  c.nmul = m.nmul
  c.snm  = m.snm

  c.knl[0], c.knl[1] = 0, 0
  c.ksl[0], c.ksl[1] = 0, 0

  for i=1,c.nmul do
    c.knl[i-1] = m.knl[i]
    c.ksl[i-1] = m.ksl[i]
  end

  for i=1,c.snm do
    c.bfx[i-1] = m.bfx[i]
    c.bfy[i-1] = m.bfy[i]
  end
end

local function adj_mult (m)
  local knl, ksl, nmul in m
  m.nmul, m.pmap = 0, false

  for i=nmul,1,-1 do
    local val = abs(knl[i]) + abs(ksl[i])
    if val > 0 then
      m.nmul, m.pmap = i, not is_number(val)
      if m.pmap then return else break end
    end
  end

  for i=m.nmul-1,1,-1 do
    if not is_number(knl[i]+ksl[i]) then m.pmap = true ; break end
  end
end

local function get_mult (elm, m, n)
  local knl, ksl, dknl, dksl in elm

  m.nmul = max(#knl, #ksl, #dknl, #dksl, n or 0)

  for i=1,m.nmul do
    m.knl[i] = ((knl[i] or 0) + (dknl[i] or 0)) / fact(i-1)
    m.ksl[i] = ((ksl[i] or 0) + (dksl[i] or 0)) / fact(i-1)
  end
end

local function get_multphas (elm, m, n)
  local knl, ksl, dknl, dksl in elm
--local pnl, psl, dpnl, dpsl in elm

  m.nmul = max(#knl, #ksl, #dknl, #dksl, n or 0)
--m.npha = m.nmul

  for i=1,m.nmul do
    m.knl[i] = ((knl[i] or 0) + (dknl[i] or 0)) / fact(i-1)
    m.ksl[i] = ((ksl[i] or 0) + (dksl[i] or 0)) / fact(i-1)
--  m.pnl[i] =  (pnl[i] or 0) + (dpnl[i] or 0)
--  m.psl[i] =  (psl[i] or 0) + (dpsl[i] or 0)
  end
end

-- misalignments --------------------------------------------------------------o

local function get_algn (e, m)
  local al = e.misalign or  m.sequ:align (m.eidx)
  local el = m.misalign and m.sequ:ealign(m.eidx) or nil

  if not (al or el) then return nil end

  local dx, dy, ds, dthe, dphi, dpsi = 0, 0, 0, 0, 0, 0

  if al then -- element abolute/permanent misalignments
    dx, dthe = dx+(al.dx or 0), dthe+(al.dtheta or 0) -- horizontal/azimutal
    dy, dphi = dy+(al.dy or 0), dphi+(al.dphi   or 0) -- vertical/elevation
    ds, dpsi = ds+(al.ds or 0), dpsi+(al.dpsi   or 0) -- longitudinal/roll
  end

  if el then -- element relative/error misalignments
    dx, dthe = dx+(el.dx or 0), dthe+(el.dtheta or 0) -- horizontal/azimutal
    dy, dphi = dy+(el.dy or 0), dphi+(el.dphi   or 0) -- vertical/elevation
    ds, dpsi = ds+(el.ds or 0), dpsi+(el.dpsi   or 0) -- longitudinal/roll
  end

  local trn = abs(dx  )+abs(dy  )+abs(ds  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return nil end

  if m.cmap then
    local c = m.cflw
    c.tlt       = m.tlt
    c.algn.trn  = trn
    c.algn.rot  = rot
    c.algn.dx   = dx
    c.algn.dy   = dy
    c.algn.ds   = ds
    c.algn.dthe = dthe
    c.algn.dphi = dphi
    c.algn.dpsi = dpsi
  end

  return {trn=trn, rot=rot, dx=dx, dy=dy, ds=ds, dthe=dthe, dphi=dphi, dpsi=dpsi}
end

-- helpers --------------------------------------------------------------------o

local function crot (elm, m, dir, tlt)
  if m.cmap then
    map[m.cmap][srotation](m.cflw_, dir, tlt)
  else
    srotation(elm, m, dir, tlt)
  end
end

local function cmisalign (elm, m, dir)
  if m.cmap then
    map[m.cmap][misalign](m.cflw_, dir)
  else
    misalign(elm, m, dir)
  end
end

local function cfringe (elm, m, dir, frng)
  local fun = map[m.cmap][frng]
  if is_function(fun) then return frng(elm, m, dir) end

  local c = m.cflw
  local p = m.pdir == dir

  if dir ==  1 and elm.kill_ent_fringe or
     dir == -1 and elm.kill_exi_fringe
  then c.frng = 0
  else c.frng = fcut(m.fringe, elm.fringe)
  end

  if dir == 1 then
    c.e, c.h  = (m.e1 or elm.e1)*m.tdir, elm.h1*m.tdir
    c.a = p and (m.e2 or elm.e2)*m.tdir - c.e or 0
  else
    c.e, c.h  = (m.e2 or elm.e2)*m.tdir, elm.h2*m.tdir
    c.a = p and c.e - (m.e1 or elm.e1)*m.tdir or 0
  end

  if ftst(c.frng, fringe.bend) then
    c.fint, c.hgap = (dir == -1 and elm.fintx) or elm.fint, elm.hgap
  end

  if ftst(c.frng, fringe.mult) then
    c.fmax = elm.frngmax or m.frngmax
  end

  if ftst(c.frng, fringe.qsad) then
    c.f1, c.f2 = elm.f1, elm.f2
  end

  return fun(m.cflw_, dir)
end

-- element tracking -----------------------------------------------------------o

local function trackone (elm, m, inter, thick, thin)
  local sdir, atentry, atexit in m

  if m.cmap and not m.pmap then
    local cmap = map[m.cmap]
    thick, thin = cmap[thick or fnil], cmap[thin or fnil]
    m.cflw.name = elm.name
  end

  atentry(elm, m,  sdir, -1)
  inter  (elm, m,    1 , thick, thin)
  atexit (elm, m, -sdir, -2)
end

local function trackelm (elm, m, inter, thick, thin, fringe)
  local sdir, atentry, atexit in m
  local tlt  = elm.tilt*m.tdir  ; m.tlt  = tlt
  local algn = get_algn(elm, m) ; m.algn = algn
  local mis  = algn and cmisalign or fnil
  local rot  = abs(tlt) >= minang and crot or fnil
  local fng  = fringe

  if m.cmap and not m.pmap then
    local cmap = map[m.cmap]
    thick, thin, fng = cmap[thick], cmap[thin], fng ~= fnil and cfringe or fng
    if is_function(thick) or is_function(thin) then m.pmap = true end
    m.cflw.name = elm.name
  end

  atentry(elm, m,  sdir, -1)
  mis    (elm, m,  sdir)
  rot    (elm, m,  sdir, tlt)
  atentry(elm, m,  sdir, -3)
  fng    (elm, m,  sdir, fringe)
  inter  (elm, m,    1 , thick, thin)
  fng    (elm, m, -sdir, fringe)
  atexit (elm, m, -sdir, -4)
  rot    (elm, m, -sdir, tlt)
  mis    (elm, m, -sdir)
  atexit (elm, m, -sdir, -2)

  m.algn = nil
end

local function tracksub (elm, m, inter, thick, thin, fringe)
  if m.eidx == 0 then
    errorf("invalid subelement track %s (contain subelements)", elm.name)
  end

  local eidx, sdir, atentry, atexit, __sdat in m
  local tlt  = elm.tilt*m.tdir  ; m.tlt  = tlt
  local algn = get_algn(elm, m) ; m.algn = algn
  local mis  = algn and cmisalign or fnil
  local rot  = abs(tlt) >= minang and crot or fnil
  local fng  = fringe
  m.eidx = 0

  if m.cmap and not m.pmap then
    local cmap = map[m.cmap]
    thick, thin, fng = cmap[thick], cmap[thin], fng ~= fnil and cfringe or fng
    if is_function(thick) or is_function(thin) then m.pmap = true end
    m.cflw.name = elm.name
  end

  atentry(elm, m, sdir, -1)
  mis    (elm, m, sdir)
  rot    (elm, m, sdir, tlt)
  atentry(elm, m, sdir, -3)
  fng    (elm, m, sdir, fringe)

  if sdir > 0 then
    local at, lw = 0
    for i=1,#elm do
      at, lw = elm[i].sat, elm[i].sat - at
      if abs(lw) >= minlen then -- body step
        inter(elm, m, lw, thick, thin)
      end
      __sdat.clw = at
      elm[i]:track(__sdat)
      at = at + elm[i].l/m.el
    end
    lw = 1 - at
    if abs(lw) >= minlen then  -- last body step
      inter(elm, m, lw, thick, thin)
    end

  else -- backtrack
    local at, lw = 1
    for i=#elm,1,-1 do
      local sat = elm[i].sat - elm[i].l/m.el                                  -- Thick element, therefore at is the exit point (el is weighted by sdir)
      at, lw = sat, at - sat
      if abs(lw) >= minlen then -- body step
        inter(elm, m, lw, thick, thin)
      end
      __sdat.clw = at
      elm[i]:track(__sdat)
      at = at + elm[i].l/m.el
    end
    lw = at
    if abs(lw) >= minlen then -- first body step
      inter(elm, m, lw, thick, thin)
    end
  end

  fng   (elm, m, -sdir, fringe)
  atexit(elm, m, -sdir, -4)
  rot   (elm, m, -sdir, tlt)
  mis   (elm, m, -sdir)
  atexit(elm, m, -sdir, -2)

  m.algn, m.eidx = nil, eidx
end

-- kinds ----------------------------------------------------------------------o

local function track_slink (elm, m)
  m.el, m.eh, m.nmul = 0, 0, 0

  local update = elm:var_get'update'
  if update then update(elm, m) end -- update damap

  if elm.sequence then
    m:change_si(elm.sequence, elm.range, elm.nturn, elm.dir)
    return "restart_si"
  end
end

local function track_marker (elm, m)
  m.el, m.eh, m.nmul = 0, 0, 0

  if m.cmap then
    m.cflw.el   = 0
    m.cflw.eh   = 0
    m.cflw.nmul = 0
  end

  trackone(elm, m, thinonly, nil, fnil)
end

local function track_drift (elm, m)
  local l in elm
  m.el, m.eh, m.nmul = l*m.sdir, 0, 0

  if not is_number(m.el) then m.pmap = true end

  if m.cmap and not m.pmap then
    m.cflw.el   = m.el
    m.cflw.eh   = 0
    m.cflw.nmul = 0
  end

  if is_implicit(elm) then
    local inter = m.implicit and thickonly or driftonly
    trackone(elm, m, inter, strex_drift, nil)
  else
    local track = #elm == 0 and trackelm or tracksub
    local inter = l >= minlen and thickonly or driftonly
    track(elm, m, inter, strex_drift, fnil, fnil)
  end
end

local function track_multipole (elm, m)
  get_mult(elm, m, 1) ; adj_mult(m)

  if m.nmul == 0 and abs(elm.ksi) < minstr then return track_marker(elm, m) end

  local ksi, lrad in elm
  local knl, ksl, sdir in m

  if lrad == 0 and abs(ksi) > 0 then
    errorf("thin solenoid '%s' defines strength with zero lrad", elm.name)
  end

  if not (is_number(ksi) and is_number(lrad)) then m.pmap = true end

  m.lrad, m.ksi = sdir*lrad, ksi or 0

  local kick = strex_kick
  if abs(knl[1]) + abs(ksl[1]) + abs(m.ksi) >= minstr then
    kick = strex_kickhs
  end

  if m.cmap and not m.pmap then
    m.cflw.lrad = m.lrad
    m.cflw.ks   = m.ksi/m.lrad
    cpy_mult(m)
  end

  trackelm(elm, m, thinonly, fnil, kick, fnil)
end

local function track_bbeam (elm, m)
  if not elm.enabled then return track_marker(elm, m) end

  m.el, m.eh, m.nmul = 0, 0, 0

  if m.cmap then
    m.cflw.el   = 0
    m.cflw.eh   = 0
    m.cflw.nmul = 0
  end

  local kick = elm.bb6D and bbeam_kick6D or bbeam_kick
  trackelm(elm, m, thinonly, fnil, kick, fnil)
end

local function track_nllens (elm, m)
  if not elm.enabled then return track_marker(elm, m) end

  m.el, m.eh, m.nmul = 0, 0, 0

  if m.cmap then
    m.cflw.el   = 0
    m.cflw.eh   = 0
    m.cflw.nmul = 0
  end

  trackelm(elm, m, thinonly, fnil, nllens_kick, fnil)
end

local function track_sbend (elm, m, e1_, e2_)
  get_mult(elm, m, 3)

  local sdir, edir, tdir, nmul, knl, ksl, bfx, bfy in m
  local l, angle, k0, k0s, k1, k1s, k2, k2s in elm

  if l < minlen then
    errorf("invalid sbend '%s' length=%.4e [m] (>0 expected)", elm.name, l)
  end
  if abs(angle) < minang then
    errorf("invalid sbend '%s' angle=%.4e [rad] (~=0 expected)", elm.name, angle)
  end

  knl[1], ksl[1] = knl[1]+k0*l  , ksl[1]+k0s*l
  knl[2], ksl[2] = knl[2]+k1*l  , ksl[2]+k1s*l
  knl[3], ksl[3] = knl[3]+k2*l/2, ksl[3]+k2s*l/2
  m.el, m.eh = l*sdir, angle*edir/l
  m.e1, m.e2 = (e1_ or elm.e1), (e2_ or elm.e2)
  m.ang      = angle*tdir

  local model  = elm.model   or m.model
  local method = elm.method  or m.method
  local snmul  = elm.secnmul or m.secnmul or -1
  local inter, thick, kick

  m.snm = snmul

  adj_mult(m) ; getanbnr(m)

  if not (is_number(m.eh) and is_number(m.e1) and is_number(m.e2)) then
    m.pmap = true
  end

  if model == 'DKD' then                          -- curved thin
    inter, thick, kick = DKD[method], curex_drift , curex_kick
  elseif m.nmul == 1 and ksl[1] == 0 and not m.ptcmodel then -- curved thick only
    inter, thick, kick = thickonly  , sbend_thick , fnil
  else -- if abs(knl[2]) < minstr then            -- curved thick
    inter, thick, kick = TKT[method], sbend_thick , sbend_kick
  end

  if m.cmap and not m.pmap then
    m.cflw.eh   = m.eh
    m.cflw.el   = m.el
    m.cflw.ang  = m.ang
    m.cflw.mang = m.mang
    cpy_mult(m)
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, kick, curex_fringe)
  m.e1, m.e2, m.snm = nil, nil, 0
end

local function track_rbend (elm, m)
  local angle, e1, e2, true_rbend in elm

  m.mang = 0
  if not true_rbend then                                                      -- checked
    return track_sbend(elm, m, e1+angle/2, e2+angle/2)
  end

  get_mult(elm, m, 3)                                                         -- checked

  local sdir, edir, tdir, nmul, knl, ksl, ptcmodel in m
  local l, k0, k0s, k1, k1s, k2, k2s in elm

  if l < minlen then
    errorf("invalid rbend '%s' length=%.4e [m] (>0 expected)", elm.name, l)
  end

  if is_number(e1) and abs(e1) > twopi then e1 = false end
  if is_number(e2) and abs(e2) > twopi then e2 = false end

  m.eld = l*sdir
  m.elc = arc2cord(m.eld, angle)

  if e1 and e2 then                                                           -- Straight
    m.e1, m.e2, m.pdir = e1+angle/2, e2+angle/2, nil
    m.el = m.elc
  elseif e1 then                                                              -- True parallel with exit patch
    m.e1, m.e2, m.pdir = e1, angle - e1, -1
    m.el = m.elc * cos(angle/2 - e1)
  elseif e2 then                                                              -- True parallel with entry patch
    m.e1, m.e2, m.pdir = angle - e2, e2,  1
    m.el = m.elc * cos(angle/2 - e2)
  else errorf("True parallel rbend '%s' must set e1 or e2", elm.name)
  end

  l = abs(m.el)
  m.eh = angle*edir/abs(m.eld)                                                -- Must be divided by eld.

  knl[1], ksl[1] = knl[1]+k0*l  , ksl[1]+k0s*l
  knl[2], ksl[2] = knl[2]+k1*l  , ksl[2]+k1s*l
  knl[3], ksl[3] = knl[3]+k2*l/2, ksl[3]+k2s*l/2

  adj_mult(m)

  if not (is_number(m.eh) and is_number(m.e1) and is_number(m.e2)) then
    m.pmap = true
  end

  local model  = elm.model  or m.model
  local method = elm.method or m.method
  local inter, thick, kick

  if model == 'DKD' then
    inter, thick, kick = DKD[method], strex_drift, strex_kick
  elseif m.nmul == 1 and ksl[1] == 0 and not ptcmodel then
    inter, thick, kick = thickonly  , rbend_thick , fnil
  else
    inter, thick, kick = TKT[method], rbend_thick, rbend_kick
  end

  if m.cmap and not m.pmap then
    m.cflw.eh   = m.eh
    m.cflw.el   = m.el
    m.cflw.eld  = m.eld
    m.cflw.elc  = m.elc
    m.cflw.pdir = m.pdir or 0
    m.cflw.ang  = m.ang
    m.cflw.mang = m.mang
    cpy_mult(m)
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, kick, strex_fringe)
  m.e1, m.e2, m.eld, m.pdir = nil, nil, nil, nil
  if m.cmap then m.cflw.eld, m.cflw.pdir = 0, 0 end
end

local function track_quadrupole (elm, m)
  get_mult(elm, m, 2)

  local sdir, edir, tdir, nmul, knl, ksl, ptcmodel in m
  local l, angle, k0, k0s, k1, k1s in elm

  if l == 0 and abs(k1)+abs(k1s)+abs(k0)+abs(k0s) > 0 then
    warn("quadrupole '%s' defines strength with zero length", elm.name)
  end

  knl[1], ksl[1] = knl[1]+k0*l, ksl[1]+k0s*l
  knl[2], ksl[2] = knl[2]+k1*l, ksl[2]+k1s*l
  m.el, m.eh = l*sdir, 0

  adj_mult(m)

  if not (is_number(angle) and is_number(l)) then m.pmap = true end

  local model  = elm.model  or m.model
  local method = elm.method or m.method
  local no_k1  = abs(knl[2]) < minstr
  local no_k1s = abs(ksl[2]) < minstr 
  local no_ang = abs(angle)  < minang
  local no_tlt = ptcmodel and not no_k1s and (abs(knl[1]) > minstr or nmul > 2 or elm.fringe > 0)
  local inter  = ptcmodel and KMK[method] or TKT[method]
  local thick, kick

  if model == 'DKD' or no_k1 and no_k1s and no_ang then
    inter, thick, kick = DKD[method], strex_drift, strex_kick
  elseif no_k1s and no_ang or no_tlt then       -- normal thick
    m.k1 = knl[2]/l*tdir
    thick, kick = quad_thick, ptcmodel and quad_kick_ or quad_kick
  elseif no_ang then                            -- skew thick
    local a = -0.5*atan2(ksl[2], knl[2])
    m.k1, m.ca, m.sa = sqrt(knl[2]^2 + ksl[2]^2)/l*tdir, cos(a), sin(a)
    thick, kick = quad_thicks, ptcmodel and quad_kicks_ or quad_kicks
  else                                          -- combined thick            -- unchecked
    m.eh = angle/l*edir
    thick, kick = quad_thickh, ptcmodel and quad_kickh_ or quad_kickh
  end

  if m.cmap and not m.pmap then
    m.cflw.el = m.el
    m.cflw.eh = m.eh
    m.cflw.k1 = m.k1 or 0
    m.cflw.ca = m.ca or 0
    m.cflw.sa = m.sa or 0
    cpy_mult(m)
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, kick, strex_fringe)
end

-- straigth magnets (-rbend -quad -solenoid)

local function track_strexgen (elm, m, ptc_, mth_)
  local l in elm
  m.el, m.eh = l*m.sdir, 0

  adj_mult(m)

  if not is_number(m.el) then m.pmap = true end

  local model  = elm.model  or m.model
  local method = elm.method or mth_ or m.method
  local inter, thick, kick, fringe

  if l < minlen then
    inter, thick, kick, fringe = thinonly, fnil, strex_kick, fnil
  elseif model == 'DKD' or not ptc_ then
    inter, thick, kick, fringe = DKD[method], strex_drift, strex_kick, strex_fringe
  else
    m.k1 = m.knl[2]/l*m.tdir
    inter, thick, kick, fringe = KMK[method], quad_thick, quad_kick_, strex_fringe
  end

  if m.cmap and not m.pmap then
    m.cflw.eh = 0
    m.cflw.el = m.el
    m.cflw.k1 = m.k1 or 0
    cpy_mult(m)
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, kick, fringe)
end

local function track_sextupole (elm, m)
  get_mult(elm, m, 3)

  local nmul, knl, ksl in m
  local l, k2, k2s in elm

  if l == 0 and abs(k2)+abs(k2s) > 0 then
    warn("sextupole '%s' defines strength with zero length", elm.name)
  end

  knl[3] = knl[3]+k2 *l/2
  ksl[3] = ksl[3]+k2s*l/2

  track_strexgen (elm, m, m.ptcmodel)
end

local function track_octupole (elm, m)
  get_mult(elm, m, 4)

  local nmul, knl, ksl in m
  local l, k3, k3s in elm

  if l == 0 and abs(k3)+abs(k3s) > 0 then
    warn("octupole '%s' defines strength with zero length", elm.name)
  end

  knl[4] = knl[4]+k3 *l/6
  ksl[4] = ksl[4]+k3s*l/6

  track_strexgen (elm, m, m.ptcmodel)
end

local function track_decapole (elm, m)
  get_mult(elm, m, 5)

  local nmul, knl, ksl in m
  local l, k4, k4s in elm

  if l == 0 and abs(k4)+abs(k4s) > 0 then
    warn("decapole '%s' defines strength with zero length", elm.name)
  end

  knl[5] = knl[5]+k4 *l/24
  ksl[5] = ksl[5]+k4s*l/24

  track_strexgen (elm, m)
end

local function track_dodecapole (elm, m)
  get_mult(elm, m, 6)

  local nmul, knl, ksl in m
  local l, k5, k5s in elm

  if l == 0 and abs(k5)+abs(k5s) > 0 then
    warn("dodecapole '%s' defines strength with zero length", elm.name)
  end

  knl[6] = knl[6]+k5 *l/120
  ksl[6] = ksl[6]+k5s*l/120

  track_strexgen (elm, m)
end

-- kickers (straigth magnets)

local function track_kickgen (elm, m, hk, vk)
  get_mult(elm, m, 2)

  local nmul, knl, ksl, ptcmodel in m
  local method = not ptcmodel and 2 or nil

  knl[1] = knl[1] - hk
  ksl[1] = ksl[1] + vk

  track_strexgen (elm, m, ptcmodel, method)
end

local function track_tkicker (elm, m, hk_, vk_)
  track_kickgen(elm, m, elm.hkick, elm.vkick)
end

local function track_kicker (elm, m)
  track_kickgen(elm, m, elm.hkick+elm.chkick, elm.vkick+elm.cvkick)
end

local function track_hkicker (elm, m)
  track_kickgen(elm, m, elm.kick+elm.chkick, 0)
end

local function track_vkicker (elm, m)
  track_kickgen(elm, m, 0, elm.kick+elm.cvkick)
end

-- solenoid

local function track_solenoid (elm, m)
  get_mult(elm, m) ; adj_mult(m)

  local sdir, edir, tdir in m
  local l, ks, ksi, lrad in elm
  local model = elm.model or m.model

  if l == 0 and abs(ks) > 0 then
    warn("solenoid '%s' defines strength with zero length", elm.name)
  end

  if l < minlen then
    if model == "DKD" and lrad > minlen then
      return track_multipole(elm, m)
    end
    errorf("invalid solenoid '%s' length=%.4e [m] (>0 expected)", elm.name, l)
  end

  m.el, m.eh = l*sdir, 0

  local ksi = ksi + ks*l
  local no_ksi = abs(ksi) < minstr
  local method = elm.method or m.method
  local thick, kick, fringe

  if not (is_number(l) and is_number(ksi)) then m.pmap = true end

  if no_ksi then
    thick, kick, fringe = strex_drift, strex_kick , strex_fringe
  else
    m.ks = ksi/l*edir
    thick, kick, fringe = solen_thick, strex_kick, elm.new_fringe and solen_fringe or strex_fringe
  end

  if m.cmap and not m.pmap then
    m.cflw.el = m.el
    m.cflw.eh = m.eh
    m.cflw.ks = m.ks or 0
    cpy_mult(m)
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, DKD[method], thick, kick, fringe)
end

-- eseptum

local function track_eseptum (elm, m)
  get_mult(elm, m) ; adj_mult(m)

  local sdir, edir, tdir in m
  local l, ex, ey, exl, eyl in elm

  if l == 0 and abs(ex)+abs(ey) > 0 then
    warn("eseptum '%s' defines strength with zero length", elm.name)
  end

  m.el, m.eh = l*sdir, 0

  local exl = exl + ex*l
  local eyl = eyl + ey*l
  local volt = sqrt(exl^2 + eyl^2)/l*tdir
  local thick

  if not (is_number(l) and is_number(volt)) then m.pmap = true end

  if abs(volt) < minvolt then
    thick = strex_drift
  else
    local a = -atan2(eyl, exl)
    m.volt, m.ca, m.sa = volt*1e-3, cos(a), sin(a)
    thick = esept_thick
  end

  if m.cmap and not m.pmap then
    m.cflw.el   = m.el
    m.cflw.eh   = m.eh
    m.cflw.volt = m.volt or 0
    m.cflw.ca   = m.ca   or 0
    m.cflw.sa   = m.sa   or 0
    cpy_mult(m)
  end

  local inter = m.nmul == 0 and thickonly or KMK[elm.method or m.method]
  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, strex_kick, strex_fringe)
end

-- rf cavities

local function track_rfcavgen (elm, m, crab)
  local sdir in m
  local l, volt, freq, lag, harmon, n_bessel in elm

  m.el, m.eh = l*sdir, 0

  adj_mult(m)

  m.volt, m.lag = crab and 0 or volt*1e-3, lag*twopi - (crab and pi_2 or 0)
  m.freq, m.nbsl= freq*1e6, n_bessel
  if m.freq == 0 then
    m.freq = harmon*clight*m.beam.beta/m.sequ.l
  end
  if m.freq <= 0 and abs(m.volt) ~= 0 then
    errorf("invalid rfcavity '%s' frequency =%.4e [MHz] (>0 or harmon expected)",
            elm.name, m.freq)
  end

  if not (is_number(l) and is_number(volt) and is_number(m.freq) and
          is_number(lag)) then m.pmap = true end

  local inter  = l < minlen and thinonly or DKD[elm.method or m.method]
  local kick   = m.nmul+m.nbsl == 0 and rfcav_kick or rfcav_kickn
  local fringe = l < minlen and fnil or rfcav_fringe

  if m.cmap and not m.pmap then
    m.cflw.el   = m.el
    m.cflw.eh   = m.eh
    m.cflw.volt = m.volt
    m.cflw.freq = m.freq
    m.cflw.lag  = m.lag
    m.cflw.nbsl = m.nbsl
    m.cflw.Tbak = elm.no_cavity_totalpath and -2 or -1
    cpy_mult(m)
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, strex_drift, kick, fringe)
end

local function track_rfcavity (elm, m)
  get_mult      (elm, m)
  track_rfcavgen(elm, m)
end

local function track_rfmcavity (elm, m)
  get_multphas  (elm, m)
  track_rfcavgen(elm, m)
  m.npha = nil
end

local function track_crabcavity (elm, m)
  get_multphas  (elm, m, 1)
  local l, volt in elm
  m.knl[1] = m.knl[1] + volt*l*1e-3
  track_rfcavgen(elm, m, true)
  m.npha = nil
end

-- genmap element

local function track_genmap (elm, m)
  get_mult(elm, m) ; adj_mult(m)

  local sdir, edir in m
  local l, angle in elm

  m.el, m.eh = l*sdir, angle/l*edir

  m.pmap = true -- prevent C/C++ maps

  local method = elm.method or m.method
  local inter  = l < minlen  and thinonly or m.nmul == 0 and thickonly or DKD[method]
  local kick   = m.nmul == 0 and fnil or abs(angle) < minang and strex_kick   or curex_kick
  local fringe = l < minlen  and fnil or abs(angle) < minang and strex_fringe or curex_fringe

  local track  = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, genm_thick, kick, fringe)
end

-- load maps into elements ----------------------------------------------------o

local _nyi = \e ->
  errorf("tracking element %s of kind %s with length %s not yet implemented",
          e.name, e.kind, e.l)

local E = element

-- warning: set_methods overides must be consistent with survey and element.

-- element kinds
E.drift_element :set_methods {track = track_drift}

-- special elements
E.marker     :set_methods {track = track_marker}     -- cloned in sequence
E.slink      :set_methods {track = track_slink }

-- thick elements
E.sbend      :set_methods {track = track_sbend     } -- curved  , k0!, k0s, k1, k1s, k2, k2s
E.rbend      :set_methods {track = track_rbend     } -- straight, k0!, k0s, k1, k1s, k2, k2s
E.quadrupole :set_methods {track = track_quadrupole} -- straight, k0, k1!, k0s, k1s, k2, k2s
E.sextupole  :set_methods {track = track_sextupole } -- straight, k2, k2s
E.octupole   :set_methods {track = track_octupole  } -- straight, k3, k3s
E.decapole   :set_methods {track = track_decapole  } -- straight, k4, k4s
E.dodecapole :set_methods {track = track_dodecapole} -- straight, k5, k5s
E.solenoid   :set_methods {track = track_solenoid  } -- straight, ks, ksi
E.rfcavity   :set_methods {track = track_rfcavity  } -- straight, volt, freq!, lag, harmon
E.rfmultipole:set_methods {track = track_rfmcavity } -- straight, volt, freq!, lag, harmon, mult, phas
E.crabcavity :set_methods {track = track_crabcavity} -- straight, volt, freq!, lag, harmon, mult, phas

E.wiggler    :set_methods {track = _nyi         }    -- straight
E.elseparator:set_methods {track = track_eseptum}    -- straight

E.tkicker    :set_methods {track = track_tkicker}    -- straight, hkick, vkick
E.kicker     :set_methods {track = track_kicker }    -- straight, hkick, vkick
E.hkicker    :set_methods {track = track_hkicker}    -- straight,  kick
E.vkicker    :set_methods {track = track_vkicker}    -- straight,  kick

-- thin elements
E.multipole  :set_methods {track = track_multipole}  -- thin
E.beambeam   :set_methods {track = track_bbeam    }  -- thin
E.nllens     :set_methods {track = track_nllens   }  -- thin
E.genmap     :set_methods {track = track_genmap   }  -- straight or curved, damap, update

-- patches
E.xrotation  :set_methods {track = bind3rd(trackone, xrotation)}
E.yrotation  :set_methods {track = bind3rd(trackone, yrotation)}
E.srotation  :set_methods {track = bind3rd(trackone, srotation)}
E.translate  :set_methods {track = bind3rd(trackone, translate)}
E.changeref  :set_methods {track = bind3rd(trackone, changeref)}
E.changedir  :set_methods {track = bind3rd(trackone, changedir)}
E.changenrj  :set_methods {track = bind3rd(trackone, changenrj)}

-- end ------------------------------------------------------------------------o
