--[=[
 o-----------------------------------------------------------------------------o
 |
 | Survey element methods (loaded by survey)
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

--[=[
Notes about directions and quantities:
  element direction   edir: affects curvatures (edir = seq.dir).
  track direction (s) sdir: affects lengths    (sdir = cmd.dir).
  time direction  (t) tdir: affects angles     (tdir = edir x sdir).
  beam direction      bdir: affects strengths  (bdir = edir x sdir x chg).
]=]

-- locals ---------------------------------------------------------------------o

local element                in MAD
local fnil, bind3rd          in MAD.gfunc
local errorf                 in MAD.utility
local minlen, minang         in MAD.constant
local is_implicit            in element.drift
local arc2cord, arc2len      in MAD.gmath
local abs, sin, cos          in math

-- integrator schemes ---------------------------------------------------------o

local thinonly, thickonly, driftonly                             in MAD.symint

-- geometric maps -------------------------------------------------------------o

local strex_thick, curex_thick, curex_thin                       in MAD.geomap

local xrotation, yrotation, srotation, translate,
      changeref, changedir, changenrj, misalign                  in MAD.geomap

-- misalignments --------------------------------------------------------------o

local function get_algn (e, m)
  local al = e.misalign or  m.sequ:align (m.eidx)
  local el = m.misalign and m.sequ:ealign(m.eidx) or nil

  if not (al or el) then return nil end

  local dx, dy, ds, dthe, dphi, dpsi = 0, 0, 0, 0, 0, 0

  if al then -- element abolute/permanent misalignments
    dx, dthe = dx+(al.dx or 0), dthe+(al.dtheta or 0) -- horizontal/azimutal
    dy, dphi = dy+(al.dy or 0), dphi+(al.dphi   or 0) -- vertical/elevation
    ds, dpsi = ds+(al.ds or 0), dpsi+(al.dpsi   or 0) -- longitudinal/roll
  end

  if el then -- element relative/error misalignments
    dx, dthe = dx+(el.dx or 0), dthe+(el.dtheta or 0) -- horizontal/azimutal
    dy, dphi = dy+(el.dy or 0), dphi+(el.dphi   or 0) -- vertical/elevation
    ds, dpsi = ds+(el.ds or 0), dpsi+(el.dpsi   or 0) -- longitudinal/roll
  end

  local trn = abs(dx  )+abs(dy  )+abs(ds  ) >= minlen
  local rot = abs(dthe)+abs(dphi)+abs(dpsi) >= minang

  if not (trn or rot) then return nil end

--local len = m.el + m.ang*dx
--print("***** el=", m.el, "dx=", dx, "ang=", m.ang)

  return {trn=trn, rot=rot, dx=dx, dy=dy, ds=ds, dthe=dthe, dphi=dphi, dpsi=dpsi}
end

-- element tracking -----------------------------------------------------------o

local function trackone (elm, m, inter, thick, thin, fringe)
  local sdir, atentry, atexit in m

  atentry(elm, m,  sdir, -1)
  inter  (elm, m,    1 , thick, thin)
  atexit (elm, m, -sdir, -2)
end

local function trackelm (elm, m, inter, thick, thin, fringe)
  local sdir, atentry, atexit in m
  local algn = get_algn(elm, m)
  local tlt  = elm.tilt*m.tdir
  local mis  = algn and misalign or fnil
  local rot  = abs(tlt) >= minang and srotation or fnil
  local fng  = fringe or fnil
  m.tlt, m.algn = tlt, algn

  atentry(elm, m,  sdir, -1)
  mis    (elm, m,  sdir)
  rot    (tlt, m,  sdir)
  atentry(elm, m,  sdir, -3)
  fng    (elm, m,  sdir)
  inter  (elm, m,    1 , thick, thin)
  fng    (elm, m, -sdir)
  atexit (elm, m, -sdir, -4)
  rot    (tlt, m, -sdir)
  mis    (elm, m, -sdir)
  atexit (elm, m, -sdir, -2)

  m.tlt, m.algn = nil, nil
end

local function tracksub (elm, m, inter, thick, thin, fringe)
  local eidx, sdir, atentry, atexit, __sdat in m
  local algn = get_algn(elm, m)
  local tlt  = elm.tilt*m.tdir
  local mis  = algn and misalign or fnil
  local rot  = abs(tlt) >= minang and srotation or fnil
  local fng  = fringe or fnil
  m.tlt, m.algn, m.eidx = tlt, algn, nil

  if not eidx then
    errorf("invalid subelement survey %s (contain subelements)", elm.name)
  end

  atentry(elm, m, sdir, -1)
  mis    (elm, m, sdir)
  rot    (tlt, m, sdir)
  atentry(elm, m, sdir, -3)
  fng    (elm, m, sdir)

  if sdir > 0 then
    local at, lw = 0
    for i=1,#elm do
      at, lw = elm[i].sat, elm[i].sat - at
      if abs(lw) >= minlen then -- body step
        inter(elm, m, lw, thick, thin)
      end
      __sdat.clw = at
      elm[i]:track(__sdat)
      at = at + elm[i].l/m.el
    end
    lw = 1 - at
    if abs(lw) >= minlen then  -- last body step
      inter(elm, m, lw, thick, thin)
    end

  else -- backtrack
    local at, lw = 1
    for i=#elm,1,-1 do
      at, lw = elm[i].sat, at - elm[i].sat
      if abs(lw) >= minlen then -- body step
        inter(elm, m, lw, thick, thin)
      end
      __sdat.clw = at
      elm[i]:track(__sdat)
      at = at + elm[i].l/m.el
    end
    lw = at
    if abs(lw) >= minlen then -- first body step
      inter(elm, m, lw, thick, thin)
    end
  end

  fng   (elm, m, -sdir)
  atexit(elm, m, -sdir, -4)
  rot   (tlt, m, -sdir)
  mis   (elm, m, -sdir)
  atexit(elm, m, -sdir, -2)

  m.tlt, m.algn, m.eidx = nil, nil, eidx
end

-- kinds ----------------------------------------------------------------------o

local function track_slink (elm, m)
  local update = elm:var_get'update'
  if update then update(elm, m) end -- update damap

  if elm.sequence then
    m:change_si(elm.sequence, elm.range, elm.nturn, elm.dir)
    return "restart_si"
  end
end

local function track_marker (elm, m)
  m.el, m.ang = 0, 0
  trackone(elm, m, thinonly, fnil, fnil)
  m.el, m.ang = nil, nil
end

local function track_drift (elm, m)
  local ds in m
  m.el, m.ang = ds, 0

  if is_implicit(elm) then
    local inter = m.implicit and thickonly or driftonly
    trackone(elm, m, inter, strex_thick, fnil)
  else
    local track = #elm == 0 and trackelm or tracksub
    local inter = abs(ds) >= minlen and thickonly or driftonly
    track(elm, m, inter, strex_thick, fnil)
  end

  m.el, m.ang = nil, nil
end

local function track_thin (elm, m)
  local angle in elm
  m.el, m.ang = 0, angle*m.tdir

  local kick = abs(angle) >= minang and curex_thin or fnil
  trackelm(elm, m, thinonly, fnil, kick)

  m.el, m.ang = nil, nil
end

local function track_thick (elm, m, fng_)
  local ds in m
  local angle in elm
  local no_ang = abs(angle) < minang or fng_
  m.el, m.ang = fng_ and m.el or ds, angle*m.tdir

  local inter, track, thick
  if abs(ds) >= minlen then -- trick: driftonly+thick <=> thinonly+thin
    inter, thick = thickonly, no_ang and strex_thick or curex_thick
  else
    inter, thick = driftonly, no_ang and fnil        or curex_thin
  end

  local track = #elm == 0 and trackelm or tracksub
  track(elm, m, inter, thick, fnil, fng_)

  m.el, m.ang = nil, nil
end

-- rbend special --------------------------------------------------------------o

local function fng_e1 (e, m, s)
  local e1, e2, elc, sdir in m
  local d = s*sdir
  if d == -1 then
    local e_ = {name=e.name, dx=elc*sin((e2-e1)/2), dy=0, ds=0}
    translate(e_, m, -1) -- translation independant of direction
    yrotation(e2, m, -1)
  elseif e1 ~= 0 then
    yrotation(e1, m, -1)
  end
end

local function fng_e2 (e, m, s)
  local e1, e2, elc, sdir in m
  local d = s*sdir
  if d == 1 then
    local e_ = {name=e.name, dx=elc*sin((e2-e1)/2), dy=0, ds=0}
    yrotation(e1, m, -1)
    translate(e_, m, -1) -- translation independant of direction
  elseif e2 ~= 0 then
    yrotation(e2 , m, -1)
  end
end

local fng_e  = \e, m, s -> yrotation(e, m, -0.5)

local function track_rbend (elm, m)
  local fng = nil -- default: curved rbend aka sbend with parallel pole faces

  m.mang = 0

  if elm.true_rbend then
    local e1, e2, angle in elm
    m.elc = arc2cord(m.ds, angle)
    if e1 and e2 then -- MAD-like wedge rbend
      m.el = m.elc
      fng = fng_e
    else              -- true parallel rbend
      if e1 then
        m.e1, m.e2 = e1, angle - e1
        m.el = m.elc * cos(angle/2 - e1)
        fng = fng_e1
      else
        m.e1, m.e2 = angle - e2, e2
        m.el = m.elc * cos(angle/2 - e2)
        fng = fng_e2
      end
    end
  end

  track_thick(elm, m, fng)
  m.e1, m.e2, m.el, m.elc, m.mang = nil, nil, nil, nil, nil
end

-- load maps into elements ----------------------------------------------------o

local E = element

-- special elements
E.marker        :set_methods {survey = track_marker}
E.slink         :set_methods {survey = track_slink }

-- drift elements
E.drift_element :set_methods {survey = track_drift}

-- thick elements
E.thick_element :set_methods {survey = track_thick}
E.rbend         :set_methods {survey = track_rbend}

-- thin elements
E.thin_element  :set_methods {survey = track_thin}

-- patches
E.xrotation     :set_methods {survey = bind3rd(trackone, xrotation)}
E.yrotation     :set_methods {survey = bind3rd(trackone, yrotation)}
E.srotation     :set_methods {survey = bind3rd(trackone, srotation)}
E.translate     :set_methods {survey = bind3rd(trackone, translate)}
E.changeref     :set_methods {survey = bind3rd(trackone, changeref)}
E.changedir     :set_methods {survey = bind3rd(trackone, changedir)}
E.changenrj     :set_methods {survey = bind3rd(trackone, changenrj)}

-- end ------------------------------------------------------------------------o
