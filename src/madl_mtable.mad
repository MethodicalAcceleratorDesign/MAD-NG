--[=[
 o-----------------------------------------------------------------------------o
 |
 | Table module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide MAD table objects (TFS tables)
  - Many features have similar implementation to sequences

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local object, vector, cvector, toboolean, tocomplex, torange, env in MAD
local bind1st, bind2nd, bind2st                                   in MAD.gfunc
local sub, ltrue, lfalse                                          in MAD.operator
local strtrim, strsplit, strbracket, strquote, strsplitall, num2str,
      fprintf, errorf, assertf, openfile, tblicpy, tblcpy, tblcat in MAD.utility
local is_nil, is_boolean, is_number, is_integer, is_complex,
      is_string, is_table, is_rawtable, is_range, isa_matrix,
      is_object, is_iterable, is_callable, set_concept, concept,
      is_file                                                     in MAD.typeid
local not_mappable, not_extendable, not_mutable                   in concept

local abs, min, max, ceil in math

local type = type

-- root object ----------------------------------------------------------------o

local _data = {} -- hidden key

local origin = string.format("MAD %s %s %s", env.version, env.os, env.arch)

local mtable = object 'mtable' {
  title='', type='', origin=origin, kind='mtable',
  header={'title', 'type', 'origin', 'date', 'time', 'refcol'},
  column=nil, refcol=nil, novector=nil, owner=nil, reserve=8,
  [_data]={
    ridx={}, cidx={}, nvec={}, hook={},
    cref=nil, nr=0, nc=0, ng=0, rmax=0,
  },
}

-- backup original methods and metamethods
local mtable_mt = getmetatable(mtable)
local var_raw, var_val, raw_get in mtable
local tbl_cpy, var_set = mtable.copy, mtable_mt.__newindex
local readonly = mtable.set_readonly

local function is_mtable (a)
  return is_object(a) and var_raw(a, _data) ~= nil
end

local function is_owner (a)
  return is_object(a) and raw_get(a, _data) ~= nil
end

local function is_view (a)
  return is_mtable(a) and raw_get(a, _data) == nil
end

-- sanity checks --------------------------------------------------------------o

-- check dictionnary of name -> idx
local function check_index (tbl)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = var_raw(tbl,_data)
  if is_nil(data.cref) then return end
  local cref = data[data.cref]

  -- check dict vs cref: name -> index or table of indexes
  for rn,ri in pairs(data.ridx) do --
    if is_number(ri) then
      assert(cref[ri] == rn     , "unexpected corrupted dictionnary")
    elseif is_table(ri) then
      assert(cref[ri[1]] == rn  , "unexpected corrupted dictionnary")
      assert(ri.n        >= 2   , "unexpected corrupted dictionnary")
      for i=2,ri.n do
        assert(ri[i-1] < ri[i]  , "unexpected corrupted dictionnary")
        assert(cref[ri[i]] == rn, "unexpected corrupted dictionnary")
      end
    else
      error("unexpected corrupted dictionnary")
    end
  end

  -- check cref vs dict: name -> index or table of indexes
  for i=1,data.nr do
    local ri = data.ridx[cref[i]]
    if is_number(ri) then
      assert(ri == i            , "unexpected corrupted dictionnary")
    elseif is_table(ri) then
      local ii
      for j=1,ri.n do
        if ri[j] >= i then ii = ri[j] ; break end
      end
      assert(ii == i            , "unexpected corrupted dictionnary")
    else
      error("unexpected corrupted dictionnary")
    end
  end
end

-- helper for mangled names and row indexes (same as sequence) ----------------o

-- reflect indexes
local function reflect (i, n)
  return i < 0 and n+i+1 or i
end

-- canonize index (direct)
local function index_of_idx (tbl, idx)
  local n = var_raw(tbl,_data).nr
  idx = reflect(idx, n)
  return idx >= 1 and idx <= n and idx or nil
end

-- get index from name [with absolute count] (direct)
local function index_of_cnam (tbl, nam, cnt)
  local ri = var_raw(tbl,_data).ridx[nam]
  if is_table(ri) then
    return ri[ reflect(cnt, ri.n) ]
  elseif cnt == 1 or cnt == -1 then
    return ri
  end
--  return nil
end

-- get index from name [with relative count] (linear)
local function index_of_rnam (tbl, nam, cnt, ref)
  local ri = var_raw(tbl,_data).ridx[nam]
  if is_nil(ri) then return nil end
  assert(is_integer(ref), "invalid reference index (integer expected)")
  local idx = assert(index_of_idx(tbl, ref), "invalid reference index")
  if is_number(ri) then
    return (cnt ==  1 and ri >= idx and ri) or
           (cnt == -1 and ri <= idx and ri) or nil
  end
  if cnt > 0 then
    for i=1,ri.n do
      if ri[i] >= idx then return ri[i+cnt-1] end
    end
  elseif cnt < 0 then
    for i=ri.n,1,-1 do
      if ri[i] <= idx then return ri[i+cnt+1] end
    end
  end
end

-- get index from [mangled] name or s-position (direct or linear)
local function index_of_str (tbl, str, ref_)
  local num = tonumber(str)
  if num then
     assert(is_integer(num), "invalid index (integer expected)")
     return index_of_idx(tbl, num)
  end
  assert(var_raw(tbl,_data).cref, "no reference column found")
  local nam, cnt, _, bra = strbracket(str)
  cnt = is_nil(cnt) and 1 or tonumber(cnt)
  assert(is_integer(cnt) and cnt ~= 0, "invalid argument #2 (non-zero count expected)")
  if is_nil(ref_) or bra == 1 then
    return index_of_cnam(tbl, nam, cnt      )
  else
    return index_of_rnam(tbl, nam, cnt, ref_)
  end
end

-- get [mangled] name from index (linear)
local function name_of_idx (tbl, idx, ref_)
  local data = var_raw(tbl,_data)
  assert(data.cref, "no reference column found")
  idx = index_of_idx(tbl, idx)
  if is_nil(idx) then return nil end
  local nam = data[data.cref][idx]
  local ri  = data.ridx[nam]
  if is_number(ri) then
    assert(ri == idx, "unexpected corrupted dictionnary")
    return nam
  end

  local cnt, b1, b2 = 0
  if ref_ then
    assert(is_integer(ref_), "invalid reference index (integer expected)")
    local idx = assert(index_of_idx(tbl, ref_), "invalid reference index")
    for i=1,ri.n do
      if ri[i] < idx then cnt = cnt+1 else break end
    end
    b1, b2 = "{", "}"
  else
    b1, b2 = "[", "]"
  end

  for i=1,ri.n do
    if ri[i] == idx then
      if cnt >= i then cnt = cnt+1 end
      return string.format("%s%s%d%s", nam, b1, i-cnt, b2)
    end
  end
  error("unexpected corrupted dictionnary")
end

-- dict helpers ---------------------------------------------------------------o

-- shift indexes >= idx by n
local function shf_idx (data, idx, n)
  if is_nil(data.cref) then return end
  for nam,ri in pairs(data.ridx) do
    if is_number(ri) then       -- scalar
      if ri >= idx then data.ridx[nam] = ri+n end
    else for i=1,ri.n do        -- table
      if ri[i] >= idx then ri[i] = ri[i]+n end
    end end
  end
end

-- local function shf_idx (data, idx, n)
--   if is_nil(data.cref) then return end
--   local cref = data[data.cref]
--   for ri=idx,data.nr do
--     local nam = cref[ri]
--     local val = data.ridx[nam]
--     if is_number(val) then       -- scalar
--       data.ridx[nam] = ri+n
--     else for i=1,val.n do        -- table
--       if val[i] >= ri then val[i] = val[i]+n end -- BUG!!
--     end end
--   end
-- end

-- insert to dictionnary name -> idx (warning: indexes are not shifted)
local function ins_idx (data, idx)
  if is_nil(data.cref) then return end
  local nam = data[data.cref][idx]
  local val = data.ridx[nam]
  if is_nil(val) then             -- none: scalar
    data.ridx[nam] = idx
  elseif is_number(val) then      -- one : scalar to array
    data.ridx[nam] = val > idx and {idx, val, n=2} or {val, idx, n=2}
  else                            -- many: insert
    local ii = 1
    for i=val.n,1,-1 do
      if val[i] >= idx then val[i+1] = val[i] else ii = i+1 ; break end
    end
    val[ii], val.n = idx, val.n+1
  end
end

-- remove from dictionnary name -> idx (warning: indexes are not shifted)
local function rem_idx (data, idx)
  if is_nil(data.cref) then return end
  local nam = data[data.cref][idx]
  local val = data.ridx[nam]
  if is_number(val) then          -- one : delete
    data.ridx[nam] = nil
  elseif val.n == 2 then          -- two : array to scalar
    data.ridx[nam] = val[1] == idx and val[2] or val[1]
  else                            -- many: remove
    for i=1,val.n do
      if val[i] >= idx then val[i] = val[i+1] end
    end
    val.n = val.n-1
  end
end

-- add to dictionnary name -> idx (warning: indexes are not shifted)
local function add_idx (data, idx)
  if is_nil(data.cref) then return end
  local nam = data[data.cref][idx]
  local val = data.ridx[nam]
  if is_nil(val) then             -- none: scalar
    data.ridx[nam] = idx
  elseif is_number(val) then      -- one : scalar to array
    data.ridx[nam] = {val, idx, n=2}
  else                            -- many: append
    val[val.n+1], val.n = idx, val.n+1
  end
end

-- build dictionnary name -> idx
local function build_idx (data)        -- must be very fast (see add_idx)
  if is_nil(data.cref) then return end -- no reference column
  table.clear(data.ridx)               -- reuse main storage
  for i=1,data.nr do add_idx(data, i) end
end

-- build mtable ---------------------------------------------------------------o

-- finalize mtable
local function finish_mtbl (tbl)
  -- sanity checks
  if MAD.option.debug >= 2 then
    check_index(tbl)
  end
end

-- mtable initialization
local function mtbl_init (tbl)
  local nc, owner = tbl:raw_len(), raw_get(tbl, 'owner')
  if nc == 0 and not owner then return tbl end -- empty, pure inheritance
  tbl.owner = nil

  local pdat = var_raw(tbl.parent, _data)
  nc = nc + pdat.nc
  local data = table.new(nc, 9)     -- columns (data)
  data.cidx  = table.new(nc,nc+2)   -- name -> idx and idx -> name
  data.ridx  = {}                   -- name -> idx
  data.hook  = {}                   -- columns of hooked vector const views
  data.nvec  = {}                   -- columns that should not be specialized
  data.cref  = pdat.cref            -- refence column for fast row indexing
  data.nr    = 0                    -- #rows
  data.nc    = nc                   -- #cols
  data.ng    = 0                    -- #gens
  data.rmax  = 1                    -- allocated rows (specialize after 1st row)

  -- create columns
  for i=0,nc do data[i] = {} end

  -- process columns names
  tblcpy(pdat.cidx, data.cidx)
  data.cidx.is_selected, data.cidx[0] = 0, 'is_selected' -- case pdat.nc == 0

  local cref = raw_get(tbl, 'refcol')
  for i=pdat.nc+1,nc do
    local col = raw_get(tbl, i-pdat.nc)    -- column key
    if is_table(col) then                  -- cref: { key }
      assert(is_rawtable(col) and is_nil(col[2]), "invalid reference column")
      data.cref, col = i, col[1]
    end
    assert(is_string(col), "invalid column name (string expected)")
    assert(is_nil(data.cidx[col]), "invalid column name (name already in use)")
    data.cidx[col], data.cidx[i] = i, col
  end
  if cref then -- refcol precedence over {name}
    assert(is_string(cref), "invalid reference name (string expected)")
    data.cref = assert(data.cidx[cref], "invalid reference name (not found)")
  end
  tbl.refcol = data.cidx[data.cref]

  -- process non-specilized columns names
  if tbl.novector == true then
    data.nvec = data.cidx
  elseif is_table(tbl.novector) then
    data.nvec = tblcpy(pdat.nvec)
    for _,k in ipairs(tbl.novector) do
      assert(is_number(data.cidx[k]),
                       "invalid column name for non-specialization (not found)")
      data.nvec[k], data.nvec[data.cidx[k]] = data.cidx[k], k
    end
    tbl.novector = tblcat(data.nvec,{}) -- copy only array part
  end

  -- clear list of column names
  tbl:clear_array()
  -- set current date and time
  tbl.date, tbl.time = os.date'%d/%m/%y', os.date'%H:%M:%S'

  -- concat header names and column names to parent ones for I/O
  local hdrnam, colnam = raw_get(tbl, 'header'), raw_get(tbl, 'column')
  if is_table(hdrnam) and #hdrnam > 0 then
    tbl.header = tblcat(hdrnam, tbl.parent.header or {})
  end
  if is_table(colnam) and #colnam > 0 then
    tbl.column = tblcat(colnam, tbl.parent.column or {})
  end

  -- finalized
  tbl[_data] = data
  finish_mtbl(tbl)
  return tbl
end

-- copy mtable ----------------------------------------------------------------o

local function copy (tbl, name_, owner_)
  if is_nil(owner_) and is_boolean(name_) then
    owner_, name_ = name_
  end
  assert(is_mtable(tbl)           , "invalid argument #1 (mtable expected)")
  assert(not rawequal(tbl, mtable), "invalid argument #1 (cannot copy 'mtable')")
  local cpy = tbl_cpy(tbl,name_)
  if is_view(tbl) and not owner_ then return cpy end

  local data = var_raw(tbl,_data)
  local nr, nc = data.nr, data.nc
  local cdat = table.new(nc, 9)      -- see mtbl_init
  cdat.ridx  = table.new(0 ,nr)      -- name -> idx
  cdat.cidx  = table.new(nc,nc+2)    -- name -> idx and idx -> name
  cdat.hook  = {}                    -- columns of hooked vector const views
  cdat.cref  = data.cref             -- reference column (if any)
  cdat.nr    = nr                    -- #rows
  cdat.nc    = nc                    -- #cols
  cdat.ng    = 0                     -- #gens
  cdat.rmax  = nr                    -- allocated rows (no oversize with rmax)

  tblcpy(data.cidx, cdat.cidx)
  cdat.nvec = data.nvec == data.cidx and cdat.cidx or tblcpy(data.nvec)
  for i=0,nc do                      -- copy columns
    local col = data[i]
    cdat[i] = isa_matrix(col) and col:copy() or tblicpy(col, table.new(nr,0))
  end

  cpy[_data] = cdat
  return cpy:build_index()
end

-- mtable metamethods ---------------------------------------------------------o

local _slf, _idx, _col = {}, {}, {} -- hidden keys

-- column generator (RO)
local function gen_iter (s, i)
  i = i+1
  if i <= s[_data].nr then return i, s[_col](i) end
end

local gen_mt = set_concept({
  __len      = \s   -> s[_data].nr,
  __index    = \s,i -> i >= 1 and i <= s[_data].nr and s[_col](i) or nil,
  __ipairs   = \s   -> (gen_iter, s, 0),
  __tostring = \s   -> string.format("mtable column generator: %p", s),
}, not_mappable + not_extendable + not_mutable)

-- readonly column proxy (RO)
local function col_iter (s, i)
  i = i+1
  if i <= s[_data].nr then return i, s[_col][i] end
end

local col_mt = set_concept({
  __len      = \s   -> s[_data].nr,
  __index    = \s,i -> i >= 1 and i <= s[_data].nr and s[_col][i] or nil,
  __ipairs   = \s   -> (col_iter, s, 0),
  __tostring = \s   -> string.format("mtable readonly column: %p", s),
}, not_mappable + not_extendable + not_mutable)

-- reference column proxy (RW)
local ref_mt = set_concept({
  __len      = \s   -> s[_data].nr,
  __index    = \s,i -> i >= 1 and i <= s[_data].nr and s[_col][i] or nil,
  __newindex = \s,i,v => local data = s[_data]
                       assert(not (data.ro or s[_slf]:is_readonly()),
                              "invalid write access to readonly mtable")
                       assert(i >= 1 and i <= data.nr, "row index out of bounds")
                       if not v then
                         error("invalid argument #3 (valid reference key expected)")
                       elseif not rawequal(v, s[_col][i]) then
                         rem_idx(data, i)
                         s[_col][i] = v
                         ins_idx(data, i)
                       end
                     end,
  __ipairs   = \s -> (col_iter, s, 0),
  __tostring = \s -> string.format("mtable reference column: %p", s),
}, not_mappable + not_mutable)

-- row proxy (RW)
local function row_iter (s, i)
  i = i+1
  local col = s[_data][i]
  if col then return i, col[s[_idx]] end
end

local row_mt = set_concept({
  __len      = \s   -> s[_data].nc,
  __index    = \s,i => local data = s[_data]
                       local ci = is_integer(i) and reflect(i, data.nc) or data.cidx[i]
                       if data[ci] then return data[ci][s[_idx]] end
                     end,
  __newindex = \s,i,v => local data = s[_data]
                       assert(not (data.ro or s[_slf]:is_readonly()),
                              "invalid write access to readonly mtable")
                       local ci = is_integer(i) and reflect(i, data.nc) or data.cidx[i]
                       assert(data[ci], "invalid column in row write access")
                       local ri = s[_idx]
                       if ci ~= data.cref then
                         data[ci][ri] = v
                       elseif not v then
                         error("invalid argument #3 (valid reference key expected)")
                       elseif not rawequal(v, data[ci][ri]) then
                         rem_idx(data, ri)
                         data[ci][ri] = v
                         ins_idx(data, ri)
                       end
                     end,
  __ipairs   = \s -> (row_iter, s, 0),
  __tostring = \s -> string.format("mtable row: %p", s),
}, not_mappable+ not_mutable)

-- count proxy
local function cnt_iter (s, i)
  i = i+1
  local ri = s[_idx][i]
  if ri then s[_data][_idx] = ri return i, s[_data] end
end

local cnt_mt = set_concept({
  __len      = \s   -> s[_idx].n,
  __index    = \s,i => local ri = s[_idx][ reflect(i, s[_idx].n) ]
                       if ri then s[_data][_idx] = ri return s[_data] end
                       end,
  __ipairs   = \s   -> (cnt_iter, s, 0),
  __tostring = \s   -> string.format("mtable count: %p", s),
}, not_mappable + not_extendable + not_mutable)

-- number of rows
local function len_mm (tbl)
  return var_raw(tbl,_data).nr
end

-- read access precedence: row index, variable key, column key, row key.
local function index_mm (tbl, key)
  -- row index
  if type(key) == 'number' then                              -- see index_of_idx
    local data = var_raw(tbl,_data)
    key = reflect(key, data.nr)
    if key < 1 or key > data.nr then return nil end
    return setmetatable({[_idx]=key, [_data]=data, [_slf]=tbl}, row_mt)
  end
  -- variable
  local var = var_raw(tbl, key)
  if not is_nil(var) then return var_val(tbl, key, var) end
  -- column name
  local data = var_raw(tbl,_data)
  local ci = data.cidx[key]
  if ci then -- full column
    return (ci ~= data.cref or data.ro) and data[ci] or -- index proxy
           setmetatable({[_col]=data[ci], [_data]=data, [_slf]=tbl}, ref_mt)
  end
  -- row name
  local ri = data.ridx[key]
  if is_number(ri) then
    return setmetatable({[_idx]=ri, [_data]=data, [_slf]=tbl}, row_mt)
  elseif is_table(ri) then
    return setmetatable({[_idx]=ri, [_data]= -- count proxy
           setmetatable({[_idx]=0 , [_data]=data, [_slf]=tbl}, row_mt)}, cnt_mt)
  end
end

local function newindex_mm (tbl, key, val)
  local data = var_raw(tbl,_data)
  -- row index or col/row name
  if is_number(key) or data.cidx[key] or data.ridx[key] then
    error("invalid mtable write access (use 'set' methods)")
  end
  -- variables
  var_set(tbl, key, val)
end

-- readonly protection --------------------------------------------------------o

local function set_readonly (tbl, set_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = raw_get(tbl,_data)
  if data then
    set_ = set_ ~= false and true or false
    if set_ ~= tbl:is_readonly() then
      for i=1,data.nc-data.ng do -- is_selected is never RO
        if set_ then -- protect
          if is_table(data[i])
          then data[i] = setmetatable({[_col]=data[i], [_data]=data}, col_mt)
          else data[i], data.hook[i] = data[i]:constview(), data[i]
          end
        else         -- unprotect
          if is_table(data[i])
          then data[i] = data[i][_col]
          else data[i], data.hook[i] = data.hook[i], nil
          end
        end
      end
      data.ro = set_
    end
  end
  return readonly(tbl, set_)
end

-- row index dict -------------------------------------------------------------o

local function build_index (tbl, key_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = var_raw(tbl,_data)
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")

  if key_ == 'none' then -- 'none' disable index
    data.ridx, data.cref, tbl.refcol = {}
  elseif key_ then       -- change reference column
    local ci = is_integer(key_) and reflect(key_, data.nc) or data.cidx[key_]
    assert(data[ci], "invalid argument #2 (valid column expected)")
    tbl.refcol, data.cref = data.cidx[ci], ci
  end

  build_idx (data)
  finish_mtbl(tbl)
  return tbl
end

-- methods (readonly) ---------------------------------------------------------o

local function name_of (tbl, ri, ref_)
  assert(is_mtable (tbl), "invalid argument #1 (mtable expected)")
  assert(is_integer(ri) , "invalid argument #2 (integer expected)")
  return name_of_idx(tbl, ri, ref_)
end

local function index_of (tbl, a, ref_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
      if is_integer(a) then return index_of_idx(tbl, a)
  elseif is_string (a) then return index_of_str(tbl, a, ref_)
  end
  error("invalid argument #2 (integer or string expected)")
end

local function range_of (tbl, rng_, ref_, dir_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local start, stop, istart, istop
  if is_nil(rng_) then
    local dir = dir_ or 1
        if dir ==  1 then return 1, #tbl
    elseif dir == -1 then return #tbl, 1
    else error("invalid range direction (1 or -1 expected)")
    end
  elseif is_integer(rng_) then
    start, istart = rng_, index_of_idx(tbl, rng_)
    stop , istop  = start, istart
  elseif is_string(rng_) then
    local s1, i2 = strsplit(rng_, "/" )
    local s2 = i2 == 0 and s1 or strtrim(rng_, i2+1)
    start, stop = s1, s2
  elseif is_range(rng_) then
    start, stop = rng_:ranges()
  elseif is_table(rng_) then
    start, stop, ref_ = rng_[1], rng_[2] or rng_[1], ref_ or rng_[3]
  else error "invalid argument #2 (integer, string, table or range expected)"
  end
  if not is_number(rng_) then
    istart = index_of(tbl, start, ref_)
    istop  = index_of(tbl, stop , ref_)
  end
  if not istart then errorf("invalid range start '%s'", tostring(start)) end
  if not istop  then errorf("invalid range stop '%s'" , tostring(stop )) end
  return istart, istop
end

local function length_of (tbl, rng_, ntrn_, dir_) -- see iter
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
    local start, stop = range_of(tbl, rng_, nil, dir_)
  if is_nil(start) then return 0 end
  local dir = dir_ or 1
  local siz, trn = (stop-start)*dir, ntrn_ or 1
  return 1 + siz + #tbl * (trn-1 + (siz < 0 and 1 or 0))
end

-- memory helpers -------------------------------------------------------------o

-- expand vectors, specialize on 1st row unless nvec[col] is set
local function expand (data, tbl, extra)
  local rmax = ceil(max(tbl.reserve, data.rmax*1.5, data.rmax+extra))
  assert(rmax <= 1e8, "too big mtable") -- should see 'out of memory' first
  local nr, nc, cvec = data.nr, data.nc-data.ng

  -- nth expand, expand only vectors
  if data.rmax > 1 then
    for i=1,nc do
      local col = data[i]
      if isa_matrix(col) then
        data[i], data.rmax = col:same(rmax,1):_reshapeto(nr):copy(col), rmax
      end
    end
    return
  end

  -- 1st expand, specialize vectors
  for i=0,nc do
    local col = data[i]
        if is_number (col[1]) and not data.nvec[i] then
      data[i], cvec =  vector(rmax):_reshapeto(1), true
    elseif is_complex(col[1]) and not data.nvec[i] then
      data[i], cvec = cvector(rmax):_reshapeto(1), true
    else
      data[i] = table.new(rmax,0)
    end
    data[i][1] = col[1]
  end
  data.rmax = cvec and rmax or 1e8
end

-- methods (R/W, update dict) -------------------------------------------------o

local function get (tbl, row, col, cnt_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data, ri, ci = var_raw(tbl,_data)

  if is_integer(col)
  then ci = reflect(col, data.nc)
  else ci = data.cidx[col]
  end
  if is_nil(data[ci]) then return nil end

  if is_integer(row)
  then ri = reflect(row, data.nr)
  else ri = data.ridx[row]
    if is_table(ri) then
      local cnt = cnt_ or 1
      assert(is_integer(cnt), "invalid argument #4 (integer expected)")
      ri = ri[ reflect(cnt, ri.n) ]
    end
  end

  return data[ci][ri]
end

local function set (tbl, row, col, val, cnt_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = var_raw(tbl,_data)
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")

  local ci, ri
  if is_integer(col)
  then ci = reflect(col, data.nc)
  else ci = data.cidx[col]
  end
  assert(data[ci], "invalid argument #3 (valid column expected)")

  if is_integer(row) then
    ri = reflect(row, data.nr)
    assert(ri >= 1 and ri <= data.nr, "row index out of bounds")
  else
    ri = assert(data.ridx[row], "invalid argument #2 (valid row expected)")
    if is_table(ri) then
      local cnt = cnt_ or 1
      assert(is_integer(cnt), "invalid argument #5 (number expected)")
      ri = assert(ri[ reflect(cnt, ri.n) ],
                                "invalid argument #2 (valid row[cnt] expected)")
    end
  end

  if ci ~= data.cref then
    data[ci][ri] = val
  elseif not val then
    error("invalid argument #4 (valid reference key expected)")
  elseif not rawequal(val, data[ci][ri]) then
    rem_idx(data, ri)
    data[ci][ri] = val
    ins_idx(data, ri)
  end
end

--- cleaning -------------------------------o

local function clr_dat (tbl)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = var_raw(tbl,_data)
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")
  for i=1,data.nc-data.ng do
    if is_table(data[i])
    then table.clear(data[i])
    else data[i]:zeros():_reshapeto(0)
    end
  end
  data.nr = 0
  return tbl
end

--- columns -------------------------------o

local function get_col (tbl, key)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = var_raw(tbl,_data)
  local ci = is_integer(key) and reflect(key, data.nc) or data.cidx[key]
  if not ci or ci < 0 or ci > data.nc then return nil end
  return (ci ~= data.cref or data.ro) and data[ci] or -- index proxy
          setmetatable({[_col]=data[ci], [_data]=data, [_slf]=tbl}, ref_mt)
end

local function set_col (tbl, key, val)
  local data = var_raw(tbl,_data)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")
  local ci = is_integer(key) and reflect(key, data.nc) or data.cidx[key]
  assert(ci and ci >= 0 and ci <= data.nc, "invalid argument #2 (valid column expected)")
  if rawequal(data[ci],val) then return tbl end
  if ci > data.nc-data.ng then -- generator to use
    assert(is_callable(val), "invalid argument #2 (callable expected)")
    data[ci][_col] = val
  elseif is_callable(val) then  -- generator to call
    for ri=1,data.nr do data[ci][ri] = val(ri) end
  elseif is_iterable(val) then  -- iterable to copy
    for ri=1,data.nr do data[ci][ri] = val[ri] end
  else error("invalid argument #3 (callable or iterable expected)")
  end
  if ci == data.cref then build_idx(data) end
  return tbl
end

local function ins_col (tbl, key_, kval, val, nvec_)
  if is_nil(val) then
    kval, val, key_ = key_, kval -- right shift
  end
  local data = var_raw(tbl,_data)
  assert(is_mtable(tbl) , "invalid argument #1 (mtable expected)")
  assert(is_string(kval), "invalid argument #2 (string expected)")
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")
  assertf(is_nil(data.cidx[kval]), "invalid argument #3 (column name '%s' already in use)", kval)
  local ci = is_nil(key_) and data.nc+1 or
             is_integer(key_) and reflect(key_, data.nc) or data.cidx[key_]
  assert(ci and ci >= 1 and ci <= data.nc+1,
                                "invalid insertion key (valid column expected)")
  local cg = data.nc-data.ng+1
  if is_callable(val) then     -- generator
    if ci < cg then ci = cg end
    table.insert(data, ci, setmetatable({[_col]=val, [_data]=data}, gen_mt) )
    data.ng = data.ng+1
  elseif is_iterable(val) then -- iterable
    if ci > cg then ci = cg end
    if is_number(val[1]) and not nvec_ and data.nvec ~= data.cidx then
      table.insert(data, ci, vector(data.rmax):_reshapeto(data.nr):fill(val))
    elseif is_complex(val[1]) and not nvec_ and data.nvec ~= data.cidx then
      table.insert(data, ci, cvector(data.rmax):_reshapeto(data.nr):fill(val))
    else
      table.insert(data, ci, table.new(data.nr,0))
      for ri=1,data.nr do data[ci][ri] = val[ri] end
    end
    if nvec_ and data.nvec ~= data.cidx then
      data.nvec[kval] = ci
      table.insert(data.nvec, ci, kval)
    end
    if data.cref and ci <= data.cref then data.cref = data.cref+1 end
  else error("invalid argument #4 (callable or iterable expected)")
  end
  data.nc, data.cidx[kval] = data.nc+1, ci
  table.insert(data.cidx, ci, kval)
  for i=ci+1,data.nc do data.cidx[data.cidx[i]] = i end
  return tbl
end

local function add_col (tbl, kval, val, nvec_)
  return ins_col(tbl, nil, kval, val, nvec_)
end

local function rem_col (tbl, key)
  local data = var_raw(tbl,_data)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")
  local ci = is_integer(key) and reflect(key, data.nc) or data.cidx[key]
  assert(ci and ci >= 1 and ci <= data.nc, "invalid argument #2 (valid column expected)")
  if ci > data.nc-data.ng then data.ng = data.ng-1 end
  data.nc, data.cidx[data.cidx[ci]] = data.nc-1, nil
  table.remove(data     , ci)
  table.remove(data.cidx, ci)
  for i=ci,data.nc do data.cidx[data.cidx[i]] = i end
  if data.cref then
        if ci <  data.cref then data.cref = data.cref-1
    elseif ci == data.cref then data.cref, data.ridx = nil, {}
  end end
  return tbl
end

--- rows ----------------------------------o

local function clrrow (data, ri) -- not exposed
  for ci=0,data.nc-data.ng do
    data[ci][ri] = isa_matrix(data[ci]) and 0 or nil
  end
end

local function cpyrow (data, ri, val) -- not exposed
  for ci=1,data.nc-data.ng do
    local v = val[ci]
    if is_nil(v) then v = val[data.cidx[ci]] end
    data[ci][ri] = isa_matrix(data[ci]) and (v or 0) or v
  end
  data[0][ri] = nil
end

local function get_row (tbl, key, ref_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local ri = index_of(tbl, key, ref_)
  if is_nil(ri) then return nil end
  return (setmetatable({[_idx]=ri, [_data]=var_raw(tbl,_data), [_slf]=tbl}, row_mt))
end

local function clr_row (tbl, key, ref_)
  local data = var_raw(tbl, _data)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")
  local ri = assert(index_of(tbl, key, ref_), "invalid argument #2 (valid row expected)")
  local ck = data.cref and data[data.cref][ri] -- backup
  clrrow(data, ri)
  if ck then data[data.cref][ri] = ck end
  return tbl
end

local function set_row (tbl, key, val, ref_)
  local data = var_raw(tbl, _data)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")
  local ri = assert(index_of(tbl, key, ref_), "invalid argument #2 (valid row expected)")
  assert(is_iterable(val), "invalid argument #3 (iterable expected)")
  local ck = data.cref and not rawequal(val[data.cref] or val[data.cidx[data.cref]], data[data.cref][ri])
  if ck then rem_idx(data, ri) end
  for ci=0,data.nc-data.ng do
    local v = val[ci]
    if is_nil(v) then v = val[data.cidx[ci]] end
    if not is_nil(v) then data[ci][ri] = v end -- update if not nil
  end
  if ck then ins_idx(data, ri) end
  return tbl
end

local function add_row (tbl, val)
  local data = var_raw(tbl, _data)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")
  assert(is_iterable(val), "invalid argument #2 (iterable expected)")
  assert(is_nil(data.cref) or val[data.cref] or val[data.cidx[data.cref]],
                                    "invalid argument #3 (nil reference value)")
  local nr = data.nr+1
  if nr > data.rmax then expand(data, tbl, 1) end
  for ci=1,data.nc-data.ng do
    local v = val[ci]
    if is_nil(v) then v = val[data.cidx[ci]] end
    if isa_matrix(data[ci])
    then data[ci]:_reshapeto(nr):seti(nr, v or 0)
    else data[ci][nr] = v
  end end
  data[0][nr] = nil
  add_idx(data, nr) -- add after update
  data.nr = nr
  return tbl
end

local function ins_row (tbl, key, val, ref_)
  local data = var_raw(tbl, _data)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  if key == #tbl+1 then return add_row(tbl, val) end
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")
  local ri = assert(index_of(tbl, key, ref_), "invalid argument #2 (valid row expected)")
  assert(is_iterable(val), "invalid argument #3 (iterable expected)")
  assert(is_nil(data.cref) or val[data.cref] or val[data.cidx[data.cref]],
                                    "invalid argument #3 (nil reference value)")
  local nr = data.nr+1
  if nr > data.rmax then expand(data, tbl, 1) end
  for ci=1,data.nc-data.ng do
    local v = val[ci]
    if is_nil(v) then v = val[data.cidx[ci]] end
    if isa_matrix(data[ci])
    then data[ci]:_reshapeto(nr):shiftv(ri, 1):seti(ri, v or 0)
    else table.insert(data[ci], ri, v)
  end end
  data[0][ri] = nil
  shf_idx(data, ri, 1)
  ins_idx(data, ri) -- insert after update
  data.nr = nr
  return tbl
end

local function rem_row (tbl, key, ref_)
  local data = var_raw(tbl, _data)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")
  local ri = assert(index_of(tbl, key, ref_), "invalid argument #2 (valid row expected)")
  local nr = data.nr,
  rem_idx(data, ri) -- remove before update
  shf_idx(data, ri, -1)
  for ci=0,data.nc-data.ng do
    if isa_matrix(data[ci])
    then data[ci]:shiftv(ri, -1):seti(nr, 0):_reshapeto(nr-1)
    else table.move(data[ci], ri+1, nr, ri)[nr] = nil
  end end
  data.nr = nr-1
  return tbl
end

local function swp_row (tbl, key1, key2, ref1_, ref2_)
  local data = var_raw(tbl, _data)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")
  local ri1 = assert(index_of(tbl, key1, ref1_)         , "invalid argument #2 (valid row expected)")
  local ri2 = assert(index_of(tbl, key2, ref2_ or ref1_), "invalid argument #3 (valid row expected)")
  if ri1 == ri2 then return tbl end
  local swp = data.cref and not rawequal(data[data.cref][ri1], data[data.cref][ri2])
  if swp then rem_idx(data, ri1) ; rem_idx(data, ri2) end -- remove before update
  for ci=0,data.nc-data.ng do
    data[ci][ri1], data[ci][ri2] = data[ci][ri2], data[ci][ri1]
  end
  if swp then ins_idx(data, ri1) ; ins_idx(data, ri2) end -- insert after update
  return tbl
end

-- functional methods ---------------------------------------------------------o

local pknd   = \knd,k,  r,i -> knd[i] == k
local psel   = \sel,b,  r,i -> not not sel[i] == b
local pnam   = \ref,pat,r,i -> string.match(ref[i], pat) ~= nil
local pand   = \p,p2,   r,i -> p(r,i) and p2(r,i)
local ptrue  = \p,_ ,   r,i -> p(r,i) and true
local pfalse = \p,_ ,   r,i -> p(r,i) or false

local function foreach (tbl, act, rng_, sel_, not_) -- action, range, selection, default
  local data = var_raw(tbl, _data)
  local f, p

  -- foreach(sel) -> foreach(sel.action, sel)
  if is_nil(rng_) and is_rawtable(act) then
    f, rng_ = act.action, act     -- extract action + right shift
  else
    f = act
  end
  -- foreach(act,sel) -> foreach(act, sel.range, sel)
  if is_nil(sel_) and is_rawtable(rng_) and is_nil(rng_[1]) then
    rng_, sel_ = rng_.range, rng_ -- extract range + right shift
  end

  if is_rawtable(sel_) then       -- logically and'ed selections
    if is_nil(not_) and (sel_.default == 'none' or sel_.default == true) then
      not_ = true
    end
    local op = not_ ~= true and ptrue or pfalse
    if sel_.select then
      assert(is_callable(sel_.select), "invalid select (callable expected)")
      op, p = pand, bind2st(op, sel_.select, p)
    end
    if sel_.pattern then
      assert(is_string(sel_.pattern), "invalid pattern (string expected)")
      assert(data.cref, "unexpected pattern selection (no reference column)")
      op, p = pand, bind2st(op, bind2st(pnam,data[data.cref], sel_.pattern), p)
    end
    if sel_.kind then
      assert(is_string(sel_.kind), "invalid kind (string expected)")
      assert(data.cidx.kind, "unexpected 'kind' selection (no 'kind' column)")
      op, p = pand, bind2st(op, bind2st(pknd,data[data.cidx.kind], sel_.kind),p)
    end
    if sel_.selected then
      assert(is_boolean(sel_.selected), "invalid selected (boolean expected)")
      op, p = pand, bind2st(op, bind2st(psel, data[0], sel_.selected), p)
    end
  elseif not is_nil(sel_) then    -- build the selection
    p = is_boolean (sel_) and bind2st(psel, data[0], sel_)         or
        is_string  (sel_) and assert(data.cref, "unexpected pattern selection (no reference column)")
                          and bind2st(pnam, data[data.cref], sel_) or
        is_callable(sel_) and sel_                                 or nil
  end
  if is_nil(p) then p = (not_ ~= true or rng_) and ltrue or lfalse end

  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  assert(is_callable(f), "invalid argument #2 (callable expected)")
  assert(is_callable(p), "invalid argument #4 (callable expected)")

  if p ~= lfalse then
    for ri,row in tbl:iter(rng_) do
      if p(row,ri) then f(row,ri) end
    end
  end
  return tbl
end

local do_select = \sel,_,i => sel[i] = true end

local function select (tbl, rng_, sel_, not_)
  local f = bind1st(do_select, var_raw(tbl,_data)[0])
  return tbl:foreach(f, rng_, sel_, not_)
end

local do_deselect = \sel,_,i => sel[i] = nil end

local function deselect (tbl, rng_, sel_, not_)
  local f = bind1st(do_deselect, var_raw(tbl,_data)[0])
  return tbl:foreach(f, rng_, sel_, not_)
end

local do_filter = \ri,_,i => local n=ri.n+1 ; ri[n], ri.n = i, n end

local function filter (tbl, rng_, sel_, not_)
  local ri = table.new(8,1)
  local f = bind1st(do_filter, ri)
  ri.n = 0
  tbl:foreach(f, rng_, sel_, not_)
  local n = ri.n ; ri.n = nil
  return ri, n
end

-- methods (R/W, rebuild dict) ------------------------------------------------o

local function remove (tbl, rng_, sel_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = var_raw(tbl,_data)
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")

  -- collect indexes of elements to remove
  local idx_r, nr
  if is_number(rng_) and is_nil(sel_) and 1 <= rng_ and rng_ <= data.nr+1 then
    idx_r, nr = { rng_ }, 1
    -- if true then tbl:remrow(rng_) return tbl end -- uniformity test
  else
    idx_r, nr = filter(tbl, rng_, sel_, true)
  end
  if nr == 0 then return tbl end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- remove rows by increasing indexes
  local ni, nc = data.nr-nr, data.nc-data.ng
  local i, j, r = idx_r[1], idx_r[1]+1, 2
  while i <= ni do
    if j == idx_r[r] then
      r = r+1
    else
      for ic=0,nc do data[ic][i] = data[ic][j] end
      i = i+1
    end
    j = j+1
  end
  -- clear remaning rows
  for i=ni+1,data.nr do clrrow(data, i) end

  -- reshape vectors and clear tables
  for i=1,nc do
    if isa_matrix(data[i]) then data[i]:_reshapeto(ni) end
  end
  data.nr = ni

  return tbl:build_index()
end

local function insert (tbl, rows, rng_, sel_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = var_raw(tbl,_data)
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")

  -- collect indexes of elements to select
  local idx_r, nr
  if is_number(rng_) and is_nil(sel_) and 1 <= rng_ and rng_ <= data.nr+1 then
    idx_r, nr = { rng_ }, 1
    -- if #rows == 1 then tbl:insrow(rng_, rows[1]) return tbl end -- uniformity test
  else
    -- insert(rows, sel) -> insert(rows, sel.range, sel)
    if is_nil(sel_) and is_rawtable(rng_) and is_nil(rng_[1]) then
      rng_, sel_ = rng_.range, rng_ -- extract range + right shift (see foreach)
    end

    idx_r, nr = filter(tbl, rng_, sel_, true)
    if is_rawtable(sel_) and sel_.where == 'after' then
      for i=1,nr do idx_r[i] = idx_r[i]+1 end
    end
  end
  if nr == 0 then return tbl end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- check for non nil reference keys
  local rsize = #rows
  if data.cref then
    local ki, kr = data.cref, data.cidx[data.cref]
    for ri=1,rsize do
      assert(rows[ri][ki] or rows[ri][kn], "invalid argument #2 (nil reference value)")
    end
  end

  -- process cases: 1x1, 1xR, Nx1, NxR where R=#rows and N=#selected=nr
  local nrs = rsize == 1 and nr    or
              nr    == 1 and rsize or min(nr, rsize)

  -- expand if needed
  if data.nr+nrs > data.rmax then expand(data, tbl, nrs) end

  -- reshape vectors
  data.nr = data.nr+nrs
  local nc = data.nc-data.ng
  for i=1,nc do
    if isa_matrix(data[i]) then data[i]:_reshapeto(data.nr) end
  end

  -- insert rows by decreasing indexes
  local i, j, ni = data.nr, data.nr-nrs, idx_r[1]
  local k = (nrs-1) % rsize + 1
  local r = (nrs-1) % nr    + 1
  while i >= ni do
    if j == idx_r[r]-1 then
      cpyrow(data, i, rows[k])
      k = (k-2) % rsize + 1
      r = (r-2) % nr    + 1
    else
      for ic=0,nc do data[ic][i] = data[ic][j] end
      j = j-1
    end
    i = i-1
  end

  return tbl:build_index()
end

local function sort (tbl, cmp, rng_, sel_)
  assert(is_mtable(tbl)  , "invalid argument #1 (mtable expected)")
  assert(is_callable(cmp), "invalid argument #2 (callable expected)")
  local data = var_raw(tbl,_data)
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")

  -- collect indexes of elements to sort
  local idx_r, nr = filter(tbl, rng_, sel_)
  if nr == 0 then return end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- sort indexes (indirectly)
  local row1  = setmetatable({[_idx]=0, [_data]=data, [_slf]=tbl}, row_mt)
  local row2  = setmetatable({[_idx]=0, [_data]=data, [_slf]=tbl}, row_mt)
  local idx_s = tblicpy(idx_r, table.new(nr,0))
  table.sort(idx_s, \i1,i2 => row1[_idx], row2[_idx] = i1, i2
                              return cmp(row1,row2) end)

  -- build lookup table
  local idx_l = table.new(0,nr)
  for i=1,nr do idx_l[idx_r[i]] = idx_s[i] end

  -- sort rows
  local nc = data.nc-data.ng
  local tmp = table.new(nc+1,0)
  for ii=1,nr do
    local s, r = idx_s[ii], idx_l[idx_s[ii]]
    if s == r then -- identity (cleanup)
      idx_l[s] = nil
    elseif r then  -- not yet processed
      local ts = s
      for i=0,nc do tmp[i] = data[i][s] end
      while r ~= ts do
        for i=0,nc do data[i][s] = data[i][r] end
        s, r, idx_l[s] = r, idx_l[r]
      end
      for i=0,nc do data[i][s] = tmp[i] end
      idx_l[s] = nil
    end
  end
  assert(is_nil(next(idx_l)), "unexpected corrupted lookup indexes (sort)")

  return tbl:build_index()
end

-- special --------------------------------------------------------------------o

local function cycle (tbl, a)
  assert(is_mtable(tbl)  , "invalid argument #1 (mtable expected)")
  assert(index_of(tbl, a), "invalid argument #2 (reference expected)")
  tbl.start_at = a
  return tbl
end

-- iterators ------------------------------------------------------------------o

local function niliter (state, i)
  return nil
end

local function fwditer (state, i)
  if i == state.stop then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end
  i = i < state.nr and i+1 or 1
  state.row[_idx] = i
  return i, state.row
end

local function bwditer (state, i)
  if i == state.stop then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end
  i = i > 1 and i-1 or state.nr
  state.row[_idx] = i
  return i, state.row
end

local function iter (tbl, rng_, ntrn_, dir_)
  local nturn, dir = ntrn_ or 1, dir_ or 1
  assert(is_mtable(tbl)                  ,"invalid argument #1 (mtable expected)")
  assert(is_integer(nturn) and nturn > 0 ,"invalid argument #3 (integer >1 expected)")
  assert(dir == 1 or dir == -1           ,"invalid argument #4 (1 or -1 expected)")

  if #tbl == 0 then return niliter end

  local data, start, stop = var_raw(tbl,_data)
  if is_nil(rng_) then
    local idx1, idxn = 1, data.nr
    if dir < 0 then idx1, idxn = idxn, idx1 end
    if is_nil(tbl.start_at) then
      start, stop = idx1, idxn
    else
      start = assert(index_of(tbl, tbl.start_at), "invalid cycle reference")
      stop  = start == idx1 and idxn or start-dir
    end
  else
    start, stop = range_of(tbl, rng_)
  end
  if start == stop+dir then nturn = nturn+1 end

  local row = setmetatable({[_idx]=0, [_data]=data, [_slf]=tbl}, row_mt)
  return dir > 0 and fwditer or bwditer,
         { row=row, nr=data.nr, stop=stop, turn=nturn-1 }, start-dir
end

-- I/O methods ----------------------------------------------------------------o

local function write (tbl, filnam_, colnam_, hdrnam_, rowsel_)
  if is_rawtable(filnam_) and is_nil(colnam_) then
    local arg = filnam_  -- named arguments
    filnam_, colnam_, hdrnam_, rowsel_ =
      arg.filename or arg.file, arg.column, arg.header, arg.selected
  else -- right shifts
    if is_nil(rowsel_) and (is_table(filnam_) or is_boolean(filnam_)) then
      filnam_, colnam_, hdrnam_, rowsel_ = nil, filnam_, colnam_, hdrnam_
    end
    if is_nil(rowsel_) and is_boolean(colnam_) then
      colnam_, hdrnam_, rowsel_ = nil, colnam_, hdrnam_
    end
    if is_nil(rowsel_) and is_boolean(hdrnam_) then
      hdrnam_, rowsel_ = nil, hdrnam_
    end
  end

  local data = var_raw(tbl,_data)
  local file = openfile(filnam_, 'w', '.tfs')
  local cnam = colnam_ or tbl.column or data.cidx
  local hnam = hdrnam_ or tbl.header
  local nrow = data.nr
  local ncol = #cnam
  local cols = table.new(ncol, 0)

  -- collect column
  for i=1,ncol do
    local ci = is_number(cnam[i]) and reflect(cnam[i], ncol) or data.cidx[cnam[i]]
    cols[i] = assert(data[ci], "invalid column name or index")
    cnam[i] = data.cidx[ci]
  end

  -- dump header
  local v
  for i, k in ipairs(hnam) do
    k, v = hnam[k] or k, tbl[k]
    if is_number(v) then
      fprintf(file, '@ %-18s %%le  %s\n', k, num2str(v))
    elseif is_complex(v) then
      fprintf(file, '@ %-18s %%lz  %s\n', k, tostring(v))
    elseif is_range(v) then
      fprintf(file, '@ %-18s %%lr  %s\n', k, tostring(v))
    elseif is_string(v) then
      if k == 'type' and v == '' then v = tbl.kind end -- to review
      fprintf(file, '@ %-18s %%%02ds  %q\n', k, #v, v)
    elseif is_table(v) then
      fprintf(file, '@ %-18s %%%02dt  %q\n', k, #v, table.concat(v,', '))
    elseif is_boolean(v) then
      fprintf(file, '@ %-18s %%b  %s\n', k, tostring(v))
    else
      fprintf(file, '@ %-18s %%?  %s\n', k, tostring(v))
    end
  end

  if ncol > 0 then
    -- dump col names
    file:write('*')
    for i=1,ncol do
      fprintf(file, i < ncol and ' %-17s ' or ' %s\n', cnam[i])
    end

    -- dump col types
    file:write('$')
    for i=1,ncol do
      v = cols[i][1]
      local s = is_string (v) and '%s'  or
                is_number (v) and '%le' or
                is_complex(v) and '%lz' or
                is_range  (v) and '%lr' or
                is_boolean(v) and '%b'  or '%?'
      fprintf(file, i < ncol and ' %-17s ' or ' %s\n', s)
    end

    -- dump rows
    for j=1,nrow do
      if not rowsel_ or data[0][j] then -- is_selected
        file:write(' ')
        for i=1,ncol do
          v = cols[i][j]
              if is_number(v) then v = num2str(v)
          elseif is_string(v) then v = string.format("%q", v) end
          fprintf(file, i < ncol and ' %-17s ' or ' %s\n', tostring(v))
        end
      end
    end
  end

  if is_string(filnam_) then file:close() else file:flush() end
  return tbl
end

local function print_ (tbl, colnam_, hdrnam_, rowsel_)
  return write(tbl, nil, colnam_, hdrnam_, rowsel_)
end

local function read (tbl, filnam_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local file = openfile(filnam_, 'r', '.tfs')
  local hnam = table.new(8,8)
  local cnam = nil
  local ncol = 0
  local row  = {n=0}
  local ln   = 0

  -- read header
  for line in file:lines() do
    ln = ln+1
    row, ncol = strsplitall(line, " \t", nil, row)
    if row[1] == '@' then
      assertf(ncol == 4, "invalid header format (4 columns expected, line %d)", ln)
      local typ = string.sub(row[3],-1)
      -- types: b, {e, f}, {i, z}, r, s, t, ?
          if typ == 'e' or typ == 'f' then                -- number
        hnam[row[2]] = assertf(tonumber(row[4]),
                        "invalid header format (missing number, line %d)", ln)
      elseif typ == 'i' or typ == 'z' then                -- complex
        hnam[row[2]] = assertf(tocomplex(row[4]),
                        "invalid header format (missing complex, line %d)", ln)
      elseif typ == 'r' then                              -- range
        hnam[row[2]] = assertf(torange(row[4]),
                        "invalid header format (missing range, line %d)", ln)
      elseif typ == 'b' then                              -- boolean
        hnam[row[2]] = toboolean(row[4])
        assertf(hnam[row[2]] ~= nil,
                        "invalid header format (missing boolean, line %d)", ln)
      elseif typ == 's' then                              -- string
        hnam[row[2]] = strquote(row[4])
        if #hnam[row[2]] ~= tonumber(string.sub(row[3],2,-2)) then
          errorf("invalid header format (unmatched string length, line %d)", ln)
        end
      elseif typ == 't' then                              -- table
        local res, n = strsplitall(strquote(row[4]), ",")
        if n ~= tonumber(string.sub(row[3],2,-2)) then
          errorf("invalid header format (unmatched table length, line %d)", ln)
        end
        for i=1,n do
          local r = tonumber(res[i]) or toboolean(res[i])
          if is_nil(r) then r = strquote(res[i]) end
          res[i] = r
        end
        hnam[row[2]] = res
      elseif typ == '?' then                             -- unkownn
        hnam[row[2]] = row[4] ~= 'nil' and row[4] or nil
      else                                               -- invalid
        error("invalid header field type: '"..typ.."'")
      end
      hnam[#hnam+1] = row[2]
    elseif row[1] == '*' then -- col names
      cnam, row.n = table.new(ncol-1,0), ncol-1
      for i=1,ncol-1 do cnam[i] = row[i+1] end
    elseif row[1] == '$' then -- col types (discarded, optionnal)
      break
    end
  end

  -- to review: require some factory?
  assert(hnam.type == tbl.type or tbl.type == '' and hnam.type == tbl.kind,
         "invalid parent table (kinds differ)")

  -- create table from header
  for i,v in ipairs(hnam) do
    cnam[v], hnam[v] = hnam[v], nil
  end
  tbl = tbl(hnam.name, cnam) -- inherit from tbl
  tbl.header = hnam

  -- read and add rows
  for line in file:lines() do
    ln = ln+1
    row, ncol = strsplitall(line, " \t", nil, row)
    if row.n ~= ncol then
      errorf("invalid row format (%d missing columns, line %d)", row.n-ncol, ln)
    end
    for i=1,ncol do -- convert to number or to boolean or remove quotes (if any)
      local r = tonumber(row[i]) or tocomplex(row[i]) or
                torange (row[i]) or toboolean(row[i])
      if is_nil(r) and row[i] ~= 'nil' then r = strquote(row[i]) end
      row[i] = r
    end
    tbl:addrow(row)
  end

  -- build index with column 'name' (if any)
  local cref = raw_get(tbl, 'refcol')
  if cref then tbl:build_index(cref) end

  if is_string(filnam_) then file:close() end
  return tbl
end

-- members --------------------------------------------------------------------o

mtable :set_methods {
  -- nrow, ncol, ngen
  nrow         = len_mm,
  ncol         = \s -> var_raw(s, _data).nc,
  ngen         = \s -> var_raw(s, _data).ng,

  -- cells manipulation
  get          = get,
  set          = set,

  -- columns manipulation
  getcol       = get_col,
  addcol       = add_col,
  setcol       = set_col,
  remcol       = rem_col,
  inscol       = ins_col,

  -- rows manipulation
  getrow       = get_row,
  addrow       = add_row,
  setrow       = set_row,
  clrrow       = clr_row,
  remrow       = rem_row,
  insrow       = ins_row,
  swprow       = swp_row,

  -- clear all data, keep everything else
  clrdat       = clr_dat,

  -- sequence-like methods
  name_of      = name_of,
  index_of     = index_of,
  range_of     = range_of,
  length_of    = length_of,

  foreach      = foreach,
  select       = select,
  deselect     = deselect,
  filter       = filter,

  copy         = copy,
  sort         = sort,
  insert       = insert,
  remove       = remove,
--replace      = replace, ??

  cycle        = cycle,
  iter         = iter,

  -- read/write
  read         = read,
  write        = write,
  print        = print_,

  -- readonly
  set_readonly = set_readonly,

  -- ownership
  is_owner     = is_owner,
  is_view      = is_view,

  -- index dict
  build_index  = build_index,
  check_index  = check_index,

  -- disabled method
  is_selected := error("invalid mtable operation", 2),

} :set_metamethods ({
  __add        = add_row,
  __len        = len_mm,
  __index      = index_mm,
  __newindex   = newindex_mm,
-- __pairs     = pairs_mm , default from object
-- __ipairs    = ipairs_mm, default from object
  __copy       = copy,
  __init       = mtbl_init,

}, true) :set_readonly()

-- env ------------------------------------------------------------------------o

MAD.typeid.is_mtable = is_mtable

-- end ------------------------------------------------------------------------o
return { mtable = mtable }

--[[ 'High level table access is very slow!
code A:
t0=os.clock()
do
  local a, t = 0, MAD.mtable 'mytable' { {'name'}, 'x', 'y', 'z' }
  t=t+{'A', 1.1,1.2,1.3}+{'B', 2.1,2.2,2.3}+{'A', 3.1,3.2,3.3}
  for i=1,1e7 do a=a+t.B.x end -- t:get('A','x',2) end
  print('a=',a)
end
print('time=',os.clock()-t0)
time= 1.14

code B:
t0=os.clock()
do
  local a, t = 0, MAD.mtable 'mytable' { {'name'}, 'x', 'y', 'z' }
  t=t+{'A', 1.1,1.2,1.3}+{'B', 2.1,2.2,2.3}+{'A', 3.1,3.2,3.3}
  for i=1,1e7 do a=a+t.x[2] end
  print('a=',a)
end
print('time=',os.clock()-t0)
time= 1.14

Output code A:
building dict:  1
a=  21000000.000896
time= 1.14
changing t.B.x by t[2].x
time= 1.14
changing t.B.x by t.x[2]
time= 0.012
]]
