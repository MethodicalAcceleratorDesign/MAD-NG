--[=[
 o-----------------------------------------------------------------------------o
 |
 | Table module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide MAD table objects (TFS tables)
  - Many features have similar implementation to sequences

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local object, vector, cvector, toboolean, tocomplex, torange, option, env in MAD

local round                                                       in MAD.gmath
local bind1st, bind2nd, bind2st                                   in MAD.gfunc
local sub, ltrue, lfalse                                          in MAD.gfunc
local strtrim, strsplit, strbracket, strquote, strsplitall,
      num2str, str2cmp, fprintf, errorf, assertf, openfile,
      tblicpy, tblcpy, tblcat, lst2tbl                            in MAD.utility
local is_nil, is_boolean, is_number, is_integer, is_complex,
      is_string, is_table, is_rawtable, is_range, isa_matrix,
      is_object, is_element, is_file, set_concept, concept,
      is_iterable, is_mappable, is_callable,
      is_cdata, is_vector, is_cvector                             in MAD.typeid
local not_mappable, not_extendable, not_mutable                   in concept

local abs, min, max, ceil, floor in math

local type, getmetatable, setmetatable, assert, error, rawequal =
      type, getmetatable, setmetatable, assert, error, rawequal

local ipairs, pairs, tostring, tonumber =
      ipairs, pairs, tostring, tonumber

local string, table, io =
      string, table, io

-- root object ----------------------------------------------------------------o

--[[
TODO:
  + avoid destruction of column specs, e.g. should not be in object plain array.
  + optimise speed of proxies (closures)
--]]

local origin = string.format("MAD %s %s %s", env.version, env.os, env.arch)

local mtable = object 'mtable' {
    type='user', title='no-title', origin=origin, date=nil, time=nil,
    header={'name', 'type', 'title', 'origin', 'date', 'time', 'refcol'},-- default header
    column=nil, refcol=nil, novector=nil, owner=nil, reserve=8,
    __dat={ridx={}, cidx={}, nvec={}, hook={},
           cref=nil, nr=0, nc=0, ng=0, rmax=0,},
  }

-- backup original methods and metamethods
local mtable_mt = getmetatable(mtable)
local var_get, var_val, raw_get in mtable
local tbl_cpy, var_set = mtable.copy, mtable_mt.__newindex
local readonly = mtable.set_readonly

-- identity -------------------------------------------------------------------o

local _id = {} -- identity

local function is_mtable (a)
  local mt = getmetatable(a)
  return mt ~= nil and mt.__mtbl == _id
end

local function is_view (a)
  return raw_get(a, '__dat') == nil
end

-- sanity checks --------------------------------------------------------------o

-- check dictionnary of name -> idx
local function check_mtbl (tbl)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = tbl.__dat
  if is_nil(data.cref) then return end
  local cref = data[data.cref]

  -- check dict vs cref: name -> index or table of indexes
  for rn,ri in pairs(data.ridx) do --
    if is_number(ri) then
      assert(cref[ri] == rn     , "unexpected corrupted dictionnary")
    elseif is_table(ri) then
      assert(cref[ri[1]] == rn  , "unexpected corrupted dictionnary")
      assert(ri.n        >= 2   , "unexpected corrupted dictionnary")
      for i=2,ri.n do
        assert(ri[i-1] < ri[i]  , "unexpected corrupted dictionnary")
        assert(cref[ri[i]] == rn, "unexpected corrupted dictionnary")
      end
    else
      error("unexpected corrupted dictionnary")
    end
  end

  -- check cref vs dict: name -> index or table of indexes
  for i=1,data.nr do
    local ri = data.ridx[cref[i]]
    if is_number(ri) then
      assert(ri == i            , "unexpected corrupted dictionnary")
    elseif is_table(ri) then
      local ii
      for j=1,ri.n do
        if ri[j] >= i then ii = ri[j] ; break end
      end
      assert(ii == i            , "unexpected corrupted dictionnary")
    else
      error("unexpected corrupted dictionnary")
    end
  end
end

-- helper for mangled names and row indexes (same as sequence) ----------------o

-- reflect indexes
local function ireflect (i, n)
  return i < 0 and n+i+1 or i
end

-- canonize index (direct)
local function index_of_idx (tbl, idx)
  local n = tbl.__dat.nr
  idx = ireflect(idx, n)
  return idx >= 1 and idx <= n and idx or nil
end

local index_of_fnam -- forward declaration

-- get index of ref (direct)
local function index_of_ref (tbl, ref)
  local msg, idx = "invalid reference index (name or index expected)"
  if is_string(ref) then
    idx, msg = index_of_fnam(tbl, ref), "invalid reference name '%s'"
  elseif is_integer(ref) then
    idx, msg = index_of_idx (tbl, ref), "invalid reference index %d"
  end
  return assertf(idx, msg, ref)
end

-- get index from name [with absolute count] (direct)
local function index_of_cnam (tbl, nam, cnt)
  local ri = tbl.__dat.ridx[nam]
  if is_table(ri) then
    return ri[ ireflect(cnt, ri.n) ]
  elseif cnt == 1 or cnt == -1 then
    return ri
  end
end

-- get index from name [with relative count] (linear)
local function index_of_rnam (tbl, nam, cnt, ref)
  local ri = tbl.__dat.ridx[nam]
  if is_nil(ri) then return nil end
  local idx = index_of_ref(tbl, ref)
  if is_number(ri) then
    return (cnt ==  1 and ri >= idx and ri) or
           (cnt == -1 and ri <= idx and ri) or nil
  end
  if cnt > 0 then
    for i=1,ri.n do
      if ri[i] >= idx then return ri[i+cnt-1] end
    end
  elseif cnt < 0 then
    for i=ri.n,1,-1 do
      if ri[i] <= idx then return ri[i+cnt+1] end
    end
  end
end

-- get index from row position (direct)
local function index_of_num (tbl, num, ref_, dir_)
  if ref_ then return num + index_of_ref(tbl, ref_) end
  local num = index_of_idx(tbl, num)
  if not num then return nil end
  local idx, dir = num, dir_ or 0
  if not is_integer(idx) then
        if dir ==  0 then idx = round(idx)
    elseif dir ==  1 then idx = ceil (idx)
    elseif dir == -1 then idx = floor(idx)
    else error("invalid direction (0, 1 or -1 expected)")
    end
  end
  return idx, num
end

-- get index from [mangled] name or s-position (direct or linear)
local function index_of_str (tbl, str, ref_, dir_)
  local num = tonumber(str)
  if num then return index_of_num(tbl, num, ref_, dir_) end
  assert(tbl.__dat.cref, "no reference column found")
  local nam, cnt, _, bra = strbracket(str)
  cnt = is_nil(cnt) and 1 or tonumber(cnt)
  assert(is_integer(cnt) and cnt ~= 0, "invalid argument #2 (non-zero count expected)")
  if is_nil(ref_) or bra == 1 then
    return index_of_cnam(tbl, nam, cnt      )
  else
    return index_of_rnam(tbl, nam, cnt, ref_)
  end
end

-- get index from 'ref' [mangled] name (direct or linear)
function index_of_fnam (tbl, nam, ref_) -- already declared local
  assert(is_string(nam), "invalid argument #2 (string expected)")
  assert(tbl.__dat.cref, "no reference column found")
  local nam, cnt, _, bra = strbracket(nam)
  cnt = is_nil(cnt) and 1 or tonumber(cnt)
  assert(is_integer(cnt) and cnt ~= 0, "invalid argument #2 (non-zero count expected)")
  if is_nil(ref_) or bra ~= 2 then -- need both for relative from
    return index_of_cnam(tbl, nam, cnt      ), bra
  else
    return index_of_rnam(tbl, nam, cnt, ref_), bra
  end
end

-- get index from element (linear) from sequence                              -- untested.
local function index_of_elm (tbl, elm, ref_, dir_)
  local nam, data, seq = elm.name, tbl.__dat, tbl.__seq
  assert(seq, "no sequence attached found")
  assert(data.cidx.eidx, "no element index column found")
  assert(data.cref , "no reference column found")
  local ei, eidx = data.ridx[nam], data.cidx.eidx
  if is_nil(ei) then return nil end
  local idx = ref_ and index_of_ref(tbl, ref_) or 1
  if is_number(ei) then
    return ei >= idx and seq[eidx[ei]] == elm and ei or nil
  end
  local dir = dir_ or 1
  assert(dir == 1 or dir == -1, "invalid direction (1 or -1 expected)")
  if dir == 1 then
    for i=1,ei.n do
      if ei[i] >= idx and seq[eidx[ei]] == elm then return ei[i] end
    end
  else
    for i=ei.n,1,-1 do
      if ei[i] <= idx and seq[eidx[ei]] == elm then return ei[i] end
    end
  end
end

-- get [mangled] name from index (linear)
local function name_of_idx (tbl, idx, ref_)
  local data = tbl.__dat
  assert(data.cref, "no reference column found")
  idx = index_of_idx(tbl, idx)
  if is_nil(idx) then return nil end
  local nam = data[data.cref][idx]
  local ri  = data.ridx[nam]
  if is_number(ri) then
    assert(ri == idx, "unexpected corrupted dictionnary")
    return tostring(nam)
  end

  local cnt, b1, b2 = 0
  if ref_ then
    local idx = index_of_ref(tbl, ref_)
    for i=1,ri.n do
      if ri[i] < idx then cnt = cnt+1 else break end
    end
    b1, b2 = "{", "}"
  else
    b1, b2 = "[", "]"
  end

  for i=1,ri.n do
    if ri[i] == idx then
      if cnt >= i then cnt = cnt+1 end
      return string.format("%s%s%d%s", tostring(nam), b1, i-cnt, b2)
    end
  end
  error("unexpected corrupted dictionnary")
end

-- dict helpers ---------------------------------------------------------------o

-- shift indexes >= idx by n
local function shf_idx (data, idx, n)
  if is_nil(data.cref) then return end
  for nam,ri in pairs(data.ridx) do
    if is_number(ri) then       -- scalar
      if ri >= idx then data.ridx[nam] = ri+n end
    else for i=1,ri.n do        -- table
      if ri[i] >= idx then ri[i] = ri[i]+n end
    end end
  end
end

-- local function shf_idx (data, idx, n)
--   if is_nil(data.cref) then return end
--   local cref = data[data.cref]
--   for ri=idx,data.nr do
--     local nam = cref[ri]
--     local val = data.ridx[nam]
--     if is_number(val) then       -- scalar
--       data.ridx[nam] = ri+n
--     else for i=1,val.n do        -- table
--       if val[i] >= ri then val[i] = val[i]+n end -- BUG!!
--     end end
--   end
-- end

-- insert to dictionnary name -> idx (warning: indexes are not shifted)
local function ins_idx (data, idx)
  if is_nil(data.cref) then return end
  local nam = data[data.cref][idx]
  local val = data.ridx[nam]
  if is_nil(val) then             -- none: scalar
    data.ridx[nam] = idx
  elseif is_number(val) then      -- one : scalar to array
    data.ridx[nam] = val > idx and {idx, val, n=2} or {val, idx, n=2}
  else                            -- many: insert
    local ii = 1
    for i=val.n,1,-1 do
      if val[i] >= idx then val[i+1] = val[i] else ii = i+1 ; break end
    end
    val[ii], val.n = idx, val.n+1
  end
end

-- remove from dictionnary name -> idx (warning: indexes are not shifted)
local function rem_idx (data, idx)
  if is_nil(data.cref) then return end
  local nam = data[data.cref][idx]
  local val = data.ridx[nam]
  if is_number(val) then          -- one : delete
    data.ridx[nam] = nil
  elseif val.n == 2 then          -- two : array to scalar
    data.ridx[nam] = val[1] == idx and val[2] or val[1]
  else                            -- many: remove
    for i=1,val.n do
      if val[i] >= idx then val[i] = val[i+1] end
    end
    val.n = val.n-1
  end
end

-- add to dictionnary name -> idx (warning: indexes are not shifted)
local function add_idx (data, idx)
  if is_nil(data.cref) then return end
  local nam = data[data.cref][idx]
  local val = data.ridx[nam]
  if is_nil(val) then             -- none: scalar
    data.ridx[nam] = idx
  elseif is_number(val) then      -- one : scalar to array
    data.ridx[nam] = {val, idx, n=2}
  else                            -- many: append
    val[val.n+1], val.n = idx, val.n+1
  end
end

-- build dictionnary name -> idx
local function build_idx (data)        -- must be very fast (see add_idx)
  if is_nil(data.cref) then return end -- no reference column
  table.clear(data.ridx)               -- reuse main storage
  for i=1,data.nr do add_idx(data, i) end
end

-- build mtable ---------------------------------------------------------------o

-- finalize mtable
local function finish_mtbl (tbl)
  -- clear cycle (if any)
  tbl:raw_set('__cycle', nil)

  -- sanity checks
  if option.debug > 2 then check_mtbl(tbl) end
end

-- mtable initialization
local function init_mm (tbl)
  local nc, owner = tbl:raw_len(), raw_get(tbl, 'owner')
  if nc == 0 and owner ~= true then return tbl end -- view
  -- tbl.owner = nil

  local pdat = tbl.parent.__dat
  nc = nc + pdat.nc
  local data = table.new(nc, 9)     -- columns (data)
  data.cidx  = table.new(nc,nc+2)   -- name -> idx and idx -> name
  data.ridx  = {}                   -- name -> idx
  data.hook  = {}                   -- columns of hooked vector const views
  data.nvec  = {}                   -- columns that should not be specialized
  data.cref  = pdat.cref            -- refence column for fast row indexing
  data.nr    = 0                    -- #rows
  data.nc    = nc                   -- #cols
  data.ng    = 0                    -- #gens
  data.rmax  = 1                    -- allocated rows (specialize after 1st row)

  -- create columns
  for i=0,nc do data[i] = {} end

  -- process columns names
  tblcpy(pdat.cidx, data.cidx)
  data.cidx.is_selected, data.cidx[0] = 0, 'is_selected' -- case pdat.nc == 0

  local cref = raw_get(tbl, 'refcol')
  for i=pdat.nc+1,nc do
    local col = raw_get(tbl, i-pdat.nc)    -- column key
    if is_table(col) then                  -- cref: { key }
      assert(is_rawtable(col) and is_nil(col[2]), "invalid reference column")
      data.cref, col = i, col[1]
    end
    assert(is_string(col), "invalid column name (string expected)")
    assert(is_nil(data.cidx[col]), "invalid column name (name already in use)")
    data.cidx[col], data.cidx[i] = i, col
  end
  if cref then -- refcol precedence over {name}
    assert(is_string(cref), "invalid reference name (string expected)")
    data.cref = assert(data.cidx[cref], "invalid reference name (not found)")
  end
  tbl.refcol = data.cidx[data.cref]

  -- process non-specilized columns names
  if tbl.novector == true then
    data.nvec = data.cidx
  elseif is_table(tbl.novector) then
    data.nvec = tblcpy(pdat.nvec)
    for _,k in ipairs(tbl.novector) do
      assert(is_number(data.cidx[k]),
                       "invalid column name for non-specialization (not found)")
      data.nvec[k], data.nvec[data.cidx[k]] = data.cidx[k], k
    end
    tbl.novector = tblcat(data.nvec,{}) -- copy only array part
  end

  -- clear list of column names
  tbl:clear_array()
  -- set current date and time
  tbl.date, tbl.time = os.date'%d/%m/%y', os.date'%H:%M:%S'

  -- concat header names and column names to parent ones for I/O
  local hdrnam, colnam = raw_get(tbl, 'header'), raw_get(tbl, 'column')
  if is_table(hdrnam) and #hdrnam > 0 then
    tbl.header = tblcat(tbl.parent.header or {}, hdrnam)
  end
  if is_table(colnam) and #colnam > 0 then
    tbl.column = tblcat(tbl.parent.column or {}, colnam)
  end

  -- finalized
  tbl.__dat = data
  finish_mtbl(tbl)
  return tbl
end

-- copy mtable ----------------------------------------------------------------o

local function copy_mm (tbl, name_, owner_)
  if is_nil(owner_) and is_boolean(name_) then
    owner_, name_ = name_
  end
  assert(is_mtable(tbl)           , "invalid argument #1 (mtable expected)")
  assert(not rawequal(tbl, mtable), "invalid argument #1 (cannot copy 'mtable')")
  local cpy = tbl_cpy(tbl,name_)
  if is_view(tbl) and owner_ ~= true then return cpy end

  local data = tbl.__dat
  local nr, nc = data.nr, data.nc
  local cdat = table.new(nc, 9)      -- see init_mm
  cdat.ridx  = table.new(0 ,nr)      -- name -> idx
  cdat.cidx  = table.new(nc,nc+2)    -- name -> idx and idx -> name
  cdat.hook  = {}                    -- columns of hooked vector const views
  cdat.cref  = data.cref             -- reference column (if any)
  cdat.nr    = nr                    -- #rows
  cdat.nc    = nc                    -- #cols
  cdat.ng    = 0                     -- #gens
  cdat.rmax  = nr                    -- allocated rows (no oversize with rmax)

  tblcpy(data.cidx, cdat.cidx)
  cdat.nvec = data.nvec == data.cidx and cdat.cidx or tblcpy(data.nvec)
  for i=0,nc do                      -- copy columns
    local col = data[i]
    cdat[i] = isa_matrix(col) and col:copy() or tblicpy(col, table.new(nr,0))
  end

  cpy.__dat = cdat
  return cpy:make_dict()
end

-- mtable metamethods ---------------------------------------------------------o

-- column generator (RO)
local function gen_iter (s, i)
  i = i+1
  if i <= s.__dat.nr then return i, s.__col(i,s.__slf) end
end

local gen_mt = set_concept({
  __len      = \s   -> s.__dat.nr,
  __index    = \s,i -> i >= 1 and i <= s.__dat.nr and s.__col(i,s.__slf) or nil,
  __ipairs   = \s   -> (gen_iter, s, 0),
  __tostring = \s   -> string.format("mtable column generator: %p", s),
}, not_mappable + not_extendable + not_mutable)

-- readonly column proxy (RO)
local function col_iter (s, i)
  i = i+1
  if i <= s.__dat.nr then return i, s.__col[i] end
end

local col_mt = set_concept({
  __len      = \s   -> s.__dat.nr,
  __index    = \s,i -> i >= 1 and i <= s.__dat.nr and s.__col[i] or nil,
  __ipairs   = \s   -> (col_iter, s, 0),
  __tostring = \s   -> string.format("mtable readonly column: %p", s),
}, not_mappable + not_extendable + not_mutable)

-- reference column proxy (RW)
local ref_mt = set_concept({
  __len      = \s   -> s.__dat.nr,
  __index    = \s,i -> i >= 1 and i <= s.__dat.nr and s.__col[i] or nil,
  __newindex = \s,i,v => local data = s.__dat
                       assert(not (data.ro or s.__slf:is_readonly()),
                              "invalid write access to readonly mtable")
                       assert(i >= 1 and i <= data.nr, "row index out of bounds")
                       if not v then
                         error("invalid argument #3 (valid reference key expected)")
                       elseif not rawequal(v, s.__col[i]) then
                         rem_idx(data, i)
                         s.__col[i] = v
                         ins_idx(data, i)
                       end
                     end,
  __ipairs   = \s -> (col_iter, s, 0),
  __tostring = \s -> string.format("mtable reference column: %p", s),
}, not_mappable + not_mutable)

-- row proxy (RW)
local function row_iter (s, i)
  i = i+1
  local col = s.__dat[i]
  if col then return i, col[s.__idx] end
end

local row_mt = set_concept({
  __len      = \s   -> s.__dat.nc,
  __index    = \s,i => local data = s.__dat
                       local ci = is_integer(i) and ireflect(i, data.nc) or data.cidx[i]
                       if data[ci] then return data[ci][s.__idx] end
                     end,
  __newindex = \s,i,v => local data = s.__dat
                       assert(not (data.ro or s.__slf:is_readonly()),
                              "invalid write access to readonly mtable")
                       local ci = is_integer(i) and ireflect(i, data.nc) or data.cidx[i]
                       assert(data[ci], "invalid column in row write access")
                       local ri = s.__idx
                       if ci ~= data.cref then
                         data[ci][ri] = v
                       elseif not v then
                         error("invalid argument #3 (valid reference key expected)")
                       elseif not rawequal(v, data[ci][ri]) then
                         rem_idx(data, ri)
                         data[ci][ri] = v
                         ins_idx(data, ri)
                       end
                     end,
  __ipairs   = \s -> (row_iter, s, 0),
  __tostring = \s -> string.format("mtable row: %p", s),
}, not_mappable+ not_mutable)

-- count proxy
local function cnt_iter (s, i)
  i = i+1
  local ri = s.__idx[i]
  if ri then s.__dat.__idx = ri return i, s.__dat end
end

local cnt_mt = set_concept({
  __len      = \s   -> s.__idx.n,
  __index    = \s,i => local ri = s.__idx[ ireflect(i, s.__idx.n) ]
                       if ri then s.__dat.__idx = ri return s.__dat end
                       end,
  __ipairs   = \s   -> (cnt_iter, s, 0),
  __tostring = \s   -> string.format("mtable count: %p", s),
}, not_mappable + not_extendable + not_mutable)

-- number of rows
local function len_mm (tbl)
  return tbl.__dat.nr
end

-- read access precedence: row index, variable key, column key, row key.
local function index_mm (tbl, key)
  -- row index
  if type(key) == 'number' then                              -- see index_of_idx
    local data = tbl.__dat
    key = ireflect(key, data.nr)
    if key < 1 or key > data.nr then return nil end
    return setmetatable({__idx=key, __dat=data, __slf=tbl}, row_mt)
  end
  -- variable (or method)
  local var = var_get(tbl, key)
  if type(var) ~= 'nil' then
    return var_val(tbl, key, var)
  end
  -- column name
  local data = tbl.__dat
  local ci = data.cidx[key]
  if ci then -- full column
    return (ci ~= data.cref or data.ro) and data[ci] or -- index proxy
           setmetatable({__col=data[ci], __dat=data, __slf=tbl}, ref_mt)
  end
  -- row name
  local ri = data.ridx[key]
  if is_number(ri) then
    return setmetatable({__idx=ri, __dat=data, __slf=tbl}, row_mt)
  elseif is_table(ri) then
    return setmetatable({__idx=ri, __dat= -- count proxy
           setmetatable({__idx=0 , __dat=data, __slf=tbl}, row_mt)}, cnt_mt)
  end
end

local function newindex_mm (tbl, key, val)
  local data = tbl.__dat
  -- row index or col/row name
  if is_number(key) or data.cidx[key] or data.ridx[key] then
    error("invalid mtable write access (use 'set' methods)")
  end
  -- variables
  var_set(tbl, key, val)
end

-- readonly protection --------------------------------------------------------o

local function set_readonly (tbl, set_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = raw_get(tbl,'__dat')
  if data then
    set_ = set_ ~= false and true or false
    if set_ ~= tbl:is_readonly() then
      for i=1,data.nc-data.ng do -- is_selected is never RO
        if set_ then -- protect
          if is_table(data[i])
          then data[i] = setmetatable({__col=data[i], __dat=data, __slf=tbl}, col_mt)
          else data[i], data.hook[i] = data[i]:constview(), data[i]
          end
        else         -- unprotect
          if is_table(data[i])
          then data[i] = data[i].__col
          else data[i], data.hook[i] = data.hook[i], nil
          end
        end
      end
      data.ro = set_
    end
  end
  return readonly(tbl, set_)
end

-- row index dict -------------------------------------------------------------o

local function build_index (tbl, key_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = tbl.__dat
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")

  if key_ == 'none' then -- 'none' disable index
    data.ridx, data.cref, tbl.refcol = {}
  elseif key_ then       -- change reference column
    local ci = is_integer(key_) and ireflect(key_, data.nc) or data.cidx[key_]
    assert(data[ci], "invalid argument #2 (valid column expected)")
    tbl.refcol, data.cref = data.cidx[ci], ci
  end

  build_idx (data)
  finish_mtbl(tbl)
  return tbl
end

-- methods (readonly) ---------------------------------------------------------o

local function index (tbl, idx)
  assert(is_mtable (tbl), "invalid argument #1 (mtable expected)")
  assert(is_integer(idx), "invalid argument #2 (integer expected)")
  return index_of_idx(tbl, idx)
end

local function name_of (tbl, idx, ref_)
  assert(is_mtable (tbl), "invalid argument #1 (mtable expected)")
  assert(is_integer(idx) , "invalid argument #2 (integer expected)")
  return name_of_idx(tbl, idx, ref_)
end

local function index_of (tbl, a, ref_, dir_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
      if is_number (a) then return index_of_num(tbl, a, ref_, dir_)
  elseif is_string (a) then return index_of_str(tbl, a, ref_, dir_)
  elseif is_element(a) then return index_of_elm(tbl, a, ref_, dir_)
  end
  errorf("invalid argument #2 (number, string or element expected, got %s)",
          tostring(a))
end

local function range_of (tbl, rng_, ref_, dir_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local start, stop, step, istart, istop, sstart, sstop, dir, doidx
  if is_nil(rng_) then
    dir = dir_ or 1
        if dir ==  1 then return 1, #tbl,  1
    elseif dir == -1 then return #tbl, 1, -1 end
  elseif is_number(rng_) then
    start, istart = rng_, index_of_num(tbl, rng_, ref_, dir_)
    stop , istop  = start, istart
  elseif is_string(rng_) then
    local s1, i2 = strsplit(rng_, "/" )
    local s2 = i2 == 0 and s1 or strtrim(rng_, i2+1)
    doidx, start, stop = true, s1, s2
  elseif is_range(rng_) then
    doidx, start, stop, step = true, rng_:ranges()
    dir_ = dir_ or step
  elseif is_rawtable(rng_) then
    doidx, start, stop, ref_, dir_ = true, rng_[1], rng_[2] or rng_[1],
                                     ref_ or rng_[3],  dir_ or rng_[4]
  else
    errorf("invalid argument #2 (number, string, table or range expected, got %s)",
           tostring(rng_))
  end
  dir = dir_ or 1
  if dir ~= 1 and dir ~= -1 then
    errorf("invalid range direction '%s' (1 or -1 expected)", tostring(dir))
  end
  if doidx then
    istart, sstart = index_of(tbl, start, ref_,  dir)
    istop , sstop  = index_of(tbl, stop , ref_, -dir)
  end
  if not istart then errorf("invalid range start '%s'", tostring(start)) end
  if not istop  then errorf("invalid range stop '%s'" , tostring(stop )) end
  if sstart and sstop and (istart-istop)*(sstart-sstop) < 0 then
    return nil -- empty range
  end
  return istart, istop, dir
end

local function length_of (tbl, rng_, ntrn_, dir_) -- see iter
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local start, stop, dir = range_of(tbl, rng_, nil, dir_)
  if is_nil(start) then return 0 end
  local siz, trn = (stop-start)*dir, ntrn_ or 1
  return 1 + siz + #tbl * (trn-1 + (siz < 0 and 1 or 0))
end

-- memory helpers -------------------------------------------------------------o

-- expand vectors, specialize on 1st row unless nvec[col] is set
local function expand (data, tbl, extra)
  local rmax = ceil(max(tbl.reserve, data.rmax*1.5, data.rmax+extra))
  assert(rmax <= 2e8, "too big mtable") -- should see 'out of memory' first
  local nr, nc, cvec = data.nr, data.nc-data.ng

  -- nth expand, expand only vectors
  if data.rmax > 1 then
    for i=1,nc do
      local col = data[i]
      if isa_matrix(col) then
        data[i], data.rmax = col:copy(col:same(rmax,1):_reshapeto(nr)), rmax
      end
    end
    return
  end

  -- 1st expand, specialize vectors
  for i=0,nc do
    local col = data[i]
        if is_number (col[1]) and not data.nvec[i] then
      data[i], cvec =  vector(rmax):_reshapeto(1), true
    elseif is_complex(col[1]) and not data.nvec[i] then
      data[i], cvec = cvector(rmax):_reshapeto(1), true
    else
      data[i] = table.new(rmax,0)
    end
    data[i][1] = col[1]
  end
  data.rmax = cvec and rmax or 1e8
end

-- methods (R/W, update dict) -------------------------------------------------o

local function get_cel (tbl, row, col, cnt_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data, ri, ci = tbl.__dat

  if is_integer(col)
  then ci = ireflect(col, data.nc)
  else ci = data.cidx[col]
  end
  if is_nil(data[ci]) then return nil end

  if is_integer(row)
  then ri = ireflect(row, data.nr)
  else ri = data.ridx[row]
    if is_table(ri) then
      local cnt = cnt_ or 1
      assert(is_integer(cnt), "invalid argument #4 (integer expected)")
      ri = ri[ ireflect(cnt, ri.n) ]
    end
  end
  return data[ci][ri]
end

local function set_cel (tbl, row, col, val, cnt_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = tbl.__dat
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")

  local ci, ri
  if is_integer(col)
  then ci = ireflect(col, data.nc)
  else ci = data.cidx[col]
  end
  assert(data[ci], "invalid argument #3 (valid column expected)")

  if is_integer(row) then
    ri = ireflect(row, data.nr)
    assert(ri >= 1 and ri <= data.nr, "row index out of bounds")
  else
    ri = assert(data.ridx[row], "invalid argument #2 (valid row expected)")
    if is_table(ri) then
      local cnt = cnt_ or 1
      assert(is_integer(cnt), "invalid argument #5 (number expected)")
      ri = assert(ri[ ireflect(cnt, ri.n) ],
                                "invalid argument #2 (valid row[cnt] expected)")
    end
  end

  if ci ~= data.cref then
    data[ci][ri] = val
  elseif not val then
    error("invalid argument #4 (valid reference key expected)")
  elseif not rawequal(val, data[ci][ri]) then
    rem_idx(data, ri)
    data[ci][ri] = val
    ins_idx(data, ri)
  end
  return tbl
end

--- cleaning -------------------------------o

local function clr_dat (tbl)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = tbl.__dat
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")
  for i=1,data.nc-data.ng do data[i] = {} end
  data.nr, data.rmax = 0, 1
  table.clear(data.ridx) -- clear dict (if any)
  return tbl
end

--- columns -------------------------------o

local function get_col (tbl, key)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = tbl.__dat
  local ci = is_integer(key) and ireflect(key, data.nc) or data.cidx[key]
  if not ci or ci < 0 or ci > data.nc then return nil end
  return (ci ~= data.cref or data.ro) and data[ci] or -- index proxy
          setmetatable({__col=data[ci], __dat=data, __slf=tbl}, ref_mt)
end

local function set_col (tbl, key, val)
  local data = tbl.__dat
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")
  local ci = is_integer(key) and ireflect(key, data.nc) or data.cidx[key]
  assert(ci and ci >= 0 and ci <= data.nc, "invalid argument #2 (valid column expected)")
  if rawequal(data[ci],val) then return tbl end
  if ci > data.nc-data.ng then -- generator to use
    assert(is_callable(val), "invalid argument #2 (callable expected)")
    data[ci].__col = val
  elseif is_callable(val) then  -- generator to call
    for ri=1,data.nr do data[ci][ri] = val(ri) end
  elseif is_iterable(val) then  -- iterable to copy
    for ri=1,data.nr do data[ci][ri] = val[ri] end
  else error("invalid argument #3 (callable or iterable expected)")
  end
  if ci == data.cref then build_idx(data) end
  return tbl
end

local function ins_col (tbl, key_, kval, val, nvec_)
  if is_nil(val) then
    kval, val, key_ = key_, kval -- right shift
  end
  local data = tbl.__dat
  assert(is_mtable(tbl) , "invalid argument #1 (mtable expected)")
  assert(is_string(kval), "invalid argument #2 (string expected)")
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")
  assertf(is_nil(data.cidx[kval]), "invalid argument #3 (column name '%s' already in use)", kval)
  local ci = is_nil(key_) and data.nc+1 or
             is_integer(key_) and ireflect(key_, data.nc) or data.cidx[key_]
  assert(ci and ci >= 1 and ci <= data.nc+1,
                                "invalid insertion key (valid column expected)")
  local cg = data.nc-data.ng+1
  if is_callable(val) then     -- generator
    if ci < cg then ci = cg end
    table.insert(data, ci, setmetatable({__col=val, __dat=data, __slf=tbl}, gen_mt) )
    data.ng = data.ng+1
  elseif is_iterable(val) then -- iterable  TODO: if nr == 0 specialize again...
    local nr = data.nr
    if ci > cg then ci = cg end
    if is_vector(val) or is_number(val[1]) and not nvec_ and data.nvec ~= data.cidx then
      table.insert(data, ci,  vector(data.rmax):_reshapeto(nr):fill(val))
    elseif is_cvector(val) or is_complex(val[1]) and not nvec_ and data.nvec ~= data.cidx then
      table.insert(data, ci, cvector(data.rmax):_reshapeto(nr):fill(val))
    else
      table.insert(data, ci, table.new(nr,0))
      for ri=1,nr do data[ci][ri] = val[ri] end
    end
    if nvec_ and data.nvec ~= data.cidx then
      data.nvec[kval] = ci
      table.insert(data.nvec, ci, kval)
    end
    if data.cref and ci <= data.cref then data.cref = data.cref+1 end
  else error("invalid argument #4 (callable or iterable expected)")
  end
  data.nc, data.cidx[kval] = data.nc+1, ci
  table.insert(data.cidx, ci, kval)
  for i=ci+1,data.nc do data.cidx[data.cidx[i]] = i end
  return tbl
end

local function add_col (tbl, kval, val, nvec_)
  return ins_col(tbl, nil, kval, val, nvec_)
end

local function rem_col (tbl, key)
  local data = tbl.__dat
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")
  local ci = is_integer(key) and ireflect(key, data.nc) or data.cidx[key]
  assert(ci and ci >= 1 and ci <= data.nc, "invalid argument #2 (valid column expected)")
  if ci > data.nc-data.ng then data.ng = data.ng-1 end
  data.nc, data.cidx[data.cidx[ci]] = data.nc-1, nil
  table.remove(data     , ci)
  table.remove(data.cidx, ci)
  for i=ci,data.nc do data.cidx[data.cidx[i]] = i end
  if data.cref then
        if ci <  data.cref then data.cref = data.cref-1
    elseif ci == data.cref then data.cref, data.ridx = nil, {}
  end end
  return tbl
end

local function ren_col (tbl, key, nkey)
  local data = tbl.__dat
  if key == nkey then return tbl end
  assert(is_mtable(tbl) , "invalid argument #1 (mtable expected)")
  assert(is_string(nkey), "invalid argument #2 (string expected)")
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")
  local ci = is_integer(key) and ireflect(key, data.nc) or data.cidx[key]
  assert(ci and ci >= 1 and ci <= data.nc, "invalid argument #2 (valid column expected)")
  data.cidx[ci], data.cidx[nkey], data.cidx[data.cidx[ci]] = nkey, ci, nil
  if data.cref == ci then tbl.refcol = nkey end
  return tbl
end

--- rows ----------------------------------o

local function clrrow (data, ri) -- not exposed
  for ci=0,data.nc-data.ng do
    data[ci][ri] = isa_matrix(data[ci]) and 0 or nil
  end
end

local function cpyrow (data, ri, val) -- not exposed
  for ci=1,data.nc-data.ng do
    local v = val[ci]
    if is_nil(v) then v = val[data.cidx[ci]] end
    data[ci][ri] = isa_matrix(data[ci]) and (v or 0) or v
  end
  data[0][ri] = nil
end

local function get_row (tbl, key, ref_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local ri = index_of(tbl, key, ref_)
  if is_nil(ri) then return nil end
  return (setmetatable({__idx=ri, __dat=tbl.__dat, __slf=tbl}, row_mt))
end

local function clr_row (tbl, key, ref_)
  local data = tbl.__dat
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")
  local ri = assert(index_of(tbl, key, ref_), "invalid argument #2 (valid row expected)")
  local ck = data.cref and data[data.cref][ri] -- backup
  clrrow(data, ri)
  if ck then data[data.cref][ri] = ck end
  return tbl
end

local function set_row (tbl, key, val, ref_)
  local data = tbl.__dat
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")
  local ri = assert(index_of(tbl, key, ref_), "invalid argument #2 (valid row expected)")
  assert(is_iterable(val), "invalid argument #3 (iterable expected)")
  local ck = data.cref and not rawequal(val[data.cref] or val[data.cidx[data.cref]], data[data.cref][ri])
  if ck then rem_idx(data, ri) end
  for ci=0,data.nc-data.ng do
    local v = val[ci]
    if is_nil(v) then v = val[data.cidx[ci]] end
    if not is_nil(v) then data[ci][ri] = v end -- update if not nil
  end
  if ck then ins_idx(data, ri) end
  return tbl
end

local function add_row (tbl, val)
  local data = tbl.__dat
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")
  assert(is_iterable(val), "invalid argument #2 (iterable expected)")
  assert(is_nil(data.cref) or val[data.cref] or val[data.cidx[data.cref]],
                                    "invalid argument #3 (nil reference value)")
  local nr = data.nr+1
  if nr > data.rmax then expand(data, tbl, 1) end
  for ci=1,data.nc-data.ng do
    local v = val[ci]
    if is_nil(v) then v = val[data.cidx[ci]] end
    if isa_matrix(data[ci])
    then data[ci]:_appendto(v) -- was :_reshapeto(nr):seti(nr, v or 0)
    else data[ci][nr] = v
  end end
  data[0][nr] = nil
  add_idx(data, nr) -- add after update
  data.nr = nr
  return tbl
end

local function ins_row (tbl, key, val, ref_)
  local data, ri = tbl.__dat, key
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local nr = data.nr+1
  if ri ~= nr then
    ri = assert(index_of(tbl, ri, ref_), "invalid argument #2 (valid row expected)")
  end
  if ri == nr then return add_row(tbl, val) end
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")
  assert(is_iterable(val), "invalid argument #3 (iterable expected)")
  assert(is_nil(data.cref) or val[data.cref] or val[data.cidx[data.cref]],
                                    "invalid argument #3 (nil reference value)")
  if nr > data.rmax then expand(data, tbl, 1) end
  for ci=1,data.nc-data.ng do
    local v = val[ci]
    if is_nil(v) then v = val[data.cidx[ci]] end
    if isa_matrix(data[ci])
    then data[ci]:_reshapeto(nr):shiftv(ri, 1):seti(ri, v or 0)
    else table.insert(data[ci], ri, v)
  end end
  data[0][ri] = nil
  shf_idx(data, ri, 1)
  ins_idx(data, ri) -- insert after update
  data.nr = nr
  return tbl
end

local function rem_row (tbl, key, ref_)
  local data = tbl.__dat
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")
  local ri = assert(index_of(tbl, key, ref_), "invalid argument #2 (valid row expected)")
  local nr = data.nr,
  rem_idx(data, ri) -- remove before update
  shf_idx(data, ri, -1)
  for ci=0,data.nc-data.ng do
    if isa_matrix(data[ci])
    then data[ci]:shiftv(ri, -1):seti(nr, 0):_reshapeto(nr-1)
    else table.move(data[ci], ri+1, nr, ri)[nr] = nil
  end end
  data.nr = nr-1
  return tbl
end

local function swp_row (tbl, key1, key2, ref1_, ref2_)
  local data = tbl.__dat
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")
  local ri1 = assert(index_of(tbl, key1, ref1_)         , "invalid argument #2 (valid row expected)")
  local ri2 = assert(index_of(tbl, key2, ref2_ or ref1_), "invalid argument #3 (valid row expected)")
  if ri1 == ri2 then return tbl end
  local swp = data.cref and not rawequal(data[data.cref][ri1], data[data.cref][ri2])
  if swp then rem_idx(data, ri1) ; rem_idx(data, ri2) end -- remove before update
  for ci=0,data.nc-data.ng do
    data[ci][ri1], data[ci][ri2] = data[ci][ri2], data[ci][ri1]
  end
  if swp then ins_idx(data, ri1) ; ins_idx(data, ri2) end -- insert after update
  return tbl
end

-- functional methods ---------------------------------------------------------o

local psel   = \sel,b,  _,i -> b == (sel[i] == true)
local ptbl   = \col,tbl,_,i -> tbl[col[i]]
local pnam   = \ref,pat,_,i -> string.match(ref[i], pat) ~= nil
local pand   = \p,p2,   r,i -> p(r,i) and p2(r,i)
local ptrue  = \p,_ ,   r,i -> p(r,i) and true
local pfalse = \p,_ ,   r,i -> p(r,i) or false

local l2t = \l -> not is_table(l) and {[l]=true} or is_nil(l[1]) and l or lst2tbl(l)

local function foreach (tbl, act, rng_, sel_, not_) -- action, range, selection, default
  -- foreach(sel) -> foreach(sel.action, sel)
  if is_nil(rng_) and is_rawtable(act) then
    act, rng_ = act.action, act     -- extract action + right shift
  end
  -- foreach(act,sel) -> foreach(act, sel.range, sel)
  if is_nil(sel_) and is_rawtable(rng_) and is_nil(rng_[1]) then
    rng_, sel_ = rng_.range, rng_ -- extract range + right shift
  end

  local data, p = tbl.__dat
  if is_rawtable(sel_) then       -- logically and'ed selections
    if is_nil(not_) and (sel_.default == 'none' or sel_.default == true) then
      not_ = true
    end
    local op = not_ ~= true and ptrue or pfalse
    if sel_.select ~= nil then
      assert(is_callable(sel_.select), "invalid select (callable expected)")
      op, p = pand, bind2st(op, sel_.select, p)
    end
    if sel_.list ~= nil then
      local cname = is_table(sel_.list) and sel_.list.colname or 'name'
      assertf(data.cidx[cname], "unexpected 'list' selection (no '%s' column)", cname)
      op, p = pand, bind2st(op, bind2st(ptbl,data[data.cidx[cname]],l2t(sel_.list)), p)
    end
    if sel_.table ~= nil then
      assert(data.cidx.name, "unexpected 'table' selection (no 'name' column)")
      op, p = pand, bind2st(op, bind2st(ptbl,data[data.cidx.name],l2t(sel_.table)), p)
    end
    if sel_.kind ~= nil then
      assert(data.cidx.kind, "unexpected 'kind' selection (no 'kind' column)")
      op, p = pand, bind2st(op, bind2st(ptbl,data[data.cidx.kind],l2t(sel_.kind)), p)
    end
    if sel_.pattern ~= nil then
      assert(is_string(sel_.pattern), "invalid pattern (string expected)")
      assert(data.cref, "unexpected pattern selection (no reference column)")
      op, p = pand, bind2st(op, bind2st(pnam,data[data.cref],sel_.pattern), p)
    end
    if sel_.selected ~= nil then
      assert(is_boolean(sel_.selected), "invalid selected (boolean expected)")
      op, p = pand, bind2st(op, bind2st(psel,data[0],sel_.selected), p)
    end
  elseif not is_nil(sel_) then    -- build the selection
    p = is_boolean (sel_) and bind2st(psel, data[0], sel_)         or
        is_string  (sel_) and assert(data.cref, "unexpected pattern selection (no reference column)")
                          and bind2st(pnam, data[data.cref], sel_) or
        is_callable(sel_) and sel_                                 or
        is_mappable(sel_) and assert(data.cidx.name, "unexpected list or table selection (no 'name' column)")
                          and bind2st(ptbl, data[data.cidx.name], l2t(sel_)) or nil
  end
  if is_nil(p) then p = (not_ ~= true or rng_) and ltrue or lfalse end

  assert(is_mtable  (tbl), "invalid argument #1 (mtable expected)")
  assert(is_callable(act), "invalid argument #2 (callable expected)")
  assert(is_callable(p)  , "invalid argument #4 (callable expected)")

  if p ~= lfalse then
    for ri,row in tbl:iter(rng_) do if p(row,ri) then act(row,ri) end end
  end
  return tbl
end

local do_select = \sel,_,i => sel[i] = true end

local function select (tbl, rng_, sel_, not_)
  local act = bind1st(do_select, tbl.__dat[0])
  return tbl:foreach(act, rng_, sel_, not_)
end

local do_deselect = \sel,_,i => sel[i] = nil end

local function deselect (tbl, rng_, sel_, not_)
  local act = bind1st(do_deselect, tbl.__dat[0])
  return tbl:foreach(act, rng_, sel_, not_)
end

local do_filter = \ri,_,i => local n=ri.n+1 ; ri[n], ri.n = i, n end

local function filter (tbl, rng_, sel_, not_)
  local ri = table.new(8,1)
  local act = bind1st(do_filter, ri)
  ri.n = 0
  tbl:foreach(act, rng_, sel_, not_)
  local n = ri.n ; ri.n = nil
  return ri, n
end

-- methods (R/W, rebuild dict) ------------------------------------------------o

local function remove (tbl, rng_, sel_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = tbl.__dat
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")

  -- collect indexes of elements to remove
  local idx_r, nr
  if is_number(rng_) and is_nil(sel_) and 1 <= rng_ and rng_ <= data.nr+1 then
    idx_r, nr = { rng_ }, 1
    -- if true then tbl:remrow(rng_) return tbl end -- uniformity test
  else
    idx_r, nr = filter(tbl, rng_, sel_, true)
  end
  if nr == 0 then return tbl end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- remove rows by increasing indexes
  local ni, nc = data.nr-nr, data.nc-data.ng
  local i, j, r = idx_r[1], idx_r[1]+1, 2
  while i <= ni do
    if j == idx_r[r] then
      r = r+1
    else
      for ic=0,nc do data[ic][i] = data[ic][j] end
      i = i+1
    end
    j = j+1
  end
  -- clear remaning rows
  for i=ni+1,data.nr do clrrow(data, i) end

  -- reshape vectors and clear tables
  for i=1,nc do
    if isa_matrix(data[i]) then data[i]:_reshapeto(ni) end
  end
  data.nr = ni

  return build_index(tbl)
end

local function insert (tbl, rows, rng_, sel_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = tbl.__dat
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")

  -- collect indexes of rows to select
  local idx_r, nr
  if is_number(rng_) and is_nil(sel_) and 1 <= rng_ and rng_ <= data.nr+1 then
    idx_r, nr = { rng_ }, 1
    -- if #rows == 1 then tbl:insrow(rng_, rows[1]) return tbl end -- uniformity test
  else
    -- insert(rows, sel) -> insert(rows, sel.range, sel)
    if is_nil(sel_) and is_rawtable(rng_) and is_nil(rng_[1]) then
      rng_, sel_ = rng_.range, rng_ -- extract range + right shift (see foreach)
    end

    idx_r, nr = filter(tbl, rng_, sel_, true)
    if is_rawtable(sel_) then
      if sel_.where == 'after' then for i=1,nr do idx_r[i] = idx_r[i]+1 end end
      if sel_.rows then rows = sel_.rows end
    end
  end
  if nr == 0 then return tbl end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- check for non nil reference keys
  local rsize = #rows
  if data.cref then
    local ki, kr = data.cref, data.cidx[data.cref]
    for ri=1,rsize do
      assert(rows[ri][ki] or rows[ri][kn], "invalid argument #2 (nil reference value)")
    end
  end

  -- process cases: 1x1, 1xR, Nx1, NxR where R=#rows and N=#selected=nr
  local nrs = rsize == 1 and nr    or
              nr    == 1 and rsize or min(nr, rsize)

  -- expand if needed
  if data.nr+nrs > data.rmax then expand(data, tbl, nrs) end

  -- reshape vectors
  data.nr = data.nr+nrs
  local nc = data.nc-data.ng
  for i=1,nc do
    if isa_matrix(data[i]) then data[i]:_reshapeto(data.nr) end
  end

  -- insert rows by decreasing indexes
  local i, j, ni = data.nr, data.nr-nrs, idx_r[1]
  local k = (nrs-1) % rsize + 1
  local r = (nrs-1) % nr    + 1
  while i >= ni do
    if j == idx_r[r]-1 then
      cpyrow(data, i, rows[k])
      k = (k-2) % rsize + 1
      r = (r-2) % nr    + 1
    else
      for ic=0,nc do data[ic][i] = data[ic][j] end
      j = j-1
    end
    i = i-1
  end

  return build_index(tbl)
end

local function sort (tbl, cmp, rng_, sel_)
  if is_string(cmp) then cmp = str2cmp(cmp) end
  assert(is_mtable(tbl)  , "invalid argument #1 (mtable expected)")
  assert(is_callable(cmp), "invalid argument #2 (string or callable expected)")
  local data = tbl.__dat
  assert(not (data.ro or tbl:is_readonly()), "invalid write access to readonly mtable")

  -- collect indexes of elements to sort
  local idx_r, nr = filter(tbl, rng_, sel_)
  if nr == 0 then return end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- sort indexes (indirectly)
  local row1  = setmetatable({__idx=0, __dat=data, __slf=tbl}, row_mt)
  local row2  = setmetatable({__idx=0, __dat=data, __slf=tbl}, row_mt)
  local idx_s = tblicpy(idx_r, table.new(nr,0))
  table.sort(idx_s, \i1,i2 => row1.__idx, row2.__idx = i1, i2
                              return cmp(row1,row2) end)

  -- build lookup table
  local idx_l = table.new(0,nr)
  for i=1,nr do idx_l[idx_r[i]] = idx_s[i] end

  -- sort rows
  local nc = data.nc-data.ng
  local tmp = table.new(nc+1,0)
  for ii=1,nr do
    local s, r = idx_s[ii], idx_l[idx_s[ii]]
    if s == r then -- identity (cleanup)
      idx_l[s] = nil
    elseif r then  -- not yet processed
      local ts = s
      for i=0,nc do tmp[i] = data[i][s] end
      while r ~= ts do
        for i=0,nc do data[i][s] = data[i][r] end
        s, r, idx_l[s] = r, idx_l[r]
      end
      for i=0,nc do data[i][s] = tmp[i] end
      idx_l[s] = nil
    end
  end
  assert(is_nil(next(idx_l)), "unexpected corrupted lookup indexes (sort)")

  return build_index(tbl)
end

-- special --------------------------------------------------------------------o

local function cycle (tbl, a)
  assert(is_mtable(tbl)  , "invalid argument #1 (mtable expected)")
  assert(index_of(tbl, a), "invalid argument #2 (valid reference expected)")
  assert(not tbl:is_readonly(), "invalid write access to readonly mtable")
  tbl:raw_set('__cycle', a)
  return tbl
end

-- iterators ------------------------------------------------------------------o

local function niliter (state, i)
  return nil
end

local function fwditer (state, i)
  if i == state.stop then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end
  i = i < state.nr and i+1 or 1
  state.row.__idx = i
  return i, state.row
end

local function bwditer (state, i)
  if i == state.stop then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end
  i = i > 1 and i-1 or state.nr
  state.row.__idx = i
  return i, state.row
end

local function iter (tbl, rng_, ntrn_, dir_)
  local nturn, dir = ntrn_ or 1
  assert(is_mtable(tbl)                  ,"invalid argument #1 (mtable expected)")
  assert(is_integer(nturn) and nturn > 0 ,"invalid argument #3 (integer >1 expected)")

  if #tbl == 0 then return niliter end

  local data, start, stop = tbl.__dat
  if is_nil(rng_) then
    local idx1, idxn = 1, data.nr
    dir = dir_ or 1
    if dir < 0 then idx1, idxn = idxn, idx1 end
    if is_nil(tbl.__cycle) then
      start, stop = idx1, idxn
    else
      start = assert(index_of(tbl, tbl.__cycle), "invalid cycle reference")
      stop  = start == idx1 and idxn or start-dir
    end
  else
    start, stop, dir = range_of(tbl, rng_, nil, dir_)
    if is_nil(start) then return niliter end
  end
  if start == stop+dir then nturn = nturn+1 end

  assert(dir == 1 or dir == -1,"invalid argument #4 (1 or -1 expected)")

  local row = setmetatable({__idx=0, __dat=data, __slf=tbl}, row_mt)
  return dir > 0 and fwditer or bwditer,
         { row=row, nr=data.nr, stop=stop, turn=nturn-1, dir=dir }, start-dir
end

-- flags ----------------------------------------------------------------------o

local function save_sel (tbl, sel_)
  assert(is_mtable(tbl),"invalid argument #1 (mtable expected)")
  local data = tbl.__dat
  local dat0 = data[0]
  local sel  = sel_ or table.new(data.nr,0)
  for i=1,data.nr do sel[i] = dat0[i] == true end
  return sels
end

local function restore_sel (tbl, sel)
  assert(is_mtable(tbl)  , "invalid argument #1 (mtable expected)")
  assert(is_iterable(sel), "invalid argument #2 (iterable expected)")
  local data = tbl.__dat
  local dat0 = data[0]
  for i=1,data.nr do dat0[i] = sel[i] == true or nil end
end

-- I/O methods ----------------------------------------------------------------o

local tblext = {'.tfs', '.txt', '.dat'}

-- convert table of values and strings to table of strings and quoted strings
local function tbl2str (tbl, i_, j_)
  local i, j = i_ or 1, j_ or #tbl

  local n = j-i+1
  local res = table.new(n,0)
  for k=i,j do -- try some identification or generate a quoted string
    if is_string(tbl[k])
    then res[k-i+1] = string.format("%q", tbl[k])
    else res[k-i+1] = tostring(tbl[k])
    end
  end

  return res, n
end

-- convert table of strings to table of values or quoted strings
local function str2tbl (tbl, i_, j_)
  local i, j = i_ or 1, j_ or #tbl

      if            tbl[i]        == '{' then i=i+1
  elseif string.sub(tbl[i], 1, 1) == '{' then tbl[i] = string.sub(tbl[i],2,-1)
  end
      if            tbl[j]        == '}' then j=j-1
  elseif string.sub(tbl[j],-1,-1) == '}' then tbl[j] = string.sub(tbl[j],1,-2)
  end

  local n = j-i+1
  local res = table.new(n,0)
  for k=i,j do -- try some conversion or generate a quoted string
    local r = tonumber(tbl[k]) or tocomplex(tbl[k]) or
              torange (tbl[k]) or toboolean(tbl[k])
    if is_nil(r) and tbl[k] ~= 'nil' then r = strquote(tbl[k]) end
    res[k-i+1] = r
  end

  return res, n
end

local function write (tbl, filnam_, colnam_, hdrnam_, rowsel_)
  if is_rawtable(filnam_) and is_nil(colnam_) then
    local arg = filnam_  -- named arguments
    filnam_, colnam_, hdrnam_, rowsel_ =
      arg.filename or arg.file, arg.column, arg.header, arg.selected
  else -- right shifts
    if is_nil(rowsel_) and (is_table(filnam_) or is_boolean(filnam_)) then
      filnam_, colnam_, hdrnam_, rowsel_ = nil, filnam_, colnam_, hdrnam_
    end
    if is_nil(rowsel_) and is_boolean(colnam_) then
      colnam_, hdrnam_, rowsel_ = nil, colnam_, hdrnam_
    end
    if is_nil(rowsel_) and is_boolean(hdrnam_) then
      hdrnam_, rowsel_ = nil, hdrnam_
    end
  end

  local data = tbl.__dat
  local cnam = colnam_ or tbl.column or data.cidx
  local hnam = hdrnam_ or tbl.header
  local nrow = data.nr
  local ncol = #cnam
  local clst = table.new(ncol, 0)
  local cols = table.new(ncol, 0)

  -- collect column
  local j = 1
  for i=1,ncol do
    local ci = is_number(cnam[i]) and ireflect(cnam[i], ncol) or data.cidx[cnam[i]]
    if not data[ci] then
      errorf("invalid column name (or index) '%s'", tostring(cnam[i]))
    end
    local v = data[ci][1] -- discard cdata except complex and range
    if not (is_table(v) or is_cdata(v)) or is_complex(v) or is_range(v) then
      cols[j], clst[j], j = data[ci], data.cidx[ci], j+1
    end
  end
  ncol = j-1

  -- open file
  local file = assert(openfile(filnam_, 'w', tblext),
                      "unable to open MTable file in write mode")

  -- setup format (TODO: support per header and per column format)
  local fmt = option.numfmt
  local hwd = tbl.hdrwidth or option.hdrwidth
  local cwd = tbl.colwidth or option.colwidth
  option.numfmt = tbl.format or option.numfmt

  -- dump header
  local sfmt, v = '@ %-'..hwd..'s %%'
  for i, k in ipairs(hnam) do
    k, v = hnam[k] or k, tbl[k]
    if is_number(v) then
      fprintf(file, sfmt..'le      %s\n', k, num2str(v))
    elseif is_complex(v) then
      fprintf(file, sfmt..'lz      %s\n', k, tostring(v))
    elseif is_range(v) then
      fprintf(file, sfmt..'lr      %s\n', k, tostring(v))
    elseif is_string(v) then
      fprintf(file, sfmt..'%02ds     %q\n', k, #v, v)
    elseif is_table(v) then
      local n = #v
      local s = '{'.. table.concat(tbl2str(v,1,n), ', ') ..'}'
      fprintf(file, sfmt..'%02dt     %s\n', k, n, s)
    elseif is_boolean(v) then
      fprintf(file, sfmt..'b       %s\n', k, tostring(v))
    elseif is_nil(v) then
      fprintf(file, sfmt..'n       %s\n', k, tostring(v))
    else
      fprintf(file, sfmt..'?       %s\n', k, tostring(v))
    end
  end

  if ncol > 0 then
    local sfmt = '%-'..cwd..'s '

    -- dump col names
    file:write('* ')
    for i=1,ncol do
      fprintf(file, i < ncol and sfmt or '%s\n', clst[i])
    end

    -- dump col types
    file:write('$ ')
    for i=1,ncol do
      v = cols[i][1]
      local s = is_string (v) and '%s'  or
                is_number (v) and '%le' or
                is_complex(v) and '%lz' or
                is_range  (v) and '%lr' or
                is_boolean(v) and '%b'  or '%?'
      fprintf(file, i < ncol and sfmt or '%s\n', s)
    end

    -- dump rows
    for j=1,nrow do
      if not rowsel_ or data[0][j] then -- is_selected
        file:write('  ')
        for i=1,ncol do
          v = cols[i][j]
              if is_number(v) then v = num2str(v)
          elseif is_string(v) then v = string.format("%q", v)
          else                     v = tostring(v) end
          fprintf(file, i < ncol and sfmt or '%s\n', v)
        end
      end
    end
  end

  -- restore format
  option.numfmt = fmt

  if is_string(filnam_) then file:close() else file:flush() end
  return tbl
end

local function print_ (tbl, colnam_, hdrnam_, rowsel_)
  return write(tbl, nil, colnam_, hdrnam_, rowsel_)
end

local function read (tbl, filnam_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local file = assert(openfile(filnam_, 'r', tblext),
                      "unable to open MTable file in read mode")
  local hnam = table.new(8,8)
  local cnam = nil
  local ncol = 0
  local row  = {n=0}
  local ln   = 0

  -- read header
  for line in file:lines() do
    ln = ln+1
    row, ncol = strsplitall(line, " \t,", nil, row)
    if row[1] == '@' then
      assertf(ncol >= 4, "invalid header format (4 columns expected, line %d)", ln)
      local typ = string.sub(row[3],-1)
      assertf(ncol == 4 or typ == 't',
                         "invalid header format (4 columns expected, line %d)", ln)
      -- types: n, b, {e, f}, {i, z}, r, s, t, ?
          if typ == '?' then                              -- unknown
        hnam[row[2]] = row[4]
      elseif typ == 'n' then                              -- nil
        assertf(row[4]=='nil', "invalid header format (missing nil, line %d)", ln)
        hnam[row[2]] = nil
      elseif typ == 'e' or typ == 'f' then                -- number
        hnam[row[2]] = assertf(tonumber(row[4]),
                        "invalid header format (missing number, line %d)", ln)
      elseif typ == 'i' or typ == 'z' then                -- complex
        hnam[row[2]] = assertf(tocomplex(row[4]),
                        "invalid header format (missing complex, line %d)", ln)
      elseif typ == 'r' then                              -- range
        hnam[row[2]] = assertf(torange(row[4]),
                        "invalid header format (missing range, line %d)", ln)
      elseif typ == 'b' then                              -- boolean
        hnam[row[2]] = toboolean(row[4])
        assertf(hnam[row[2]] ~= nil,
                        "invalid header format (missing boolean, line %d)", ln)
      elseif typ == 's' then                              -- string
        hnam[row[2]] = strquote(row[4])
        if #hnam[row[2]] ~= tonumber(string.sub(row[3],2,-2)) then
          errorf("invalid header format (unmatched string length, line %d)", ln)
        end
      elseif typ == 't' then                              -- table
--        local res, n = strsplitall(string.sub(row[4],2,-2), ",")
        local res, n = str2tbl(row, 4, ncol)
        if n ~= tonumber(string.sub(row[3],2,-2)) then
          errorf("invalid header format (unmatched table length, line %d)", ln)
        end
        hnam[row[2]] = res
      else                                               -- invalid
        error("invalid header field type: '"..typ.."'")
      end
      hnam[#hnam+1] = row[2]
    elseif row[1] == '*' then -- col names
      cnam, row.n = table.new(ncol-1,0), ncol-1
      for i=1,ncol-1 do cnam[i] = row[i+1] end
    elseif row[1] == '$' then -- col types (discarded, optionnal)
      break
    end
  end

  -- create table from header
  for i,v in ipairs(hnam) do
    cnam[v], hnam[v] = hnam[v], nil
  end
  tbl = tbl(hnam.name, cnam) -- inherit from tbl
  tbl.header = hnam

  -- read and add rows
  for line in file:lines() do
    ln = ln+1
    row, ncol = strsplitall(line, " \t", nil, row)
    if row.n ~= ncol then
      errorf("invalid row format (%d missing columns, line %d)", row.n-ncol, ln)
    end
    for i=1,ncol do -- convert to number or to boolean or remove quotes (if any)
      local r = tonumber(row[i]) or tocomplex(row[i]) or
                torange (row[i]) or toboolean(row[i])
      if is_nil(r) and row[i] ~= 'nil' then r = strquote(row[i]) end
      row[i] = r
    end
    tbl:addrow(row)
  end

  -- build index with column 'name' (if any)
  local cref = raw_get(tbl, 'refcol')
  if cref then build_index(tbl, cref) end

  if is_string(filnam_) then file:close() end
  return tbl
end

-- members --------------------------------------------------------------------o

mtable :set_methods {
  -- nrow, ncol, ngen, nalloc, colname, colnames, index
  nrow         = len_mm,
  ncol         = \s   -> s.__dat.nc,
  ngen         = \s   -> s.__dat.ng,
  colname      = \s,n -> s.__dat.cidx[n],
  colnames     = \s,t -> tblicpy(s.__dat.cidx, t),
  index        = index,

  -- cells manipulation
  get          = get_cel,
  set          = set_cel,

  -- columns manipulation
  getcol       = get_col,
  addcol       = add_col,
  setcol       = set_col,
  remcol       = rem_col,
  inscol       = ins_col,
  rencol       = ren_col,

  -- rows manipulation
  getrow       = get_row,
  addrow       = add_row,
  setrow       = set_row,
  clrrow       = clr_row,
  remrow       = rem_row,
  insrow       = ins_row,
  swprow       = swp_row,

  -- clear rows data, keep everything else
  clear        = clr_dat,

  -- sequence-like methods
  name_of      = name_of,
  index_of     = index_of,
  range_of     = range_of,
  length_of    = length_of,

  foreach      = foreach,
  select       = select,
  deselect     = deselect,
  filter       = filter,

  copy         = copy_mm,
  sort         = sort,
  insert       = insert,
  remove       = remove,
--replace      = replace, ??

  cycle        = cycle,
  iter         = iter,

  -- read/write
  read         = read,
  write        = write,
  print        = print_,

  -- ownership
  is_view      = is_view,

  -- selection
  save_sel    = save_sel,
  restore_sel = restore_sel,

  -- readonly
  set_readonly = set_readonly,

  -- make dict
  make_dict   = build_index,

  -- for debugging
  check_mtbl  = check_mtbl,

  -- disabled method
  is_selected := error("invalid mtable operation", 2),

} :set_metamethods {
  __mtbl       = _id,
  __init       = init_mm,
  __copy       = copy_mm,
  __add        = add_row,
  __len        = len_mm,
  __index      = index_mm,
  __newindex   = newindex_mm,
-- __ipairs    = ipairs_mm, default from object
-- __pairs     = pairs_mm , default from object
} :set_readonly()

-- env ------------------------------------------------------------------------o

MAD.typeid.is_mtable = is_mtable

-- end ------------------------------------------------------------------------o
return { mtable = mtable }

--[[ 'High level table access is very slow!
code A:
t0=os.clock()
do
  local a, t = 0, MAD.mtable 'mytable' { {'name'}, 'x', 'y', 'z' }
  t=t+{'A', 1.1,1.2,1.3}+{'B', 2.1,2.2,2.3}+{'A', 3.1,3.2,3.3}
  for i=1,1e7 do a=a+t.B.x end -- t:get('A','x',2) end
  print('a=',a)
end
print('time=',os.clock()-t0)
time= 1.14

code B:
t0=os.clock()
do
  local a, t = 0, MAD.mtable 'mytable' { {'name'}, 'x', 'y', 'z' }
  t=t+{'A', 1.1,1.2,1.3}+{'B', 2.1,2.2,2.3}+{'A', 3.1,3.2,3.3}
  for i=1,1e7 do a=a+t.x[2] end
  print('a=',a)
end
print('time=',os.clock()-t0)
time= 1.14

Output code A:
building dict:  1
a=  21000000.000896
time= 1.14
changing t.B.x by t[2].x
time= 1.14
changing t.B.x by t.x[2]
time= 0.012
]]
