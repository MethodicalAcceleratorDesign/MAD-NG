--[=[
 o-----------------------------------------------------------------------------o
 |
 | Table module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide MAD table objects (TFS tables)
  - Many features have similar implementation to sequences

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local Object, vector, env                                        in MAD
local bind1st, bind2nd, bind2st                                  in MAD.gfunc
local sub, ltrue, lfalse                                         in MAD.operator
local strtrim, strsplit, strbracket, fprintf, kpairs             in MAD.utility
local is_nil, is_boolean, is_number, is_integer, is_decimal,
      is_positive, is_string, is_table, is_rawtable, is_range,
      is_file, is_matrix, is_iterable, is_callable, set_concept,
      concept                                                    in MAD.typeid
local not_keyrable, not_extendable, not_mutable                  in concept

local abs, max, ceil in math
local strsub = string.sub
local table_new, table_clear, table_insert, table_remove =
      table.new, table.clear, table.insert, table.remove

-- root object ----------------------------------------------------------------o

-- hidden keys.
local _data = {}

local origin = string.format("MAD %s %s %s", env.version, env.os, env.arch)

local mtable = Object 'mtable' {
  type='', title='', origin=origin, kind='mtable',
  header = { 'name', 'type', 'title', 'origin', 'date', 'time' },
  column = nil, --{},
  reserve=8, novector=nil,
  [_data]={ridx={}, cidx={}, cref=nil, nvec=nil, [0]={nr=0},
           nr=0, nc=0, ng=0, rmax=0},
}

-- backup original methods and metamethods
local mtable_mt = getmetatable(mtable)
local var_raw, var_val = mtable.var_raw, mtable.var_val
local var_get, var_set = mtable_mt.__index, mtable_mt.__newindex
local raw_get, tbl_cpy = mtable.raw_get, mtable.copy
local parent, readonly = mtable.__par, mtable.set_readonly

local function is_mtable (a)
  return is_table(a) and a[_data] ~= nil
end

local function is_orig_mtable (a)
  return is_mtable(a) and raw_get(a, _data) ~= nil
end

local function original (a)
  while raw_get(a, _data) == nil do a = parent(a) end
  assert(not rawequal(a,mtable), "no original mtable found")
  return a
end

-- sanity checks --------------------------------------------------------------o

-- check dictionnary of name -> idx
local function check_dict (tbl)
  local data = var_raw(tbl,_data)
  if is_nil(data.cref) then return end
  local cref = data[data.cref]
  for rn,ri in pairs(data.ridx) do -- name -> index or table of indexes
    if is_number(ri) then
      assert(cref[ri] == rn     , "unexpected corrupted dictionnary")
    elseif is_table(ri) then
      assert(cref[ri[1]] == rn  , "unexpected corrupted dictionnary")
      for i=2,ri.n do
        assert(ri[i-1] < ri[i]  , "unexpected corrupted dictionnary")
        assert(cref[ri[i]] == rn, "unexpected corrupted dictionnary")
      end
    else
      error("unexpected corrupted dictionnary")
    end
  end
end

-- helper for mangled names and row indexes (same as sequence) ----------------o

local index_of_idx -- forward declaration

-- get index from s-position (binary)
local function index_of_num (tbl, num, typ)
  assert(is_number(num), "invalid argument #2 (number expected)")
  if typ ~= 'spos' and is_integer(num) then
    return index_of_idx(tbl, num, typ)
  end
  local data = var_raw(tbl,_data)
  print('index_of_num', tbl, data)
  local s = data[data.cidx.s]
  assert(s, "missing column 's'")
  local l = s[data.nr]
  if num < 0 then num = l+num end -- reflect
  if num < 0 or num > l then return nil end
  return bsearch(s, num)
end

-- get row index from signed index (direct)
function index_of_idx (tbl, idx, typ)
  assert(is_integer(idx), "invalid argument #2 (number expected)")
  if typ == 'spos' then return index_of_num(tbl, idx, typ) end
  local n = var_raw(tbl,_data).nr
  if idx < 0 then idx = n+idx+1 end -- reflect
  if idx < 1 or idx > n then return nil end
  return idx
end

-- get index from name [with count] (direct)
local function index_of_cnam (tbl, nam, cnt)
  local ri = var_raw(tbl,_data).ridx[nam]
  if is_table(ri) then
    if cnt < 0 then cnt = ri.n+cnt+1 end -- reflect
    return ri[cnt]
  end
  return ri
end

-- get index from name [with relative count] (linear)
local function index_of_rnam (tbl, nam, cnt, idx)
  local ri = var_raw(tbl,_data).ridx[nam]
  if is_nil(ri) then return nil end
  idx = index_of_idx(tbl, idx)
  if is_nil(idx) then return nil end
  if is_number(ri) then
    return (cnt ==  1 and ri >= idx and ri) or
           (cnt == -1 and ri <= idx and ri) or nil
  end
  if cnt > 0 then
    for i=1,ri.n do
      if ri[i] >= idx then return ri[i+cnt-1] end
    end
  elseif cnt < 0 then
    for i=1,ri.n do
      if ri[i] >  idx then return ri[i+cnt  ] end
    end
  end
  return nil
end

-- get index from [mangled] name (direct or linear)
local function index_of_str (tbl, nam, idx_)
  assert(is_string(nam), "invalid argument #2 (string expected)")
  local num = tonumber(nam)
  if num then return index_of_num(tbl, num, idx_) end
  local nam, cnt, _, bra = strbracket(nam)
  cnt = is_nil(cnt) and 1 or tonumber(cnt)
  assert(is_number(cnt), "invalid count (number expected)")
  if is_nil(idx_) or bra == 1 then
    return index_of_cnam(tbl, nam, cnt      )
  else
    return index_of_rnam(tbl, nam, cnt, idx_)
  end
end

-- get [mangled] name from index (linear)
local function name_of_idx (tbl, idx, ref_)
  idx = index_of_idx(tbl, idx, ref_)
  if is_nil(idx) then return nil end
  local data = var_raw(tbl,_data)
  assert(data.cref, "no reference column found")
  local nam = data[data.cref][idx]
  local ri  = data.ridx[nam]
  if is_number(ri) then
    assert(ri == idx, "unexpected corrupted dictionnary")
    return nam
  end

  local cnt, b1, b2 = 0
  if ref_ then
    ref_ = index_of_idx(tbl, ref_)
    for i=1,ri.n do
      if ri[i] >= ref_ then break else cnt = cnt+1 end
    end
    b1, b2 = "{", "}"
  else
    b1, b2 = "[", "]"
  end

  for i=1,ri.n do
    if ri[i] == idx then
      return string.format("%s%s%d%s", nam, i-cnt, b1, b2)
    end
  end
  error("unexpected corrupted dictionnary")
end

-- build mtable ---------------------------------------------------------------o

-- finalize mtable
local function finish_mtbl (tbl)
  -- sanity checks
  if MAD.option.debug > 2 then
    check_dict(tbl)
  end
end

-- mtable initialization
local function mtbl_init (tbl)
  local nc = tbl:raw_len()
  if nc == 0 then return tbl end -- empty

  local nr   = tbl.reserve          -- forseen rows
  local data = table_new(nc, 8)     -- columns (data)
  data.ridx  = table_new( 0,nr)     -- name -> idx
  data.cidx  = table_new(nc+1,nc+1) -- name -> idx and idx -> name
  data[0]    = table_new(nr, 1)     -- selected rows
  data.nr    = 0                    -- #rows
  data.nc    = nc                   -- #cols
  data.ng    = 0                    -- #gens
  data.rmax  = 1                    -- allocated rows (specialize after 1st row)
  data.nvec  = {}                   -- columns that should not be specialized

  if is_table(tbl.novector) then
    for _,k in ipairs(tbl.novector) do data.nvec[k] = true end
  elseif tbl.novector == true then
    data.nvec = data.cidx
  end

  for i=1,nc do
    local col = raw_get(tbl,i)      -- column key
    if is_table(col) then           -- ref: { key }
      assert(is_rawtable(col) and is_nil(col[2]), "invalid reference column")
      data.cref, col = i, col[1]
    end
    assert(is_string(col), "invalid column name (string expected)")
    data.cidx[col], data.cidx[i] = i, col
    data[i] = {nr=0}
  end
  data[0].nr, data.cidx.is_selected, data.cidx[0] = 0, 0, 'is_selected'
  tbl:clear_array() -- clear list of column names
  tbl.date, tbl.time = os.date'%d/%m/%y', os.date'%H:%M:%S'
  tbl[_data] = data
  finish_mtbl(tbl)
  return tbl
end

-- mtable metamethods ---------------------------------------------------------o

local _idx, _gen = {}, {}

-- column generator
local function gen_iter (s, i)
  i = i+1
  if i <= s[_data].nr then return i, s[_gen](i) end
end

local gen_mt = set_concept({
  __len      = \s   -> s[_data].nr,
  __index    = \s,i -> i >= 1 and i <= s[_data].nr and s[_gen](i) or nil,
  __pairs    = \s   -> (gen_iter, s, 0),
  __ipairs   = \s   -> (gen_iter, s, 0),
  __tostring = \s   -> string.format("mtable column generator: %p", s),
}, not_keyrable + not_extendable + not_mutable)

-- column proxy (RO)
local function col_iter (s, i)
  i = i+1
  if i <= s[_data].nr then return i, s[_data][i] end
end

local col_mt = set_concept({
  __len      = \s   -> s[_data].nr,
  __index    = \s,i -> i >= 1 and i <= s[_data].nr and s[_data][i] or nil,
  __pairs    = \s   -> (col_iter, s, 0),
  __ipairs   = \s   -> (col_iter, s, 0),
  __tostring = \s   -> string.format("mtable readonly column: %p", s),
}, not_keyrable + not_extendable + not_mutable)

-- row proxy
local function row_iter (s, i)
  i = i+1
  local col = s[_data][i]
  if col then return i, col[s[_idx]] end
end

local function row_kiter (s, k)
  local data = s[_data]
  local i = k and data.cidx[k]+1 or 1
  local col = data[i]
  if col then return data.cidx[i], col[s[_idx]] end
end

local row_mt = set_concept({
  __len      = \s   -> s[_data].nr,
  __index    = \s,i => local data = s[_data]
                       local col = is_number(i) and data[i] or data[data.cidx[i]]
                       if col then return col[s[_idx]] end
                       end,
  __newindex = \s,i,v => local data = s[_data]
                       local col = is_number(i) and data[i] or data[data.cidx[i]]
                       assert(col, "invalid column (write access)")
                       col[s[_idx]] = v
                       end,
  __pairs    = \s   -> (row_iter , s, 0  ),
  __ipairs   = \s   -> (row_iter , s, 0  ),
  __kpairs   = \s   -> (row_kiter, s, nil),
  __tostring = \s   -> string.format("mtable row: %p", s),
}, not_mutable)

-- count proxy
local function cnt_iter (s, i)
  i = i+1
  local ri = s[_idx][i]
  if ri then s[_data][_idx] = ri return i, s[_data] end
end

local cnt_mt = set_concept({
  __len      = \s   -> s[_idx].n,
  __index    = \s,i => local ri = s[_idx][i]
                       if ri then s[_data][_idx] = ri return s[_data] end
                       end,
  __pairs    = \s   -> (cnt_iter, s, 0),
  __ipairs   = \s   -> (cnt_iter, s, 0),
  __tostring = \s   -> string.format("mtable count: %p", s),
}, not_keyrable + not_extendable + not_mutable)

-- iterators over rows
local function rows_iter (row, i)
  i = i+1
  if i <= row[_data].nr then row[_idx] = i ; return i, row end
end

local function ipairs_mm (tbl)
  local row = setmetatable({[_idx]=0, [_data]=var_raw(tbl,_data)}, row_mt)
  return rows_iter, row, 0
end

-- number of rows
local function len_mm (tbl)
  return var_raw(tbl,_data).nr
end

-- read access precedence: row index, variable key, column key, row key.
local function index_mm (tbl, key)
  -- row index
  if is_number(key) then              -- see index_of_idx
    local data = var_raw(tbl,_data)
    local n = data.nr
    if key < 0 then key = n+key+1 end -- reflect
    if key < 1 or key > n then return nil end
    return setmetatable({[_idx]=key, [_data]=data}, row_mt)
  end
  -- variable
  local var = var_raw(tbl, key)
  if var then return var_val(tbl, key, var) end
  -- column name
  local data = var_raw(tbl,_data)
  local idx = data.cidx[key]
  if idx then return data[idx] end -- full column
  -- row name
  local idx = data.ridx[key]
  if is_number(idx) then
    return setmetatable({[_idx]=idx, [_data]=data}, row_mt)
  elseif is_table(idx) then
    return setmetatable({[_idx]=idx, [_data]=
           setmetatable({[_idx]=0  , [_data]=data}, row_mt)}, cnt_mt)
  end
end

local function newindex_mm (tbl, key, val)
  local data = var_raw(tbl,_data)
  -- row index or col/row name
  if is_number(key) or data.cidx[key] or data.ridx[key] then
    error("invalid mtable write access (use 'set' methods)")
  end
  -- variables
  var_set(tbl, key, val)
end

-- readonly protection --------------------------------------------------------o

local function set_readonly (tbl, set_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = raw_get(tbl,_data)
  if set_ ~= false and not tbl:is_readonly() then -- RW -> RO
    for i=1,data.nc-data.ng do
      data[i] = setmetatable({ [_data]=data[i] }, col_mt)
    end
  elseif set_ == false and tbl:is_readonly() then -- RO -> RW
    for i=1,data.nc-data.ng do
      data[i] = data[i][_data]
    end
  end
  return readonly(tbl, set_)
end

-- methods (readonly) ---------------------------------------------------------o

local function name_of (tbl, a, ref_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  if is_integer(a) then return name_of_idx(tbl, a, ref_) end
  error("invalid argument #2 (number expected)")
end

local function index_of (tbl, a, ref_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
      if is_integer(a) then return index_of_idx(tbl, a, ref_)
  elseif is_number (a) then return index_of_num(tbl, a, ref_)
  elseif is_string (a) then return index_of_str(tbl, a, ref_)
  end
  error("invalid argument #2 (number or string expected)")
end

local function range_of (tbl, rng, ref_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local start, stop
  if is_integer(rng) then
    start = index_of_idx(tbl, rng, ref_)
    return start, start
  elseif is_string(rng) then
    local s1, i2 = strsplit(rng, "/" )
    local s2 = i2 > 0 and strtrim(rng, i2+1) or nil
    start, stop = tonumber(s1) or s1, tonumber(s2) or s2
  elseif is_table(rng) then
    start, stop, ref_ = rng[1], rng[2], ref_ or rng[3]
  elseif is_range(rng) then
    start, stop = rng:bounds()
  else error "invalid argument #2 (index, string, table or range expected)"
  end
  ref_ = ref_ or (is_decimal(start) or is_decimal(stop)) and 'spos' or nil
  start = index_of(tbl, start, ref_)
  stop  = stop and index_of(tbl, stop, ref_) or start
  return start, stop
end

local function length_of (tbl, rng_, ntrn_) -- see iter
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local siz = rng_ and 1-sub(range_of(tbl, rng_)) or 0
  return siz + #tbl * ((ntrn_ or 0) + (siz <= 0 and 1 or 0))
end

-- dict helpers ---------------------------------------------------------------o

-- shift indexes >= idx by n
local function shf_idx (data, idx, n)
  if is_nil(data.cref) then return end
  local ridx = data.ridx
  for nam,ei in pairs(ridx) do
    if is_number(ei) then       -- scalar
      if ei >= idx then ridx[nam] = ei+n end
    else for i=1,ei.n do        -- table
      if ei[i] >= idx then ei[i] = ei[i]+n end
    end end
  end
end

-- insert to dictionnary name -> idx (warning: indexes are not shifted)
local function ins_idx (data, idx)
  if is_nil(data.cref) then return end
  local nam = data[data.cref][idx]
  local val = data.ridx[nam]
  if is_nil(val) then             -- none: scalar
    data.ridx[nam] = idx
  elseif is_number(val) then      -- one : scalar to array
    data.ridx[nam] = val > idx and {idx, val, n=2} or {val, idx, n=2}
  else                            -- many: insert
    local i, n = 1, val.n
    while i <= n and idx <= val[i] do i = i+1 end
    while i <= n do val[i], idx, i = idx, val[i], i+1 end
    val.n, val[i] = i, idx
  end
end

-- remove from dictionnary name -> idx (warning: indexes are not shifted)
local function rem_idx (data, idx)
  if is_nil(data.cref) then return end
  local nam = data[data.cref][idx]
  local val = data.ridx[nam]
  if is_number(val) then          -- one : delete
    data.ridx[nam] = nil
  elseif val.n == 2 then          -- two : array to scalar
    data.ridx[nam] = val[1] == idx and val[2] or val[1]
  else                            -- many: remove
    local i, n = 1, val.n
    while idx < val[i] do i = i+1 end
    assert(idx == val[i], "unexpected corrupted dictionnary")
    while i < n do val[i], i = val[i+1], i+1 end
    val.n, val[i] = i-1, nil
  end
end

-- add to dictionnary name -> idx (warning: indexes are not shifted)
local function add_idx (data, idx)
  if is_nil(data.cref) then return end
  local nam = data[data.cref][idx]
  local val = data.ridx[nam]
  if is_nil(val) then             -- none: scalar
    data.ridx[nam] = idx
  elseif is_number(val) then      -- one : scalar to array
    data.ridx[nam] = {val, idx, n=2}
  else                            -- many: append
    local n = val.n+1
    val[n], val.n = idx, n
  end
end

-- build dictionnary name -> idx
local function build_idx (tbl)         -- must be very fast (see add_idx)
  local data = var_raw(tbl,_data)
  if is_nil(data.cref) then return end -- no reference column
  table_clear(data.ridx)               -- reuse main storage
  for i=1,data.nr do add_idx(data, i) end
end

-- memory helpers -------------------------------------------------------------o

-- expand vectors, specialize on 1st row unless nvec[col] is set
local function expand (data, tbl, extra)
  local rmax = ceil(max(tbl.reserve, data.rmax*1.5, data.rmax+extra))
  assert(rmax <= 1e8, "too big mtable") -- should see 'out of memory' first
  local nr, nc, cvec = data.nr, data.nc-data.ng, nil
  for i=1,nc do
    local val, nvec = data[i], data.nvec[i] or data.nvec[data.cidx[i]]
    if is_number(data[i][1]) and not nvec then
      data[i] = vector(rmax)
      data[i].nr, cvec = nr, true
      if nr > 1 then data[i]:copy(val) else data[i][1] = val[1] end
    elseif data.rmax == 1 then -- expand only for 1st row
      data[i] = table_new(rmax,1)
      data[i][1], data[i].nr = val[1], nr
    end
  end
  data.rmax = cvec and rmax or 1e8
end

-- methods (R/W, update dict) -------------------------------------------------o

local function get (tbl, row, col, cnt_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = var_raw(tbl,_data)
  local cidx = is_number(col) and col or data.cidx[col]
  if is_nil(cidx) then return nil end
  if cidx < 0 then cidx = data.nc+cidx+1 end
  local ridx = is_number(row) and row or data.ridx[row]
  if is_table(ridx) then ridx = ridx[cnt_ or 1] end
  if is_nil(ridx) then return nil end
  if ridx < 0 then ridx = data.nr+ridx+1 end
  return ridx >= 1 and ridx <= data.nr and data[cidx][ridx] or nil
end

local function get_col (tbl, key)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local data = var_raw(tbl,_data)
  local idx = is_number(key) and key or data.cidx[key]
  if is_nil(idx) then return nil end
  if idx < 0 then idx = data.nr+idx+1 end
  return data[idx] -- full column data, column generator or nil
end

local function add_col (tbl, key, val, nvec_)
  assert(is_orig_mtable(tbl), "invalid argument #1 (original mtable expected)")
  assert(is_string(key)     , "invalid argument #2 (string expected)")
  local data = raw_get(tbl,_data)
  assert(is_nil(data.cidx[key]), "invalid argument #2 (column name already in use)")
  assert(not tbl:is_readonly(), "invalid modification of readonly mtable")

  if is_callable(val) then     -- generator
    local idx = data.nc+1
    data[idx] = setmetatable({ [_data]=data, [_gen]=val }, gen_mt)
    data.cidx[key], data.cidx[idx], data.ng = idx, key, data.ng+1
  elseif is_iterable(val) then -- iterable
    local idx = data.nc-data.ng+1
    if is_number(val[1]) and not nvec_ then
      table_insert(data, idx, vector(data.rmax):fill(val))
    else
      table_insert(data, idx, table_new(data.rmax,1))
      for i=1,data.nr do data[idx][i] = val[i] end
    end
    data[idx].nr = data.nr
    for k,i in kpairs(data.cidx) do
      if i >= idx then data.cidx[k] = i+1 end
    end
    data.cidx[key] = idx
    table_insert(data.cidx, idx, key)
    if nvec_ and data.nvec ~= data.cidx then data.nvec[key] = true end
  end
  data.nc = data.nc+1
end

local function rem_col (tbl, col)
  assert(is_orig_mtable(tbl), "invalid argument #1 (original mtable expected)")
  local data = var_raw(tbl,_data)
  local idx  = is_number(col) and col or data.cidx[col]
  local key  = data.cidx[idx]
  assert(data.nc-data.ng < idx and idx <= data.nc,
    "invalid argument #2 (generator column expected)")
  assert(not tbl:is_readonly(), "invalid modification of readonly mtable")

  table_remove(data, idx)
  table_remove(data.cidx, idx)
  data.nc, data.ng, data.cidx[key] = data.nc-1, data.ng-1, nil
  for k,i in kpairs(data.cidx) do
    if i > idx then data.cidx[k] = i-1 end
  end
end

local function cpy_row (data, idx, val, i0, nr) -- not exposed
  if val[1] then             -- copy by idx-value
    for i=1,data.nc-data.ng do
      data[i].nr = nr
      data[i][idx] = val[i0+i]
    end
    data[0].nr = nr
    data[0][idx] = true
  else                       -- copy by key-value
    for k,v in pairs(val) do
      local col = is_number(k) and data[k] or data[data.cidx[k]]
      assert(col, "invalid argument #3 (valid column expected)")
      col.nr = nr
      col[idx] = v
    end
  end
end

local function get_row (tbl, key, ref_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local idx = index_of(tbl, key, ref_)
  if is_nil(idx) then return nil end
  return setmetatable({[_idx]=idx, [_data]=var_raw(tbl,_data)}, row_mt)
end

local function add_row (tbl, val, ini_)
  ini_ = ini_ or 1
  assert(is_mtable(tbl)  , "invalid argument #1 (mtable expected)")
  assert(is_iterable(val), "invalid argument #2 (iterable expected)")
  assert(is_number(ini_) , "invalid argument #3 (number expected)")
  local data = var_raw(tbl, _data)
  local idx  = data.nr+1
  if idx > data.rmax then expand(data, tbl, 1) end
  cpy_row(data, idx, val, ini_-1, idx)
  add_idx(data, idx)
  data.nr = idx
  return tbl
end

local function set_row (tbl, key, val, ini_, ref_)
  ini_ = ini_ or 1
  assert(is_mtable(tbl)  , "invalid argument #1 (mtable expected)")
  local idx = index_of(tbl, key, ref_)
  assert(is_number(idx)  , "invalid argument #2 (valid row expected)")
  assert(is_iterable(val), "invalid argument #3 (iterable expected)")
  assert(is_number(ini_) , "invalid argument #4 (number expected)")
  local data = var_raw(tbl, _data)
  rem_idx(data, idx)
  cpy_row(data, idx, val, ini_-1, data.nr)
  ins_idx(data, idx)
  return tbl
end

local function rem_row (tbl, key, ref_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local idx = index_of(tbl, key, ref_)
  assert(is_number(idx), "invalid argument #2 (valid row expected)")
  local data = var_raw(tbl, _data)
  local nr, nc = data.nr, data.nc-data.ng
  for i=0,nc do
    local col = data[i]
    for j=idx,nr-1 do col[j] = col[j+1] end
    col.nr = col.nr-1
  end
  data.nr =data.nr-1
  rem_idx(data, idx)
  shf_idx(data, idx, -1)
  return tbl
end

local function ins_row (tbl, key, val, ini_, ref_)
  ini_ = ini_ or 1
  assert(is_mtable(tbl)  , "invalid argument #1 (mtable expected)")
  local idx = index_of(tbl, key, ref_)
  assert(is_number(idx)  , "invalid argument #2 (valid row expected)")
  assert(is_iterable(val), "invalid argument #3 (iterable expected)")
  assert(is_number(ini_) , "invalid argument #4 (number expected)")
  local data = var_raw(tbl, _data)
  local nr, nc = data.nr, data.nc-data.ng
  if nr+1 > data.rmax then expand(data, tbl, 1) end
  for i=0,nc do
    local col = data[i]
    col.nr = col.nr+1
    for j=nr,idx,-1 do col[j+1] = col[j] end
  end
  data.nr =data.nr+1
  cpy_row(data, idx, val, ini_-1, data.nr)
  shf_idx(data, idx, 1)
  ins_idx(data, idx)
  return tbl
end

local function swp_row (tbl, key1, key2, ref_)
  assert(is_mtable(tbl) , "invalid argument #1 (mtable expected)")
  local idx1, idx2 = index_of(tbl, key1, ref_), index_of(tbl, key2, ref_)
  assert(is_number(idx1), "invalid argument #2 (valid row expected)")
  assert(is_number(idx2), "invalid argument #3 (valid row expected)")
  if idx1 == idx2 then return tbl end
  local data = var_raw(tbl, _data)
  rem_idx(data, idx1) ; rem_idx(data, idx2)
  for i=0,data.nc-data.ng do
    data[i][idx1], data[i][idx2] = data[i][idx2], data[i][idx1]
  end
  ins_idx(data, idx1) ; ins_idx(data, idx2)
  return tbl
end

-- functional methods ---------------------------------------------------------o -- TODO

local pknd   = \knd,k,  r,i -> knd[i] == k
local psel   = \sel,    r,i -> sel[i] == true
local pnam   = \ref,pat,r,i -> string.match(ref[i], pat) ~= nil
local pand   = \p,p2,   r,i -> p(r,i) and p2(r,i)
local ptrue  = \p,_ ,   r,i -> p(r,i) and true
local pfalse = \p,_ ,   r,i -> p(r,i) or false

local function foreach (tbl, act, rng_, sel_, not_) -- action, range, selection, default
  local f, p
  if is_nil(rng_) and is_rawtable(act) then
    f, rng_ = act.action, act     -- extract action + right shift
  else
    f = act
  end
  if is_nil(sel_) and is_rawtable(rng_) and is_nil(rng_[1]) then
    rng_, sel_ = rng_.range, rng_ -- extract range  + right shift
  end
  if is_nil(not_) and is_boolean(sel_) then
    not_, sel_ = sel_             --                  right shift
  end

  local data = var_raw(tbl, _data)
  if is_rawtable(sel_) then       -- logically and'ed selections
    if is_nil(not_) and (sel_.default == 'none' or sel_.default == true) then
      not_ = true
    end
    local op = not_ ~= true and ptrue or pfalse
    if sel_.select then
      assert(is_callable(sel_.select), "invalid select (callable expected)")
      op, p = pand, bind2st(op, sel_.select, p)
    end
    if sel_.pattern then
      assert(is_string(sel_.pattern), "invalid pattern (string expected)")
      assert(data.cref, "unexpected pattern selection (no reference column)")
      op, p = pand, bind2st(op, bind2st(pnam,data[data.cref], sel_.pattern), p)
    end
    if sel_.kind then
      assert(is_string(sel_.kind), "invalid kind (string expected)")
      assert(data.cidx.kind, "unexpected 'kind' selection (no 'kind' column)")
      op, p = pand, bind2st(op, bind2st(pknd,data[data.cidx.kind], sel_.kind),p)
    end
    if sel_.selected then
      op, p = pand, bind2st(op, bind1st(psel, data[0]), p)
    end
  elseif not is_nil(sel_) then    -- build the selection
    p = is_boolean (sel_) and bind1st(psel, data[0])               or
        is_string  (sel_) and assert(data.cref, "unexpected pattern selection (no reference column)")
                          and bind2st(pnam, data[data.cref], sel_) or
        is_callable(sel_) and sel_                                 or nil
  end
  if is_nil(p) then p = not_ ~= true and ltrue or lfalse end

  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  assert(is_callable(f), "invalid argument #2 (callable expected)")
  assert(is_callable(p), "invalid argument #4 (callable expected)")

  if p ~= lfalse then
    for idx,row in tbl:iter(rng_) do
      if p(row,idx) then f(row,idx) end
    end
  end
  return tbl
end

local do_select = \sel,_,i => sel[i] = true end

local function select (tbl, rng_, sel_, not_)
  local f = bind1st(do_select, var_raw(tbl,_data)[0])
  return tbl:foreach(f, rng_, sel_, not_)
end

local do_deselect = \sel,_,i => sel[i] = false end

local function deselect (tbl, rng_, sel_, not_)
  local f = bind1st(do_deselect, var_raw(tbl,_data)[0])
  return tbl:foreach(f, rng_, sel_, not_)
end

local do_filter = \idx,_,i => local n=idx.n+1 ; idx[n], idx.n = i, n end

local function filter (tbl, rng_, sel_, not_)
  local idx = table_new(8,1)
  local f = bind1st(do_filter, idx)
  idx.n = 0
  tbl:foreach(f, rng_, sel_, not_)
  return idx
end

-- methods (R/W, rebuild dict) ------------------------------------------------o -- TODO

local function build_index (tbl, key_)
  assert(is_orig_mtable(tbl), "invalid argument #1 (original mtable expected)")
  if key_ then -- change reference column
    local data = var_raw(tbl, _data)
    local idx = is_number(key_) and key_ or data.cidx[key_]
    assert(data[idx] or key_ == 'none', "invalid argument #2 (valid column expected)")
    data.cref = idx  -- key_ = 'none' disable index
  end
  build_idx  (tbl)
  finish_mtbl(tbl)
  return tbl
end

local function remove (tbl, rng_, sel_)
  assert(is_orig_mtable(tbl), "invalid argument #1 (original mtable expected)")

  -- collect indexes of elements to remove
  local idx_r = filter(tbl, rng_, sel_, true)
  local nr = idx_r.n
  if nr == 0 then return end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- move rows by increasing indexes
  local data = raw_get(tbl,_data)
  local j, nc = 0, data.nc-data.ng
  for ii=idx_r[1],data.nr-nr do
    if ii == idx_r[j+1] then j = j+1 end
    for i=0,nc do data[i][ii] = data[i][ii+j] end
  end
  data.nr = data.nr - nr
  for i=0,nc do data[i].nr = data.nr end
  assert(j == nr, "unexpected corrupted move of rows (remove)")

  build_index(tbl)
  return tbl
end

local function insert (tbl, rows, rng_, sel_)
  assert(is_orig_mtable(tbl), "invalid argument #1 (original mtable expected)")

  -- collect indexes of elements to remove
  local idx_r = filter(tbl, rng_, sel_, true)
  local nr = idx_r.n
  if nr == 0 then return end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- expand if needed
  local data = raw_get(tbl,_data)
  if data.nr+nr > data.rmax then expand(data, tbl, nr) end

  -- move rows by decreasing indexes
  local j, nc = nr, data.nc-data.ng
  data.nr = data.nr + nr
  for i=0,nc do data[i].nr = data.nr end
  for ii=data.nr,idx_r[1],-1 do
    if ii == idx_r[j] then
      for i=0,nc do data[i][ii] = rows[j][i] end
      j = j-1
    else
      for i=0,nc do data[i][ii] = data[i][ii-j] end
    end
  end
  assert(j == 0, "unexpected corrupted move of rows (insert)")

  build_index(tbl)
  return tbl
end

local function sort (tbl, cmp, rng_, sel_)
  assert(is_orig_mtable(tbl), "invalid argument #1 (original mtable expected)")
  assert(is_callable(cmp)   , "invalid argument #2 (callable expected)")

  -- collect indexes of elements to remove
  local idx_r = filter(tbl, rng_, sel_)
  local nr = idx_r.n
  if nr == 0 then return end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  -- sort indexes (indirectly)
  local data  = raw_get(tbl,_data)
  local row1  = setmetatable({[_idx]=0, [_data]=data}, row_mt)
  local row2  = setmetatable({[_idx]=0, [_data]=data}, row_mt)
  local idx_s = table.copy(idx_r, table_new(nr,0))
  table.sort(idx_s, \i1,i2 => row1[_idx], row2[_idx] = idx_s[i1], idx_s[i2]
                              return cmp(row1,row2) end)

  -- build lookup table
  local idx_l = table_new(0,nr)
  for i=1,nr do idx_l[idx_s[i]] = idx_r[i] end

  -- sort rows
  local nc = data.nc-data.ng
  local tmp = table_new(nc,0)
  for ii=1,nr do
    local s, r = idx_s[ii], idx_l[idx_s[ii]]
    if s == r then -- identity (cleanup)
      idx_l[s] = nil
    elseif r then  -- not yet processed
      local ts = s
      for i=1,nc do tmp[i] = data[i][s] end
      while r ~= ts do
        for i=1,nc do data[i][s] = data[i][r] end
        s, r, idx_l[s] = r, idx_l[r]
      end
      for i=1,nc do data[i][s] = tmp[i] end
      idx_l[s] = nil
    end
  end
  assert(is_nil(next(idx_l)), "unexpected corrupted lookup indexes (sort)")

  build_index(tbl)
  return tbl
end

local function copy (tbl, name_)
  assert(not rawequal(tbl, mtable), "invalid argument #1 (cannot copy 'mtable')")
  assert(is_mtable(tbl)           , "invalid argument #1 (mtable expected)")
  local cpy  = tbl_cpy(tbl,name_)
  local data = raw_get(tbl,_data)
  if not data then return cpy end -- tbl is not an original table

  local nr, nc, ng = data.nr, data.nc, data.ng
  local cdat = table_new(nc, 8) -- see mtbl_init
  cdat.ridx  = table_new( 0,nr)  -- name -> idx
  cdat.cidx  = table_new(nc,nc)  -- name -> idx and idx -> name
  cdat.nr    = nr                -- #rows
  cdat.nc    = nc                -- #cols
  cdat.ng    = ng                -- #gens
  cdat.rmax  = nr                -- allocated rows
  cdat.cref  = data.cref         -- reference column (if any)
  cdat.nvec  = {}                -- don't use vectors for columns

  table.copy(data.cidx, cdat.cidx)

  if  data.nvec == data.cidx
  then cdat.nvec = cdat.cidx
  else cdat.nvec = table.copy(data.nvec)
  end

  for i=0,nc-ng do                              -- copy data columns
    cdat[i] = is_table(data[i]) and table_new(nr,1) or vector(nr)
    for j=1,nr do cdat[i][j] = data[i][j] end
    cdat[i].nr = nr
  end
  for i=nc-ng+1,nc do                           -- copy generators
    cdat[i] = setmetatable({ [_data]=cdat, [_gen]=data[i][_gen] }, gen_mt)
  end

  cpy[_data] = cdat
  build_index(cpy)
  return cpy
end

-- special --------------------------------------------------------------------o

local function cycle (tbl, a)
  assert(is_mtable(tbl)  , "invalid argument #1 (mtable expected)")
  assert(index_of(tbl, a), "invalid argument #2 (reference expected)")
  tbl.start_at = a
  return tbl
end

-- iterators ------------------------------------------------------------------o

local function fwditer (state, i)
  if i == state.stop then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end
  i = i < state.n and i+1 or 1
  state.row[_idx] = i
  return i, state.row
end

local function bwditer (state, i)
  if i == state.stop then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end
  i = i > 1 and i-1 or state.n
  state.row[_idx] = i
  return i, state.row
end

local function iter (tbl, rng_, ntrn_, dir_)
  local nturn, dir = ntrn_ or 0, dir_ or 1
  assert(is_mtable(tbl)                  ,"invalid argument #1 (mtable expected)")
  assert(is_number(nturn) and nturn >= 0 ,"invalid argument #3 (number expected)")
  assert(is_number(dir) and abs(dir) == 1,"invalid argument #4 (direction expected)")

  local start, stop
  if is_nil(rng_) then
    local s0, sn = 1, #tbl
    if dir < 0 then s0, sn = sn, s0 end
    if is_nil(tbl.start_at) then
      start, stop = s0, sn
    else
      start = assert(index_of(tbl, tbl.start_at), "invalid cycle reference")
      stop  = start == s0 and sn or start-dir
    end
  else
    start, stop = range_of(tbl, rng_)
    assert(is_number(start), "invalid range start")
    assert(is_number(stop ), "invalid range stop" )
  end
  if start == stop+dir then nturn = nturn+1 end

  local row = setmetatable({[_idx]=0, [_data]=var_raw(tbl,_data)}, row_mt)
  return dir > 0 and fwditer or bwditer,
         { row=row, n=#tbl, stop=stop, turn=nturn }, start-dir
end

-- I/O methods ----------------------------------------------------------------o

local function write (tbl, filnam_, colnam_, hdrnam_)
  if is_table(filnam_) and is_nil(hdrnam_) then
    filnam_, colnam_, hdrnam_ = nil, filnam_, colnam_ -- right shift
  end
  local data = var_raw(tbl,_data)
  local fnam = filnam_ or tbl.name
  local cnam = colnam_ or tbl.column or data.cidx
  local hnam = hdrnam_ or tbl.header
  local nrow = data.nr
  local ncol = #cnam
  local cols = table_new(ncol, 0)

  -- collect column
  for i=1,ncol do
    local idx = is_number(cnam[i]) and cnam[i] or data.cidx[cnam[i]]
    cols[i] = assert(data[idx], "invalid column name or index")
  end

  -- open file
  local file = fnam
  if is_string(fnam) then
    if strsub(fnam,-4) ~= '.tfs' then fnam = fnam .. '.tfs' end
    file = assert(io.open(fnam, 'w'))
  end
  assert(io.type(file) == 'file', "invalid argument #2 (open file expected)")

  -- dump header
  for i=1,#hnam do
    local k, v = hnam[i], tbl[hnam[i]]
    if is_string(v) then
      if k == 'type' and v == '' then v = tbl.kind end -- to review
      fprintf(file, '@ %-18s %%%02ds %q\n', k, #v, v)
    elseif is_number(v) then
      fprintf(file, '@ %-18s %%le %s\n', k, tostring(v))
    else
      fprintf(file, '@ %-18s %%? %s\n', k, tostring(v))
    end
  end

  if ncol > 0 then
    local fmt, v
    -- dump col names
    file:write('*')
    fmt = ' %-17s '
    for i=1,ncol do
      if i == ncol then fmt = ' %s\n' end
      fprintf(file, fmt, cnam[i])
    end

    -- dump col types
    file:write('$')
    fmt = ' %-17s '
    for i=1,ncol do
      local v = cols[i][1]
      local s = is_string(v) and '%s' or is_number(v) and '%le' or '%?'
      if i == ncol then fmt = ' %s\n' end
      fprintf(file, fmt, s)
    end

    -- dump rows
    for j=1,nrow do
      if data[0][j] then -- is_selected
        file:write(' ')
        for i=1,ncol-1 do
          v = cols[i][j]
          if is_string(v) then v = string.format("%q", v) end
          fprintf(file, '%-18s ', tostring(v))
        end
        v = cols[ncol][j]
        if is_string(v) then v = string.format("%q", v) end
        file:write(tostring(v), '\n')
      end
    end
  end

  file:close()
  return tbl
end

local function read (tbl, filnam_)
  assert(is_mtable(tbl), "invalid argument #1 (mtable expected)")
  local quote, splitall in string
  local fnam = filnam_ or tbl.name
  local hnam = table.new(8,8)
  local cnam = nil
  local ncol = 0
  local row  = {n=0}
  local ln   = 0

  -- open file
  local file = fnam
  if is_string(fnam) then
    if strsub(fnam,-4) ~= '.tfs' then fnam = fnam .. '.tfs' end
    file = assert(io.open(fnam, 'r'))
  end
  assert(io.type(file) == 'file', "invalid argument #2 (open file expected)")

  -- read header
  for line in file:lines() do
    ln = ln+1
    row, ncol = splitall(line, " \t", nil, row)
    if row[1] == '@' then
      if ncol ~= 4 then
        error("invalid header format (4 columns expected at line "..ln..")")
      end
      hnam[#hnam+1], hnam[row[2]] = row[2], tonumber(row[4]) or quote(row[4])
    elseif row[1] == '*' then -- col names
      cnam, row.n = table.new(ncol-1,0), ncol-1
      for i=1,ncol-1 do cnam[i] = row[i+1] end
    elseif row[1] == '$' then -- col types (discarded)
      break
    end
  end

  assert(hnam.type == tbl.type or tbl.type == '' and hnam.type == tbl.kind,
         "invalid parent table (kinds differ)") -- to review

  -- create table from header
  for i,v in ipairs(hnam) do
    cnam[v], hnam[v] = hnam[v], nil
  end
  tbl = tbl(hnam.name, cnam) -- inherit from tbl
  tbl.header, hnam.n = hnam, nil

  -- read and add rows
  for line in file:lines() do
    ln = ln+1
    row, ncol = splitall(line, " \t", nil, row)
    if row.n ~= ncol then
      error("invalid row format (".. (row.n-ncol) ..
            " missing columns at line ".. ln ..")")
    end
    for i=1,ncol do -- convert to numbers or remove quotes (if any)
      row[i] = row[i] ~= 'nil' and (tonumber(row[i]) or quote(row[i])) or nil
    end
    tbl:addrow(row)
  end

  -- build index with column 'name' (if any)
  if tbl:getcol 'name' then
    tbl:build_index 'name'
  end

  file:close()
  return tbl
end

-- members --------------------------------------------------------------------o

mtable.original = original

mtable: set_methods {
  get           = get,

  -- columns manipulation
  getcol        = get_col,
  addcol        = add_col,
  remcol        = rem_col,

  -- rows manipulation
  getrow        = get_row,
  addrow        = add_row,
  setrow        = set_row,
  remrow        = rem_row,
  insrow        = ins_row,
  swprow        = swp_row,

  -- sequence-like methods
  name_of       = name_of,
  index_of      = index_of,
  range_of      = range_of,
  length_of     = length_of,

  foreach       = foreach,
  select        = select,
  deselect      = deselect,
  filter        = filter,

  remove        = remove,
  insert        = insert,
  sort          = sort,
  copy          = copy,

  cycle         = cycle,

  iter          = iter,

  -- read/write
  read          = read,
  write         = write,

  -- readonly
  set_readonly  = set_readonly,

  -- index dict
  build_index = build_index,

  -- disabled methods
  is_selected  := error("invalid mtable operation", 2),

}: set_metamethods ({
  __add         = add_row,
  __len         = len_mm,
  __index       = index_mm,
  __newindex    = newindex_mm,
-- __pairs      = pairs_mm, default from Object
  __ipairs      = ipairs_mm,
-- __kpairs     = kpairs_mm, default from Object

  __copy        = copy,
  __init        = mtbl_init,

}, true): set_readonly()

-- env ------------------------------------------------------------------------o

MAD.typeid.is_mtable          = is_mtable
MAD.typeid.is_original_mtable = is_orig_mtable

-- end ------------------------------------------------------------------------o
return {
  mtable = mtable,
  __help = require 'madh_mtable',
}

--[[ 'High level table access is very slow!
code A:
t0=os.clock()
do
  local a, t = 0, MAD.mtable 'mytable' { {'name'}, 'x', 'y', 'z' }
  t=t+{'A', 1.1,1.2,1.3}+{'B', 2.1,2.2,2.3}+{'A', 3.1,3.2,3.3}
  for i=1,1e7 do a=a+t.B.x end
  print('a=',a)
end
print('time=',os.clock()-t0)
time= 1.14

code B:
t0=os.clock()
do
  local a, t = 0, MAD.mtable 'mytable' { {'name'}, 'x', 'y', 'z' }
  t=t+{'A', 1.1,1.2,1.3}+{'B', 2.1,2.2,2.3}+{'A', 3.1,3.2,3.3}
  for i=1,1e7 do a=a+t.x[2] end
  print('a=',a)
end
print('time=',os.clock()-t0)
time= 1.14

Output code A:
building dict:  1
a=  21000000.000896
time= 1.14
changing t.B.x by t[2].x
time= 1.14
changing t.B.x by t.x[2]
time= 0.012
]]
