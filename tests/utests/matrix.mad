--[=[
 o-----------------------------------------------------------------------------o
 |
 | Matrix module regression tests - real matrices
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the matrix module.

 o-----------------------------------------------------------------------------o
]=]

local complex, range, nrange, nlogrange, vector, cvector, matrix,
      cmatrix, linspace, logspace, totable, tostring, concat     in MAD
local assertEquals, assertAlmostEquals, assertInf, assertFalse,
      assertNotEquals, assertErrorMsgContains, assertNaN,
      assertIsString, assertTrue, assertAllAlmostEquals          in MAD.utest
local is_vector, is_matrix, is_cvector, is_cmatrix, isa_vector,
      is_nil, isa_matrix, is_table, is_cdata, is_string          in MAD.typeid
local sqrt, abs, log, exp, min, random, randomseed, floor, round,
      sin, cos, tan, sinh, cosh, tanh, asin, acos, atan, asinh,
      acosh, atanh                                               in MAD.gmath
local chain, duplicate                                           in MAD.fun
local rep                                                        in MAD.utility

local eps, tiny, huge, inf, nan, pi                              in MAD.constant

local infi = complex(0,inf)

-- locals ---------------------------------------------------------------------o

local dat = require 'matrix_dat'
local mth = \f,s,... s[f](s,...)
local idx = \i,j,nc ( (i-1)*nc+j )

local errMat = matrix(2)

local G  = {}
G.matidx = {}
G.mattmp = {}
G.size   = {}
G.vi     = {}
G.vj     = {}

for nr=1,5 do
  G.vi[nr] = vector(nr):fill(1..nr)
  G.vj[nr] = vector(nr):fill(1..nr)
  for nc=1,5 do
    G.matidx[#G.matidx+1] = matrix(nr,nc):fill(1..nr*nc)
    G.mattmp[#G.mattmp+1] = matrix(nr,nc)
    G.size  [#G.size+1]   = {nr,nc}
  end
end

randomseed( os.clock() )

-- regression test suites -----------------------------------------------------o

TestMatrix    = {}
TestMatrixErr = {}

TestMatrixGet = {}
TestMatrixSet = {}

TestMatrixInPlace   = {}
TestMatrixInPlaceII = {}
TestMatrixFun       = {}

TestMatrixSMaps  = {}
TestMatrixSFolds = {}
TestMatrixSScans = {}

TestMatrixSympl  = {}
TestMatrixLinAlg = {}
TestMatrixOps    = {}
TestMatrixLapack = {}
TestMatrixFFT    = {}
TestMatrixRot    = {}
TestMatrixConv   = {}

function TestMatrixErr:testCtor()
  local msg = {
  "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
   "matrix is too large",
  }
  assertErrorMsgContains( msg[1], matrix, ''     )
  assertErrorMsgContains( msg[1], matrix, nil    )
  assertErrorMsgContains( msg[1], matrix, 0      )
  assertErrorMsgContains( msg[1], matrix, tiny   )
  assertErrorMsgContains( msg[1], matrix, eps    )
  assertErrorMsgContains( msg[1], matrix, 1..2   )
  assertErrorMsgContains( msg[1], matrix, infi   )
  assertErrorMsgContains( msg[1], matrix, nan    )
  assertErrorMsgContains( msg[1], matrix,-1      )
  assertErrorMsgContains( msg[1], matrix,-eps    )
  assertErrorMsgContains( msg[2], matrix, inf    )
  assertErrorMsgContains( msg[2], matrix, huge   )
  assertErrorMsgContains( msg[2], matrix, 2^15+1 )
  assertErrorMsgContains( msg[2], vector, 2^30+1 )
end

function TestMatrix:testCtor()
  --assertTrue( is_matrix( vector(2^(30-1))) )
  --assertTrue( is_matrix( matrix(2^(15-1))) )
  --collectgarbage()
  for i,m in ipairs(G.matidx) do
    local mn, nr, nc = m:size(), m:sizes()
    for i=1,mn do
      assertEquals( m.data[i-1], i )
    end
    assertTrue( is_matrix(m) )
    if nc==1 then
      assertTrue  ( is_vector(m) )
      assertEquals( nc, 1 )
    else
    assertEquals( nr, G.size[i][1] )
    assertEquals( nc, G.size[i][2] )
    end
  end
end

function TestMatrixErr:testCtorFromtable()
  local msg = {
  "invalid argument #1 (non-empty table expected)",
  "cannot convert 'string' to 'double'"           ,
  }
  assertErrorMsgContains( msg[1],  matrix, {nil} )
  assertErrorMsgContains( msg[2],  matrix, {''}  )
end

function TestMatrix:testCtorFromtable()
  local v = vector{1,2,3,4,5,6}
  local m = matrix{{1,2,3},{4,5,6}}
  for i=1,m:size() do assertEquals( m.data[i-1], i ) end
  for i=1,v:size() do assertEquals( v.data[i-1], i ) end
  assertTrue  ( is_matrix( matrix{2}            ) )
  assertTrue  ( is_vector( matrix{2}            ) )
  assertTrue  ( is_matrix( matrix{complex(0,0)} ) )
  assertEquals( matrix{complex(0,0)},  matrix(1)  ) -- complex/real matrix
  assertEquals( matrix{complex(0,0)}, cmatrix(1)  )
end

function TestMatrix:testCdataType()
  local m, v = matrix(2), vector(2)
  assertTrue ( is_matrix ( m ) )
  assertTrue ( is_matrix ( v ) )
  assertFalse( is_vector ( m ) )
  assertTrue ( is_vector ( v ) )
  assertFalse( is_cmatrix( m ) )
  assertFalse( is_cmatrix( v ) )
  assertFalse( is_cvector( m ) )
  assertFalse( is_cvector( v ) )
  assertFalse( isa_vector( m ) )
  assertTrue ( isa_vector( v ) )
  assertTrue ( isa_matrix( m ) )
  assertTrue ( isa_matrix( v ) )
end

function TestMatrixErr:testLinspace()
  local msg = {
    "invalid argument #1 (finite scalar expected)"  ,
    "invalid argument #2 (finite scalar expected)"  ,
    "invalid argument #3 (positive number expected)",
    "bad argument #1 to 'ceil'"                     ,
    "matrix is too large"                           ,
  }
  assertErrorMsgContains( msg[1], linspace, nil            )
  assertErrorMsgContains( msg[1], linspace, nil, 2         )
  assertErrorMsgContains( msg[1], linspace, '' , 2         )
  assertErrorMsgContains( msg[1], linspace, nan, 2         )
  assertErrorMsgContains( msg[1], linspace, inf, 2         )
  assertErrorMsgContains( msg[1], linspace,-inf, 2         )
  assertErrorMsgContains( msg[2], linspace, 2  , ''        )
  assertErrorMsgContains( msg[2], linspace, 2  , 1..2      )
  assertErrorMsgContains( msg[2], linspace, 2  , nan       )
  assertErrorMsgContains( msg[2], linspace, 2  , inf       )
  assertErrorMsgContains( msg[2], linspace, 2  ,-inf       )
  assertErrorMsgContains( msg[2], linspace, 2  , 1..2      )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  , 0    )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  ,-1    )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  , nan  )
  assertErrorMsgContains( msg[5], linspace, 2  , 2  , inf  )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  ,-inf  )
  assertErrorMsgContains( msg[4], linspace, 2  , 2  , ''   )
  assertErrorMsgContains( msg[4], linspace, 2  , 2  , 1..2 )
end

function TestMatrix:testLinspace()
  local nrng, l, nr = {
        { 1 , 10, 100}, { 1, 10, 100}, { 10, 1 , 10}, { 1,-10, 10},
        { 10,-1 , 100}, {-1, 10, 100}, {-10, 1 , 10}, {-1,-10, 10},
        {-10,-1 , 100},
        }
  assertTrue  (  is_vector (linspace(1,1))          )
  assertTrue  (  is_cvector(linspace(complex(1,1))) )

  assertEquals(  linspace( 1 )           [1]  , 0            )
  assertEquals(  linspace( 1 )           [100], 1            )
  assertEquals(  linspace( 2, 2, nil)    [1]  , 2            )
  assertEquals(  linspace( 2, 2, nil)    [100], 2            )
  assertEquals( #linspace( 2, 2, nil)         , 100          )
  assertEquals(  linspace( complex(1,1) )[100], complex(1,1) )
  assertEquals(  linspace( complex(1,1) )[1]  , complex(0,0) )
  nr = nrange  ( 0.5, 1 , 1000 )
  l  = linspace( 0.5, 1 , 1000 )
  assertEquals ( l[1]   , nr[1]    )
  assertEquals ( l[1000], nr[1000] )

  for _,v in ipairs(nrng) do
    nr = nrange  ( v[1], v[2], v[3] )
    l  = linspace( v[1], v[2], v[3] )
    for i=1,#nr do
      assertEquals( l[i] - nr[i], 0 )
    end
    nr = nrange  ( v[1], v[2], v[3] )
    l  = linspace( complex(v[1],v[1]), complex(v[2],v[2]), v[3] )
    for i=1,#nr do
      assertAlmostEquals( l[i]:real() - complex(nr[i],nr[i]):real() , 0, eps )
      assertAlmostEquals( l[i]:imag() - complex(nr[i],nr[i]):imag() , 0, eps )
    end
  end
end

function TestMatrixErr:testLogspace()
  local msg = {
    "invalid argument #1 (positive finite number expected)",
    "invalid argument #2 (positive finite number expected)",
    "invalid argument #3 (positive number expected)"       ,
    "bad argument #1 to 'ceil'"                            ,
  }
  assertErrorMsgContains( msg[1], logspace, 0               )
  assertErrorMsgContains( msg[1], logspace, nil             )
  assertErrorMsgContains( msg[1], logspace, nil , 1         )
  assertErrorMsgContains( msg[1], logspace, ''  , 1         )
  assertErrorMsgContains( msg[1], logspace, 1..2, 2         )
  assertErrorMsgContains( msg[1], logspace, nan , 2         )
  assertErrorMsgContains( msg[1], logspace, inf , 2         )
  assertErrorMsgContains( msg[1], logspace,-inf , 2         )
  assertErrorMsgContains( msg[2], logspace, 1   , ''        )
  assertErrorMsgContains( msg[2], logspace, 2   , 1..2      )
  assertErrorMsgContains( msg[2], logspace, 2   , nan       )
  assertErrorMsgContains( msg[2], logspace, 2   , inf       )
  assertErrorMsgContains( msg[2], logspace, 2   ,-inf       )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  ,-1    )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  , 0    )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  , nan  )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  ,-inf  )
  assertErrorMsgContains( msg[4], logspace, 2   , 2  , ''   )
  assertErrorMsgContains( msg[4], logspace, 2   , 2  , 1..2 )
end

function TestMatrix:testLogspace()
  local nlrng, nr, l =  { { 10^5, 1, 100 }, { 1, 10^5, 100 }, { 1, 10^-5, 100 }, }
  assertTrue  ( is_vector (logspace(1,1))          )
  assertTrue  ( is_cvector(logspace(complex(1,1))) )

  assertEquals      ( logspace( 1 )           [1]                               , 1        )
  assertEquals      ( logspace( 1 )           [100]                             , 1        )
  assertEquals      ( logspace( 2, 2, nil)    [1]                               , 2        )
  assertEquals      ( logspace( 2, 2, nil)    [100]                             , 2        )
  assertEquals      (#logspace( 2, 2, nil)                                      , 100      )
  assertAlmostEquals( logspace( 0.1 )         [100]        - 0.1                , 0  , eps )
  assertAlmostEquals( logspace( complex(1,1) )[100]:real() - complex(1,1):real(), 0  , eps )
  assertAlmostEquals( logspace( complex(1,1) )[100]:imag() - complex(1,1):imag(), 0  , eps )

  for _,v in ipairs(nlrng) do
    nr = nlogrange  ( v[1], v[2], v[3] )
    l  = logspace( v[1], v[2], v[3] )
    for i=1,#nr do
      assertEquals( l[i] - nr[i], 0 )
    end
    nr = nrange  ( v[1], v[2], v[3] )
    l  = linspace( complex(v[1],v[1]), complex(v[2],v[2]), v[3] )
    for i=1,#nr do
      assertAlmostEquals( l[i]:real() - complex(nr[i],nr[i]):real(), 0, eps )
      assertAlmostEquals( l[i]:imag() - complex(nr[i],nr[i]):imag(), 0, eps )
    end
  end
end

-- get, set, same -------------------------------------------------------------o

function TestMatrixSet:setUp()
  for _,m in ipairs(G.mattmp) do m:zeros() end
  for _,m in ipairs(G.matidx) do m:fill(1..m:size()) end
end

function TestMatrixSet:tearDown()
  for _,m in ipairs(G.mattmp) do m:zeros() end
  for _,m in ipairs(G.matidx) do m:fill(1..m:size()) end
end

function TestMatrixErr:testGeti0()
    local msg = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'geti0', errMat, nil )
end

function TestMatrixGet:testGeti0()
  for _,m in ipairs(G.matidx) do
    for i=1,m:size() do assertEquals( m:geti0(i-1), i ) end
  end
end

function TestMatrixErr:testGeti()
  local msg = {
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'geti', errMat, nil )
end

function TestMatrixGet:testGeti()
  for _,m in ipairs(G.matidx) do
    for i=1,m:size() do assertEquals( m:geti(i), i ) end
  end
end

function TestMatrixErr:testGet0()
  local msg = {
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'get0', errMat, 0  , nil )
  assertErrorMsgContains( msg[1], mth, 'get0', errMat, nil, 0   )
end

function TestMatrixGet:testGet0()
  for _,m in ipairs(G.matidx) do
    local nr, nc = m:sizes()
    for i=1,nr do
    for j=1,nc do
      assertEquals( m:get0(i-1,j-1), idx(i,j,nc) )
    end end
  end
end

function TestMatrixErr:testGet()
  local msg = {
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'get0', errMat, 1  , nil )
  assertErrorMsgContains( msg[1], mth, 'get0', errMat, nil, 1   )
end

function TestMatrixGet:testGet()
  for _,m in ipairs(G.matidx) do
    local nr, nc = m:sizes()
    for i=1,nr do
    for j=1,nc do
      assertEquals( m:get(i,j), idx(i,j,nc) )
    end end
  end
end

function TestMatrixErr:testSeti0()
  local msg = {
    "0-based index out of bounds"       ,
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'seti0', errMat, nan  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', errMat,-1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', errMat,-eps  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', errMat, 4    , 1 )
  assertErrorMsgContains( msg[2], mth, 'seti0', errMat, nil  , 1 )
end

function TestMatrixSet:testSeti0()
  for _,m in ipairs(G.mattmp) do
    for i=1,m:size() do
      m:seti0((i-1), i)
      assertEquals( m:geti0(i-1), i )
    end
  end
  local m = G.matidx[25]
  m:seti0( 0, complex(1,1) )
  assertFalse( is_cmatrix( m ) )
end

function TestMatrixErr:testSeti()
  local msg = {
    "index out of bounds"               ,
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'seti', errMat, nan  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', errMat, 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', errMat, 1-eps, 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', errMat, 5    , 1 )
  assertErrorMsgContains( msg[2], mth, 'seti', errMat, nil  , 1 )
end


function TestMatrixSet:testSeti()
  for _,m in ipairs(G.mattmp) do
    for i=1,m:size() do
      m:seti((i), i)
      assertEquals( m:geti(i), i )
    end
  end
  local m = G.matidx[25]
  m:seti( 1, complex(1,1) )
  assertFalse( is_cmatrix( m ) )
end

function TestMatrixErr:testSet0()
  local msg = {
    "0-based index out of bounds"       ,
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], errMat.set0, errMat, nan  , 1    , 1 )
  assertErrorMsgContains( msg[1], errMat.set0, errMat,-1    , 0    , 1 )
  assertErrorMsgContains( msg[1], errMat.set0, errMat,-1+eps, 0    , 1 )
  assertErrorMsgContains( msg[1], errMat.set0, errMat, 0    ,-1+eps, 1 )
  assertErrorMsgContains( msg[1], errMat.set0, errMat, 2    , 1    , 1 )
  assertErrorMsgContains( msg[1], errMat.set0, errMat, 1    , 2    , 1 )
  assertErrorMsgContains( msg[2], errMat.set0, errMat, nil  , 1    , 1 )
  assertErrorMsgContains( msg[2], errMat.set0, errMat, 1    , nil  , 1 )
end

function TestMatrixSet:testSet0()
  for _,m in ipairs(G.mattmp) do
    local nr, nc = m:sizes()
    for i=1,nr do
    for j=1,nc do
      m:set0( i-1,j-1, idx(i,j,nc) )
      assertEquals( m:get0(i-1,j-1), idx(i,j,nc) )
    end end
  end
  local m = G.matidx[25]
  m:set0( 0, 0, complex(1,1) )
  assertFalse( is_cmatrix( m ) )
end

function TestMatrixErr:testSet()
  local msg = {
    "index out of bounds"               ,
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], errMat.set, errMat, nan  , 1    , 1 )
  assertErrorMsgContains( msg[1], errMat.set, errMat, 0    , 1    , 1 )
  assertErrorMsgContains( msg[1], errMat.set, errMat, 1    , 0    , 1 )
  assertErrorMsgContains( msg[1], errMat.set, errMat, 1-eps, 1    , 1 )
  assertErrorMsgContains( msg[1], errMat.set, errMat, 1    , 1-eps, 1 )
  assertErrorMsgContains( msg[2], errMat.set, errMat, nil  , 1    , 1 )
end

function TestMatrixSet:testSet()
  for _,m in ipairs(G.mattmp) do
    local nr, nc = m:sizes()
    for i=1,nr do
    for j=1,nc do
      m:set( i, j, idx(i,j,nc) )
      assertEquals( m:get(i,j), idx(i,j,nc) )
    end end
  end
  local m = G.matidx[25]
  m:set( 1, 1, complex(1,1) )
  assertFalse( is_cmatrix( m ) )
end

function TestMatrixErr:testSame()
  local msg, s = {
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
    "invalid argument #1 (non-empty table expected)"                           ,
    "invalid argument #2 (nil or scalar expected)"                             ,
  }
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1   , ''      )
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1   , 1..2    )
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1   , nan     )
  assertErrorMsgContains( msg[2], mth, 'same', errMat, 1   , {}      )
  assertErrorMsgContains( msg[3], mth, 'same', errMat, ''  , 2   , 2 )
  assertErrorMsgContains( msg[3], mth, 'same', errMat, 1..2, 2   , 2 )
end

function TestMatrixSet:testSame()
  local m, _ = matrix(2)
  assertEquals( m:same( nan), matrix(m:sizes()) )
  assertEquals( m:same( inf), matrix(m:sizes()) )
  assertEquals( m:same( 0  ), matrix(m:sizes()) )
  for i,m in ipairs(G.matidx) do
    --                   e ,nr,nc
    assertEquals( m:same(        ),  matrix(m:sizes())          ) -- 1) x:same(               )
    assertEquals( m:same(0i      ), cmatrix(m:sizes())          ) -- 5) x:same(   e           )
    -- two arg: nr, nc
    assertEquals( m:same(2 , 2   ),  matrix(2)                  ) -- 4')x:same( nr , nc       )
    assertEquals( m:same(6 , 5   ),  matrix(6,5)                )
    assertEquals( m:same(_ , 2 ,2),  matrix(2)                  ) -- 4) x:same( nil, nr , nc  )
    -- three arg: e_, nr, nc
    assertEquals( m:same(0i, 2, 2), cmatrix(2)                  ) -- 8) x:same(   e, nr , nc  )
    assertEquals( m:same(1 , 2, 2),  matrix(2)                  )
    -- one size defined
    assertEquals( m:same(_ , 1   ),  matrix(1       , m:ncol()) ) -- 2) x:same( nil, nr       )
    assertEquals( m:same(_ , _, 1),  matrix(m:nrow(), 1       ) ) -- 3) x:same( nil, nil, nc  )
    assertEquals( m:same(0i, _, 1), cmatrix(m:nrow(), 1       ) ) -- 7) x:same(   e, nil, nc  )
  end
end

-- getx, setx -----------------------------------------------------------------o

function TestMatrixErr:testGetsub()
  local C = complex(1,1)
  local msg = {
    "invalid argument #2 (iterable expected)"                                  ,
    "invalid argument #3 (iterable expected)"                                  ,
    "invalid argument #4 (iterable expected)"                                  ,
    "invalid range member '1'"                                                 ,
    "cannot convert 'nil' to 'double'"                                         ,
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'getsub', errMat, nil              )
  assertErrorMsgContains( msg[1], mth, 'getsub', errMat, ''               )
  assertErrorMsgContains( msg[1], mth, 'getsub', errMat, \x x             )
  assertErrorMsgContains( msg[1], mth, 'getsub', errMat, C                )
  assertErrorMsgContains( msg[2], mth, 'getsub', errMat, 1   , nil        )
  assertErrorMsgContains( msg[2], mth, 'getsub', errMat, 1   , ''         )
  assertErrorMsgContains( msg[2], mth, 'getsub', errMat, 1   , \x x       )
  assertErrorMsgContains( msg[3], mth, 'getsub', errMat, 0   , 0   , 1    )
  assertErrorMsgContains( msg[3], mth, 'getsub', errMat, 1   , 1   , \x x )
  assertErrorMsgContains( msg[4], mth, 'getsub', errMat, 1   , 1   , 1..4 )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, 0   , 0          )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, 0   , 1          )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, 1   , 0          )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, 3   , 1          )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, 1   , 3          )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, {0}       , 1    )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, vector(1) , 1    )
  assertErrorMsgContains( msg[6], mth, 'getsub', errMat, 2..1      , 1    )
end

function TestMatrixGet:testGetsub()
  local m, r = G.matidx[25]
  assertEquals( m:getsub(2,2          ):geti(1) , m:get(2,2) )
  assertEquals( m:getsub(2,2,{}       )[1]      , m:get(2,2) )
  assertEquals( m:getsub(2,2,vector(2)):get(1,1), m:get(2,2) )
  assertEquals( m:getsub(2,2,vector(2)):get(2,1), 0          )
  r = m:getsub( 1..2, 1..3) for i=1,2 do for j=1,3 do assertEquals( r:get(i,j), idx(i,j,5) ) end end
  r = m:getsub({1}  ,{1,2}) for i=1,1 do for j=1,2 do assertEquals( r:get(i,j), idx(i,j,5) ) end end

  for _,m in ipairs(G.matidx) do    -- 25  (all shapes over 5x5)
    local nr, nc = m:sizes()
    for li=1,nr do                  -- 625 (all sub-shapes over 5x5)
    for lj=1,nc do
      local vi, vj = G.vi[li], G.vj[lj]
      vi:shuffle(); vj:shuffle()
      local r = m:getsub(vi, vj)
      for i=1,li do
      for j=1,lj do
        assertEquals( r:get(i,j), m:get(vi[i], vj[j]) )
      end end
    end end
  end
end

function TestMatrixErr:testSetsub()
  local C = complex(1,1)
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (iterable expected)"          ,
    "invalid argument #4 (scalar or iterable expected)",
    "index out of bounds"                              ,
    "cannot convert 'nil' to 'double'"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'setsub', errMat, nil , 1  , 1   )
  assertErrorMsgContains( msg[1], mth, 'setsub', errMat, ''  , 1  , 1   )
  assertErrorMsgContains( msg[1], mth, 'setsub', errMat, \x x, 1  , 1   )
  assertErrorMsgContains( msg[2], mth, 'setsub', errMat, 1              )
  assertErrorMsgContains( msg[2], mth, 'setsub', errMat, 1   , nil, 1   )
  assertErrorMsgContains( msg[2], mth, 'setsub', errMat, 1   , '' , 1   )
  assertErrorMsgContains( msg[3], mth, 'setsub', errMat, 1   , 1  , nil )
  assertErrorMsgContains( msg[3], mth, 'setsub', errMat, 1   , 1  , ''  )
  assertErrorMsgContains( msg[4], mth, 'setsub', errMat, nan , 1  , 1   )
  assertErrorMsgContains( msg[4], mth, 'setsub', errMat, 1   , nan, 1   )
  assertErrorMsgContains( msg[4], mth, 'setsub', errMat, 0   , 1  , 1   )
  assertErrorMsgContains( msg[4], mth, 'setsub', errMat, 1   , 0  , 1   )
  assertErrorMsgContains( msg[1], mth, 'setsub', errMat, C   , 1  , 1   )
  assertErrorMsgContains( msg[2], mth, 'setsub', errMat, 1   , C  , 1   )
end

function TestMatrixSet:testSetsub()
  local m = G.mattmp[25]
  m:setsub( 1..5, 1, {1,1,1,1,1}) assertEquals( m:getsub( 1..5, 1   ), m:same(5,1):fill(1)    )
                                  assertEquals( m:getsub( 1..5, 2..5), m:same(5,4)            )
  m:setsub( 1..5, 1, 1..5       ) assertEquals( m:getsub( 1..5, 1   ), m:same(5,1):fill(1..5) )
                                  assertEquals( m:getsub( 1..5, 2..5), m:same(5,4)            )
  m:setsub( 1..5, 1..5, 1       ) assertEquals( m:getsub( 1..5, 1..5), m:same(5,5):fill(1)    )
  m:zeros()
-- recycling
  m:setsub( 1..5, 1   , {1,1}   ) assertEquals( m:getsub( 1..5, 1   ), m:same(5,1):fill(1)    )
                                  assertEquals( m:getsub( 1..5, 2..5), m:same(5,4)            )
  m:setsub( 1..5, 1   , 1..3    ) assertEquals( m:getsub( 1..3, 1   ), m:same(3,1):fill(1..3) )
                                  assertEquals( m:getsub( 4..5, 1   ), m:same(2,1):fill(1..2) )
                                  assertEquals( m:getsub( 1..5, 2..5), m:same(5,4)            )
  m:setsub( 1..5, 1..5, 1..5    )
  for i =1,5 do assertEquals( m:getsub( i, 1..5), m:same(1,5):fill(1..5) ) end

  for i,m in ipairs(G.mattmp) do
    local nr, nc = m:sizes()
    for li=1,nr do
    for lj=1,nc do
      local vi, vj = G.vi[li], G.vj[lj]
      m:zeros()
      vi:shuffle(); vj:shuffle()
      m:setsub(vi,vj,duplicate(2))
      assertEquals( m:getsub(vi,vj), matrix(#vi,#vj):fill(2) )
      m:setsub(vi,vj,1..#vi*#vj  )
      if     #vi ~= nr and #vj ~= nc then  assertEquals( m:getsub(1    ..nr, #vj+1..nc), m:same(nr    , nc-#vj) )
                                           assertEquals( m:getsub(#vi+1..nr, 1    ..nc), m:same(nr-#vi, nc    ) )
      elseif #vi == nr and #vj ~= nc then  assertEquals( m:getsub(1    ..nr, #vj+1..nc), m:same(nr    , nc-#vj) )
      elseif #vi ~= nr and #vj == nc then  assertEquals( m:getsub(#vi+1..nr, 1    ..nc), m:same(nr-#vi, nc    ) ) end
      local rset  = m:getsub(vi, vj)
      for i=1,li do
      for j=1,lj do
        assertEquals( rset:get(i,j), idx(i,j,lj) )
      end end
    end end
  end
end

function TestMatrixErr:testGetv()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'double"        ,
    "invalid range member '1'"               ,
  }
  assertErrorMsgContains( msg[1], mth, 'getv', errMat, nil             )
  assertErrorMsgContains( msg[1], mth, 'getv', errMat, ''              )
  assertErrorMsgContains( msg[2], mth, 'getv', errMat, 1        , ''   )
  assertErrorMsgContains( msg[2], mth, 'getv', errMat, 1        , 1    )
  assertErrorMsgContains( msg[2], mth, 'getv', errMat, 1        , \x x )
  assertErrorMsgContains( msg[3], mth, 'getv', errMat, nan             )
  assertErrorMsgContains( msg[3], mth, 'getv', errMat, 0               )
  assertErrorMsgContains( msg[4], mth, 'getv', errMat, 1        , 1..2 )
  assertErrorMsgContains( msg[3], mth, 'getv', errMat, matrix(2)       )
end

function TestMatrixGet:testGetv()
  local m = matrix(4):fill(1..16)
  assertEquals( m:getv(1   , {}       ), {1}                  )
  assertEquals( m:getv(1   , vector(2)), vector{1,0}          )
  assertEquals( m:getv(1..2           ), vector(2):fill(1..2) )
  assertEquals( m:getv({1,2}          ), vector(2):fill(1..2) )

  for _,m in ipairs(G.matidx) do
    local mn, nr, nc = m:size(), m:sizes()
    for j=1,mn do assertEquals( m:getv(j), vector{j} ) end
    for li=1,nr do
      local vi = G.vi[li]:copy()
      vi:random(nil,1,mn):shuffle()
      assertEquals( m:getv(vi), vi )
    end
  end
  m:getv(1..5,'in') assertEquals( m, matrix(4):fill(1..16) ) -- same output - to documentation
end

function TestMatrixErr:testSetv()
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
    "invalid argument #3 (scalar or callable expected)",
    "index out of bounds"  ,
  }
  assertErrorMsgContains( msg[1], mth, 'setv', errMat, nil , 0          )
  assertErrorMsgContains( msg[1], mth, 'setv', errMat, ''  , 0          )
  assertErrorMsgContains( msg[1], mth, 'setv', errMat, \x x, 0          )
  assertErrorMsgContains( msg[2], mth, 'setv', errMat, 1   , ''         )
  assertErrorMsgContains( msg[2], mth, 'setv', errMat, 1   , nil        )
  assertErrorMsgContains( msg[2], mth, 'setv', errMat, 1   , \x x       )
  assertErrorMsgContains( msg[3], mth, 'setv', errMat, 1   , nil , 1, 1 )
  assertErrorMsgContains( msg[4], mth, 'setv', errMat, nan , 0          )
end

function TestMatrixSet:testSetv()
  local m = G.mattmp[25]
  m:setv(1..5, 1          ) assertEquals( m:getv(1..5 ), m:same(5 ,1):fill(1   ) )
                            assertEquals( m:getv(6..25), m:same(20,1)            )
  m:setv(1..5, 1..5       ) assertEquals( m:getv(1..5 ), m:same(5 ,1):fill(1..5) )
                            assertEquals( m:getv(6..25), m:same(20,1)            )
  m:setv(1..5, {0,0,0,0,0}) assertEquals( m            , m:same(5   )            )
-- recycling
  m:setv(1..6, 1..3       ) assertEquals( m:getv(1..3 ), m:same(3 ,1):fill(1..3) )
                            assertEquals( m:getv(4..6 ), m:same(3 ,1):fill(1..3) )
  m:setv(1..6, 1..7       ) assertEquals( m:getv(1..6 ), m:same(6 ,1):fill(1..6) )
                            assertEquals( m:getv(7    ), m:same(1 ,1)            )

  for _,m in ipairs(G.mattmp) do
    local nr, nc = m:sizes()
    for j=1,m:size() do
      m:setv(j,j)
      assertEquals( m:getv(j), vector{j} )
    end
    for li=1,nr do
      local vi = G.vi[li]
      vi:shuffle()
      local mt = m:getv(vi)
      m:setv(vi, 1..li)
      assertEquals( m:getv(vi), vi:same(li):fill(1..li) )
      m:setv(vi, duplicate(li) )
      assertEquals( m:getv(vi), vi:same(li):fill(li) )
      m:setv(vi, mt   )
    end
  end
end

function TestMatrixErr:testGetdiag()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid range member '1'"               ,
  }
  assertErrorMsgContains( msg[1], mth, 'getdiag', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'getdiag', errMat, \x x )
  assertErrorMsgContains( msg[1], mth, 'getdiag', errMat, 1    )
  assertErrorMsgContains( msg[2], mth, 'getdiag', errMat, 1..2 )
end

function TestMatrixGet:testGetdiag()
  for _,m in ipairs(G.matidx) do
    local nr, nc = m:sizes()
    local n , d  = min(nr,nc), m:getdiag()
    assertEquals( {d:sizes()}, {n,1} )
    for i=1,n do assertEquals( d[i], m:get(i,i) ) end
  end
end

function TestMatrixErr:testSetdiag()
  local msg = {
    "invalid argument #2 (scalar or iterable expected)",
    "invalid argument #2 (scalar or callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'setdiag', errMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'setdiag', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'setdiag', errMat, \x x      )
  assertErrorMsgContains( msg[2], mth, 'setdiag', errMat, nil, 1, 1 )
end

function TestMatrixSet:testSetdiag()
  for _,m in ipairs(G.mattmp) do
    local nr, nc = m:sizes()
    local n = min(nr,nc)
    for i=1,n do
      local ra = 1..i
      m:setdiag(ra)
      local d = m:getdiag()
      assertEquals( {m:getdiag():sizes()}, {n,1} )
      for i=1,n do assertEquals( d[i], m:get(i,i) ) end
    end
    m:setdiag(duplicate(2))
    assertEquals( m:getdiag(), vector(n):fill(2) )
  end
  local m = G.mattmp[25]
  m:setdiag(1..3)                 assertEquals( m:getdiag(), vector{1,2,3,1,2} ) -- recycling
  m:setdiag(1..6)                 assertEquals( m:getdiag(), vector{1,2,3,4,5} ) -- recycling
  m:setdiag(chain({3,1},{5,4,3})) assertEquals( m:getdiag(), vector{3,1,5,4,3} )
end

function TestMatrixErr:testGetrow()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'double'"       ,
    "invalid range member '1'"               ,
    "index out of bounds"                    ,
  }
  assertErrorMsgContains( msg[1], mth, 'getrow', errMat, ''              )
  assertErrorMsgContains( msg[1], mth, 'getrow', errMat, nil             )
  assertErrorMsgContains( msg[1], mth, 'getrow', errMat, \x x            )
  assertErrorMsgContains( msg[2], mth, 'getrow', errMat, 1   , ''        )
  assertErrorMsgContains( msg[2], mth, 'getrow', errMat, 1   , 1         )
  assertErrorMsgContains( msg[3], mth, 'getrow', errMat, nan             )
  assertErrorMsgContains( msg[3], mth, 'getrow', errMat, 0               )
  assertErrorMsgContains( msg[3], mth, 'getrow', errMat, 5               )
  assertErrorMsgContains( msg[4], mth, 'getrow', errMat, 1   , 1..2      )
  assertErrorMsgContains( msg[5], mth, 'getrow', errMat, 1   , vector(1) )
end

function TestMatrixGet:testGetrow()
  for _,m in ipairs(G.matidx) do
    local nr, nc = m:sizes()
    for i=1,nr do
    for a=1,i  do
      for li=1,i-a+1 do
        local ra = a..i..li
        assertEquals( m:getrow(ra), m:getsub(ra, 1..nc) )
      end
    end end
  end
end

function TestMatrixErr:testSetrow()
  local m = matrix(3)
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
    "invalid argument #3 (scalar or callable expected)",
    "index out of bounds"                              ,
    "cannot convert 'nil' to 'double'"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'setrow', errMat, ''               )
  assertErrorMsgContains( msg[1], mth, 'setrow', errMat, nil              )
  assertErrorMsgContains( msg[1], mth, 'setrow', errMat, \x x             )
  assertErrorMsgContains( msg[2], mth, 'setrow', errMat, nan              )
  assertErrorMsgContains( msg[2], mth, 'setrow', errMat, 1   , nil        )
  assertErrorMsgContains( msg[3], mth, 'setrow', errMat, 1   , nil, 1, 1  )
  assertErrorMsgContains( msg[2], mth, 'setrow', errMat, 1   , ''         )
  assertErrorMsgContains( msg[4], mth, 'setrow', errMat, 0   , 1          )
  assertErrorMsgContains( msg[4], mth, 'setrow', errMat, 3   , 1          )
end

function TestMatrixSet:testSetrow()
  local m = G.mattmp[25]
  m:setrow(1, 1)           assertEquals( m:getrow(1   ), m:same(1,5):fill(1)    )
                           assertEquals( m:getrow(2..5), m:same(4,5)            )
  m:setrow(1, 1..5)        assertEquals( m:getrow(1   ), m:same(1,5):fill(1..5) )
                           assertEquals( m:getrow(2..5), m:same(4,5)            )
  m:setrow(1, {0,0,0,0,0}) assertEquals( m:getrow(1..5), m:same(5,5)            )
-- recycling
  m:setrow(1, 1..3)        assertEquals( m:getrow(1   ), m:same(1,5):fill({1,2,3,1,2}) )
                           assertEquals( m:getrow(2..5), m:same(4,5)                   )
  m:setrow(1, {0} )        assertEquals( m:getrow(1..5), m:same(5,5)                   )

  for _,m in ipairs(G.mattmp) do
    local nr, nc = m:sizes()
    for i=1,nr do
    for a=1,i  do
      for li=1,i-a+1 do
        local ra = a..i..li
        local r = 1..nc*#ra
        m:setrow(ra,r)
        for ii=1,#ra do
        for jj=1,nc  do
          assertEquals( m:getrow(ra):get(ii,jj), idx(ii,jj,nc) )
        end end
        m:setrow(ra,duplicate(2))
        for ii=1,#ra do
          assertEquals( m:getrow(ra[ii]), vector(nc):fill(2):t() )
        end
        m:setrow(ra,0)
      end
    end end
  end
end

function TestMatrixErr:testGetcol()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'double'"       ,
    "invalid range member '1'"               ,
    "index out of bounds"                    ,
  }
  assertErrorMsgContains( msg[1], mth, 'getcol', errMat, ''              )
  assertErrorMsgContains( msg[1], mth, 'getcol', errMat, nil             )
  assertErrorMsgContains( msg[1], mth, 'getcol', errMat, \x x            )
  assertErrorMsgContains( msg[2], mth, 'getcol', errMat, 1   , ''        )
  assertErrorMsgContains( msg[2], mth, 'getcol', errMat, 1   , 1         )
  assertErrorMsgContains( msg[3], mth, 'getcol', errMat, nan             )
  assertErrorMsgContains( msg[3], mth, 'getcol', errMat, 0               )
  assertErrorMsgContains( msg[3], mth, 'getcol', errMat, 3               )
  assertErrorMsgContains( msg[4], mth, 'getcol', errMat, 1   , 1..2      )
  assertErrorMsgContains( msg[5], mth, 'getcol', errMat, 1   , vector(1) )
end

function TestMatrixGet:testGetcol()
  local m = G.matidx[25]
  assertEquals( m:getcol({1,2}          ), m:getsub(1..5,{1,2}    ) )
  assertEquals( m:getcol(vector{1,2}    ), m:getsub(1..5,{1,2}    ) )
  assertEquals( m:getcol(vector{1}  , {}), m:getsub(1..5,{1}  , {}) )

  for _,m in ipairs(G.matidx) do
    local nr, nc = m:sizes()
    for j=1,nc do
    for b=1,j  do
      for lj = 1,j-b+1 do
        local rb = b..j..lj
        assertEquals( m:getcol(rb) , m:getsub(1..nr,rb) )
      end
    end end
  end
end

function TestMatrixErr:testSetcol()
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
    "invalid argument #3 (scalar or callable expected)",
    "index out of bounds"                              ,
    "cannot convert 'nil' to 'double'"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'setcol', errMat, ''               )
  assertErrorMsgContains( msg[1], mth, 'setcol', errMat, nil              )
  assertErrorMsgContains( msg[1], mth, 'setcol', errMat, \x x             )
  assertErrorMsgContains( msg[2], mth, 'setcol', errMat, nan              )
  assertErrorMsgContains( msg[2], mth, 'setcol', errMat, 1   ,  ''        )
  assertErrorMsgContains( msg[2], mth, 'setcol', errMat, 1   ,  nil       )
  assertErrorMsgContains( msg[3], mth, 'setcol', errMat, 1   ,  nil, 1, 1 )
  assertErrorMsgContains( msg[4], mth, 'setcol', errMat, 0   ,  1         )
  assertErrorMsgContains( msg[4], mth, 'setcol', errMat, 3   ,  1         )
end

function TestMatrixSet:testSetcol()
  local m = G.mattmp[25]
  m:setcol(1, 1)           assertEquals( m:getcol(1   ), m:same(5,1):fill(1   )        )
                           assertEquals( m:getcol(2..5), m:same(5,4)                   )
  m:setcol(1, 1..5)        assertEquals( m:getcol(1   ), m:same(5,1):fill(1..5)        )
                           assertEquals( m:getcol(2..5), m:same(5,4)                   )
  m:setcol(1, {0,0,0,0,0}) assertEquals( m:getcol(1..5), m:same(5,5)                   )
-- recycling
  m:setcol(1, 1..3)        assertEquals( m:getcol(1   ), m:same(5,1):fill({1,2,3,1,2}) )
                           assertEquals( m:getcol(2..5), m:same(5,4)                   )
  m:setcol(1, {0} )        assertEquals( m:getcol(1..5), m:same(5,5)                   )
  for _,m in ipairs(G.mattmp) do
    local nr, nc = m:sizes()
    for j=1,nc do
    for b=1,j  do
      for lj = 1,j-b+1 do
        local rb = b..j..lj
        local r = 1..nr*#rb
        m:setcol(rb,r)
        for ii=1,nr  do
        for jj=1,#rb do
          assertEquals( m:getcol(rb):get(ii,jj), idx(jj,ii,nr) )
        end end
        m:setcol(rb,duplicate(2))
        for ii=1,#rb do
          assertEquals( m:getcol(rb[ii]), vector(nr):fill(2) )
        end
        m:setcol(rb,0)
      end
    end end
  end
end

-- size -----------------------------------------------------------------------o

function TestMatrix:testNrow()
  for i,m in ipairs(G.matidx) do
    assertEquals( m:nrow(), G.size[i][1] )
  end
end

function TestMatrix:testNcol()
  for i,m in ipairs(G.matidx) do
    assertEquals( m:ncol(), G.size[i][2] )
  end
end

function TestMatrix:testSize()
  for i,m in ipairs(G.matidx) do
    assertEquals( m:size(), G.size[i][1]*G.size[i][2] )
  end
end

function TestMatrix:testSizes()
  for i,m in ipairs(G.matidx) do
    assertEquals( {m:sizes()}, G.size[i] )
  end
end

function TestMatrix:testTsizes()
  for i,m in ipairs(G.matidx) do
    assertEquals( {m:tsizes()}, {G.size[i][2], G.size[i][1]} )
  end
end

-- in place -------------------------------------------------------------------o

function TestMatrixInPlace:setUp()
  for _,m in ipairs(G.matidx) do m:fill(1..m:size()) end
end

function TestMatrixInPlace:tearDown()
  for _,m in ipairs(G.matidx) do m:fill(1..m:size()) end
end

function TestMatrixErr:testRandom()
  local msg, s = {
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
    "invalid argument #1 (non-empty table expected)"                           ,
  }
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1, ''   )
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1, nan  )
  assertErrorMsgContains( msg[2], mth, 'same', errMat, 1, {}   )
end

function TestMatrixInPlace:testRandom()
  for _,m in ipairs(G.matidx) do
    local mn = m:size()
    local oldVal, val = table.new(mn,0), table.new(mn,0)
    oldVal[0] = 1
    m:random()
    for i = 1,mn do
      val[i] = m:geti(i)
      assertTrue ( val[i] <  1    )
      assertTrue ( val[i] >= 0    )
      assertFalse( val[i] == oldVal[i-1] )
      oldVal[i] = val[i]
    end
    m:random(nil,1,mn)
    for i = 1,mn do
      assertTrue ( m:geti(i) <= mn )
      assertTrue ( m:geti(i) >= 1  )
    end
  end
end

function TestMatrixInPlaceII:testShuffle()
  local oldV = {}
  local v = vector(25):fill(1..25)
  oldV[0] = 0
  for i=1,10 do
    v = v:shuffle()
    for is=1,v:size() do
      assertTrue( v:geti(is) <= 25 )
      assertTrue( v:geti(is) >= 1  )
    end
    assertFalse( v == oldV[i-1] )
    oldV[i] = v:copy()
  end
end

function TestMatrixErr:testFill()
  local msg = {
    "invalid argument #2 (scalar, callable or iterable expected)",
    "incompatible container size"                                ,
    "invalid container (iterable expected)"                      ,
  }
  assertErrorMsgContains( msg[1], mth,'fill', errMat, nil  )
  assertErrorMsgContains( msg[1], mth,'fill', errMat, true )
  assertErrorMsgContains( msg[1], mth,'fill', errMat, ''   )
  assertErrorMsgContains( msg[2], mth,'fill', errMat, {}   )
end

function TestMatrixInPlace:testFill()
  for _,m in ipairs(G.matidx) do
    local mn = m:size()
    --scalar
    m:fill(nan)               for i=1,mn do assertNaN   ( m:geti(i)      ) end
    m:fill(inf)               for i=1,mn do assertInf   ( m:geti(i)      ) end
    m:fill(1  )               for i=1,mn do assertEquals( m:geti(i), 1   ) end
    m:fill(complex(1,1))      for i=1,mn do assertEquals( m:geti(i), 1   ) end
    --generator
    m:fill(1..mn)             for i=1,mn do assertEquals( m:geti(i), i   ) end
    m:fill\x x^2              for i=1,mn do assertEquals( m:geti(i), i^2 ) end
    --2D container
    m:fill( m:same() )        for i=1,mn do assertEquals( m:geti(i), 0   ) end
    --1D container
    local t={} for i=1,mn do t[i]=i end
    m:fill(t)                 for i=1,mn do assertEquals( m:geti(i), i   ) end
    m:fill(vector(mn))        for i=1,mn do assertEquals( m:geti(i), 0   ) end
    m:fill(duplicate(2))      for i=1,mn do assertEquals( m:geti(i), 2   ) end
  end
  local m, t = matrix(5), {}
  for i=1,5 do t[i] = {}      for j=1,5 do t[i][j]=(i-1)*5+j end end
  m :fill(t)                  for i=1,m:size() do assertEquals( m:geti(i), i ) end
  assertTrue ( is_matrix( m:same():fill(complex(1,1))) ) -- no matrix types change
end

function TestMatrixErr:testCopy()
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth,'copy', errMat, 1          )
  assertErrorMsgContains( msg[1], mth,'copy', errMat, cmatrix(1) )
end

function TestMatrixInPlaceII:testCopy()
  for i,m in ipairs(G.matidx) do
    local mcopy = matrix( m:sizes() )
    mcopy:copy(m)
    assertEquals( m       , mcopy )
    assertEquals( m:copy(), m     )
  end
end

function TestMatrixInPlaceII:testResize()
  local mres, minr, minc, m, m1, _
  for i,m in ipairs(G.matidx) do
    local nr,nc = m:sizes()
    for ic=nc+1,nc+3 do
    for ir=nr+1,nr+3 do
      mres       = m:resize(ir, ic)
      minr, minc = min(nr,ir), min(nc,ic)
      assertEquals( {mres:sizes()}                    , {ir, ic}                    )
      assertEquals( mres:getsub(1..minr   ,1..minc   ), m:getsub(1..minr ,1..minc ) )
      assertEquals( mres:getsub(minr+1..ir,1..minc   ), m:same(_, ir-minr, minc   ) )
      assertEquals( mres:getsub(1..minr   ,minc+1..ic), m:same(_, minr   , ic-minc) )
    end
    end
    for ic=1,nc do
    for ir=1,nr do
      mres       = m:resize(ir, ic)
      minr, minc = min(nr,ir), min(nc,ic)
      assertEquals( {mres:sizes()}, {ir, ic}                  )
      assertEquals( mres          , m:getsub(1..minr,1..minc) )
    end
    end
  end
  m , m1 = matrix(2):fill(1..4), matrix(3)
  mres = m:resize(m1)
  assertEquals({mres:sizes()}          ,{m1:sizes()}           )
  assertEquals( mres:getsub(1..2, 1..2), m :getsub(1..2, 1..2) )
  assertEquals( mres:getsub(3   , 1..3), m1:getsub(3   , 1..3) )
  assertEquals( mres:getsub(1..3, 3   ), m1:getsub(1..3, 3   ) )
end

function TestMatrixInPlace:testZeros()
  for _,m in ipairs(G.matidx) do
    m:zeros()
    assertEquals( m, m:same() )
  end
end

function TestMatrixInPlace:testOnes()
  for _,m in ipairs(G.matidx) do
    m:ones(  ) assertEquals( m, m:same():fill(1) )
    m:ones(2 ) assertEquals( m, m:same():fill(2) )
    m:ones(1i) assertEquals( m, m:same()         )
  end
end

function TestMatrixInPlace:testEye()
  for i,m in ipairs(G.matidx) do
    local nr, nc = m:sizes()
    local min = min(nr,nc)
    m:eye()
    assertEquals( m:getdiag(), m:same(min,1):fill(1) )
    for i=1,nr do
    for j=1,nc do
      if i~=j then assertEquals( m:get(i,j), 0 ) end
    end end
    m:eye(2 ) assertEquals( m:getdiag(), m:same(min,1):fill(2) )
    m:eye(1i) assertEquals( m          , m:same()              )
  end
end

function TestMatrixErr:testSymp()
  local msg = {
    "invalid argument #1 (2n matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth,'symp',  matrix(3)   )
  assertErrorMsgContains( msg[1], mth,'symp',  vector(2)   )
  assertErrorMsgContains( msg[1], mth,'symp',  matrix(4,3) )
end

function TestMatrixInPlaceII:testSymp()
  for i=2,6,2 do
    local m = matrix(i):symp()
    assertTrue( m:t() == -m )
    for ii=1,m:ncol() do
    for jj=1,m:nrow() do
      if     ii==2 and jj==1 then assertEquals( m:get(ii,jj),-1 )
      elseif ii==4 and jj==3 then assertEquals( m:get(ii,jj),-1 )
      elseif ii==6 and jj==5 then assertEquals( m:get(ii,jj),-1 )
      elseif ii==1 and jj==2 then assertEquals( m:get(ii,jj), 1 )
      elseif ii==3 and jj==4 then assertEquals( m:get(ii,jj), 1 )
      elseif ii==5 and jj==6 then assertEquals( m:get(ii,jj), 1 )
      else                        assertEquals( m:get(ii,jj), 0 ) end
    end end
  end
end

function TestMatrixErr:testCirc()
  local msg = {
    "invalid argument #2 (iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth,'circ', errMat, nil  )
  assertErrorMsgContains( msg[1], mth,'circ', errMat, 1    )
  assertErrorMsgContains( msg[1], mth,'circ', errMat, \x x )
end

function TestMatrixInPlaceII:testCirc()
  for i=1,5 do
    local m = matrix(i)
    local t = {} for j=1,i do t[j]=j end
    --'row'
    m:circ(t)
    for j=1,i   do assertEquals( m:get(j  ,j  ), 1   ) end
    for j=1,i-1 do assertEquals( m:get(j+1,j  ), 2   )
                   assertEquals( m:get(j  ,j+1), i   ) end
    for j=1,i-2 do assertEquals( m:get(j+2,j  ), 3   )
                   assertEquals( m:get(j  ,j+2), i-1 ) end
    for j=1,i-3 do assertEquals( m:get(j+3,j  ), 4   )
                   assertEquals( m:get(j  ,j+3), i-2 ) end
    m:fill(0):circ(vector(i):fill(1..i))
    for j=1,i   do assertEquals( m:get(j  ,j  ), 1   ) end
    for j=1,i-1 do assertEquals( m:get(j+1,j  ), 2   )
                   assertEquals( m:get(j  ,j+1), i   ) end
    for j=1,i-2 do assertEquals( m:get(j+2,j  ), 3   )
                   assertEquals( m:get(j  ,j+2), i-1 ) end
    for j=1,i-3 do assertEquals( m:get(j+3,j  ), 4   )
                   assertEquals( m:get(j  ,j+3), i-2 ) end
    --'col'
    m:fill(0):circ(matrix(1,i):fill(1..i))
    for j=1,i   do assertEquals( m:get(j  ,j  ), 1   ) end
    for j=1,i-1 do assertEquals( m:get(j+1,j  ), i   )
                   assertEquals( m:get(j  ,j+1), 2   ) end
    for j=1,i-2 do assertEquals( m:get(j+2,j  ), i-1 )
                   assertEquals( m:get(j  ,j+2), 3   ) end
    for j=1,i-3 do assertEquals( m:get(j+3,j  ), i-2 )
                   assertEquals( m:get(j  ,j+3), 4   ) end
  end
end

function TestMatrixErr:testShiftv()
  local msg = {
    "index out of bound",
  }
  local v = vector(4)

  assertErrorMsgContains( msg[1], mth, 'shiftv', v,  0, 0 )
  assertErrorMsgContains( msg[1], mth, 'shiftv', v, -1, 0 )
  assertErrorMsgContains( msg[1], mth, 'shiftv', v,  5, 0 )
end


function TestMatrixInPlaceII:testShiftv()
  for n=1,6 do
    for i=1,n do
      for j=0,n-i do
        -- left shift
        local v = vector(n):fill(1..n)
        local w = vector(n):fill(1..n)
        v:shiftv(i,-j)
        w:setv(i..n-j, w:getv(i+j..n) )
        assertAllAlmostEquals(totable(v), totable(w))
        -- right shift
        local v = vector(n):fill(1..n)
        local w = vector(n):fill(1..n)
        v:shiftv(i,+j)
        w:setv(i+j..n, w:getv(i..n-j) )
        assertAllAlmostEquals(totable(v), totable(w))
      end
    end
  end
end

function TestMatrixInPlaceII:testRoll()
  local m = vector(4):fill(1..4)
  assertEquals( m:roll( 0  , 0  ), m )
  assertEquals( m:roll( 4  , 0  ), m )
  assertEquals( m:roll( 0  , 1  ), m )
  assertEquals( m:roll( 0  , 2  ), m )
  assertEquals( m:roll( nil, 0  ), m )
  assertEquals( m:roll( 0  , nil), m )
  assertEquals( m:roll( nil, nil), m )

  m = matrix(2):fill(1..4)
  assertEquals( m:roll( 0  , 0  ), m )
  assertEquals( m:roll( 3  , 0  ), m )
  assertEquals( m:roll(-3  , 0  ), m )

  for nr=1,5 do
  for nc=1,5 do
    m = matrix(nr,nc):fill(1..nr*nc)
    for inc=0,nc do
    for inr=0,nr do
      m:roll(inr,inc)
      for jnr=1,nr do
      for jnc=1,nc do
        if     jnc<=inc and jnr<=inr then assertEquals( m:get(jnr,jnc), idx(jnr+(nr-inr),jnc+(nc-inc),nc) )
        elseif jnc<=inc and jnr> inr then assertEquals( m:get(jnr,jnc), idx(jnr-inr     ,jnc+(nc-inc),nc) )
        elseif jnc> inc and jnr<=inr then assertEquals( m:get(jnr,jnc), idx(jnr+(nr-inr),jnc- inc    ,nc) )
        else                              assertEquals( m:get(jnr,jnc), idx(jnr-inr     ,jnc- inc    ,nc) ) end
      end end
      m:roll(-inr,-inc)
    end end
  end end
end

function TestMatrixErr:testReshape()
  local msg = {
    "invalid matrix new sizes",
  }
  assertErrorMsgContains( msg[1], mth,'reshape', errMat, nil, 2 )
  assertErrorMsgContains( msg[1], mth,'reshape', errMat, 0  , 1 )
  assertErrorMsgContains( msg[1], mth,'reshape', errMat, 1  , 0 )
  assertErrorMsgContains( msg[1], mth,'reshape', errMat, 3  , 2 )
  assertErrorMsgContains( msg[1], mth,'reshape', errMat, 1  , 5 )
end

function TestMatrixInPlaceII:testReshape()
  local m
  m = matrix(2,2) assertEquals( {m:reshape() :sizes()}, {4,1} )
  m = matrix(2,2) assertEquals( {m:reshape(1):sizes()}, {1,1} )
  for nr=1,5 do
  for nc=1,5 do
    for i=1,nr do
    for j=1,nc do
      m = matrix(nr,nc):fill(1..nr*nc)
      m:reshape(i,j)
      assertEquals( {m:sizes()}, {i,j}                    )
      assertEquals( m          , matrix(i,j):fill(1..i*j) )
    end end
  end end
end

-- foreach, filter, map, fold, scan -------------------------------------------o

function TestMatrixFun:setUp()
  for _,m in ipairs(G.matidx) do m:fill(1..m:size()) end
end

function TestMatrixFun:tearDown()
  for _,m in ipairs(G.matidx) do m:fill(1..m:size()) end
end

function TestMatrixErr:testForeach()
  local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, 1         )
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, { }       )
end

function TestMatrixFun:testForeach()
  for _,m in ipairs(G.matidx) do
    local nr, nc = m:sizes()
    local t = table.new(nr,nc)
    local f = \x,i,j => t[i][j] = x  end
    for i=0,nr-1 do local c = t[i+1] or table.new(nc,0); t[i+1] = c end
    m:foreach(f)
    for i=1,nr do for j=1,nc do assertEquals( t[i][j], idx(i,j,nc) ) end end
  end
end

function TestMatrixErr:testMap()
  local msg = {
    "invalid argument #2 (callable expected)"                 ,
    "invalid argument #2 (scalar function expected)"          ,
    "invalid argument #3 (iterable expected)"                 ,
    "attempt to perform arithmetic on local 'y' (a nil value)",
    "invalid range member '1'"                                ,
  }
  assertErrorMsgContains( msg[1], mth, 'map', errMat, ''              )
  assertErrorMsgContains( msg[1], mth, 'map', errMat, 1..2            )
  assertErrorMsgContains( msg[1], mth, 'map', errMat, 1               )
  assertErrorMsgContains( msg[1], mth, 'map', errMat, matrix(1)       )
  assertErrorMsgContains( msg[1], mth, 'map', errMat, {}              )
  assertErrorMsgContains( msg[2], mth, 'map', errMat, '!'             )
  assertErrorMsgContains( msg[4], mth, 'map', errMat, '+'             )
  assertErrorMsgContains( msg[3], mth, 'map', errMat, \x x+1   , ''   )
  assertErrorMsgContains( msg[3], mth, 'map', errMat, \x x+1   , 1    )
  assertErrorMsgContains( msg[5], mth, 'map', errMat, \x x+1   , 1..2 )
end

function TestMatrixFun:testMap()
  for i,m in ipairs(G.matidx) do
    local mn, nr, nc = m:size(), m:sizes()
    assertEquals( m:map('~'      ), m:same():fill(-1..-mn..-1) )
    assertEquals( m:map(\x x-x   ), m:same()                   )
    --totable test
    assertEquals( m:map(\x x-x,{}), rep(0    , mn) )
    assertEquals( m:map('!'   ,{}), rep(false, mn) )
    --'in' place test
    m:map('~'   , 'in') assertEquals( m, m:same():fill(-1..-mn..-1) )
    m:map(\x x-x, 'in') assertEquals( m, m:same()                   )
  end
end

function TestMatrixErr:testMap2()
  local m = matrix(1)
  local msg = {
    "invalid argument #2 (scalar or iterable expected)"       ,
    "invalid argument #3 (callable expected)"                 ,
    "invalid argument #3 (scalar function expected)"          ,
    "invalid argument #4 (iterable expected)"                 ,
    "invalid range member '1'"                                ,
    "attempt to perform arithmetic on local 'y' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'map2', errMat, nil               )
  assertErrorMsgContains( msg[1], mth, 'map2', errMat, ''                )
  assertErrorMsgContains( msg[1], mth, 'map2', errMat, \x x              )
  assertErrorMsgContains( msg[2], mth, 'map2', errMat, nan               )
  assertErrorMsgContains( msg[2], mth, 'map2', errMat, m    , nil        )
  assertErrorMsgContains( msg[2], mth, 'map2', errMat, m    , ''         )
  assertErrorMsgContains( msg[2], mth, 'map2', errMat, m    , 1..2       )
  assertErrorMsgContains( msg[2], mth, 'map2', errMat, m    , 1          )
  assertErrorMsgContains( msg[3], mth, 'map2', errMat, m    , '!'        )
  assertErrorMsgContains( msg[4], mth, 'map2', errMat, m    , \x x, 1    )
  assertErrorMsgContains( msg[5], mth, 'map2', errMat, m    , \x x, 1..2 )
  assertErrorMsgContains( msg[6], mth, 'map2', errMat, m    , \x,y  x+y  )
end

function TestMatrixFun:testMap2()
  for _,m in ipairs(G.matidx) do
    local mn, nr, nc = m:size(), m:sizes()
    assertEquals( m:map2(1 , '+'     ), m:same():fill( 2.. mn+1    ) )
    assertEquals( m:map2(1 , \x,y x-y), m:same():fill( 0.. mn-1    ) )
    assertEquals( m:map2(m, '~'      ), m:same():fill(-1..-mn  ..-1) )

    local ir = { m, 1..mn, totable(1..mn) }
    for d=1,#ir do
      assertEquals( m:map2(ir[d], '+'     ), m:same():fill(2..2*mn..2) )
      assertEquals( m:map2(ir[d], \x,y x-y), m:same()                  )
      --totable test
      assertEquals( m:map2(ir[d], '-'   , {}), rep(0    , mn) )
      assertEquals( m:map2(ir[d], '<'   , {}), rep(false, mn) )
      assertEquals( m:map2(m    , '!'   , {}), rep(false, mn) )
    end
    --'in' place test
    for d=1,#ir do
      m:map2(ir[d], '~'     , 'in') for i=1,mn do assertEquals( m:geti(i), i*(-1)^d ) end
    end
      m:map2(m    , \x,y x-y, 'in') assertEquals( m, m:same() )
  end
end

function TestMatrixErr:testMap3()
  local m = matrix(1)
  local msg = {
    "invalid argument #2 (scalar or iterable expected)"       ,
    "invalid argument #3 (scalar or iterable expected)"       ,
    "invalid argument #4 (callable expected)"                 ,
    "invalid argument #4 (scalar function expected)"          ,
    "invalid argument #5 (iterable expected)"                 ,
    "invalid range member '1'"                                ,
    "attempt to perform arithmetic on local 'y' (a nil value)",
    "attempt to perform arithmetic on local 'z' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'map3', errMat, nil                          )
  assertErrorMsgContains( msg[1], mth, 'map3', errMat, ''                           )
  assertErrorMsgContains( msg[1], mth, 'map3', errMat, \x x                         )
  assertErrorMsgContains( msg[2], mth, 'map3', errMat, nan                          )
  assertErrorMsgContains( msg[2], mth, 'map3', errMat, errMat, nil                  )
  assertErrorMsgContains( msg[2], mth, 'map3', errMat, errMat, ''                   )
  assertErrorMsgContains( msg[2], mth, 'map3', errMat, errMat, \x x                 )
  assertErrorMsgContains( msg[3], mth, 'map3', errMat, errMat, nan                  )
  assertErrorMsgContains( msg[3], mth, 'map3', errMat, errMat, errMat, nil          )
  assertErrorMsgContains( msg[3], mth, 'map3', errMat, errMat, errMat, 1..2         )
  assertErrorMsgContains( msg[3], mth, 'map3', errMat, errMat, errMat, 1            )
  assertErrorMsgContains( msg[4], mth, 'map3', errMat, m     , m     , '!'          )
  assertErrorMsgContains( msg[5], mth, 'map3', errMat, errMat, errMat, \x x, 1      )
  assertErrorMsgContains( msg[6], mth, 'map3', errMat, errMat, errMat, \x x, 1..2   )
  assertErrorMsgContains( msg[7], mth, 'map3', errMat, m     , errMat, \x,y,z x+y+z )
  assertErrorMsgContains( msg[7], mth, 'map3', errMat, m     , m     , \x,y,z x+y+z )
  assertErrorMsgContains( msg[8], mth, 'map3', errMat, errMat, m     , \x,y,z x+y+z )
end

function TestMatrixFun:testMap3()
  for _,m1 in ipairs(G.matidx) do
    local mn, nr, nc = m1:size(), m1:sizes()
    assertEquals( m1:map3(m1, m1, '~'             ), m1:same():fill(-1.. -mn..-1) )
    assertEquals( m1:map3(m1, m1, '+'             ), m1:same():fill( 2..2*mn.. 2) )
    assertEquals( m1:map3(m1, m1, \x,y,z x+y+z    ), m1:same():fill( 3..3*mn.. 3) )
    assertEquals( m1:map3(m1, m1, '<'         , {}), rep(false, mn)               )

    local m2 = { m1, 1..mn, totable(1..mn) }
    local m3 = { m1, 1..mn, totable(1..mn) }
    for i=1,#m2 do
    for j=1,#m3 do
      assertEquals( m1:map3(m2[i], m3[j], \x,y,z x+y+z    ), m1:same():fill(3..3*mn..3) )
      assertEquals( m1:map3(m2[i], m3[j], \x,y,z x+y+z, {}),        totable(3..3*mn..3) ) -- totable test
    end end
    --'in' place test
    m1:map3(m1, m1, '~'         , 'in') assertEquals( m1, m1:copy():fill(-1..  -mn..-1) )
    m1:map3(m1, m1, \x,y,z x+y+z, 'in') assertEquals( m1, m1:same():fill(-3..-3*mn..-3) )
  end
end

function TestMatrixErr:testMapij()
  local msg = {
    "invalid argument #2 (callable expected)",
    "invalid argument #3 (iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, nil             )
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, ''              )
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, 1..2            )
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, 1               )
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, matrix(1)       )
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, { }             )
  assertErrorMsgContains( msg[2], mth, 'mapij', errMat, \x x+1   , ''   )
  assertErrorMsgContains( msg[2], mth, 'mapij', errMat, \x x+1   , \x x )
end

function TestMatrixFun:testMapij()
  local m1
  for i,m in ipairs(G.matidx) do
    local mn, nr, nc = m:size(), m:sizes()
    assertEquals( m:mapij('~'       ), m:same():fill(-1..-mn..-1) )
    assertEquals( m:mapij(\x x-x    ), m:same()                   )
    assertEquals( m:mapij('!'   , {}), rep(false, mn)             ) --totable test
    assertEquals( m:mapij(\x x-x, {}), rep(0    , mn)             ) --totable test
    --'in' place test
    m:mapij('~'         , 'in')  assertEquals( m, m:same():fill(-1..-mn..-1) )
    m:mapij(\x x-x      , 'in')  assertEquals( m, m:same()                   )
    m:mapij(\x,i,j i+j  , 'in') for i=1,nr do for j=1,nc do assertEquals( m:get(i,j), i+j             ) end end
    m:fill(1..nr*nc)
    m:mapij(\x,i,j i+j+x, 'in') for i=1,nr do for j=1,nc do assertEquals( m:get(i,j), i+j+idx(i,j,nc) ) end end
    m:fill(1..nr*nc)
    m = m:mapij( \x,i,j => if j>3 then x=3 end return x end, {} )
    for i=1,nr do
    for j=1,nc do
      if j > 3 then assertEquals( m[idx(i,j,nc)], 3           )
               else assertEquals( m[idx(i,j,nc)], idx(i,j,nc) ) end
    end end
  end
end

function TestMatrixErr:testMapat()
  local msg = {
    "invalid argument #2 (callable expected)"                 ,
    "invalid argument #3 (iterable expected)"                 ,
    "invalid argument #4 (iterable expected)"                 ,
    "invalid range member '1'"                                ,
    "attempt to perform arithmetic on local 'x' (a nil value)",
    "attempt to perform arithmetic on local 'y' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, nil                    )
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, ''                     )
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, 1..2                   )
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, 1                      )
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, matrix(1)              )
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, { }                    )
  assertErrorMsgContains( msg[2], mth, 'mapat', errMat, \x x+1   , ''          )
  assertErrorMsgContains( msg[2], mth, 'mapat', errMat, \x x+1   , nil         )
  assertErrorMsgContains( msg[2], mth, 'mapat', errMat, \x x+1   , \x x        )
  assertErrorMsgContains( msg[3], mth, 'mapat', errMat, \x x+1   , 1    , ''   )
  assertErrorMsgContains( msg[3], mth, 'mapat', errMat, \x x+1   , 1    , \x x )
  assertErrorMsgContains( msg[4], mth, 'mapat', errMat, \x x+1   , 1    , 1..2 )
  assertErrorMsgContains( msg[5], mth, 'mapat', errMat, \x x+1   , nan         )
  assertErrorMsgContains( msg[5], mth, 'mapat', errMat, \x x+1   , 0           )
  assertErrorMsgContains( msg[5], mth, 'mapat', errMat, \x x+1   , 5           )
  assertErrorMsgContains( msg[6], mth, 'mapat', errMat, '+'      , 1           )
end

function TestMatrixFun:testMapat()
  for _,m in ipairs(G.matidx) do
    local mn, nr, nc = m:size(), m:sizes()
    for li=1,nr do
      local vi = G.vi[li]:copy()
      for j=1,li do vi[j] = random(1,mn) end
      vi:shuffle()
      assertEquals( m:mapat('~',vi):getv(vi), vector(#vi):fill(-vi) )
      assertEquals( m:mapat('!',vi):getv(vi), vector(#vi):fill( 0)  )
    end
  end
  local m   = G.matidx[5]
  local res = {-1,-2,-3, 4, 5}
  assertEquals   ( m:mapat('~',vector{1,2,3}    ), vector(res):t() )
  assertEquals   ( m:mapat('~',      {1,2,3}    ), vector(res):t() )
  assertAllAlmostEquals( m:mapat('~',vector{1,2,3}, {}), res       )
  res = { 2, 3, 4, 4, 5}
  m:mapat(\x x+1,vector{1,2,3}, 'in') assertEquals( m, vector(res):t() )
end

function TestMatrixErr:testFoldl()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
    "attempt to perform arithmetic on local 'x' (a table value)" ,
  }
  local m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, nil                   )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, nan                   )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, ''                    )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, {}                    )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, 1                     )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, 1..2                  )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, m                     )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, cm                    )
  assertErrorMsgContains( msg[3], mth, 'foldl', errMat, \x x, ''              )
  assertErrorMsgContains( msg[3], mth, 'foldl', errMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', errMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', errMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'foldl', errMat, \x x, 1 , 'vec', ''   )
  assertErrorMsgContains( msg[2], mth, 'foldl', errMat, \x x, 1 , 'vec', 1    )
  assertErrorMsgContains( msg[2], mth, 'foldl', errMat, \x x, 1 , 'vec', \x x )
  assertErrorMsgContains( msg[5], mth, 'foldl', errMat, '+' , {}              )
end
--[[
parameters:
  f: callable, x0: initial value, d: ['vec', 'row', 'col'], r: iterable
  r:{}, cmatrix(2), matrix(2), 1..2

fold cases:
  1) x:fold( f )
  2) x:fold( f, nil, d )      and 2') x:fold( f, d )
  3) x:fold( f, nil, nil, r ) and 3') x:fold( f, r ) and  3") x:fold( f, nil, r)
  4) x:fold( f, nil, d, r )   and 4') x:fold( f, d, r) and  4") x:fold( f, d, nil, r )
  5) x:fold( f, x0 )
  6) x:fold( f, x0 , d )
  7) x:fold( f, x0, nil, r ) and 7') x:fold( f, x0, r )
  8) x:fold( f, x0 , d, r )
]]
local sum = \r =>local x = 0    for i=1,r:size() do x = x + r[i] end return x end
local sub = \r =>local x = r[1] for i=2,r:size() do x = x - r[i] end return x end

function TestMatrixFun:testFoldl()
  local _ = nil
  for i,m in ipairs(G.matidx) do
    local mn, nr, nc = m:size(), m:sizes()
    local s = sum(1..mn)
    --                     f  , x0 , d    , r
    assertEquals( m:foldl(\r r                ) , 1   ) -- 1)
    assertEquals( m:foldl('+' , 2  , nil  , {}) , s+2 ) -- 7)
    assertEquals( m:foldl('+'                 ) , s   ) -- 1)
    assertEquals( m:foldl('+'      , 'vec'    ) , s   ) -- 2)
    assertEquals( m:foldl('+' , nil, 'vec'    ) , s   ) -- 2)
    assertEquals( m:foldl('+'      , 'vec', {}) , s   ) -- 4)
    assertEquals( m:foldl('+' , 2             ) , s+2 ) -- 5)
    assertEquals( m:foldl('+' , 2  , 'vec'    ) , s+2 ) -- 6)
    assertEquals( m:foldl('+' , nil       , {}) , s   ) -- 3)
    assertEquals( m:foldl('+' , nil, nil  , {}) , s   ) -- 3)

    local t ={} for i=1,nc do t [i]=sum(idx(1,i,nc)..idx(nr,i,nc)..nc) end
    local tr={} for i=1,nr do tr[i]=sum(idx(i,1,nc)..idx(i,nc,nc)..1 ) end
    assertEquals         ( m:foldl('+'   , 'col'    ) , matrix(t ):t() ) -- 2)
    assertEquals         ( m:foldl('+'   , 'row'    ) , matrix(tr)     ) -- 2)
    assertEquals         ( m:foldl('+', 0, 'col'    ) , matrix(t ):t() ) -- 6)
    assertEquals         ( m:foldl('+', 0, 'row'    ) , matrix(tr)     ) -- 6)
    assertAllAlmostEquals( m:foldl('+', 0, 'col', {}) , t              ) -- 8)
    assertAllAlmostEquals( m:foldl('+', 0, 'row', {}) , tr             ) -- 8)

  -- non-commutative operations
    local mrefC = m:same(_,1  ):mapij\x,i,j sub(idx(1,j,nc)..idx(nr,j,nc)..nc)
    local mrefR = m:same(_,_,1):mapij\x,i,j sub(idx(i,1,nc)..idx(i,nc,nc)..1 )
    if mn%2 == 0 then assertEquals( m:foldl '~',-1 )
                 else assertEquals( m:foldl '~', 1 ) end
    assertEquals( m:foldl('-'       ) , sub(1..mn) )
    assertEquals( m:foldl('-', 'col') , mrefC      )
    assertEquals( m:foldl('-', 'row') , mrefR      )
  end
  assertEquals( vector(4):fill(4..1..-1):foldl '^', (4^3)^2 )
end

function TestMatrixErr:testFoldr()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  local m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, nil                   )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, nan                   )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, ''                    )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, {}                    )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, 1                     )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, 1..2                  )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, m                     )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, cm                    )
  assertErrorMsgContains( msg[3], mth, 'foldr', errMat, \x x, ''              )
  assertErrorMsgContains( msg[3], mth, 'foldr', errMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', errMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', errMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'foldr', errMat, \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'foldr', errMat, \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'foldr', errMat, \x x, 1 , "vec", \x x )
end

function TestMatrixFun:testFoldr()
  for _,m in ipairs(G.matidx) do
    local mn, nr, nc = m:size(), m:sizes()
    local s = sum(1..mn)
    --                     f  , x0 , d   , r
    assertEquals( m:foldr(\r r               ) , 1   ) -- 1)
    assertEquals( m:foldr('+' , 2 , nil  , {}) , s+2 ) -- 7)
    assertEquals( m:foldr('+'                ) , s   ) -- 1)
    assertEquals( m:foldr('+'     , 'vec'    ) , s   ) -- 2)
    assertEquals( m:foldr('+', nil, 'vec'    ) , s   ) -- 2)
    assertEquals( m:foldr('+'     , 'vec', {}) , s   ) -- 4)
    assertEquals( m:foldr('+', 2             ) , s+2 ) -- 5)
    assertEquals( m:foldr('+', 2  , 'vec'    ) , s+2 ) -- 6)
    assertEquals( m:foldr('+', nil       , {}) , s   ) -- 3)
    assertEquals( m:foldr('+', nil, nil  , {}) , s   ) -- 3)

    local t ={} for i=1,nc do t [i]=sum(idx(1,i,nc)..idx(nr,i,nc)..nc) end
    local tr={} for i=1,nr do tr[i]=sum(idx(i,1,nc)..idx(i,nc,nc)..1 ) end
    assertEquals         ( m:foldr('+'   , 'col'    ) , matrix(t ):t() ) -- 2)
    assertEquals         ( m:foldr('+'   , 'row'    ) , matrix(tr)     ) -- 2)
    assertEquals         ( m:foldr('+', 0, 'col'    ) , matrix(t ):t() ) -- 6)
    assertEquals         ( m:foldr('+', 0, 'row'    ) , matrix(tr)     ) -- 6)
    assertAllAlmostEquals( m:foldr('+', 0, 'col', {}) , t              ) -- 8)
    assertAllAlmostEquals( m:foldr('+', 0, 'row', {}) , tr             ) -- 8)

  -- non-commutative operations
    local mrefC = m:same(_,1 ,nc):mapij\x,i,j sum(idx(1,j,nc)..idx(nr,j,nc)..2*nc) - sum(idx(2,j,nc)..idx(nr,j,nc)..2*nc)
    local mrefR = m:same(_,nr,1 ):mapij\x,i,j sum(idx(i,1,nc)..idx(i,nc,nc)..2   ) - sum(idx(i,2,nc)..idx(i,nc,nc)..2   )
    local v = vector( m:size() ):fill(1..m:size()):map(\x => if x%2==0 then x=-x end return x end)
    if mn == 1 then assertEquals( m:foldr '~', 1 )
               else assertEquals( m:foldr '~',-1 ) end
    assertEquals( m:foldr '-'        , v:foldr('+') )
    assertEquals( m:foldr('-', 'col'), mrefC        )
    assertEquals( m:foldr('-', 'row'), mrefR        )
  end
  assertEquals( vector(4):fill(4..1..-1):foldr '^', 4^(3^2) )
end

--[[ scan cases:
1) x:scan( f )
2) x:scan( f, nil, d )      and 2') x:scan( f, d )
3) x:scan( f, nil, nil, r ) and 3') x:scan( f, r ) and  3") x:scan( f, nil, r)
4) x:scan( f, nil, d, r )   and 4') x:scan( f, d, r) and  4")x:scan( f, d, nil, r )
5) x:scan( f, x0 )
6) x:scan( f, x0 , d )
7) x:scan( f, x0 , nil, r ) and 7') x:scan( f, x0, r )
8) x:scan( f, x0 , d, r )              ]]

function TestMatrixErr:testScanl()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  local m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, nil                   )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, nan                   )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, ''                    )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, {}                    )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, 1                     )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, 1..2                  )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, m                     )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, cm                    )
  assertErrorMsgContains( msg[3], mth, 'scanl', errMat, \x x, ''              )
  assertErrorMsgContains( msg[3], mth, 'scanl', errMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', errMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', errMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'scanl', errMat, \x x, 1 , 'vec', ''   )
  assertErrorMsgContains( msg[2], mth, 'scanl', errMat, \x x, 1 , 'vec', 1    )
  assertErrorMsgContains( msg[2], mth, 'scanl', errMat, \x x, 1 , 'vec', \x x )
end

function TestMatrixFun:testScanl()
  for _,m in ipairs(G.matidx) do
    local mn, nr, nc = m:size(), m:sizes()
    local t = {} for i=1,mn do t[i] = sum(1..i) end
    local mref  = m:same():fill(1..mn):map(\x sum(1..x)  )
    local mref2 = m:same():fill(1..mn):map(\x sum(1..x)+2)
    assertEquals         ( m:scanl(\x x               ), m:same():fill(1) ) -- 1)
    assertEquals         ( m:scanl('+'                ), mref             ) -- 1)
    assertEquals         ( m:scanl('+','vec'          ), mref             ) -- 2)
    assertEquals         ( m:scanl('+', 2             ), mref2            ) -- 5)
    assertEquals         ( m:scanl('+', 2   ,'vec'    ), mref2            ) -- 6)
    assertAllAlmostEquals( m:scanl('+','vec', {}      ), t                ) -- 4)
    assertAllAlmostEquals( m:scanl('+', 0   ,'vec', {}), t                ) -- 8)
    assertAllAlmostEquals( m:scanl('+', nil       , {}), t                ) -- 3)
    assertAllAlmostEquals( m:scanl('+', nil , nil , {}), t                ) -- 3)
    assertAllAlmostEquals( m:scanl('+', 0   , nil , {}), t                ) -- 7)

    mref  = m:copy():mapij\x,i,j sum(idx(1,j,nc)..idx(i,j,nc)..nc)
    mref2 = m:copy():mapij\x,i,j sum(idx(i,1,nc)..idx(i,j,nc)..1 )
    assertEquals( m:scanl('+', 'col'), mref  ) -- 2)
    assertEquals( m:scanl('+', 'row'), mref2 ) -- 2)

  -- non-commutative operations
    mref  = m:same():fill(1..mn):map(\x sub(1..x))
    mref2 = m:copy():mapij\x,i,j sub(idx(i,1,nc)..idx(i,j,nc)..1 )
    assertEquals( m:scanl '-'        , mref  )
    assertEquals( m:scanl('-', 'row'), mref2 )
  end
  assertEquals( vector(4):fill(4..1..-1):scanl '^', vector{4, 4^3, (4^3)^2, ((4^3)^2)^1} )
end

function TestMatrixErr:testScanr()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  local m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, nil                   )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, nan                   )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, ''                    )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, {}                    )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, 1                     )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, 1..2                  )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, m                     )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, cm                    )
  assertErrorMsgContains( msg[3], mth, 'scanr', errMat, \x x, ''              )
  assertErrorMsgContains( msg[3], mth, 'scanr', errMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', errMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', errMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'scanr', errMat, \x x, 1 , 'vec', ''   )
  assertErrorMsgContains( msg[2], mth, 'scanr', errMat, \x x, 1 , 'vec', 1    )
  assertErrorMsgContains( msg[2], mth, 'scanr', errMat, \x x, 1 , 'vec', \x x )
end

function TestMatrixFun:testScanr()
  local function subR(r)
    local s = r:size()
    local x = table.new(s,1)
    x[s] = r[s]
    for i=r:size()-1,1,-1 do
      if i%2 == 0 then x[i]= -(x[i+1] - r[i])
                  else x[i]= - x[i+1] + r[i]  end
    end
    return x
  end
  for _,m in ipairs(G.matidx) do
    local mn, nr, nc = m:size(), m:sizes()
    local mref  = m:same():fill(1..mn):map(\x sum(x..mn))
    local mref2 = m:same():fill(1..mn):map(\x sum(x..mn)+2)
    local t = {} for i=1,mn do t[i] = sum(i..mn) end
    assertEquals         ( m:scanr(\x x               ) , m:same():fill(1..mn) ) -- 1)
    assertEquals         ( m:scanr('+'                ) , mref                 ) -- 1)
    assertEquals         ( m:scanr('+','vec'          ) , mref                 ) -- 2)
    assertEquals         ( m:scanr('+', 2             ) , mref2                ) -- 5)
    assertEquals         ( m:scanr('+', 2   ,'vec'    ) , mref2                ) -- 6)
    assertAllAlmostEquals( m:scanr('+','vec', {}      ) , t                    ) -- 4)
    assertAllAlmostEquals( m:scanr('+', 0   ,'vec', {}) , t                    ) -- 8)
    assertAllAlmostEquals( m:scanr('+', nil       , {}) , t                    ) -- 3)
    assertAllAlmostEquals( m:scanr('+', nil , nil , {}) , t                    ) -- 3)
    assertAllAlmostEquals( m:scanr('+', 0   , nil , {}) , t                    ) -- 7)

    mref  = m:copy():mapij\x,i,j sum(idx(nr,j,nc)..idx(i,j,nc)..-nc)
    mref2 = m:copy():mapij\x,i,j sum(idx(i,nc,nc)..idx(i,j,nc)..-1 )
    assertEquals( m:scanr('+', 'col'), mref  )
    assertEquals( m:scanr('+', 'row'), mref2 )

    -- non-commutative operations
    mref  = m:copy():mapij\x,i,j sum(idx(i,j,nc)..idx(nr,j,nc)..2*nc)-sum(idx(i+1,j,nc)..idx(nr,j,nc)..2*nc)
    mref2 = m:copy():mapij\x,i,j sum(idx(i,j,nc)..idx(i,nc,nc)..2   )-sum(idx(i,j+1,nc)..idx(i,nc,nc)..2   )
    assertEquals         ( m:scanr('-'          ) , m:same():fill(subR(1..mn)) )
    assertEquals         ( m:scanr('-','col'    ) , mref        )
    assertEquals         ( m:scanr('-','row'    ) , mref2       )
    assertAllAlmostEquals( m:scanr('-', nil , {}) , subR(1..mn) )
  end
  assertEquals( vector(4):fill(4..1..-1):scanr '^', vector{ 4^3^2^1, 3^2^1, 2^1, 1 } )
end

function TestMatrixErr:testFilter()
  local msg = {
    "invalid argument #2 (callable expected)",
    "invalid argument #3 (iterable expected)",
    "invalid matrix new sizes"               ,
  }
  assertErrorMsgContains( msg[1], mth, 'filter', errMat   , nil             )
  assertErrorMsgContains( msg[1], mth, 'filter', errMat   , ''              )
  assertErrorMsgContains( msg[1], mth, 'filter', errMat   , 1..2            )
  assertErrorMsgContains( msg[1], mth, 'filter', errMat   , 1               )
  assertErrorMsgContains( msg[1], mth, 'filter', errMat   , matrix(1)       )
  assertErrorMsgContains( msg[1], mth, 'filter', errMat   , { }             )
  assertErrorMsgContains( msg[2], mth, 'filter', errMat   , \x x     , ''   )
  assertErrorMsgContains( msg[2], mth, 'filter', errMat   , \x x     , 1    )
  assertErrorMsgContains( msg[2], mth, 'filter', errMat   , \x x     , \x x )
  assertErrorMsgContains( msg[3], mth, 'filter', matrix{1}, \x x~=1         )
end

function TestMatrixFun:testFilter()
 for _,m in ipairs(G.matidx) do
    local mn = m:size()
    assertEquals( m:filter(\x x==1    )         , vector(1) :fill(1)     )
    assertEquals( m:filter(\x x~=0    )         , vector(mn):fill(1..mn) )
    assertEquals( m:filter(\x x> 1, {})         , totable(2..mn)         )
    assertEquals( m:filter(\x x==1, {})         , {1}                    )
    assertEquals( m:filter(\x x==1, vector(25)) , vector(1):seti(1,1)    )
    if mn>=5 then assertEquals( m:filter(\x x<6), m:same(5 ,1):fill(1..idx(5 ,1,1)) )
             else assertEquals( m:filter(\x x<6), m:same(mn,1):fill(1..idx(mn,1,1)) )  end
    local mc = m:copy()
    mc:filter(\x x==1, 'in' ) assertEquals( mc  , vector(1) :fill(1)     )
  end
end

function TestMatrixErr:testFilter_out()
  local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, 1         )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, {}        )
end

function TestMatrixFun:testFilter_out()
  for _,m in ipairs(G.matidx) do
    local mn = m:size()
    assertEquals( m:filter_out(\x x~=1    ), m:filter(\x x==1    ) )
    assertEquals( m:filter_out(\x x==0    ), m:filter(\x x~=0    ) )
    assertEquals( m:filter_out(\x x>=6    ), m:filter(\x x< 6    ) )
    assertEquals( m:filter_out(\x x<=1, {}), m:filter(\x x> 1, {}) )
    assertEquals( m:filter_out(\x x~=1, {}), m:filter(\x x==1, {}) )
  end
end

-- special maps ---------------------------------------------------------------o

function TestMatrixSMaps:setUp()
  for _,m in ipairs(G.mattmp) do m:zeros() end
  for _,m in ipairs(G.matidx) do m:fill(1..m:size()) end
end

function TestMatrixSMaps:tearDown()
  for _,m in ipairs(G.mattmp) do m:zeros() end
  for _,m in ipairs(G.matidx) do m:fill(1..m:size()) end
end

function TestMatrixSMaps:testCeil ()
  for _,m in ipairs(G.mattmp) do
    local r = nrange(0.01, 1, m:size())
    m:fill(r):ceil('in')
    assertEquals( m, m:same():fill(1) )
  end
end

function TestMatrixSMaps:testFloor()
  for _,m in ipairs(G.mattmp) do
    local r = nrange(0, 1-0.01, m:size())
    m:fill(r):floor('in')
    assertEquals( m, m:same() )
  end
end

function TestMatrixSMaps:testFrac()
  for _,m in ipairs(G.mattmp) do
    local r  = range(0.1,(m:size())/10,0.1)
    local mn = m:size()
    m:fill(r):frac('in')
    for i=1,mn do
      if     r[i] < 1 then assertAlmostEquals( m:geti(i) -  i/10   , 0,   eps )
      elseif r[i] < 2 then assertAlmostEquals( m:geti(i) - (i/10-1), 0,   eps )
                      else assertAlmostEquals( m:geti(i) - (i/10-2), 0, 2*eps ) end
    end
  end
end

function TestMatrixSMaps:testTrunc()
  for _,m in ipairs(G.mattmp) do
    local r = nrange(0, 3-0.01, m:size())
    m:fill(r):trunc('in')
    for i=1,m:size() do
      if     r[i] < 1 then assertEquals( m:geti(i), 0 )
      elseif r[i] < 2 then assertEquals( m:geti(i), 1 )
                      else assertEquals( m:geti(i), 2 ) end
    end
  end
end

function TestMatrixSMaps:testRound()
  for _,m in ipairs(G.mattmp) do
    local r = nrange(0, 1, m:size())
    m:fill(r):round('in')
    for i=1,m:size() do
    if r[i] < 0.5 then assertEquals( m:geti(i), 0 )
                  else assertEquals( m:geti(i), 1 ) end
    end
  end
end

function TestMatrixSMaps:testAbs()
  for _,m in ipairs(G.mattmp) do
    local r = nrange(-3, 3, m:size())
    m:fill(r):abs('in')
    local res = m:map(\x x>=0, {})
    assertEquals( res, rep(true, m:size()) )
  end
end

function TestMatrixSMaps:testSqrt()
  for _,m in ipairs(G.matidx) do
    local mn = m:size()
    m:map(\x x*x):sqrt('in')
    assertEquals( m, m:same():fill(1..mn) )
  end
end

function TestMatrixSMaps:testExp()
  for _,m in ipairs(G.matidx) do
    local mn = m:size()
    m:exp('in')
    assertEquals( m:map(log), m:same():fill(1..mn) )
  end
end

function TestMatrixSMaps:testLog()
  for _,m in ipairs(G.matidx) do
    local mn = m:size()
    m:log('in')
    local res = m:map(\x exp(x) )
    assertTrue( res:eq( m:same():fill(1..mn), 16*eps ) )
  end
end

function TestMatrixSMaps:testLog10()
  for _,m in ipairs(G.matidx) do
    local mres = m:copy():map(\x log(x)/log(10) )
    m:log10('in')
    assertTrue( m:eq( mres, eps) )
  end
end

function TestMatrixSMaps:testSin()
  for _,m in ipairs(G.mattmp) do
    local r = nrange(1, pi/2, m:size())
    m:fill(r)
    assertEquals( m:sin(), m:copy():map(\x -sin(-x)) )
  end
end

function TestMatrixSMaps:testCos()
  for _,m in ipairs(G.mattmp) do
    local r = nrange(1, pi/2, m:size())
    m:fill(r)
    assertEquals( m:cos(),    m:copy():map(\x cos(-x    ))        )
    assertTrue  ( m:cos():eq( m:copy():map(\x sin(pi/2-x)), eps ) )
  end
end

function TestMatrixSMaps:testTan()
  for _,m in ipairs(G.mattmp) do
    local r = nrange(1,pi/2,m:size())
    m:fill(r)
    assertTrue( m:tan():eq( m:copy():map(\x sin(x)/cos(x)), 32*eps ) )
  end
end

function TestMatrixSMaps:testSinh()
  for _,m in ipairs(G.mattmp) do
    local r = nrange(1,pi/2,m:size())
    m:fill(r)
    assertTrue( m:sinh():eq( m:copy():map(\x 2*sinh(x/2)*cosh(x/2)), 2*eps ) )
  end
end

function TestMatrixSMaps:testCosh()
  for _,m in ipairs(G.mattmp) do
    local r = nrange(1,pi/2,m:size())
    m:fill(r)
    assertTrue( m:cosh():eq( m:copy():map(\x 2*sinh(x/2)^2 + 1), 2*eps ) )
  end
end

function TestMatrixSMaps:testTanh()
  for _,m in ipairs(G.mattmp) do
    local r = nrange(1,pi/2,m:size())
    m:fill(r)
    assertTrue( m:tanh():eq( m:copy():map(\x sinh(x)/cosh(x)), eps) )
  end
end

function TestMatrixSMaps:testAsin()
  for _,m in ipairs(G.matidx) do
    local r = nrange(1,pi/2,m:size())
    m:fill(r)
    assertTrue( m:sin():asin('in'):eq( m:copy(), 8*eps) ) -- linux err: 6*eps
  end
end

function TestMatrixSMaps:testAcos()
  for _,m in ipairs(G.mattmp) do
    local r = nrange(1,pi/2,m:size())
    m:fill(r)
    assertTrue( m:cos():acos('in'):eq( m:copy(), eps ) )
  end
end

function TestMatrixSMaps:testAtan()
  for _,m in ipairs(G.mattmp) do
    local r = nrange(1,pi/2,m:size())
    m:fill(r)
    assertTrue( m:tan():atan('in'):eq( m:same():fill(r), eps ) )
  end
end

function TestMatrixSMaps:testAsinh()
  for _,m in ipairs(G.mattmp) do
    local r = nrange(1,pi/2,m:size())
    m:fill(r)
    assertTrue( m:asinh():sinh('in'):eq( m:copy(), 2*eps ) )
  end
end

function TestMatrixSMaps:testAcosh()
  for _,m in ipairs(G.mattmp) do
    local r = nrange(1,pi/2,m:size())
    m:fill(r)
    assertTrue( m:acosh():cosh('in'):eq( m:copy(), eps ) )
  end
end

function TestMatrixSMaps:testAtanh()
  for _,m in ipairs(G.mattmp) do
    local r = nrange(1,pi/2,m:size())
    m:fill(r)
    assertTrue( m:tanh():atanh('in'):eq( m:copy(), 2*eps ) )
  end
end

--function TestMatrixSMaps:testErf()    end
--function TestMatrixSMaps:testTgamma() end
--function TestMatrixSMaps:testLgamma() end

function TestMatrixSMaps:testCarg()
  for _,m in ipairs(G.matidx) do
    assertEquals( m:carg(), m:same() )
  end
end

function TestMatrixSMaps:testReal()
  for _,m in ipairs(G.matidx) do
    assertEquals( m:real(), m:same():fill(1..m:size()) )
  end
end

function TestMatrixSMaps:testImag()
  for i,m in ipairs(G.matidx) do
    assertEquals( m:imag(), m:same() )
  end
end

function TestMatrixSMaps:testConj()
  for _,m in ipairs(G.matidx) do
    assertEquals( m:conj(), m:same():fill(1..m:size()) )
  end
end

function TestMatrixSMaps:testProj()
  for _,m in ipairs(G.matidx) do
    assertEquals( m:proj(), m:same():fill(1..m:size()) )
  end
end

function TestMatrixSMaps:testRect()
  for _,m in ipairs(G.matidx) do
    assertEquals( m:rect(), m:same():fill(1..m:size()) )
  end
end

function TestMatrixSMaps:testPolar()
  for _,m in ipairs(G.matidx) do
    local mn = m:size()
    assertEquals( m:polar(), m:same(0i):fill(1..mn) )
  end
end

-- special folds --------------------------------------------------------------o

function TestMatrixSFolds:testMin()
  for _,m in ipairs(G.matidx) do
    local nr,nc,_ = m:sizes()
    assertEquals( m:min()     , 1                                         )
    assertEquals( m:min('col'), m:same(_,1 ,nc):fill(1..nc)               )
    assertEquals( m:min('row'), m:same(_,nr,1 ):fill(1..idx(nr,1,nc)..nc) )
  end
end

function TestMatrixSFolds:testMax()
  for _,m in ipairs(G.matidx) do
    local nr,nc,_ = m:sizes()
    assertEquals( m:max()     , m:size() )
    assertEquals( m:max('col'), m:same(_,1 ,nc):fill(idx(nr,1,nc)..idx(nr,nc,nc)..1 ) )
    assertEquals( m:max('row'), m:same(_,nr,1 ):fill(idx(1,nc,nc)..idx(nr,nc,nc)..nc) )
  end
end

function TestMatrixSFolds:testSum()
  for _,m in ipairs(G.matidx) do
    local nr,nc,_ = m:sizes()
    assertEquals( m:sum()     , sum(1..m:size()) )
    assertEquals( m:sum('col'), m:same(_,1 ,nc):mapij\x,i,j sum(idx(1,j,nc)..idx(nr,j,nc)..nc) )
    assertEquals( m:sum('row'), m:same(_,nr,1 ):mapij\x,i,j sum(idx(i,1,nc)..idx(i,nc,nc)..1 ) )
  end
end

function TestMatrixSFolds:testSumabs()
  for _,m in ipairs(G.matidx) do
    local nr,nc,_ = m:sizes()
    local m1 = m:copy():map(\x -x)
    assertEquals( m1:sumabs()     , sum(1..m:size()) )
    assertEquals( m1:sumabs('col'), m:same(_,1 ,nc):mapij\x,i,j sum(idx(1,j,nc)..idx(nr,j,nc)..nc) )
    assertEquals( m1:sumabs('row'), m:same(_,nr,1 ):mapij\x,i,j sum(idx(i,1,nc)..idx(i,nc,nc)..1 ) )
  end
end

function TestMatrixSFolds:testSumsqr()
  local sumsqr = \r =>local x = 0 for i=1,r:size() do x = x + r[i]^2 end return x end
  for _,m in ipairs(G.matidx) do
    local nr,nc,_ = m:sizes()
    assertEquals( m:sumsqr()     , sumsqr(1..m:size()) )
    assertEquals( m:sumsqr('col'), m:same(_,1 ,nc):mapij\x,i,j sumsqr(idx(1,j,nc)..idx(nr,j,nc)..nc) )
    assertEquals( m:sumsqr('row'), m:same(_,nr,1 ):mapij\x,i,j sumsqr(idx(i,1,nc)..idx(i,nc,nc)..1 ) )
  end
end

function TestMatrixSFolds:testProduct()
  local prod = \r =>local x = 1 for i=1,r:size() do x = x * r[i] end return x end
  for _,m in ipairs(G.matidx) do
    local nr,nc,_ = m:sizes()
    assertEquals( m:product()     , prod(1..m:size()) )
    assertEquals( m:product('col'), m:same(_,1 ,nc):mapij\x,i,j prod(idx(1,j,nc)..idx(nr,j,nc)..nc) )
    assertEquals( m:product('row'), m:same(_,nr,1 ):mapij\x,i,j prod(idx(i,1,nc)..idx(i,nc,nc)..1 ) )
  end
end

function TestMatrixErr:testAll()
  local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'all', errMat, nil    )
  assertErrorMsgContains( msg[1], mth, 'all', errMat, ''     )
  assertErrorMsgContains( msg[1], mth, 'all', errMat, 1..2   )
  assertErrorMsgContains( msg[1], mth, 'all', errMat, 1      )
  assertErrorMsgContains( msg[1], mth, 'all', errMat, errMat )
  assertErrorMsgContains( msg[1], mth, 'all', errMat, { }    )
end

function TestMatrixSFolds:testAll()
  for _,m in ipairs(G.matidx) do
    local mn, t, nr, nc = m:size(), nil, m:sizes()
    assertFalse ( m:all \x x> m:size()           )
    assertTrue  ( m:all \x x< m:size()+1         )
    assertTrue  ( m:all(\x x< m:size()+1, 'vec') )
    assertEquals( m:all(\x x<16                ), m:all( \x x<16, 'vec')  )
    assertEquals( m:all(\x x< m:size()+1, 'col'), m:same(_,1 ,nc):fill(1) )

    t = table.new(nc,1)
    if     mn <  16 then for i=1,nc   do t[i]=true  end
    elseif mn == 16 then for i=1,nc-1 do t[i]=true  end t[nc] = false
    else                 for i=1,nc   do t[i]=false end               end
    assertEquals( m:all( \x x<16, 'col', {}), t )

    t = table.new(nr,1)
    if mn >= 16 then for i=1,3  do t[i]=true  end
                     for i=4,nr do t[i]=false end
    else             for i=1,nr do t[i]=true  end end
    assertEquals( m:all( \x x<16, 'row', {}), t )
  end
end

function TestMatrixErr:testAny()
  local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'any', errMat, nil    )
  assertErrorMsgContains( msg[1], mth, 'any', errMat, ''     )
  assertErrorMsgContains( msg[1], mth, 'any', errMat, 1..2   )
  assertErrorMsgContains( msg[1], mth, 'any', errMat, 1      )
  assertErrorMsgContains( msg[1], mth, 'any', errMat, errMat )
  assertErrorMsgContains( msg[1], mth, 'any', errMat, { }    )
end

function TestMatrixSFolds:testAny()
  for _,m in ipairs(G.matidx) do
    local mn, t, nr, nc = m:size(), nil, m:sizes()
    assertFalse ( m:any \x x> m:size()           )
    assertTrue  ( m:any \x x< m:size()+1         )
    assertTrue  ( m:any(\x x< m:size()+1, 'vec') )
    assertEquals( m:any(\x x< 16               ), m:any( \x x<16, 'vec')  )
    assertEquals( m:any(\x x< m:size()+1, 'col'), m:same(_,1 ,nc):fill(1) )

    t = table.new(nc,1)
    if     nr == 4 and nc == 5 then for i=2,nc do t[i]=true  end t[1]=false
    elseif mn > 16             then for i=1,nc do t[i]=true  end
    else                            for i=1,nc do t[i]=false end             end
    assertEquals( m:any(\x x>16, 'col', {}), t )

    t = table.new(nr,1)
    if     mn == 20 then for i=1,nr do t[i]  = false end t[nr] = true
    elseif mn >  16 then for i=1,3  do t[i]  = false end
                         for i=4,nr do t[i]  = true  end
    else                 for i=1,nr do t[i]  = false end               end
    assertEquals( m:any(\x x>16, 'row', {}), t )
  end
end

-- special scans --------------------------------------------------------------o

-- left accumulation
function TestMatrixSScans:testAccmin()
  for _,m in ipairs(G.matidx) do
    local nr, nc = m:sizes()
    local mref   = m:same()
    assertEquals( m:accmin()     , m:same():fill(1) )
    for i=1,nr do mref:setrow(i, 1..nc      ) end
    assertEquals( m:accmin('col'), mref )
    for i=1,nr do mref:setrow(i, idx(i,1,nc)) end
    assertEquals( m:accmin('row'), mref )
  end
end

function TestMatrixSScans:testAccmax()
  for _,m in ipairs(G.matidx) do
    assertEquals( m:accmax()     , m:same():fill(1..m:size()) )
    assertEquals( m:accmax('col'), m:copy() )
    assertEquals( m:accmax('row'), m:copy() )
  end
end

function TestMatrixSScans:testAccsum()
  for _,m in ipairs(G.matidx) do
    local nr, nc = m:sizes()
    assertEquals( m:accsum()     , m:copy():map\x sum(1..x) )
    assertEquals( m:accsum('col'), m:copy():mapij(\x,i,j sum(idx(1,j,nc)..idx(i,j,nc)..nc)) )
    assertEquals( m:accsum('row'), m:copy():mapij(\x,i,j sum(idx(i,1,nc)..idx(i,j,nc)..1 )) )
  end
end

function TestMatrixSScans:testAccsumabs()
for _,m0 in ipairs(G.matidx) do
    local nr, nc = m0:sizes()
    local m = m0:copy():map(\x -x)
    assertEquals( m:accsumabs()     , m0:copy():map\x sum(1..x) )
    assertEquals( m:accsumabs('col'), m0:copy():mapij(\x,i,j sum(idx(1,j,nc)..idx(i,j,nc)..nc)) )
    assertEquals( m:accsumabs('row'), m0:copy():mapij(\x,i,j sum(idx(i,1,nc)..idx(i,j,nc)..1 )) )
  end
end

function TestMatrixSScans:testAccsumsqr()
  local sumsqr = \r =>local x = 0 for i=1,r:size() do x = x + r[i]^2 end return x end
  for _,m in ipairs(G.matidx) do
    local nr, nc = m:sizes()
    assertEquals( m:accsumsqr()     , m:copy():map\x sumsqr(1..x) )
    assertEquals( m:accsumsqr('col'), m:copy():mapij(\x,i,j sumsqr(idx(1,j,nc)..idx(i,j,nc)..nc)) )
    assertEquals( m:accsumsqr('row'), m:copy():mapij(\x,i,j sumsqr(idx(i,1,nc)..idx(i,j,nc)..1 )) )
  end
end

function TestMatrixSScans:testAccprod()
  local prod = \r =>local x = 1 for i=1,r:size() do x = x * r[i] end return x end
  for _,m in ipairs(G.matidx) do
    local nr, nc = m:sizes()
    assertEquals( m:accprod()     , m:copy():map\x prod(1..x) )
    assertEquals( m:accprod('col'), m:copy():mapij(\x,i,j prod(idx(1,j,nc)..idx(i,j,nc)..nc)) )
    assertEquals( m:accprod('row'), m:copy():mapij(\x,i,j prod(idx(i,1,nc)..idx(i,j,nc)..1 )) )
  end
end

-- right accumulation
function TestMatrixSScans:testRaccmin()
  for _,m in ipairs(G.matidx) do
    local nr, nc = m:sizes()
    assertEquals( m:raccmin()     , m:copy() )
    assertEquals( m:raccmin('col'), m:copy():mapij\x,i,j idx(i,j,nc) )
    assertEquals( m:raccmin('row'), m:copy():mapij\x,i,j idx(i,j,nc) )
  end
end

function TestMatrixSScans:testRaccmax()
  for _,m in ipairs(G.matidx) do
    local nr, nc = m:sizes()
    assertEquals( m:raccmax()     , m:same():fill(m:geti(m:size())) )
    assertEquals( m:raccmax('col'), m:copy():mapij\x,i,j idx(nr,j ,nc) )
    assertEquals( m:raccmax('row'), m:copy():mapij\x,i,j idx(i ,nc,nc) )
  end
end

function TestMatrixSScans:testRaccsum()
  for _,m in ipairs(G.matidx) do
    local nr, nc = m:sizes()
    assertEquals( m:raccsum()     , m:copy():mapij\x sum(x..nr*nc) )
    assertEquals( m:raccsum('col'), m:copy():mapij\x,i,j sum(idx(nr,j,nc)..idx(i,j ,nc)..-nc) )
    assertEquals( m:raccsum('row'), m:copy():mapij\x,i,j sum(idx(i ,j,nc)..idx(i,nc,nc))      )
  end
end

function TestMatrixSScans:testRaccsumabs()
  for _,m0 in ipairs(G.matidx) do
    local nr, nc = m0:sizes()
    local m = m0:copy():map(\x -x)
    assertEquals( m:raccsumabs()     , m0:copy():mapij\x sum(x..nr*nc) )
    assertEquals( m:raccsumabs('col'), m0:copy():mapij\x,i,j sum(idx(nr,j,nc)..idx(i,j ,nc)..-nc) )
    assertEquals( m:raccsumabs('row'), m0:copy():mapij\x,i,j sum(idx(i ,j,nc)..idx(i,nc,nc))      )
  end
end

function TestMatrixSScans:testRaccsumsqr()
  local sumsqr = \r =>local x = 0 for i=1,r:size() do x = x + r[i]^2 end return x end
  for _,m in ipairs(G.matidx) do
    local nr, nc = m:sizes()
    assertEquals( m:raccsumsqr()     , m:copy():map\x sumsqr(x..nr*nc) )
    assertEquals( m:raccsumsqr('col'), m:copy():mapij\x,i,j sumsqr(idx(nr,j,nc)..idx(i,j ,nc)..-nc) )
    assertEquals( m:raccsumsqr('row'), m:copy():mapij\x,i,j sumsqr(idx(i ,j,nc)..idx(i,nc,nc)     ) )
  end
end

function TestMatrixSScans:testRaccprod()
  local prod = \r =>local x = 1 for i=1,r:size() do x = x * r[i] end return x end
  for _,m in ipairs(G.matidx) do
    local nr, nc = m:sizes()
    if nr*nc < 25 then
      assertTrue( m:raccprod()   :eq( m:copy():map\x prod(x..nr*nc) ) )
    end
    assertTrue( m:raccprod('col'):eq( m:copy():mapij\x,i,j prod(idx(nr,j,nc)..idx(i,j ,nc)..-nc), eps) )
    assertTrue( m:raccprod('row'):eq( m:copy():mapij\x,i,j prod(idx(i ,j,nc)..idx(i,nc,nc))     , eps) )
  end
end

-- symplectic matrix ----------------------------------------------------------o

function TestMatrixErr:testSympconj()
  local msg = {
   "invalid argument #1 (2n matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth,'sympconj',  matrix(3)   )
  assertErrorMsgContains( msg[1], mth,'sympconj',  matrix(4,3) )
end

function TestMatrixSympl:testSympconj()
  local mat = {
    matrix{{1,1},{0,1}},
    matrix{{1,0},{0,1}},
    matrix{{1,0},{1,1}},
    matrix{{0,1},{1,0}},
    matrix{{0,1},{1,1}},
    matrix{{1,1},{1,0}},
  }
  for _,M in ipairs(mat) do
    local J = M:same():symp()
    local R = -J*M:t()*J
    assertEquals( M:sympconj(), R )
  end

  for i=2,10,2 do
    local J = matrix(i):symp()
    local M = matrix(i):fill(1..i*i)
    local R = -J*M:t()*J
    assertEquals( M:sympconj( ), R )
    assertEquals( M:sympconj(M), R ) -- in place
  end
end

function TestMatrixErr:testSymperr()
  local msg = {
    "invalid argument #1 (2n matrix expected)"       ,
    "invalid argument #2 (different matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth,'symperr',  matrix(3)   )
  assertErrorMsgContains( msg[1], mth,'symperr',  matrix(4,3) )
end

function TestMatrixSympl:testSymperr()
  for i=2,10,2 do
    local J = matrix(i):symp()
    local M = matrix(i):fill(1..i*i)
    local R = M:t()*J*M - J
    assertEquals( M:symperr(), R:norm() ) -- M' J M - J
  end
  local smat = { matrix{{1,0},{0,1}},
                 matrix{{1,0},{1,1}},
                 matrix{{1,1},{0,1}}, }
  for _,M in ipairs(smat) do
    assertEquals( M:symperr(), 0 )
  end
end

function TestMatrixErr:testSymplectify()   end
function TestMatrixSympl:testSymplectify() end

-- conjugate, transpose -------------------------------------------------------o

function TestMatrixLinAlg:testConjugate()
  for _,m in ipairs(G.matidx) do assertEquals( m:conj(), m )  end
end

function TestMatrixLinAlg:testTranspose()
  for _,m in ipairs(G.matidx) do
    local nr, nc = m:sizes()
    local mc = m:copy()
    assertEquals( {m:t():sizes()}, {nc,nr}        )
    assertEquals(  m:t()  :t()   , m              )
    assertEquals( (m + mc):t()   , m:t() + mc:t() )
    assertEquals( (2 * m ):t()   , 2 * m:t()      )
    if nr == nc then
      assertEquals( (m*mc):t(), m:t()*mc:t() )
      mc:t('in') for i=1,nr do for j=1,nc do assertEquals( mc:get(i,j), m:get(j,i) ) end end
    end
    mc = m:t()   for i=1,nr do for j=1,nc do assertEquals( mc:get(i,j), m:get(j,i) ) end end
  end
end

function TestMatrixLinAlg:testTrace()
  for _,m in ipairs(G.matidx) do
    assertEquals( m:tr(), m:getdiag():sum() )
  end
end

-- inner, cross, mixed, outer -------------------------------------------------o

function TestMatrixErr:testInner()
  local msg = {
    "invalid argument #2 (matrix expected)",
    "incompatible matrix sizes"            ,
  }
  assertErrorMsgContains( msg[1], mth, 'inner', errMat, nil            )
  assertErrorMsgContains( msg[1], mth, 'inner', errMat, ''             )
  assertErrorMsgContains( msg[1], mth, 'inner', errMat, 1              )
  assertErrorMsgContains( msg[1], mth, 'inner', errMat, 1..2           )
  assertErrorMsgContains( msg[1], mth, 'inner', errMat, {}             )
  assertErrorMsgContains( msg[2], mth, 'inner', errMat, errMat, errMat )
end

function TestMatrixLinAlg:testInner()
  -- inner prod:  u'.v = |u|.|v| cos(u^v)
  for _,m in ipairs(G.matidx) do
    local mres, mref
    local mc = m:copy()
    mres =  m:inner(mc)
    mref = (m:t() * mc):getdiag():t()
    if mref:size() == 1 then assertEquals( mres, mref:geti(1) )
    else                     assertEquals( mres, mref         ) end
    mres =  m:inner(mc,'tr')
    mref = (m:t() * mc):tr()
    assertEquals( mres, mref )
  end
end

function TestMatrixErr:testOuter()
  local m = matrix(2,1)
  local msg = {
    "invalid argument #2 (matrix expected)",
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'outer', m          , nil         )
  assertErrorMsgContains( msg[1], mth, 'outer', m          , ''          )
  assertErrorMsgContains( msg[1], mth, 'outer', m          , {}          )
  assertErrorMsgContains( msg[1], mth, 'outer', m          , 1           )
  assertErrorMsgContains( msg[1], mth, 'outer', m          , 1..2        )
  assertErrorMsgContains( msg[2], mth, 'outer', matrix(1,2), matrix(2,2) )
end

function TestMatrixLinAlg:testOuter()
  -- x * y:t() without temporary
  for nr=1,5 do
    local m1 = vector(nr):fill(1..2*nr..2)
    local m2 = vector(nr):fill(1..  nr)
    assertEquals( m1:outer(m2), m1*m2:t() )
  end
end

function TestMatrixErr:testCross()
  local m = matrix(3)
  local msg = {
    "invalid argument #2 (matrix expected)",
    "invalid matrix sizes"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'cross', m     , nil  )
  assertErrorMsgContains( msg[1], mth, 'cross', m     , ''   )
  assertErrorMsgContains( msg[1], mth, 'cross', m     , 1    )
  assertErrorMsgContains( msg[1], mth, 'cross', m     , 1..2 )
  assertErrorMsgContains( msg[1], mth, 'cross', m     , {}   )
  assertErrorMsgContains( msg[2], mth, 'cross', errMat, m    )
end

function TestMatrixLinAlg:testCross()
  -- cross prod:  uxv = |u|.|v| sin(u^v) \vec{n}
  local m1 = matrix(3):fill(0..8)   -- skew-symmetric matrix
  local m2 = vector {2,-4,2}
  local m3 = m2:copy()
  assertEquals( m2:cross(m3), m1*m3 )
  for nc=1,5 do
    m1 = matrix(3,nc):fill(1   ..3*nc)
    m2 = m1:copy()   :fill(3*nc..1   ..-1)
    m3 = m2:copy()
    assertEquals(    m1 :cross(m2)   ,  -m2:cross(  m1)              )
    assertEquals(    m1 :cross(m2+m3),   m1:cross(  m2)+m1:cross(m3) )
    assertEquals( (2*m1):cross(m2)   ,   m1:cross(2*m2)              )
    assertEquals( (2*m1):cross(m2)   , 2*m1:cross(  m2)              )
    assertEquals( (2*m1):cross(m2)   , 2*m1:cross(  m2)              )
    if nc == 3 then
      assertEquals( m1:cross( m2:cross(m3) ), m2*(m1*m3)-m3*(m1*m2)  )
    end
  end
end

function TestMatrixErr:testMixed()
  local msg = {
    "invalid argument #2 (matrix expected)",
    "invalid argument #3 (matrix expected)",
    "invalid matrix sizes"                 ,
    "incompatible matrix sizes"            ,
  }
  local m1 = matrix(3,1)
  assertErrorMsgContains( msg[1], mth, 'mixed', m1         , nil                      )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1         , ''                       )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1         , 1                        )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1         , 1..2                     )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1         , {}                       )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1         , m1         , nil         )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1         , m1         , ''          )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1         , m1         , 1           )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1         , m1         , 1..2        )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1         , m1         , {}          )
  assertErrorMsgContains( msg[3], mth, 'mixed', matrix(2,1), m1         , m1          )
  assertErrorMsgContains( msg[4], mth, 'mixed', matrix(3,2), m1         , m1          )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1         , matrix(2,1), m1          )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1         , matrix(3,2), m1          )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1         , m1         , matrix(2,1) )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1         , m1         , matrix(3,2) )
end

function TestMatrixLinAlg:testMixed()
  -- x:cross(y):inner(z) without temporary
  for nc=1,5 do
    local m1 = matrix(3,nc):fill(1   ..3*nc  )
    local m2 = m1:same()   :fill(3*nc..1.. -1)
    local m3 = m1:same()   :fill(1)
    assertEquals( m1:mixed(m2,m3), m1:cross(m2):inner(m3) )
  end
end

-- norm, unit, center, angle (in place) ---------------------------------------o

function TestMatrixLinAlg:testNorm() --|u| = sqrt(u'.u), forbidius norm
  for _,m in ipairs(G.matidx) do
    assertEquals( m:norm(), sqrt(m:map(\x x^2):sum()) )
  end
end

function TestMatrixErr:testDistance()
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'distance', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'distance', errMat, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'distance', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'distance', errMat, {}   )
end

function TestMatrixLinAlg:testDistance()
  --sqrt( trace((A-B) * (A-B)') )
  for _,m in ipairs(G.matidx) do
    local mn = m:size()
    local mc = m:copy()
    local m2 = m:same():fill(mn..1..-1)
    assertEquals( m:distance(mc), sqrt( ( (m-mc)*(m-mc):t() ):tr()) )
    assertEquals( m:distance(m2), sqrt( ( (m-m2)*(m-m2):t() ):tr()) )
  end
end

function TestMatrixErr:testUnit()
  local msg = {
    "null matrix norm",
  }
  assertErrorMsgContains( msg[1], mth, 'unit', matrix(2) )
end

function TestMatrixLinAlg:testUnit()  --  unit :  u / |u|
  for _,m in ipairs(G.matidx) do
    assertEquals( m:unit(), m / m:norm() )
  end
end

function TestMatrixLinAlg:testCenter()
  for _,m in ipairs(G.matidx) do
    local mid = m:sum() / m:size()
    assertEquals( m:center(),  m:map(\x x-mid) )
  end
end

function TestMatrixErr:testAngle()
  local msg = {
    "null vector norm",
  }
  assertErrorMsgContains( msg[1], mth, 'angle', vector{1,1,1}, vector{0,0,0} )
  assertErrorMsgContains( msg[1], mth, 'angle', vector{0,0,0}, vector{1,1,1} )
end

function TestMatrixLinAlg:testAngle()
  -- angle:  u^v = acos(u'.v / |u|.|v|)  in [0,pi] (or [-pi,pi] if n)
  local rad = \i,n -> pi*(i-1)/n
  local function unitVectors(n1, n2, r)
    local v = {}
    if is_nil(r) then r=1 end
    for i = 1, n1 do
      local a = rad(i, n1)
      v[i]={}
      for j = 1, n2 do
        local b = rad(j,n2)
        local x = r * cos(a) * sin(b)
        local y = r * sin(a) * sin(b)
        local z = r * cos(b)
        v[i][j] = vector{x,y,z}
      end
    end
    return v
  end

  local n, m = 16, 16
  for i,t in ipairs( unitVectors( m, n ) ) do
  for j,v in ipairs( t ) do
    assertAlmostEquals( vector{0,0,1}:angle( v ) - rad(j, n), 0, 2*eps )
  end
  end
  assertAlmostEquals( vector{1,0,0}:angle(vector{ 1, 1, 0}), pi/4  , eps )
  assertAlmostEquals( vector{1,0,1}:angle(vector{ 1, 1, 0}), pi/3  , eps )
  assertEquals      ( vector{1,0,0}:angle(vector{ 1, 0, 0}), 0           )
  assertEquals      ( vector{1,0,0}:angle(vector{ 0, 1, 0}), pi/2        )
  assertEquals      ( vector{1,0,0}:angle(vector{-1,-1, 0}), 3*pi/4      )
  assertEquals      ( vector{1,0,0}:angle(vector{-1, 0, 0}), pi          )
  assertEquals      ( vector{0,0,1}:angle(vector{ 0, 0, 1}), 0           )
  assertEquals      ( vector{0,0,1}:angle(vector{ 0, 0,-1}), pi          )
end

-- operators ------------------------------------------------------------------o

function TestMatrixOps:setUp()
  for _,m in ipairs(G.mattmp) do m:zeros() end
  for _,m in ipairs(G.matidx) do m:fill(1..m:size()) end
end

function TestMatrixOps:tearDown()
  for _,m in ipairs(G.mattmp) do m:zeros() end
  for _,m in ipairs(G.matidx) do m:fill(1..m:size()) end
end

function TestMatrixOps:testUnm()
  for _,m in ipairs(G.matidx) do
    local mn = m:size()
    local mref = m:same():fill(-1..-mn..-1)
    assertEquals( -m      , mref )
    assertEquals(  m:unm(), mref )
  end
end

function TestMatrixOps:testMod()
  for _,m in ipairs(G.matidx) do
    assertEquals( m%m:copy()                         , m:same()         )
    assertEquals( m:same():fill(4)%m:same(  ):fill(3), m:same():fill(1) )
    assertEquals( m:same():fill(4)%m:same(0i):fill(3), m:same():fill(1) )
  end
end

function TestMatrixOps:testPow()
  for _,m in ipairs(G.matidx) do
    local mref = m:copy():map(\x x*x)
    assertEquals( m^2               , mref )
    assertEquals( m^m:same():fill(2), mref )
  end
end

function TestMatrixErr:testEq()
  local errMat = matrix(2):fill(1..4)
  local msg = {
    "invalid argument #3 (number expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'eq', errMat, matrix(1), '' )
  assertErrorMsgContains( msg[1], mth, 'eq', errMat, matrix(1), {} )
end

function TestMatrixOps:testEq()
  for _,m in ipairs(G.matidx) do
    local cm = m:map(\x complex(x,0))
    assertTrue ( m  == m:copy() ) -- mat  == mat
    assertFalse( m  == m:same() )
    assertTrue ( m  == cm       ) -- mat  == cmat
    assertTrue ( cm == m:copy() ) -- cmat == mat
    -- f defined
    assertTrue (  m       :eq(  m:copy()                       ,   0  ) )
    assertTrue (  m       :eq(  m:map(\x x+  eps)              ,   eps) )
    assertFalse(  m       :eq(  m:map(\x x+2*eps)              ,   eps) )
    assertFalse(  m       :eq(  m:map(\x x+  eps):seti(1,3*eps),   eps) )
  end
  -- f as function
  local  m =  matrix(2)
  local cm = cmatrix(2)
  assertTrue (  0        ==  m:same()         ) -- num  == mat
  assertFalse(  0        ==  m:same():fill(1) )
  assertTrue (  0        == cm:same()         ) -- num  == cmat
  assertFalse(  0        == cm:same():fill(1) )
  assertTrue (  m:same() == 0                 ) -- mat  == num
  assertTrue (  m:same() == 0+0i              ) -- mat  == cpx
end

function TestMatrixErr:testAdd()
  local msg = {
    "invalid arguments (unsupported matrix operation '+')",
    "incompatible matrix sizes"                       ,
  }
  assertErrorMsgContains( msg[1], mth, 'add', errMat, ''              )
  assertErrorMsgContains( msg[1], mth, 'add', errMat, nil             )
  assertErrorMsgContains( msg[1], mth, 'add', errMat, 1..4            )
  assertErrorMsgContains( msg[2], mth, 'add', errMat, matrix(1)       )
  assertErrorMsgContains( msg[2], mth, 'add', errMat, matrix(3)       )
  assertErrorMsgContains( msg[2], mth, 'add', errMat, matrix(2), {}   )
  assertErrorMsgContains( msg[2], mth, 'add', errMat, matrix(2), 1..4 )
end

function TestMatrixOps:testAdd()
  for _,m in ipairs(G.matidx) do
    local mn = m:size()
    local mc = m:copy()
    local cm = m:same(0i):fill(1..mn):map(\x x*(1+1i))
    assertEquals( 2 + m , m:same():fill(3..mn+2    ) ) -- num + mat  => num + vec
    assertEquals( m + 2 , m:same():fill(3..mn+2    ) ) -- mat + num  => vec + num
    assertEquals( m + mc, m:copy():map(\x x*2      ) ) -- mat + mat  => vec + vec
    assertEquals( m + 2i, m:copy():map(\x x+2i     ) ) -- mat + cpx  => vec + cpx
    assertEquals( m + cm, m:copy():map(\x x*(2+1i) ) ) -- mat + cmat => vec + cvec
    assertTrue  ( is_cmatrix(m + 2i) )
    assertTrue  ( is_cmatrix(m + cm) )
  end
end

function TestMatrixOps:testAddCpx()
  for _,m in ipairs(G.matidx) do
    local mres = 2i + m
    assertEquals( mres, m:copy():map(\x x+2i) ) -- cpx + mat => cpx + vec
    assertTrue  ( is_cmatrix(mres) )
  end
end

function TestMatrixErr:testSub()
  local msg = {
    "invalid arguments (unsupported matrix operation '-')",
    "incompatible matrix sizes"                       ,
  }
  assertErrorMsgContains( msg[1], mth, 'sub', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'sub', errMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'sub', errMat, 1..4      )
  assertErrorMsgContains( msg[2], mth, 'sub', errMat, matrix(1) )
  assertErrorMsgContains( msg[2], mth, 'sub', errMat, matrix(3) )
end

function TestMatrixOps:testSub()
  for _,m in ipairs(G.matidx) do
    local mn = m:size()
    local mc = m:copy()
    local cm = m:same(0i):fill(1..mn):map(\x x*(1+1i))
    assertEquals( m - mc, m:same()                ) -- mat - mat  => vec - vec
    assertEquals( 2 - m , m:copy():map(\x 2-x )   ) -- num - mat  => num - vec
    assertEquals( m - 2 , m:same():fill(-1..mn-2) ) -- mat - num  => vec + -num
    assertEquals( m - 2i, m:copy():map(\x x-2i)   ) -- mat - cpx  => vec + -cpx
    assertEquals( m - cm, m:copy():map(\x x*1i)   ) -- mat - cmat => vec - cvec
    assertTrue  ( is_cmatrix(m - 2i) )
    assertTrue  ( is_cmatrix(m - cm) )
  end
end

function TestMatrixOps:testSubCpx()
  for _,m in ipairs(G.matidx) do
    local mres = 2i - m
    assertEquals( mres, m:copy():map(\x 2i-x) ) -- cpx - mat => cpx - vec
    assertTrue  ( is_cmatrix(mres) )
  end
end

function TestMatrixErr:testMul()
  local msg = {
    "invalid arguments (unsupported matrix operation '*')",
    "incompatible matrix sizes"                       ,
  }
  assertErrorMsgContains( msg[1], mth, 'mul', errMat     , ''          )
  assertErrorMsgContains( msg[1], mth, 'mul', errMat     , nil         )
  assertErrorMsgContains( msg[1], mth, 'mul', errMat     , 1..4        )
  assertErrorMsgContains( msg[2], mth, 'mul', matrix(2,1), matrix(2,1) )
  assertErrorMsgContains( msg[2], mth, 'mul', matrix(1,2), matrix(1,1) )
  assertErrorMsgContains( msg[2], mth, 'mul', matrix(1,2), matrix(3,1) )
end

local function refMul(m1, m2, i, j )
  local mref = matrix(m1:nrow(), m2:ncol())
  for i=1,m1:nrow() do
  for j=1,m2:ncol() do
    local x = 0
    for ii=1,m1:ncol()
      do x = x + m1:get(i,ii) * m2:get(ii,j)
    end
    mref:set(i,j,x)
  end end
  return mref
end

function TestMatrixOps:testMul()
  for _,m in ipairs(G.matidx) do
    local mn, nr, nc, _ = m:size(), m:sizes()
    for j=1,5 do
      local m2 = m:same(_ ,nc,j):fill(1..nc*j)
      local cm = m:same(0i,nc,j):fill(1..nc*j)
      assertEquals( j * m   , m:same():fill(j..mn*j..j) ) -- num * mat  => num * vec
      assertEquals( m * j   , m:same():fill(j..mn*j..j) ) -- mat * num  => vec * num
      assertEquals( m * j*1i, m:copy():map(\x x*j*1i  ) ) -- mat * cpx  => vec * cp
      assertEquals( m * m2  , refMul(m,m2)              ) -- mat * mat
      assertEquals( m * cm  , refMul(m,cm)              ) -- mat * cmat
      assertTrue  ( is_cmatrix(m * 2i) )
      assertTrue  ( is_cmatrix(m * cm) )
    end
  end
end

function TestMatrixOps:testMulCpx()
  for _,m in ipairs(G.matidx) do
    local mref = 2i * m
    assertEquals( mref, m:copy():map(\x x*2i) )
    assertTrue  ( is_cmatrix(mref) )
  end
end

function TestMatrixErr:testTmul()
  local msg = {
    "invalid arguments (unsupported matrix operation '*')",
    "incompatible matrix sizes"                       ,
  }
  assertErrorMsgContains( msg[1], mth, 'tmul', errMat     , ''          )
  assertErrorMsgContains( msg[1], mth, 'tmul', errMat     , nil         )
  assertErrorMsgContains( msg[1], mth, 'tmul', errMat     , 1..4        )
  assertErrorMsgContains( msg[2], mth, 'tmul', matrix(2,1), matrix(1,2) )
  assertErrorMsgContains( msg[2], mth, 'tmul', matrix(1,2), matrix(3,1) )
end

function TestMatrixOps:testTmul()
  for _,m in ipairs(G.matidx) do
    local nr, _ = m:nrow()
    for i=1,5 do
      local m2 = m:same(_ ,nr,i):fill(1..nr*i)
      local cm = m:same(0i,nr,i):fill(1..nr*i)
      assertEquals( m:tmul(m2), refMul(m:t(),m2) ) -- mat' * mat
      assertEquals( m:tmul(cm), refMul(m:t(),cm) ) -- mat' * cmat
      assertTrue  ( is_cmatrix(m:tmul(cm)) )
    end
  end
end

function TestMatrixErr:testMult()
  local msg = {
    "invalid arguments (unsupported matrix operation '*')",
    "incompatible matrix sizes"                       ,
  }
  assertErrorMsgContains( msg[1], mth, 'mult', errMat     , ''          )
  assertErrorMsgContains( msg[1], mth, 'mult', errMat     , nil         )
  assertErrorMsgContains( msg[1], mth, 'mult', errMat     , 1..4        )
  assertErrorMsgContains( msg[2], mth, 'mult', matrix(2,1), matrix(1,2) )
  assertErrorMsgContains( msg[2], mth, 'mult', matrix(1,2), matrix(3,1) )
end

function TestMatrixOps:testMult()
  for _,m in ipairs(G.matidx) do
    local nr, _ = m:ncol()
    for i=1,5 do
      local m2 = m:same(_ ,i,nr):fill(1..nr*i)
      local cm = m:same(0i,i,nr):fill(1..nr*i)
      assertEquals( m:mult(m2), refMul(m, m2:t()) ) -- mat * mat'
      assertEquals( m:mult(cm), refMul(m, cm:t()) ) -- mat * cmat'
      assertTrue  ( is_cmatrix(m:mult(cm)) )
    end
  end
end

function TestMatrixErr:testDiv()
  local msg = {
    "invalid arguments (unsupported matrix operation '/')",
    "incompatible matrix sizes"                       ,
  }
  assertErrorMsgContains( msg[1], mth, 'div', errMat     , ''          )
  assertErrorMsgContains( msg[1], mth, 'div', errMat     , nil         )
  assertErrorMsgContains( msg[1], mth, 'div', errMat     , 1..4        )
  assertErrorMsgContains( msg[2], mth, 'div', matrix(2,1), matrix(1,2) )
  assertErrorMsgContains( msg[2], mth, 'div', matrix(1,2), matrix(3,1) )
end

function TestMatrixOps:testDiv()
  for _,m in ipairs(G.matidx) do
    local mn, nr, nc = m:size(), m:sizes()
    local mc = m:copy():random(randomseed(2))
    local cm = m:same(0i):fill(1..mn):map\x x+x*1i
    if nr == nc then
      assertTrue( (mc * (1/mc)):eq( mc:copy():eye(), 6*eps) ) -- num / mat
    else
      local ru, rs, rv, info = mc:svd()
      rs = mc:same():setdiag( rs:map(\x 1/x) ):t()
      local ref = rv * rs * ru:t() -- M = V*S: reciprocal():t()*U'
      local res = 1/mc
      for i=1,#res do assertAlmostEquals( res:geti(i) - ref:geti(i), 0, 32*eps ) end -- different sizes(same values)
    end
    assertEquals(  m / 2 , m:copy():map(\x  x/2   )         ) -- mat / num
    assertEquals(  m / 2i, m:copy():map(\x -x/2*1i)         ) -- mat / cpx
    assertTrue  ( (m / m  ):eq(m:copy()*1/m        ,   eps) ) -- mat / mat
    assertTrue  ( (m / cm ):eq(m:copy()*1/cm       , 2*eps) ) -- mat / mat
  end
end

function TestMatrixOps:testDivCpx()
  for _,m in ipairs(G.matidx) do
    local mref = 2i / m
    assertTrue( mref:eq( 2i*1/m, 2*eps) )
    assertTrue( is_cmatrix(mref) )
  end
end

function TestMatrixErr:testKadd()
  local msg = {
    "incompatible number of coefficients"     ,
    "incompatible matrix type"                ,
    "incompatible matrix size"                ,
    "too many matrices"                       ,
    "invalid argument #1 (iterable expected)",
    "invalid argument #2 (iterable expected)"    ,
  }
  local t = {} for i=1,21 do t[i]=matrix(2) end
  assertErrorMsgContains( msg[1], mth, 'kadd', matrix(2), vector(2), { matrix(2)            } )
  assertErrorMsgContains( msg[2], mth, 'kadd', matrix(2), vector(2), { matrix(2),cmatrix(3) } )
  assertErrorMsgContains( msg[3], mth, 'kadd', matrix(2), vector(2), { matrix(2), matrix(3) } )
  assertErrorMsgContains( msg[4], mth, 'kadd', matrix(2), vector(2), t                        )
  assertErrorMsgContains( msg[5], mth, 'kadd', matrix(2),        3 , vector(2)                )
  assertErrorMsgContains( msg[1], mth, 'kadd', matrix(2),       {3}, vector(2)                )
end

function TestMatrixOps:testKadd()
  local l = {1,3,5,7,11,13,17,19}
  for _,m in ipairs(G.matidx) do
    local m1  = m:copy()
    local x, a = {}, {}
    for j=1,#l do
      local sum = vector(l[j]):fill(1..l[j]):sum()
      for i=1,l[j] do x[i], a[i] = m:copy(), i end
      assertEquals( m1:kadd(a,x), m1:same():fill(1..#m):map(\x sum*x) )
    end
  end
  local m = matrix(2):fill(1..4)
  local x = { m:copy(), m:copy() }
  local a = { 1, 1i }
  assertTrue  ( is_matrix(m:kadd(a,x)) )
  assertEquals( m:kadd(a,x), m:copy()  )
end

function TestMatrixErr:testEmul()
  local msg = {
    "invalid arguments (unsupported matrix operation '.*')",
    "incompatible matrix sizes"            ,
  }
  assertErrorMsgContains( msg[1], mth, 'emul', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'emul', errMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'emul', errMat, 1..4      )
  assertErrorMsgContains( msg[2], mth, 'emul', errMat, matrix(1) )
  assertErrorMsgContains( msg[2], mth, 'emul', errMat, matrix(3) )
end

function TestMatrixOps:testEmul()
  for _,m in ipairs(G.matidx) do
    local mn = m:size()
    local mc = m:copy()
    local cm = m:same(0i):fill(1..mn):map(\x x+x*1i)
    assertEquals( m:emul(mc), m:map2(mc, '*') )
    assertEquals( m:emul(cm), m:map2(cm, '*') )
    assertTrue  ( is_cmatrix(m:emul(cm)) )
  end
end

function TestMatrixErr:testEdiv()
  local msg = {
    "invalid arguments (unsupported matrix operation './')",
    "incompatible matrix sizes"            ,
  }
  assertErrorMsgContains( msg[1], mth, 'ediv', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'ediv', errMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'ediv', errMat, 1..4      )
  assertErrorMsgContains( msg[2], mth, 'ediv', errMat, matrix(1) )
  assertErrorMsgContains( msg[2], mth, 'ediv', errMat, matrix(3) )
end

function TestMatrixOps:testEdiv()
  for _,m in ipairs(G.matidx) do
    local mn = m:size()
    local mc = m:copy()
    local cm = m:same(0i):fill(1..mn):map(\x x+x*1i)
    assertEquals( m:ediv(mc), m:map2(mc, '/') )
    assertEquals( m:ediv(cm), m:map2(cm, '/') )
    assertTrue  ( is_cmatrix(m:ediv(cm)) )
   end
end

-- linear algebra -------------------------------------------------------------o

function TestMatrixLapack:testSolve()
  for i,m1 in ipairs(dat.solveIn1) do
    local m2 = dat.solveIn2[i]
    local m3 = dat.solveOut[i]
    assertTrue( m1:solve(m2):eq(m3, 2*eps) )
  end
end

function TestMatrixErr:testSvd() --TODO
  local msg = {
    "invalid input argument" ,
    "SVD failed to converged",
  }
end

function TestMatrixLapack:testSvd()
  for i,m in ipairs(dat.svdIn) do
    local refU = dat.svdU[i]
    local refS = dat.svdS[i]:getdiag()
    local refV = dat.svdV[i]
    local ru, rs, rv, info = m:svd()
    local m1   = ru * m:same():setdiag(rs) * rv:t() -- M = U*S*V'
    assertTrue( ru:eq(refU,  3*eps) )
    assertTrue( rs:eq(refS, 64*eps) )
    assertTrue( rv:eq(refV,  3*eps) )
    assertTrue( m1:eq(m   , 32*eps) )
  end
end

function TestMatrixErr:testDet()
  local msg = {
    "matrix must be square",
  }
  assertErrorMsgContains( msg[1], mth, 'det', matrix(2,1) )
end

function TestMatrixLapack:testDet()
  local M = {}
  for i=1,5 do M[i] = matrix(i):random() end
  assertEquals( matrix(2):symp():det(), 1 )
  assertEquals( matrix(2):eye() :det(), 1 )
  for i,m in ipairs(M) do
    local m1 = m:same():random()
    assertAlmostEquals( (m*m1):det() - m:det()*m1:det(), 0, 3*eps )
    assertAlmostEquals(  m:t():det() - m:det()         , 0, 2*eps )
    assertAlmostEquals( (2*m) :det() - m:det()*(2^i)   , 0,   eps )
  end
end

function TestMatrixErr:testEigen()
  local msg = {
    "matrix must be square"                  ,
    "invalid input argument"                 ,
    "eigen failed to compute all eigenvalues",
  }
  assertErrorMsgContains( msg[1], mth, 'eigen', matrix(2,1) )
  assertErrorMsgContains( msg[1], mth, 'eigen', matrix(1,3) )
end

function TestMatrixLapack:testEigen()
  for i=1,5,1 do
    local m = matrix(i)
    local w, vl, vr, info = m:eigen()
    assertEquals( w   , cvector(i)      )
    assertEquals( vl  , matrix(i):eye() )
    assertEquals( vr  , matrix(i):eye() )
    assertEquals( info, 0               )
  end
  for i,m in ipairs(dat.eigenIn) do
    local w, vl, vr, info = m:eigen()
    local refD  = dat.eigenD[i]:getdiag()
    local refW  = dat.eigenW[i]
    local refV  = dat.eigenV[i]
    local diagW = m:same():setdiag(w)
    assertTrue( w         :eq( refD               , 16*eps) )
    assertTrue( vr        :eq( refV               ,  4*eps) )
    assertTrue( vl        :eq( refW               ,  4*eps) )
    assertTrue( (m * vr)  :eq( vr    * diagW      , 64*eps) ) -- A * V - V * D
    assertTrue( (vl:t()*m):eq( diagW * vl:t()     , 64*eps) ) -- W'* A - D * W'
    assertAlmostEquals( w:sum():real() - m:tr(), 0, 64*eps  )
  end
end

-- FFT, convolution, correlation, covrariance ---------------------------------o
  --vector sizes: 1,2,3,4,5,7,11,13,17,19,25
  --matrix sizes: (of 2,5,7 combinations)

function TestMatrixFFT:testFFT()
  for i,s in ipairs(dat.sv) do -- 1D
    local ref = dat.fftVOut[i]
    local res = dat.fftVIn:getsub(1..s, 1):fft()
    assertTrue( res:real():eq( ref:real(), 16*eps ) )
    assertTrue( res:imag():eq( ref:imag(), 16*eps ) ) -- linux err: 12eps
  end

  for i ,s1 in ipairs(dat.sm) do -- 2D
  for ii,s2 in ipairs(dat.sm) do
    local ref = dat.fftMOut[idx(i,ii,3)]
    local res = dat.fftMIn:getsub(1..s1, 1..s2):fft()
    assertTrue( res:real():eq( ref:real(), 16*eps ) )
    assertTrue( res:imag():eq( ref:imag(), 16*eps ) )
  end end
end

function TestMatrixFFT:testIFFT()
  local msg = {
    "invalid argument #1 (cmatrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'ifft',  vector(1), cmatrix(2) )
end

function TestMatrixErr:testRFFT()
  local msg = {
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'rfft', vector(1), matrix(2) )
  assertErrorMsgContains( msg[1], mth, 'rfft', matrix(3), vector(2) )
end

function TestMatrixFFT:testRFFT()
  for i,s in ipairs(dat.sv) do
    local ref = dat.fftVOut[i]
    local res = dat.fftVIn:getsub(1..s, 1):rfft()
    local nr = res:nrow()
    assertTrue( res:imag():eq( ref:getrow(1..nr):imag(), 16*eps ) ) -- linux err: 12eps
    assertTrue( res:real():eq( ref:getrow(1..nr):real(), 16*eps ) )
  end
  for i ,s1 in ipairs(dat.sm) do
  for ii,s2 in ipairs(dat.sm) do
    local ref = dat.fftMOut[idx(i,ii,3)]
    local res = dat.fftMIn:getsub(1..s1, 1..s2):rfft()
    local nc, nr = res:sizes()
    assertTrue( res:imag():eq(ref:getsub(1..nc,1..nr):imag(), 16*eps) )
    assertTrue( res:real():eq(ref:getsub(1..nc,1..nr):real(), 16*eps) )
  end end
end

function TestMatrixFFT:testIRFFT()
  local msg = {
    "invalid argument #1 (cmatrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'irfft',  vector(1), cmatrix(2) )
end

function TestMatrixFFT:testNFFT()
  for i,s in ipairs(dat.sv) do
    local ref = dat.fftVOut[i]
    local res = dat.fftVIn:getsub(1..s, 1)
  end

  local m = vector(10):fill(1..10):t()
  local p = vector{{0,1,2,3,4,-5,-4,-3,-2,-1}}/#m

  assertAlmostEquals( (m:nfft(p) - m:fft()  ):norm(), 0, 512*eps )
  assertAlmostEquals( (m:nfft(p):infft() - m):norm(), 0, 512*eps )
  m = vector(10):fill(10..1..-1):t()
  assertAlmostEquals( (m:nfft(p) - m:fft()  ):norm(), 0, 512*eps )
  assertAlmostEquals( (m:nfft(p):infft() - m):norm(), 0, 512*eps )

  m = vector(10):fill(11..20):t()
  p = vector{{0,1,2,3,4,-5,-4,-3,-2,-1}}/#m
  --print( (m:nfft(p) - m:fft()  ):norm() )
  m = vector(8):fill(1..8):t()
  p = vector{{0,1,2,3,-4,-3,-2,-1}}/#m
  --print( (m:nfft(p) - m:fft()  ):norm() )
end

function TestMatrixFFT:testINFFT()
local msg = {
    "polynomial degree N has to be even"           ,
    "Polynomial degree N is smaller than cut-off m",
  }
  assertErrorMsgContains( msg[1], mth, 'nfft',  vector(1), vector(3) )
end

function TestMatrixFFT:testINFFT()
local msg = {
    "invalid argument #1 (cmatrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'infft',  vector(1), cmatrix(2) )
end

function TestMatrixErr:testConv()
  local msg = {
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'conv',  vector(1), vector(2) )
  assertErrorMsgContains( msg[1], mth, 'conv',  matrix(1), matrix(2) )
end

-- pascal triangle helpers
local pasVal = \x => local y=1 for i=1,x do y=y*i end return y end
local function pasVec(x)
  local v = vector(x)
  for z=1,x do v:seti(z, pasVal(x-1)/( pasVal(z-1)*pasVal(x-z) )) end
  return v
end

 -- convolution theorem
function TestMatrixFFT:testConv()
  -- HELP - to get full conv: nr, nc = xr+yr-1, xc+yc-1
  for i=3,8 do
    local outs = (i-1)+(i-2) - 1
    local v1  = pasVec(i-1):resize(outs,1)
    local v2  = pasVec(i-2):resize(outs,1)
    local res = v1:conv(v2)
    assertTrue( res:eq(pasVec(outs), 51*eps ) )
    assertTrue( res:eq(v2:conv(v1)          ) )
  end
  for i=3,5 do
  for j=0,2 do
    local outs = i+2
    local m = dat.fftMIn:getsub(1+j..i+j, 1+j..i+j):resize(outs)
    local k = matrix{{0,0,0},{0,1,0},{0,0,0}}      :resize(outs)
    local mres = m:conv(k):roll(-1,-1)
    assertTrue( mres:getsub(1..i     ,1..i     ):eq( m:getsub(1..i, 1..i  ), 2*eps ) )
    assertTrue( mres:getsub(i+1..outs,1..i     ):eq( matrix(outs-i, i     ),   eps ) )
    assertTrue( mres:getsub(1..i     ,i+1..outs):eq( matrix(i     , outs-i), 2*eps ) )
  end end
end

 -- correlation theorem
function TestMatrixFFT:testCorr()
  for i=3,6 do
    local outs = (i-1)+(i-2) - 1
    local v1  = pasVec(i-1):resize(outs,1)
    local v2  = pasVec(i-2):resize(outs,1)
    local res = v1:corr(v2)
    assertTrue( res:eq( pasVec(outs):roll(outs/2+1,0), 16*eps ) )
    assertTrue( res:eq( v2:corr(v1) :roll(1       ,0), 16*eps ) )
  end
  for i=3,5 do
  for j=0,2 do
    local outs = i+2
    local m = dat.fftMIn:getsub(1+j..i+j, 1+j..i+j):resize(outs)
    local k = matrix{{0,0,0},{0,1,0},{0,0,0}}      :resize(outs)
    local mref = m:conv(k):roll(-1,-1)
    local mres = m:corr(k):roll( 1 ,1)
    assertTrue( mref:eq( mres, 2*eps ) )
  end end
end

function TestMatrixFFT:testCovar()
  for i=3,6 do
    local outs = (i-1)+(i-2) - 1
    local v1 = pasVec(i-1):resize(outs,1)
    local v2 = pasVec(i-2):resize(outs,1)
    local res = v1:covar(v2)
    local ref = v1:corr (v2):center()
    assertTrue( res:eq( ref, 16*eps ) )
  end
  for i=3,5 do
    local outs = i+2
    local m = dat.fftMIn:getsub(1..i, 1..i)  :resize(outs)
    local k = matrix{{0,0,0},{0,1,0},{0,0,0}}:resize(outs)
    local mref = m:corr (k):roll(1,1):center()
    local mres = m:covar(k):roll(1,1)
    assertTrue( mref:eq( mres, 2*eps ) )
  end
end

-- rotations ------------------------------------------------------------------o

function TestMatrixErr:testRot()
  local msg = {
    "invalid argument #1 (2D squared matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'rot', matrix(2,1), pi )
  assertErrorMsgContains( msg[1], mth, 'rot', matrix(2,3), pi )
end

function TestMatrixErr:testRotxyz()
  local msg = {
    "invalid argument #1 (3D squared matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'rotx', matrix(3,2), pi )
  assertErrorMsgContains( msg[1], mth, 'roty', matrix(3,2), pi )
  assertErrorMsgContains( msg[1], mth, 'rotz', matrix(3,2), pi )
end

function TestMatrixRot:testRot()
  local m = matrix(2)
  for i,a in ipairs(dat.rad) do
    local res = m:rot(a)
    local ref = dat.rot[i]
    assertTrue( res:eq( ref, eps ) )
  end
end

function TestMatrixRot:testRotx()
  local m = matrix(3)
  for i,ax in ipairs(dat.rad) do
    local res = m:rotx(ax)
    local ref = dat.rotx[i]
    assertTrue( (res:t()*res):eq(m:same():eye(), eps) )
    assertTrue( res:eq( ref, eps ) )
  end
end

function TestMatrixRot:testRoty()
  local m = matrix(3)
  for i,ay in ipairs(dat.rad) do
    local res = m:roty(ay)
    local ref = dat.roty[i]
    assertTrue( (res:t()*res):eq(m:same():eye(), eps) )
    assertTrue( res:eq( ref, eps ) )
  end
end

function TestMatrixRot:testRotz()
  local m = matrix(3)
  for i,az in ipairs(dat.rad) do
    local res = m:rotz(az)
    local ref = dat.rotz[i]
    assertTrue( (res:t()*res):eq(m:same():eye(), eps) )
    assertTrue( res:eq( ref, eps ) )
  end
end

function TestMatrixRot:testRotxy()
  local m = matrix(3)
  for i,ax in ipairs(dat.rad) do
    for ii,ay in ipairs(dat.rad) do
      local res = m:same():rotxy(ax,ay)
      local ref = m:same():roty(ay)*m:same():rotx(ax)
      assertTrue( res:eq( ref, eps ) )
    end
  end
end

function TestMatrixRot:testRotxz()
  local m = matrix(3)
  for i,ax in ipairs(dat.rad) do
    for ii,az in ipairs(dat.rad) do
      local res = m:same():rotxz(ax,az)
      local ref = m:same():rotz(az)*m:same():rotx(ax)
      assertTrue( res:eq( ref, eps ) )
    end
  end
end

function TestMatrixRot:testRotyz()
  local m = matrix(3)
  for i,ay in ipairs(dat.rad) do
    for ii,az in ipairs(dat.rad) do
      local res = m:same():rotyz(ay,az)
      local ref = m:same():rotz(az)*m:same():roty(ay)
      assertTrue( res:eq( ref, eps ) )
    end
  end
end

function TestMatrixRot:testRotyx()
  local m = matrix(3)
  for i,ay in ipairs(dat.rad) do
    for ii,ax in ipairs(dat.rad) do
      local res = m:same():rotyx(ay,ax)
      local ref = m:same():rotx(ax)*m:same():roty(ay)
      assertTrue( res:eq( ref, eps ) )
    end
  end
end

function TestMatrixRot:testRotzx()
  local m = matrix(3)
  for i,az in ipairs(dat.rad) do
    for ii,ax in ipairs(dat.rad) do
      local res = m:same():rotzx(az,ax)
      local ref = m:same():rotx(ax)*m:same():rotz(az)
      assertTrue( res:eq( ref, eps ) )
    end
  end
end

function TestMatrixRot:testRotzy()
  local m = matrix(3)
  for i,az in ipairs(dat.rad) do
    for ii,ay in ipairs(dat.rad) do
      local res = m:same():rotzy(az,ay)
      local ref = m:same():roty(ay)*m:same():rotz(az)
      assertTrue( res:eq( ref, eps ) )
    end
  end
end

function TestMatrixRot:testRotxyz()
  local m = matrix(3)
  for i,ax in ipairs(dat.rad) do
    for ii,ay in ipairs(dat.rad) do
      for iii,az in ipairs(dat.rad) do
        local res = m:same():rotxyz(ax,ay,az)
        local ref = m:same():rotz(az)*m:same():roty(ay)*m:same():rotx(ax)
        assertTrue( res:eq( ref, eps ) )
      end
    end
  end
end

function TestMatrixRot:testRotzyx()
  local m = matrix(3)
  for i,ax in ipairs(dat.rad) do
    for ii,ay in ipairs(dat.rad) do
      for iii,az in ipairs(dat.rad) do
        local res = m:same():rotzyx(ax,ay,az)
        local ref = m:same():rotx(ax)*m:same():roty(ay)*m:same():rotz(az)
        assertTrue( res:eq( ref, eps ) )
      end
    end
  end
end
--[[
function TestMatrixRot:testRotpitch()
  local m = matrix(3)
  for i,ax in ipairs(dat.rad) do
    local res = m:rotpitch(-ax)
    local ref = dat.rotx[i]
    assertEquals( res:t()*res, m:same():eye() )
    assertTrue  ( res:eq( ref, eps ) )
  end
end

function TestMatrixRot:testRotyaw()
  local m = matrix(3)
  for i,ay in ipairs(dat.rad) do
    local res = m:rotyaw(-ay)
    local ref = dat.roty[i]
    assertEquals( res:t()*res, m:same():eye() )
    assertTrue  ( res:eq( ref, eps ) )
  end
end

function TestMatrixRot:testRotroll()
  local m = matrix(3)
  for i,az in ipairs(dat.rad) do
    local res = m:rotroll(-az)
    local ref = dat.rotz[i]
    assertEquals( res:t()*res, m:same():eye() )
    assertTrue  ( res:eq( ref, eps ) )
  end
end
]]

function TestMatrixRot:testRotmad()
  local m = matrix(3)
  for i,th in ipairs(dat.rad) do
    for ii,phi in ipairs(dat.rad) do
      for iii,psi in ipairs(dat.rad) do
        local res = m:same():rotmad(th,phi,psi)
        local ref = m:same():roty(th)*m:same():rotx(-phi)*m:same():rotz(psi)
        assertTrue( res:eq( ref, eps ) )
      end
    end
  end
end

function TestMatrixRot:testTorotmad()
  local m = matrix(3)
  for i,th in ipairs(dat.rad) do
    for ii,phi in ipairs(dat.rad) do
      for iii,psi in ipairs(dat.rad) do
        local a1, a2, a3 = m:same():rotmad(th,phi,psi):torotmad(th/2,phi/2,psi/2)
        if phi == pi then
          assertAlmostEquals( a1 - th ,-pi, eps )
          assertAlmostEquals( a2 - phi,-pi, eps )
          assertAlmostEquals( a3 - psi,-pi, eps )
        else
          assertAlmostEquals( a1 - th , 0 , eps )
          assertAlmostEquals( a2 - phi, 0 , eps )
          assertAlmostEquals( a3 - psi, 0 , eps )
        end
      end
    end
  end
end

function TestMatrixErr:testRotv()
  local msg = {
    "invalid argument #2 (iterable expected)"         ,
    "invalid argument #1 (3D squared matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'rotv', matrix(3)  , pi          )
  assertErrorMsgContains( msg[2], mth, 'rotv', matrix(2,3), {1,0,0}, pi )
end

function TestMatrixRot:testRotv()
  local v, m = vector{0,0,1}:unit(), matrix(3)
  for _,a in ipairs(dat.rad) do
    for _,a1 in ipairs(dat.rad) do
      for _,a2 in ipairs(dat.rad) do
        local m1  = m:same():rotz( a1 )
        local m2  = m:same():roty( a2 )
        local m3  = m:same():rotz( a  )
        local v1  = m1 * m2 * v
        local res = m:same():rotv(v1,a)
        local ref = m1 * m2 * m3 * ( m1 * m2 ):t()
        assertTrue( res:eq( ref, eps ) )
      end
    end
  end
end

function TestMatrixErr:testTorotv() -- TODO after fix
  local msg = {
    "invalid argument #2 (iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'torotv', matrix(3), 1  )
end

-- setup, teardown for torotv fix
--[[
local fmt = MAD.option.format
function TestMatrixRot:testSetUp()
  MAD.option.format = "%.5e"
end

function TestMatrixRot:testTearDown()
  MAD.option.format = fmt
end
]]

function TestMatrixRot:testTorotv()
  local fmt = MAD.option.format
  MAD.option.format = "%.5e"
  --print()
  --print('a/pi', '', 'a1/pi', '', 'a2/pi', '', '|res|', '', '|v1|', '', 'res-v1')
  local v, m = vector{0,0,1}:unit(), matrix(3)
  for _,a in ipairs(dat.rad) do
    for _,a1 in ipairs(dat.rad) do
      for _,a2 in ipairs(dat.rad) do
        local m1  = m:same():rotz( a1 )
        local m2  = m:same():roty( a2 )
        local v1  = m1 * m2 * v
        local res, ares = m:same():rotv(v1,a):torotv()
        assertAlmostEquals( ares - a, 0, eps )
        --print( a/pi, a1/pi, a2/pi,
        --       res[1]-v1:geti(1), res[2]-v1:geti(2), res[3]-v1:geti(3))
          --assertAlmostEquals( res[j] - v1:geti(j), 0, eps )
      end
    end
  end
  MAD.option.format = fmt
end

function TestMatrixErr:testRotq()
local msg = {
    "invalid argument #2 (iterable expected)"         ,
    "invalid argument #1 (3D squared matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'rotq', matrix(3)  , pi        )
  assertErrorMsgContains( msg[2], mth, 'rotq', matrix(2,3), {1,0,0,0} )
end

function TestMatrixRot:testRotq()
  local v, m = vector{0,0,1}:unit(), matrix(3)
  for _,a in ipairs(dat.rad) do
    for _,a1 in ipairs(dat.rad) do
      for _,a2 in ipairs(dat.rad) do
        local m1  = m:same():rotz( a1 )
        local m2  = m:same():roty( a2 )
        local m3  = m:same():rotz( a  )
        local v1  = m1 * m2 * v
        local ref = m:same():rotv(v1,a)
        local q   = {cos(a/2), v1[1]*sin(a/2), v1[2]*sin(a/2), v1[3]*sin(a/2) }
        local res = m:same():rotq(q)
        assertTrue( res:eq( ref, 2*eps ) )
      end
    end
  end
end

function TestMatrixRot:testTorotq() -- TODO
  local v, m = vector{0,0,1}:unit(), matrix(3)
  for _,a in ipairs(dat.rad) do
    for _,a1 in ipairs(dat.rad) do
      for _,a2 in ipairs(dat.rad) do
        local m1  = m:same():rotz( a1 )
        local m2  = m:same():roty( a2 )
        local v1  = m1 * m2 * v
        local q   = {cos(a/2), v1[1]*sin(a/2), v1[2]*sin(a/2), v1[3]*sin(a/2) }
        local res = (m:same():rotq(q)):torotq()
        --print(q  )
        --print(res,"\n --")
        assertAlmostEquals( res[1] - q[1], 0, eps)
      end
    end
  end
end

-- concatenation, conversion --------------------------------------------------o

function TestMatrixErr:testConcat()
  local msg = {
    "invalid argument #1 (matrix expected)"                     ,
    "invalid argument #2 (matrix expected)"                     ,
    "incompatible matrix sizes"                                 ,
    "invalid argument #3 (string 'vec', row' or 'col' expected)",
    "incompatible matrix sizes"                                 ,
  }
  assertErrorMsgContains( msg[2], mth, 'concat', errMat     , ''                            )
  assertErrorMsgContains( msg[2], mth, 'concat', errMat     , nil                           )
  assertErrorMsgContains( msg[2], mth, 'concat', errMat     , 1..4                          )
  assertErrorMsgContains( msg[3], mth, 'concat', errMat     , matrix(1)                     )
  assertErrorMsgContains( msg[3], mth, 'concat', matrix(3)  , errMat                        )
  assertErrorMsgContains( msg[4], mth, 'concat', errMat     , errMat     , ''               )
  assertErrorMsgContains( msg[4], mth, 'concat', errMat     , errMat     , 1                )
  assertErrorMsgContains( msg[5], mth, 'concat', matrix(1,2), matrix(3,2), 'row'            )
  assertErrorMsgContains( msg[5], mth, 'concat', matrix(2,3), matrix(2,2), 'col'            )
  assertErrorMsgContains( msg[5], mth, 'concat', errMat     , errMat     , 'col', matrix(3) )
end

function TestMatrix:testConcat()
  for _,m in ipairs(G.matidx) do
    local mn, nr, nc, _ = m:size(), m:sizes()
    local mref1 = m:same(_,2*nr,  nc):setsub(1..nr, 1..nc, 1..mn):setsub(1+nr..2*nr, 1   ..  nc, 1..mn)
    local mref2 = m:same(_,  nr,2*nc):setsub(1..nr, 1..nc, 1..mn):setsub(1   ..  nr, 1+nc..2*nc, 1..mn)
    local mref3 = m:same(_,2*mn,  1 ):setsub(1..mn, 1    , 1..mn):setsub(1+mn..2*mn, 1         , 1..mn)
    assertEquals( m:concat( m       ), mref1 )
    assertEquals( m:concat( m, 'col'), mref1 )
    assertEquals( m:concat( m, 'row'), mref2 )
    assertEquals( m:concat( m, 'vec'), mref3 )
  end
end

function TestMatrixConv:testTostring()
  local m = matrix(2)
  assertTrue( is_string(m:tostring(    )) )
  assertTrue( is_string(m:tostring(''  )) )
  assertTrue( is_string(m:tostring("\n")) )
  for i,m in ipairs(G.matidx) do
    local c, nr, nc = {}, m:sizes()
    local ref1 = {} for i=1,nr do for j=1,nc do c[j]=tostring(idx(i,j,nc)) end ref1[i]=table.concat(c, ' ' ) end
    local ref2 = {} for i=1,nr do for j=1,nc do c[j]=tostring(idx(i,j,nc)) end ref2[i]=table.concat(c      ) end
    local ref3 = {} for i=1,nr do for j=1,nc do c[j]=tostring(idx(i,j,nc)) end ref3[i]=table.concat(c, "\n") end
    assertEquals( m:tostring(    ), table.concat(ref1, '\n') )
    assertEquals( m:tostring(''  ), table.concat(ref2, '\n') )
    assertEquals( m:tostring('\n'), table.concat(ref3, '\n') )
  end
end

function TestMatrixErr:testTotable()
  local msg = {
    "invalid argument #2 (table expected)"          ,
    "invalid argument #2 (table of tables expected)",
  }
  assertErrorMsgContains( msg[1], errMat.totable, errMat, ''     )
  assertErrorMsgContains( msg[1], errMat.totable, errMat, 1      )
  assertErrorMsgContains( msg[1], errMat.totable, errMat, true   )
  assertErrorMsgContains( msg[1], errMat.totable, errMat, 1..2   )
  assertErrorMsgContains( msg[1], errMat.totable, errMat, errMat )
  assertErrorMsgContains( msg[2], errMat.totable, errMat, {{},5} )
end

function TestMatrixConv:testTotable()
  for i,m in ipairs(G.matidx) do
    local nr, nc = m:sizes()
    local tref   = m:totable()
    if nc ~=1 then for i=1,nr do for j=1,nc do assertEquals( tref[i][j], idx(i,j,nc) ) end end
              else for i=1,nr do               assertEquals( tref[i]   , idx(i,1,nc) ) end end
    assertTrue  ( is_table(m:totable())    )
    assertEquals( matrix  (m:totable()), m )
  end
end

TestMatrixZ = {}

function TestMatrixZ:testGMatixCheck()
  for i,m in ipairs(G.matidx) do
    local mn = m:size()
    assertEquals( G.size[i], {m:sizes()}           )
    assertEquals( m        ,  m:same():fill(1..mn) )
  end
  for i,m in ipairs(G.mattmp) do
    assertEquals( G.size[i], {m:sizes()} )
    assertEquals( m        ,  m:same()   )
  end
end

-- performance test suite -----------------------------------------------------o

Test_Matrix = {}

--fill benchmark
function Test_Matrix:testFillGen2()
  local m = matrix(2)
  local r = 1..4
  local t0 = os.clock()
  for i=1,1e7 do
    m:fill(r)
  end
  local dt = os.clock() - t0
  assertAlmostEquals( dt, 0.5, 1 )
end

function Test_Matrix:testFillScal2()
  local m = matrix(2)
  local t0 = os.clock()
  for i=1,1e7 do
    m:fill(1)
  end
  local dt = os.clock() - t0
  assertAlmostEquals( dt, 0.5, 1 )
end

function Test_Matrix:testFillTab2()
  local m = matrix(2)
  local t = {1,2,3,4}
  local t0 = os.clock()
  for i=1,1e7 do
    m:fill(t)
  end
  local dt = os.clock() - t0
  assertAlmostEquals( dt, 0.5, 1 )
end

function Test_Matrix:testFillGen3()
  local m = matrix(3)
  local r = 1..9
  local t0 = os.clock()
  for i=1,1e7 do
    m:fill(r)
  end
  local dt = os.clock() - t0
  assertAlmostEquals( dt, 0.5, 1 )
end

function Test_Matrix:testFillScal3()
  local m = matrix(3)
  local t0 = os.clock()
  for i=1,1e7 do
    m:fill(1)
  end
  local dt = os.clock() - t0
  assertAlmostEquals( dt, 0.5, 1 )
end

function Test_Matrix:testFillTab3()
  local m = matrix(3)
  local t = {1,2,3,4,5,6,7,8,9}
  local t0 = os.clock()
  for i=1,1e7 do
    m:fill(t)
  end
  local dt = os.clock() - t0
  assertAlmostEquals( dt, 0.5, 1 )
end

-- end ------------------------------------------------------------------------o


