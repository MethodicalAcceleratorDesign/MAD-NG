--[=[
 o-----------------------------------------------------------------------------o
 |
 | Matrix module regression tests - real matrices
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the matrix module.

 o-----------------------------------------------------------------------------o
]=]

local assertEquals, assertAlmostEquals, assertInf, assertFalse, assertNotEquals,
      assertErrorMsgContains, assertNil, assertNaN, assertIsString, assertTrue
      in require 'luaunit'

local vector, cvector, matrix, cmatrix, is_vector, is_matrix, is_cvector,
      is_cmatrix, isa_vector, isa_matrix, linspace, logspace in MAD

local complex, range, nrange, nlogrange,infi, tiny, eps, huge, inf, nan, pi, Pi,
      randomseed, abs, log, min, totable, is_complex, is_cdata, is_table,
      is_nil, is_string in MAD

-- locals ---------------------------------------------------------------------o

local mth = \f,s,... s[f](s,...)
local ref = \i,j,nc ( (i-1)*nc+j )

local values = {
  num = { tiny, 2^-64, 2^-63, 2^-53, eps, 2^-52, 2*eps, 2^-32, 2^-31, 1e-9,
          0.1-eps, 0.1, 0.1+eps, 0.5, 0.7-eps, 0.7, 0.7+eps, 1-eps, 1, 1+eps,
          1.1, 1.7, 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53,
          2^63, 2^64, huge },
}

local errMat = matrix(2)

local G = {}
G.mat   = {}
G.size  = {}
G.empty = {}
for nr=1,5 do
  for nc=1,5 do
    G.mat  [ref(nr,nc,5)] = matrix(nr,nc):fill(1..nr*nc)
    G.empty[ref(nr,nc,5)] = matrix(nr,nc)
    G.size [ref(nr,nc,5)] = {nr,nc}
  end
end

-- regression test suites -----------------------------------------------------o

TestMatrix    = {}
TestMatrixErr = {}

TestMatrixGet = {}
TestMatrixSet = {}

TestMatrixInPlace   = {}
TestMatrixInPlaceII = {}
TestMatrixFun       = {}

TestMatrixSMaps  = {}
TestMatrixSFolds = {}
TestMatrixSScans = {}

TestMatrixSympl  = {}
TestMatrixLinAlg = {}
TestMatrixOps    = {}
TestMatrixLapack = {}
TestMatrixFFT    = {}
TestMatrixConv   = {}

function TestMatrixErr:testCtor()
  local msg = {
  "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
   "matrix too large",
  }
  assertErrorMsgContains( msg[1], matrix, ''     )
  assertErrorMsgContains( msg[1], matrix, nil    )
  assertErrorMsgContains( msg[1], matrix, 0      )
  assertErrorMsgContains( msg[1], matrix, tiny   )
  assertErrorMsgContains( msg[1], matrix, eps    )
  assertErrorMsgContains( msg[1], matrix, 1..2   )
  assertErrorMsgContains( msg[1], matrix, infi   )
  assertErrorMsgContains( msg[1], matrix, nan    )
  assertErrorMsgContains( msg[1], matrix,-1      )
  assertErrorMsgContains( msg[1], matrix,-eps    )
  assertErrorMsgContains( msg[2], matrix, inf    )
  assertErrorMsgContains( msg[2], matrix, huge   )
  assertErrorMsgContains( msg[2], matrix, 2^15+1 )
  assertErrorMsgContains( msg[2], vector, 2^30+1 )
end

function TestMatrix:testCtor()
  local nr, nc
  --assertTrue( is_matrix( vector(2^30)) )
  --assertTrue( is_matrix( matrix(2^15)) )
  for i,m in ipairs(G.mat) do
    nr, nc = m:sizes()
    assertTrue  ( is_matrix(m) )
    if nc==1 then
      assertTrue  ( is_vector(m) )
      assertEquals( nc, 1 )
    else
    assertEquals( nr, G.size[i][1] )
    assertEquals( nc, G.size[i][2] )
    end
  end
end

function TestMatrixErr:testCtorFromtable()
  local msg = {
  "invalid argument #1 (non-empty table expected)",
  "cannot convert 'string' to 'double'"           ,
  "cannot convert 'string' to 'complex'"          ,
  }
  assertErrorMsgContains( msg[1],  matrix, {nil} )
  assertErrorMsgContains( msg[2],  matrix, {''}  )
end

function TestMatrix:testCtorFromtable() --TODO
  assertTrue  ( is_matrix( matrix{2} ) )
  assertTrue  ( is_vector( matrix{2} ) )
  assertTrue  ( is_matrix ( matrix{complex(0,0)} ) )
  assertEquals( matrix{complex(0,0)},  matrix(1) ) -- complex/real matrix
  assertEquals( matrix{complex(0,0)}, cmatrix(1) )
end

function TestMatrix:testCdataType()
  local m, v = matrix(2), vector(2)
  assertTrue ( is_matrix ( m ) )
  assertTrue ( is_matrix ( v ) )
  assertFalse( is_vector ( m ) )
  assertTrue ( is_vector ( v ) )
  assertFalse( is_cmatrix( m ) )
  assertFalse( is_cmatrix( v ) )
  assertFalse( is_cvector( m ) )
  assertFalse( is_cvector( v ) )
  assertFalse( isa_vector( m ) )
  assertTrue ( isa_vector( v ) )
  assertTrue ( isa_matrix( m ) )
  assertTrue ( isa_matrix( v ) )
end

function TestMatrixErr:testLinspace()
  local msg = {
    "invalid argument #1 (finite scalar expected)"  ,
    "invalid argument #2 (finite scalar expected)"  ,
    "invalid argument #3 (positive number expected)",
    "bad argument #1 to 'ceil'"                     ,
    "matrix too large"                              ,
  }
  assertErrorMsgContains( msg[1], linspace, nil       )
  assertErrorMsgContains( msg[1], linspace, nil, 2    )
  assertErrorMsgContains( msg[1], linspace, '' , 2    )
  assertErrorMsgContains( msg[1], linspace, nan, 2    )
  assertErrorMsgContains( msg[1], linspace, inf, 2    )
  assertErrorMsgContains( msg[1], linspace,-inf, 2    )
  assertErrorMsgContains( msg[2], linspace, 2  , ''   )
  assertErrorMsgContains( msg[2], linspace, 2  , 1..2 )
  assertErrorMsgContains( msg[2], linspace, 2  , nan  )
  assertErrorMsgContains( msg[2], linspace, 2  , inf  )
  assertErrorMsgContains( msg[2], linspace, 2  ,-inf  )
  assertErrorMsgContains( msg[2], linspace, 2  , 1..2 )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  , 0    )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  ,-1    )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  , nan  )
  assertErrorMsgContains( msg[5], linspace, 2  , 2  , inf  )
  assertErrorMsgContains( msg[3], linspace, 2  , 2  ,-inf  )
  assertErrorMsgContains( msg[4], linspace, 2  , 2  , ''   )
  assertErrorMsgContains( msg[4], linspace, 2  , 2  , 1..2 )
end

function TestMatrix:testLinspace()
  local nrng, l, nr = {
        { 1 , 10, 100}, { 1, 10, 100}, { 10, 1 , 10}, { 1,-10, 10},
        { 10,-1 , 100}, {-1, 10, 100}, {-10, 1 , 10}, {-1,-10, 10},
        {-10,-1 , 100},
        }
  assertTrue  (  is_vector (linspace(1,1))          )
  assertTrue  (  is_cvector(linspace(complex(1,1))) )
  assertEquals(  linspace( 1 )           [1]  , 0   )
  assertEquals(  linspace( 1 )           [100], 1   )
  assertEquals(  linspace( 2, 2, nil)    [1]  , 2   )
  assertEquals(  linspace( 2, 2, nil)    [100], 2   )
  assertEquals( #linspace( 2, 2, nil)         , 100 )
  assertEquals(  linspace( complex(1,1) )[100], complex(1,1) )
  assertEquals(  linspace( complex(1,1) )[1]  , complex(0,0) )
  nr = nrange  ( 0.5, 1 , 1000 )
  l  = linspace( 0.5, 1 , 1000 )
  assertEquals ( l[1]   , nr[1]    )
  assertEquals ( l[1000], nr[1000] )

  for _,v in ipairs(nrng) do
    nr = nrange  ( v[1], v[2], v[3] )
    l  = linspace( v[1], v[2], v[3] )
    for i=1,#nr do
      assertEquals( l[i] - nr[i], 0 )
    end
    nr = nrange  ( v[1], v[2], v[3] )
    l  = linspace( complex(v[1],v[1]), complex(v[2],v[2]), v[3] )
    for i=1,#nr do
      assertAlmostEquals( l[i].re - complex(nr[i],nr[i]).re , 0, eps )
      assertAlmostEquals( l[i].im - complex(nr[i],nr[i]).im , 0, eps )
    end
  end
end

function TestMatrixErr:testLogspace()
  local msg = {
    "invalid argument #1 (positive finite number expected)",
    "invalid argument #2 (positive finite number expected)",
    "invalid argument #3 (positive number expected)"       ,
    "bad argument #1 to 'ceil'"                            ,
  }
  assertErrorMsgContains( msg[1], logspace, 0          )
  assertErrorMsgContains( msg[1], logspace, nil        )
  assertErrorMsgContains( msg[1], logspace, nil , 1    )
  assertErrorMsgContains( msg[1], logspace, ''  , 1    )
  assertErrorMsgContains( msg[1], logspace, 1..2, 2    )
  assertErrorMsgContains( msg[1], logspace, nan , 2    )
  assertErrorMsgContains( msg[1], logspace, inf , 2    )
  assertErrorMsgContains( msg[1], logspace,-inf , 2    )
  assertErrorMsgContains( msg[2], logspace, 1   , ''   )
  assertErrorMsgContains( msg[2], logspace, 2   , 1..2 )
  assertErrorMsgContains( msg[2], logspace, 2   , nan  )
  assertErrorMsgContains( msg[2], logspace, 2   , inf  )
  assertErrorMsgContains( msg[2], logspace, 2   ,-inf  )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  ,-1    )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  , 0    )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  , nan  )
  assertErrorMsgContains( msg[3], logspace, 2   , 2  ,-inf  )
  assertErrorMsgContains( msg[4], logspace, 2   , 2  , ''   )
  assertErrorMsgContains( msg[4], logspace, 2   , 2  , 1..2 )
end

function TestMatrix:testLogspace()
  local nlrng, nr, l =  { { 10^5, 1, 100 }, { 1, 10^5, 100 }, { 1, 10^-5, 100 }, }
  assertTrue  ( is_vector (logspace(1,1))          )
  assertTrue  ( is_cvector(logspace(complex(1,1))) )
  assertEquals( logspace( 1 )           [1]  , 1   )
  assertEquals( logspace( 1 )           [100], 1   )
  assertEquals( logspace( 2, 2, nil)    [1]  , 2   )
  assertEquals( logspace( 2, 2, nil)    [100], 2   )
  assertEquals(#logspace( 2, 2, nil)         , 100 )
  assertAlmostEquals( logspace( 0.1 )         [100] - 0.1, 0, eps )
  assertAlmostEquals( logspace( complex(1,1) )[100].re - complex(1,1).re, 0, eps )
  assertAlmostEquals( logspace( complex(1,1) )[100].im - complex(1,1).im, 0, eps )

  for _,v in ipairs(nlrng) do
    nr = nlogrange  ( v[1], v[2], v[3] )
    l  = logspace( v[1], v[2], v[3] )
    for i=1,#nr do
      assertEquals( l[i] - nr[i], 0 )
    end
    nr = nrange  ( v[1], v[2], v[3] )
    l  = linspace( complex(v[1],v[1]), complex(v[2],v[2]), v[3] )
    for i=1,#nr do
      assertAlmostEquals( l[i].re - complex(nr[i],nr[i]).re , 0, eps )
      assertAlmostEquals( l[i].im - complex(nr[i],nr[i]).im , 0, eps )
    end
  end
end

-- get, set -------------------------------------------------------------------o

function TestMatrixSet:setUp()
  self.mat   = {}
  self.empty = {}
  for nr=1,5 do
    for nc=1,5 do
      self.mat  [ref(nr,nc,5)] = matrix(nr,nc):fill(1..nr*nc)
      self.empty[ref(nr,nc,5)] = matrix(nr,nc)
    end
  end
end

function TestMatrixErr:testGeti0()
    local msg = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'geti0', errMat, nil )
end

function TestMatrixGet:testGeti0()
  for _,m in ipairs(G.mat) do
    for i=1,m:size() do assertEquals( m:geti0(i-1), i ) end
  end
end

function TestMatrixErr:testGeti()
  local msg = {
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'geti', errMat, nil )
end

function TestMatrixGet:testGeti()
  for _,m in ipairs(G.mat) do
    for i=1,m:size() do assertEquals( m:geti(i), i ) end
  end
end

function TestMatrixErr:testGet0()
  local msg = {
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'get0', errMat, 0  , nil )
  assertErrorMsgContains( msg[1], mth, 'get0', errMat, nil, 0   )
end

function TestMatrixGet:testGet0()
  local nr, nc
  for _,m in ipairs(G.mat) do
    nr, nc = m:sizes()
    for i=1,nr do
    for j=1,nc do
      assertEquals( m:get0(i-1,j-1), ref(i,j,nc) )
    end end
  end
end

function TestMatrixErr:testGet()
  local msg = {
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'get0', errMat, 1  , nil )
  assertErrorMsgContains( msg[1], mth, 'get0', errMat, nil, 1   )
end

function TestMatrixGet:testGet()
  local nr, nc
  for _,m in ipairs(G.mat) do
    nr, nc = m:sizes()
    for i=1,nr do
    for j=1,nc do
      assertEquals( m:get(i,j), ref(i,j,nc) )
    end end
  end
end

function TestMatrixErr:testSeti0()
  local msg = {
    "0-index out of bounds"             ,
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'seti0', errMat, nan  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', errMat,-1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', errMat,-eps  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti0', errMat, 4    , 1 )
  assertErrorMsgContains( msg[2], mth, 'seti0', errMat, nil  , 1 )
end

function TestMatrixSet:testSeti0()
  for _,m in ipairs(self.empty) do
    for i=1,m:size() do
      m:seti0((i-1), i)
      assertEquals( m:geti0(i-1), i )
    end
  end
end

function TestMatrixErr:testSeti()
  local msg = {
    "1-index out of bounds"             ,
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'seti', errMat, nan  , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', errMat, 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', errMat, 1-eps, 1 )
  assertErrorMsgContains( msg[1], mth, 'seti', errMat, 5    , 1 )
  assertErrorMsgContains( msg[2], mth, 'seti', errMat, nil  , 1 )
end

function TestMatrixSet:testSeti()
  for _,m in ipairs(self.empty) do
    for i=1,m:size() do
      m:seti((i), i)
      assertEquals( m:geti(i), i )
    end
  end
end

function TestMatrixErr:testSet0()
  local msg = {
    "0-index out of bounds"             ,
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'set0', errMat, nan  , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', errMat,-1    , 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', errMat,-1+eps, 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', errMat, 0    ,-1+eps, 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', errMat, 2    , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set0', errMat, 1    , 2    , 1 )
  assertErrorMsgContains( msg[2], mth, 'set0', errMat, nil  , 1    , 1 )
  assertErrorMsgContains( msg[2], mth, 'set0', errMat, 1    , nil  , 1 )
end

function TestMatrixSet:testSet0()
  local nr, nc
  for _,m in ipairs(self.empty) do
    nr, nc = m:sizes()
    for i=1,nr do
    for j=1,nc do
      m:set0(i-1,j-1, ref(i,j,nc) )
      assertEquals( m:get0(i-1,j-1), ref(i,j,nc) )
    end end
  end
end

function TestMatrixErr:testSet()
  local msg = {
    "1-index out of bounds"             ,
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'set', errMat, nan  , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', errMat, 0    , 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', errMat, 1    , 0    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', errMat, 1-eps, 1    , 1 )
  assertErrorMsgContains( msg[1], mth, 'set', errMat, 1    , 1-eps, 1 )
  assertErrorMsgContains( msg[2], mth, 'set', errMat, nil  , 1    , 1 )
end

function TestMatrixSet:testSet()
  local nr, nc
  for _,m in ipairs(self.empty) do
    nr, nc = m:sizes()
    for i=1,nr do
    for j=1,nc do
      m:set(i, j, ref(i,j,nc) )
      assertEquals( m:get(i,j), ref(i,j,nc) )
    end end
  end
end

function TestMatrixErr:testSame()
  local msg, s = {
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
    "invalid argument #1 (non-empty table expected)"                           ,
    "invalid argument #2 (nil or scalar expected)"                             ,
  }
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1   , ''   )
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1   , 1..2 )
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1   , nan  )
  assertErrorMsgContains( msg[2], mth, 'same', errMat, 1   , {}   )
  assertErrorMsgContains( msg[3], mth, 'same', errMat, ''  , 2, 2 )
  assertErrorMsgContains( msg[3], mth, 'same', errMat, 1..2, 2, 2 )
end

function TestMatrixSet:testSame()
  local s
  s = errMat:same( nan)          assertEquals( s:get(1,1), 0 )
  s = errMat:same( inf)          assertEquals( s:get(1,1), 0 )
  s = errMat:same( 0  )          assertEquals( s:get(1,1), 0 )

  for _,m in ipairs(G.mat) do
    -- no input
    s = m:same()    assertEquals( s, matrix(m:sizes()) )
    -- two arg: nr, nc
    s = m:same(2  ,2  ) assertEquals( s, matrix(2) )
    s = m:same(6  ,6  ) assertEquals( s, matrix(6) )
    s = m:same(nil,2,2) assertEquals( s, matrix(2) )
    -- three arg: e_, nr, nc
    s = m:same(complex(1,1), 2, 2) assertEquals( {s:sizes()}, {2,2} ) assertFalse( is_matrix(s) )
    s = m:same(1, 2, 2)            assertEquals( {s:sizes()}, {2,2} ) assertTrue ( is_matrix(s) )
  end
end

-- getx, setx -----------------------------------------------------------------o

function TestMatrixErr:testGetsub()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "invalid argument #4 (iterable expected)",
    "invalid range member '1'"               ,
    "cannot convert 'nil' to 'double'"       ,
  }
  assertErrorMsgContains( msg[1], mth, 'getsub', errMat, nil          )
  assertErrorMsgContains( msg[1], mth, 'getsub', errMat, ''           )
  assertErrorMsgContains( msg[1], mth, 'getsub', errMat, \x x         )
  assertErrorMsgContains( msg[1], mth, 'getsub', errMat, complex(1,1) )
  assertErrorMsgContains( msg[2], mth, 'getsub', errMat, 1   , nil    )
  assertErrorMsgContains( msg[2], mth, 'getsub', errMat, 1   , ''     )
  assertErrorMsgContains( msg[2], mth, 'getsub', errMat, 1   , \x x   )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, 0   , 0      )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, 3   , 1      )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, 1   , 3      )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, 0   , 1      )
  assertErrorMsgContains( msg[5], mth, 'getsub', errMat, 1   , 0      )
  assertErrorMsgContains( msg[3], mth, 'getsub', errMat, 0   , 0   , 1    )
  assertErrorMsgContains( msg[3], mth, 'getsub', errMat, 1   , 1   , \x x )
  assertErrorMsgContains( msg[4], mth, 'getsub', errMat, 1   , 1   , 1..4 )
end

function TestMatrixGet:testGetsub()
  local m1
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    for i=1,nr do
    for j=1,nc do
      assertEquals( m:getsub( i, j    ), matrix{ref(i,j,nc)} )
      assertEquals( m:getsub( i, j, {}), {ref(i,j,nc)}       )
      for a=1,i do
      for b=1,j do
        for li=1,i-a+1 do
        for lj=1,j-b+1 do
          local ra, rb = a..i..li, b..j..lj
          local ir = { ra, totable(ra), vector((totable(ra))) }
          local jc = { rb, totable(rb), vector((totable(rb))) }
          for d=1,#ir do
            m1 = m:getsub( ir[d], jc[d])
            for ii=1,#ra do
              assertEquals( m1:get(ii ,1  ), ref(ref(ii,a,li), b           , nc) )
              assertEquals( m1:get(ii ,#rb), ref(ref(ii,a,li), rb[#rb]     , nc) )
            end
            for jj=1,#rb do
              assertEquals( m1:get(1  ,jj ), ref(a           , ref(jj,b,lj), nc) )
              assertEquals( m1:get(#ra,jj ), ref(ra[#ra]     , ref(jj,b,lj), nc) )
            end
          end
        end end
      end end
    end end
  end
end

function TestMatrixErr:testSetsub()
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (iterable expected)"          ,
    "invalid argument #4 (scalar or iterable expected)",
    "1-index out of bounds"                            ,
  }
  assertErrorMsgContains( msg[1], mth, 'setsub', errMat, nil , 1  , 1  )
  assertErrorMsgContains( msg[1], mth, 'setsub', errMat, ''  , 1  , 1  )
  assertErrorMsgContains( msg[1], mth, 'setsub', errMat, NaN , 1  , 1  )
  assertErrorMsgContains( msg[1], mth, 'setsub', errMat, \x x, 1  , 1  )
  assertErrorMsgContains( msg[2], mth, 'setsub', errMat, 1             )
  assertErrorMsgContains( msg[2], mth, 'setsub', errMat, 1   , nil, 1  )
  assertErrorMsgContains( msg[2], mth, 'setsub', errMat, 1   , '' , 1  )
  assertErrorMsgContains( msg[2], mth, 'setsub', errMat, 1   , NaN, 1  )
  assertErrorMsgContains( msg[3], mth, 'setsub', errMat, 1   , 1 , nil )
  assertErrorMsgContains( msg[3], mth, 'setsub', errMat, 1   , 1 , ''  )
  assertErrorMsgContains( msg[3], mth, 'setsub', errMat, 1   , 1 , NaN )
  assertErrorMsgContains( msg[4], mth, 'setsub', errMat, 0   , 1 , 1   )
  assertErrorMsgContains( msg[4], mth, 'setsub', errMat, 1   , 0 , 1   )
  assertErrorMsgContains( msg[1], mth, 'setsub', errMat, complex(1,1), 1 , 1 )
  assertErrorMsgContains( msg[2], mth, 'setsub', errMat, 1 , complex(1,1), 1 )
end

function TestMatrixSet:testSetsub() end

function TestMatrixErr:testGetv()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'double"        ,
    "invalid range member '1'"               ,
  }
  assertErrorMsgContains( msg[1], mth, 'getv', errMat, nil )
  assertErrorMsgContains( msg[1], mth, 'getv', errMat, ''  )
  assertErrorMsgContains( msg[1], mth, 'getv', errMat, NaN )
  assertErrorMsgContains( msg[2], mth, 'getv', errMat, 1  , ''   )
  assertErrorMsgContains( msg[2], mth, 'getv', errMat, 1  , 1    )
  assertErrorMsgContains( msg[2], mth, 'getv', errMat, 1  , \x x )
  assertErrorMsgContains( msg[3], mth, 'getv', errMat, 0         )
  assertErrorMsgContains( msg[3], mth, 'getv', errMat, matrix(2) )
  assertErrorMsgContains( msg[4], mth, 'getv', errMat, 1  , 1..2 )
end

function TestMatrixGet:testGetv()
  for _,m in ipairs(G.mat) do
    for i=1,m:size() do
        assertEquals( m:getv(i)          , vector{i}   )
        assertEquals( m:getv(i,{})       , {i}         )
        assertEquals( m:getv(i,vector(2)), vector{i,0} )
      for a=1,i do
      for li=1,i-a+1 do
        local ra = a..i..li
        local ir = { ra, totable(ra), vector((totable(ra))) }
        for d=1,#ir do
          assertEquals( m:getv(ir[d])    , vector(#ra):fill(ra) )
          assertEquals( m:getv(ir[d], {}), totable(ra)          )
        end
      end end
    end
  end
  local m1 = matrix(4):fill(1..16):getv(1..5,'in')
  assertEquals( m1, matrix(4):fill(1..16) ) -- same output - to documentation
end

function TestMatrixErr:testSetv()
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'setv', errMat, nil , 0    )
  assertErrorMsgContains( msg[1], mth, 'setv', errMat, ''  , 0    )
  assertErrorMsgContains( msg[1], mth, 'setv', errMat, NaN , 0    )
  assertErrorMsgContains( msg[1], mth, 'setv', errMat, \x x, 0    )
  assertErrorMsgContains( msg[2], mth, 'setv', errMat, 1   , ''   )
  assertErrorMsgContains( msg[2], mth, 'setv', errMat, 1   , nil  )
  assertErrorMsgContains( msg[2], mth, 'setv', errMat, 1   , NaN  )
  assertErrorMsgContains( msg[2], mth, 'setv', errMat, 1   , \x x )
end
function TestMatrixSet:testSetv() end

function TestMatrixErr:testGetdiag()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid range member '1'"               ,
  }
  assertErrorMsgContains( msg[1], mth, 'getdiag', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'getdiag', errMat, \x x )
  assertErrorMsgContains( msg[1], mth, 'getdiag', errMat, 1    )
  assertErrorMsgContains( msg[2], mth, 'getdiag', errMat, 1..2 )
end

function TestMatrixGet:testGetdiag()
  for _,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    local n , d  = min(nr,nc), m:getdiag()
    assertEquals( {d:sizes()}, {n,1} )
    for i=1,n do assertEquals( d[i], m:get(i,i) ) end
    assertEquals( m:getdiag({}), totable(d) )
  end
end

function TestMatrixErr:testSetdiag()
  local msg = {
    "invalid argument #2 (scalar or iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'setdiag', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'setdiag', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'setdiag', errMat, \x x )
end

function TestMatrixSet:testSetdiag()
end

function TestMatrixErr:testGetrow()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'double'"       ,
    "invalid range member '1'"               ,
    "1-index out of bounds"                  ,
  }
  assertErrorMsgContains( msg[1], mth, 'getrow', errMat, ''         )
  assertErrorMsgContains( msg[1], mth, 'getrow', errMat, nil        )
  assertErrorMsgContains( msg[1], mth, 'getrow', errMat, NaN        )
  assertErrorMsgContains( msg[1], mth, 'getrow', errMat, \x x       )
  assertErrorMsgContains( msg[2], mth, 'getrow', errMat, 1   , ''   )
  assertErrorMsgContains( msg[2], mth, 'getrow', errMat, 1   , 1    )
  assertErrorMsgContains( msg[3], mth, 'getrow', errMat, 0          )
  assertErrorMsgContains( msg[3], mth, 'getrow', errMat, 5          )
  assertErrorMsgContains( msg[4], mth, 'getrow', errMat, 1   , 1..2 )
  assertErrorMsgContains( msg[5], mth, 'getrow', errMat, 1   , vector(1) )
end

function TestMatrixGet:testGetrow()
  local r = { nil, {} }
  for ri=1,#r do
    for _,m in ipairs(G.mat) do
      local nr, nc = m:sizes()
      for i=1,nr do
      for a=1,i  do
        for li=1,i-a+1 do
          local ra = a..i..li
          local ir = { ra, totable(ra), vector((totable(ra))) }
          for j=1,#ir do
            assertEquals( m:getrow(ir[j],r[ri]), m:getsub(ir[j],1..nc,r[ri]) )
          end
        end
      end end
    end
  end
end

function TestMatrixErr:testSetrow()
  local m = matrix(3)
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
    "1-index out of bounds"                            ,
    "cannot convert 'nil' to 'double'"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'setrow', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'setrow', errMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'setrow', errMat, NaN       )
  assertErrorMsgContains( msg[1], mth, 'setrow', errMat, \x x      )
  assertErrorMsgContains( msg[2], mth, 'setrow', errMat, 1   , nil )
  assertErrorMsgContains( msg[2], mth, 'setrow', errMat, 1   , ''  )
  assertErrorMsgContains( msg[3], mth, 'setrow', errMat, 0   , 1   )
  assertErrorMsgContains( msg[3], mth, 'setrow', errMat, 3   , 1   )
  assertErrorMsgContains( msg[4], mth, 'setrow', errMat, 1   , matrix(1) )
  assertErrorMsgContains( msg[4], mth, 'setrow', m     , 1 ,1..2   )
  assertErrorMsgContains( msg[4], mth, 'setrow', m     , 1 ,{1,2}  )
end
function TestMatrixSet:testSetrow()end

function TestMatrixErr:testGetcol()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'double'"       ,
    "invalid range member '1'"               ,
    "1-index out of bounds"                  ,
  }
  assertErrorMsgContains( msg[1], mth, 'getcol', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'getcol', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'getcol', errMat, NaN  )
  assertErrorMsgContains( msg[1], mth, 'getcol', errMat, \x x )
  assertErrorMsgContains( msg[2], mth, 'getcol', errMat, 1   , ''   )
  assertErrorMsgContains( msg[2], mth, 'getcol', errMat, 1   , 1    )
  assertErrorMsgContains( msg[3], mth, 'getcol', errMat, 0          )
  assertErrorMsgContains( msg[3], mth, 'getcol', errMat, 3          )
  assertErrorMsgContains( msg[4], mth, 'getcol', errMat, 1   , 1..2 )
  assertErrorMsgContains( msg[5], mth, 'getcol', errMat, 1   , vector(1) )
end

function TestMatrixGet:testGetcol()
  local r = { nil, {} }
  for rj=1,#r do
    for _,m in ipairs(G.mat) do
      local nr, nc = m:sizes()
      for j=1,nc do
      for b=1,j  do
        for lj = 1,j-b+1 do
          local rb = b..j..lj
          local jc = { rb, totable(rb), vector((totable(rb))) }
          for jj=1,#jc do
            assertEquals( m:getcol(jc[jj],r[rj]) , m:getsub(1..nr,jc[jj],r[rj]) )
          end
        end
      end end
    end
  end
end

function TestMatrixErr:testSetcol()
  local m = matrix(3)
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
    "1-index out of bounds"                            ,
    "cannot convert 'nil' to 'double'"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'setcol', errMat, ''         )
  assertErrorMsgContains( msg[1], mth, 'setcol', errMat, nil        )
  assertErrorMsgContains( msg[1], mth, 'setcol', errMat, NaN        )
  assertErrorMsgContains( msg[1], mth, 'setcol', errMat, \x x       )
  assertErrorMsgContains( msg[2], mth, 'setcol', errMat, 1   ,  ''  )
  assertErrorMsgContains( msg[2], mth, 'setcol', errMat, 1   ,  nil )
  assertErrorMsgContains( msg[3], mth, 'setcol', errMat, 0   ,  1   )
  assertErrorMsgContains( msg[3], mth, 'setcol', errMat, 3   ,  1   )
  assertErrorMsgContains( msg[4], mth, 'setcol', errMat, 1   ,  matrix(1) )
  assertErrorMsgContains( msg[4], mth, 'setcol', m     , 1,  1..2  ) --CHECK
  assertErrorMsgContains( msg[4], mth, 'setcol', m     , 1,  {1,2} ) --CHECK
end
function TestMatrixSet:testSetcol() end

-- size, same -----------------------------------------------------------------o

function TestMatrix:testNrow()
  for i,m in ipairs(G.mat) do
    assertEquals( m:nrow(), G.size[i][1] )
  end
end

function TestMatrix:testNcol()
  for i,m in ipairs(G.mat) do
    assertEquals( m:ncol(), G.size[i][2] )
  end
end

function TestMatrix:testSize()
  for i,m in ipairs(G.mat) do
    assertEquals( m:size(), G.size[i][1]*G.size[i][2] )
  end
end

function TestMatrix:testSizes()
  for i,m in ipairs(G.mat) do
    assertEquals( {m:sizes()}, G.size[i] )
  end
end

function TestMatrix:testTsizes()
  for i,m in ipairs(G.mat) do
    assertEquals( {m:tsizes()}, {G.size[i][2], G.size[i][1]} )
  end
end

-- in place -------------------------------------------------------------------o

function TestMatrixInPlace:setUp()
  self.mat   = {}
  for nr=1,5 do
    for nc=1,5 do
      self.mat[ref(nr,nc,5)] = matrix(nr,nc):fill(1..nr*nc)
    end
  end
end

function TestMatrixErr:testRandom()
  local msg, s = {
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
    "invalid argument #1 (non-empty table expected)"                           ,
  }
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1, ''   )
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'same', errMat, 1, nan  )
  assertErrorMsgContains( msg[2], mth, 'same', errMat, 1, {}   )
end

function TestMatrixInPlace:testRandom()
  local oldVal, val = {}, {}
  for _,m in ipairs(self.mat) do
    m:random()
    for i = 1,m:size() do
      val[i] = m:geti(i)
      assertTrue ( val[i] <  1    )
      assertTrue ( val[i] >= 0    )
      assertFalse( val[i] == oldVal[i] )
      oldVal[i] =  val[i]
    end
  end
end

function TestMatrixErr:testFill()
  local msg = {
    "invalid argument #2 (scalar, callable or indexable expected)",
    "incompatible container size"                                 ,
    "invalid container (iterable expected)"                       ,
  }
  assertErrorMsgContains( msg[1], mth,'fill', errMat, nil  )
  assertErrorMsgContains( msg[1], mth,'fill', errMat, true )
  assertErrorMsgContains( msg[2], mth,'fill', errMat, {}   )
end
function TestMatrixInPlace:testFill()
  for _,m in ipairs(self.mat) do
    --scalar
    m:fill(nan)               for i=1,m:size() do assertNaN   ( m:geti(i)      ) end
    m:fill(inf)               for i=1,m:size() do assertInf   ( m:geti(i)      ) end
    m:fill(1  )               for i=1,m:size() do assertEquals( m:geti(i), 1   ) end
    m:fill(complex(1,1))      for i=1,m:size() do assertEquals( m:geti(i), 1   ) end
    --generator
    m:fill(1..#m)             for i=1,m:size() do assertEquals( m:geti(i), i   ) end
    m:fill\x x^2              for i=1,m:size() do assertEquals( m:geti(i), i^2 ) end
    --2D container
    m:fill( m:same() )        for i=1,m:size() do assertEquals( m:geti(i), 0   ) end
    --1D container
    t={} for i=1,m :size() do t[i]=i end
    m:fill(t)                 for i=1,m:size() do assertEquals( m:geti(i), i   ) end
    m:fill(vector(m :size())) for i=1,m:size() do assertEquals( m:geti(i), 0   ) end
  end
  local m, t = matrix(5), {}
  for i=1,5 do t[i] = {}      for j=1,5 do t[i][j]=(i-1)*5+j end end
  m :fill(t)                  for i=1,m :size() do assertEquals( m :geti(i), i ) end
  assertTrue( is_matrix ( matrix(5,5):fill(complex(1,1))) )  --matrix types change
end

function TestMatrixErr:testCopy()
  local msg = {
    "invalid argument #1 (matrix expected",
  }
  assertErrorMsgContains( msg[1], mth,'copy', errMat,  1 )
end

function TestMatrixInPlaceII:testCopy() --different test-suite
  for i,m in ipairs(G.mat) do
    local mcopy = G.empty[i]
    mcopy:copy(m)
    for i=1,m:size() do assertEquals( m:geti(i), mcopy:geti(i) ) end
  end
end

function TestMatrixInPlace:testZeros()
  for _,m in ipairs(self.mat) do
    local  m1 = m:zeros()
    for i=1,m:size() do assertEquals( m1:geti(i), 0 ) end
  end
end

function TestMatrixInPlace:testOnes()
  for _,m in ipairs(self.mat) do
    m:ones()
    for i=1,m:size() do assertEquals( m:geti(i), 1 ) end
  end
end

function TestMatrixInPlace:testEye()
  for i,m in ipairs(self.mat) do
    local nr, nc = m:sizes()
    m:eye()
    for i=1,nr do
    for j=1,nc do
      if i==j then assertEquals( m:get(i,j), 1 )
      else         assertEquals( m:get(i,j), 0 ) end
    end end
  end
end

function TestMatrixErr:testSymp()
  local msg = {
    "invalid argument #1 (2n matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth,'symp',  matrix(3)   ) --CHECK
  assertErrorMsgContains( msg[1], mth,'symp',  vector(2)   ) --CHECK
  assertErrorMsgContains( msg[1], mth,'symp',  matrix(4,3) ) --CHECK
end

function TestMatrixInPlaceII:testSymp() --different suite needed; skew-symmetric?
  for i=2,6,2 do
    local m = matrix(i,i):fill(1..i*i)

    for ir=1,i do
    for jc=1,i do
      m:set(jc,ir, -m:get(ir,jc)) --skew-symmetric
    end end
    local s = m:symp()
    assertTrue( m:t()*s*m   == s )
    assertTrue( s*m:t()*s*m == -m:eye() )
  end
end

function TestMatrixErr:testCirc()
  local msg = {
    "invalid argument #2 (iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth,'circ', errMat, nil  )
  assertErrorMsgContains( msg[1], mth,'circ', errMat, 1    )
  assertErrorMsgContains( msg[1], mth,'circ', errMat, \x x )
end

function TestMatrixInPlaceII:testCirc() --different suite, only square matrices
  for i=1,5 do
    local m = matrix(i)
    local t = {} for j=1,i do t[j]=j end
    --'row'
    m:circ(t)
    for j=1,i   do assertEquals( m:get(j  ,j  ), 1   ) end
    for j=1,i-1 do assertEquals( m:get(j+1,j  ), 2   )
                   assertEquals( m:get(j  ,j+1), i   ) end
    for j=1,i-2 do assertEquals( m:get(j+2,j  ), 3   )
                   assertEquals( m:get(j  ,j+2), i-1 ) end
    for j=1,i-3 do assertEquals( m:get(j+3,j  ), 4   )
                   assertEquals( m:get(j  ,j+3), i-2 ) end
    m:fill(0):circ(vector(i):fill(1..i))
    for j=1,i   do assertEquals( m:get(j  ,j  ), 1   ) end
    for j=1,i-1 do assertEquals( m:get(j+1,j  ), 2   )
                   assertEquals( m:get(j  ,j+1), i   ) end
    for j=1,i-2 do assertEquals( m:get(j+2,j  ), 3   )
                   assertEquals( m:get(j  ,j+2), i-1 ) end
    for j=1,i-3 do assertEquals( m:get(j+3,j  ), 4   )
                   assertEquals( m:get(j  ,j+3), i-2 ) end
    --'col'
    m:fill(0):circ(matrix(1,i):fill(1..i))
    for j=1,i   do assertEquals( m:get(j  ,j  ), 1   ) end
    for j=1,i-1 do assertEquals( m:get(j+1,j  ), i   )
                   assertEquals( m:get(j  ,j+1), 2   ) end
    for j=1,i-2 do assertEquals( m:get(j+2,j  ), i-1 )
                   assertEquals( m:get(j  ,j+2), 3   ) end
    for j=1,i-3 do assertEquals( m:get(j+3,j  ), i-2 )
                   assertEquals( m:get(j  ,j+3), 4   ) end
  end
end

function TestMatrixErr:testReshape()
  local msg = {
    "invalid matrix new sizes",
  }
  assertErrorMsgContains( msg[1], mth,'reshape', errMat, 3  , 2 )
  assertErrorMsgContains( msg[1], mth,'reshape', errMat, 1  , 5 )
  assertErrorMsgContains( msg[1], mth,'reshape', errMat, 0  , 2 )
  assertErrorMsgContains( msg[1], mth,'reshape', errMat, 1  , 0 )
  assertErrorMsgContains( msg[1], mth,'reshape', errMat, nil, 2 )
end

function TestMatrixInPlaceII:testReshape() --\ different suite
  local m
  m = matrix(2,2) assertEquals( {m:reshape() :sizes()}, {4,1} )
  m = matrix(2,2) assertEquals( {m:reshape(1):sizes()}, {1,1} )
  for nr=1,5 do
  for nc=1,5 do
    for i=1,nr do
    for j=1,nc do
      m = matrix(nr,nc):fill(1..nr*nc)
      m:reshape(i,j)
      assertEquals( {m:sizes()}, {i,j} )
      for i=1,m:size() do assertEquals( m:geti(i), i) end
    end end
  end end
end

-- foreach, filter, map, fold, scan -------------------------------------------o

function TestMatrixFun:setUp()
  self.mat = {}
  for nr=1,5 do
    for nc=1,5 do
      self.mat[ref(nr,nc,5)] = matrix(nr,nc):fill(1..nr*nc)
    end
  end
end

function TestMatrixErr:testForeach()
  local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, 1         )
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'foreach', errMat, { }       )
end

function TestMatrixFun:testForeach() -- for test need of filled table
  local t, nr, nc
  local f = \x,i,j => t[i][j] = x  end
  for _,m in ipairs(self.mat) do
    nr, nc = m:sizes()
    t = table.new(nr, nc)
    for i=0,nr-1 do local c = t[i+1] or table.new(nc,0); t[i+1] = c end
    m:foreach(f)
    for i=1,nr do for j=1,nc do assertEquals( t[i][j], ref(i,j,nc) ) end end
  end
end

function TestMatrixErr:testMap()
  local msg = {
    "invalid argument #2 (callable expected)"                 ,
    "invalid argument #3 (iterable expected)"                 ,
    "invalid range member '1'"                                ,
    "attempt to perform arithmetic on local 'x' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'map', errMat, ''           )
  assertErrorMsgContains( msg[1], mth, 'map', errMat, 1..2         )
  assertErrorMsgContains( msg[1], mth, 'map', errMat, 1            )
  assertErrorMsgContains( msg[1], mth, 'map', errMat, matrix(1)    )
  assertErrorMsgContains( msg[1], mth, 'map', errMat, {}           )
  assertErrorMsgContains( msg[2], mth, 'map', errMat, \x x+1, ''   )
  assertErrorMsgContains( msg[2], mth, 'map', errMat, \x x+1, 1    )
  assertErrorMsgContains( msg[3], mth, 'map', errMat, \x x+1, 1..2 )
end

function TestMatrixFun:testMap()
  local m1
  for i,m in ipairs(G.mat) do
    local nr, nc = m:sizes()
    --print(m:map('+'))
    assertEquals( m:map \x x-x    , G.empty[i] )
    --totable test
    m1 = m:map(\x x+1,{}) for i=1,#m1 do assertEquals( m1[i], i+1 ) end
    m1 = m:map(\x x-x,{}) for i=1,#m1 do assertEquals( m1[i], 0   ) end
    --'in' place test
  end
end

function TestMatrixErr:testMap2()
  local msg = {
    "invalid argument #2 (scalar or iterable expected)"       ,
    "invalid argument #3 (callable expected)"                 ,
    "invalid argument #4 (iterable expected)"                 ,
    "invalid range member '1'"                                ,
    "attempt to perform arithmetic on local 'y' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'map2', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'map2', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'map2', errMat, NaN  )
  assertErrorMsgContains( msg[1], mth, 'map2', errMat, \x x )
  assertErrorMsgContains( msg[2], mth, 'map2', errMat, matrix(1), nil  )
  assertErrorMsgContains( msg[2], mth, 'map2', errMat, matrix(1), ''   )
  assertErrorMsgContains( msg[2], mth, 'map2', errMat, matrix(1), 1..2 )
  assertErrorMsgContains( msg[2], mth, 'map2', errMat, matrix(1), 1    )
  assertErrorMsgContains( msg[3], mth, 'map2', errMat, matrix(1), \x x, 1    )
  assertErrorMsgContains( msg[4], mth, 'map2', errMat, matrix(1), \x x, 1..2 )
  assertErrorMsgContains( msg[5], mth, 'map2', errMat, matrix(1), \x,y  x+y  )
end

function TestMatrixFun:testMap2()
  for _,m1 in ipairs(self.mat) do
    local nr, nc = m1:sizes()
    local m2   = matrix(nr,nc)
    local mref = m1:same()
    m2:copy(m1)

    assertEquals( m1:map2( m2,'-'), mref )
    assertEquals( m1:map2(-m2,'+'), mref )

    --print(m2)
    --m1:map2(-m2,'+')
    --print(m2, "\n")

  --totable
    --print( m1:map2( m2,'-',{}) ,"\n")
    --print( m1:map2( m2,'+',{}) )
  end
  for _,m1 in ipairs(self.mat) do
  --'in' place test
  end
end

function TestMatrixErr:testMap3()
  local m = matrix(1)
  local msg = {
    "invalid argument #2 (scalar or iterable expected)"       ,
    "invalid argument #3 (scalar or iterable expected)"       ,
    "invalid argument #4 (callable expected)"                 ,
    "invalid argument #5 (iterable expected)"                 ,
    "invalid range member '1'"                                ,
    "attempt to perform arithmetic on local 'y' (a nil value)",
    "attempt to perform arithmetic on local 'z' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'map3', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'map3', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'map3', errMat, NaN  )
  assertErrorMsgContains( msg[1], mth, 'map3', errMat, \x x )
  assertErrorMsgContains( msg[2], mth, 'map3', errMat, errMat, nil  )
  assertErrorMsgContains( msg[2], mth, 'map3', errMat, errMat, ''   )
  assertErrorMsgContains( msg[2], mth, 'map3', errMat, errMat, NaN  )
  assertErrorMsgContains( msg[2], mth, 'map3', errMat, errMat, \x x )
  assertErrorMsgContains( msg[3], mth, 'map3', errMat, errMat, errMat, nil  )
  assertErrorMsgContains( msg[3], mth, 'map3', errMat, errMat, errMat, 1..2 )
  assertErrorMsgContains( msg[3], mth, 'map3', errMat, errMat, errMat, 1    )
  assertErrorMsgContains( msg[4], mth, 'map3', errMat, errMat, errMat, \x x, 1    )
  assertErrorMsgContains( msg[5], mth, 'map3', errMat, errMat, errMat, \x x, 1..2 )
  assertErrorMsgContains( msg[6], mth, 'map3', errMat, m     , errMat, \x,y,z x+y+z )
  assertErrorMsgContains( msg[6], mth, 'map3', errMat, m     , m     , \x,y,z x+y+z )
  assertErrorMsgContains( msg[7], mth, 'map3', errMat, errMat, m     , \x,y,z x+y+z )
end

function TestMatrixFun:testMap3() end

function TestMatrixErr:testMapij()
  local msg = {
    "invalid argument #2 (callable expected)",
    "invalid argument #3 (iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, 1         )
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'mapij', errMat, { }       )
  assertErrorMsgContains( msg[2], mth, 'mapij', errMat, \x x+1  , ''   )
  assertErrorMsgContains( msg[2], mth, 'mapij', errMat, \x x+1  , \x x )
end

function TestMatrixFun:testMapij()
  for i,m in ipairs(G.mat) do
    assertEquals( m:mapij \x x-x, G.empty[i] )
  end
end

function TestMatrixErr:testMapat()
  local msg = {
    "invalid argument #2 (callable expected)",
    "invalid argument #3 (iterable expected)",
    "invalid argument #4 (iterable expected)",
    "invalid range member '1'"               ,
    "attempt to perform arithmetic on local 'x' (a nil value)",
  }
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, 1         )
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'mapat', errMat, { }       )
  assertErrorMsgContains( msg[2], mth, 'mapat', errMat, \x x+1  , ''   )
  assertErrorMsgContains( msg[2], mth, 'mapat', errMat, \x x+1  , nil  )
  assertErrorMsgContains( msg[2], mth, 'mapat', errMat, \x x+1  , NaN  )
  assertErrorMsgContains( msg[2], mth, 'mapat', errMat, \x x+1  , \x x )
  assertErrorMsgContains( msg[3], mth, 'mapat', errMat, \x x+1  , 1    , ''   )
  assertErrorMsgContains( msg[3], mth, 'mapat', errMat, \x x+1  , 1    , \x x )
  assertErrorMsgContains( msg[4], mth, 'mapat', errMat, \x x+1  , 1    , 1..2 )
  assertErrorMsgContains( msg[5], mth, 'mapat', errMat, \x x+1  , 0    )
  assertErrorMsgContains( msg[5], mth, 'mapat', errMat, \x x+1  , 5    )
end

function TestMatrixFun:testMapat()
  for i,m in ipairs(G.mat) do
    assertEquals( m:mapij \x x-x, G.empty[i] )
  end
end

function TestMatrixErr:testFoldl()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, NaN  )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, {}   )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, 1    )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, m    )
  assertErrorMsgContains( msg[1], mth, 'foldl', errMat, cm   )
  assertErrorMsgContains( msg[3], mth, 'foldl', errMat, \x x, '')
  assertErrorMsgContains( msg[3], mth, 'foldl', errMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', errMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', errMat, \x x, 1 , m    , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', errMat, \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', errMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'foldl', errMat, \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'foldl', errMat, \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'foldl', errMat, \x x, 1 , "vec", \x x )
end

--[[
parameters:
  f: callable, x0: initial value, d: ['vec', 'row', 'col'], r: iterable
  r:{}, cmatrix(2), matrix(2), 1..2
default:
  x0 = x[ 1] or x[., 1] or x[ 1,.] for foldl
       x[#x] or x[.,nc] or x[nr,.] for foldr
   d = 'vec'  (r_ is discarded if any)
   r = scalar ['vec'] or x:same(nr,1) ['row'] or x:same(1,nc) ['col']
]]
function TestMatrixFun:testFoldl()
  local m1
  local sum=\r =>local x = 0 for i=1,r:size() do x = x + r[i] end return x end

  for _,m in ipairs(self.mat) do
    local nr, nc = m:sizes()
    local t ={}  for i=1,nc do t [i]=sum(ref(1,i,nc)..ref(nr,i,nc)..nc) end
    local tr={}  for i=1,nr do tr[i]=sum(ref(i,1,nc)..ref(i,nc,nc)..1)  end
    --1) x:fold( f )
    assertEquals( m:foldl \x x               , 1 )
    assertEquals( m:foldl '+'                , sum(1..m:size()) )
    --2) x:fold( f, nil, d )      and 2') x:fold( f, d )
    assertEquals( m:foldl('+'    , 'vec')    , sum(1..m:size()) )
    assertEquals( m:foldl('+',nil, 'vec')    , sum(1..m:size()) )
    m1 = m:foldl('+'   , 'col')    for i=1,nc do assertEquals( m1:geti(i), t [i] ) end
    m1 = m:foldl('+'   , 'row')    for i=1,nr do assertEquals( m1:geti(i), tr[i] ) end
    --4) x:fold( f, nil, d, r )   and 4') x:fold( f, d, r) and  4")x:fold( f, d, nil, r )
    assertEquals( m:foldl('+'     ,'vec', {}), sum(1..m:size()) )
    --5)  x:fold( f, x0 )
    assertEquals( m:foldl('+' , 0)           , sum(1..m:size()) )
    --6)  x:fold( f, x0 , d )
    assertEquals( m:foldl('+' , 0, 'vec')    , sum(1..m:size()) )
    m1 = m:foldl('+', 0, 'col')    for i=1,nc do assertEquals( m1:geti(i), t [i] ) end
    m1 = m:foldl('+', 0, 'row')    for i=1,nr do assertEquals( m1:geti(i), tr[i] ) end
    --8)  x:fold( f, x0 , d, r )
    m1 = m:foldl('+', 0, 'col',{}) for i=1,nc do assertEquals( m1[i]     , t [i] ) end
    m1 = m:foldl('+', 0, 'row',{}) for i=1,nr do assertEquals( m1[i]     , tr[i] ) end

    --3) x:fold( f, nil, nil, r ) and 3')x:fold( f, r ) and  3")x:fold( f, nil, r)
    --print( m:foldl('+'          , {}) )      -- err
    --print( m:foldl(\x x         , {}) )      -- empty tables
    assertEquals( m:foldl('+' ,nil      , {}), sum(1..m:size()) )
    assertEquals( m:foldl('+' ,nil, nil , {}), sum(1..m:size()) )
    --7)  x:fold( f, x0, nil, r ) and 7') x:fold( f, x0, r )
    assertEquals( m:foldl('+' , 2 , nil , {}), sum(1..m:size())+2 )
    assertEquals( m:foldl('+' , 2       , {}), sum(1..m:size())+2 )
  end
end

function TestMatrixErr:testFoldr()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, NaN  )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, {}   )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, 1    )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, m    )
  assertErrorMsgContains( msg[1], mth, 'foldr', errMat, cm   )
  assertErrorMsgContains( msg[3], mth, 'foldr', errMat, \x x, '')
  assertErrorMsgContains( msg[3], mth, 'foldr', errMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', errMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', errMat, \x x, 1 , m    , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', errMat, \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', errMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'foldr', errMat, \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'foldr', errMat, \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'foldr', errMat, \x x, 1 , "vec", \x x )
end

function TestMatrixFun:testFoldr() end

function TestMatrixErr:testScanl()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, NaN  )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, {}   )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, 1    )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, m    )
  assertErrorMsgContains( msg[1], mth, 'scanl', errMat, cm   )
  assertErrorMsgContains( msg[3], mth, 'scanl', errMat, \x x, '')
  assertErrorMsgContains( msg[3], mth, 'scanl', errMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', errMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', errMat, \x x, 1 , m    , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', errMat, \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', errMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'scanl', errMat, \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'scanl', errMat, \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'scanl', errMat, \x x, 1 , "vec", \x x )
end

function TestMatrixFun:testScanl() end

function TestMatrixErr:testScanr()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, NaN  )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, {}   )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, 1    )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, m    )
  assertErrorMsgContains( msg[1], mth, 'scanr', errMat, cm   )
  assertErrorMsgContains( msg[3], mth, 'scanr', errMat, \x x, '')
  assertErrorMsgContains( msg[3], mth, 'scanr', errMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', errMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', errMat, \x x, 1 , m    , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', errMat, \x x, 1 , cm   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', errMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'scanr', errMat, \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'scanr', errMat, \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'scanr', errMat, \x x, 1 , "vec", \x x )
end

function TestMatrixFun:testScanr() end

function TestMatrixErr:testFilter()
  local msg = {
    "invalid argument #2 (callable expected)",
    "invalid argument #3 (iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'filter', errMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'filter', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'filter', errMat, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'filter', errMat, 1         )
  assertErrorMsgContains( msg[1], mth, 'filter', errMat, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'filter', errMat, { }       )
  assertErrorMsgContains( msg[2], mth, 'filter', errMat, \x x     , ''   )
  assertErrorMsgContains( msg[2], mth, 'filter', errMat, \x x     , 1    )
  assertErrorMsgContains( msg[2], mth, 'filter', errMat, \x x     , \x x )
end

function TestMatrixFun:testFilter() end

function TestMatrixErr:testFilter_out()
  local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, 1         )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errMat, { }       )
end

function TestMatrixErr:testFilter_out() end

-- special maps ---------------------------------------------------------------o

function TestMatrixSMaps:testCeil () end
function TestMatrixSMaps:testFloor() end
function TestMatrixSMaps:testFrac () end
function TestMatrixSMaps:testTrunc() end
function TestMatrixSMaps:testRound() end
function TestMatrixSMaps:testAbs  () end
function TestMatrixSMaps:testSqrt () end
function TestMatrixSMaps:testExp  () end
function TestMatrixSMaps:testLog  () end
function TestMatrixSMaps:testLog10() end
function TestMatrixSMaps:testSin () end
function TestMatrixSMaps:testCos () end
function TestMatrixSMaps:testTan () end
function TestMatrixSMaps:testSinh() end
function TestMatrixSMaps:testCosh() end
function TestMatrixSMaps:testTanh() end
function TestMatrixSMaps:testAsin () end
function TestMatrixSMaps:testAcos () end
function TestMatrixSMaps:testAtan () end
function TestMatrixSMaps:testAsinh() end
function TestMatrixSMaps:testAcosh() end
function TestMatrixSMaps:testAtanh() end
function TestMatrixSMaps:testErf   () end
function TestMatrixSMaps:testTgamma() end
function TestMatrixSMaps:testLgamma() end
function TestMatrixSMaps:testCarg () end
function TestMatrixSMaps:testReal () end
function TestMatrixSMaps:testImag () end
function TestMatrixSMaps:testConj () end
function TestMatrixSMaps:testProj () end
function TestMatrixSMaps:testRect () end
function TestMatrixSMaps:testPolar() end

-- special scans --------------------------------------------------------------o

function TestMatrixSScans:testAccmin    () end
function TestMatrixSScans:testAccmax    () end
function TestMatrixSScans:testAccsum    () end
function TestMatrixSScans:testAccsumabs () end
function TestMatrixSScans:testAccsumsqr () end
function TestMatrixSScans:testAccprod   () end
function TestMatrixSScans:testAccsum    () end
function TestMatrixSScans:testRaccmin   () end
function TestMatrixSScans:testRaccmax   () end
function TestMatrixSScans:testRaccsum   () end
function TestMatrixSScans:testRaccsumabs() end
function TestMatrixSScans:testRaccsumsqr() end
function TestMatrixSScans:testRaccprod  () end

-- special folds --------------------------------------------------------------o

function TestMatrixSFolds:testMin()
  local mref, nr, nc
  for i,m in ipairs(G.mat) do
    nr, nc = m:sizes()
    assertEquals( m:min()     , 1 )
    assertEquals( m:min("vec"), 1 )
    assertEquals( m:min("col"), matrix(1,nc):fill(1..nc) )
    mref = vector(nr) for i=1,nr do mref:seti( i, m:geti((i-1)*nc+1)) end
    assertEquals( m:min("row"), mref )
  end
end

function TestMatrixSFolds:testMax()
  local mref, nr, nc
  for i,m in ipairs(G.mat) do
    nr, nc = m:sizes()
    assertEquals( m:max()     , m:size() )
    assertEquals( m:max("vec"), m:size() )
    assertEquals( m:max("col"), matrix(1,nc):fill((nr-1)*nc+1..m:size()) )
    mref = vector(nr) for i=1,nr do mref:seti( i, m:geti(i*nc) ) end
    assertEquals( m:max("row"), mref )
  end
end

function TestMatrixSFolds:testSum()
  local mref, x, nr, nc
  for i,m in ipairs(G.mat) do
    nr, nc = m:sizes()

    mref = 0 for i=1,m:size() do mref = mref + i end
    assertEquals( m:sum()     , mref )
    mref = vector(nr)   for i=1,nr do x=0 for j=1,nc do x=(i-1)*nc+j + x end mref:seti(i, x) end
    assertEquals( m:sum("row"), mref )
    mref = matrix(1,nc) for i=1,nc do x=0 for j=1,nr do x=(j-1)*nc+i + x end mref:seti(i, x) end
    assertEquals( m:sum("col"), mref )
  end
end

function TestMatrixSFolds:testSumabs()
  local mref, x, nr, nc
  for i,m in ipairs(G.mat) do
    nr, nc = m:sizes()

    mref = 0 for i=1,m:size() do do mref = mref + i end end
    assertEquals( m :sumabs()     ,  mref )
    assertEquals( m :sumabs('vec'),  mref )
    mref = matrix(1,nc) for j=1,nc do x=0; for i=1,nr do x=x+(i-1)*nc+j end mref:seti(j,x) end
    assertEquals( m :sumabs('col'),  mref )
    mref = vector(nr)   for i=1,nr do x=0; for j=1,nc do x=x+(i-1)*nc+j end mref:seti(i,x) end
    assertEquals( m :sumabs('row'),  mref )
  end
end

function TestMatrixSFolds:testSumsqr()
  local mref, x, nr, nc
  for i,m in ipairs(G.mat) do
    nr, nc = m:sizes()

    mref = 0 for i=1,m:size() do mref=i*i+mref end
    assertEquals( m :sumsqr()     ,  mref )
    assertEquals( m :sumsqr('vec'),  mref )
    mref = matrix(1,nc) for j=1,nc do x=0; for i=1,nr do x=x+((i-1)*nc+j)^2 end mref:seti(j,x) end
    assertEquals( m :sumsqr('col'),  mref )
    mref = vector(nr)   for i=1,nr do x=0; for j=1,nc do x=x+((i-1)*nc+j)^2 end mref:seti(i,x) end
    assertEquals( m :sumsqr('row'),  mref )
  end
end

function TestMatrixSFolds:testProduct()
  local mref, x
  for i,m in ipairs(G.mat) do
    nr, nc = m:sizes()
    mref = 1 for i=1,m:size() do mref=i*mref end
    assertEquals( m:product()     , mref )
    assertEquals( m:product('vec'), mref )
    mref = matrix(1,nc) for j=1,nc do x=1; for i=1,nr do x=x*((i-1)*nc+j) end mref:seti(j,x) end
    assertEquals( m :product('col'),  mref )
    mref = vector(nr)   for i=1,nr do x=1; for j=1,nc do x=x*((i-1)*nc+j) end mref:seti(i,x) end
    assertEquals( m :product('row'),  mref )

    if not (nr==5 and nc==5) then
      m    = m:same():fill(m:size()..1..-1 )
      mref = 1 for i=1,m:size() do mref = mref * i end
      assertAlmostEquals( m:product() - mref, 0, eps )
    end
  end
end

function TestMatrixErr:testAll()
  local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'all', errMat, nil    )
  assertErrorMsgContains( msg[1], mth, 'all', errMat, ''     )
  assertErrorMsgContains( msg[1], mth, 'all', errMat, 1..2   )
  assertErrorMsgContains( msg[1], mth, 'all', errMat, 1      )
  assertErrorMsgContains( msg[1], mth, 'all', errMat, errMat )
  assertErrorMsgContains( msg[1], mth, 'all', errMat, { }    )
end

function TestMatrixSFolds:testAll()
  for i,m in ipairs(G.mat) do
    nr, nc = m:sizes()
    assertFalse ( m:all  \x x> m:size()   )
    assertTrue  ( m:all  \x x< m:size()+1 )
    assertEquals( m:all( \x x>(m:size())/2, 'vec'), m:all \x x>(m:size())/2 )
    assertEquals( m:all( \x x< m:size()+1 , 'vec'), m:all \x x< m:size()+1  )
    if nr>1 then
      assertEquals( m:all( \x x>(m:size())/2, 'col'), matrix(1,nc) )
    else
      mref = matrix(1,nc)
      for i=1,#mref do  if m:geti(i)>(m:size())/2    then mref:seti(i,1) end end
      assertEquals( m:all( \x x>(m:size())/2, 'col'), mref )
    end
    assertEquals( m:all( \x x<m:size()+1  , 'col'), matrix(1,nc):fill(1) )
    mref = vector(nr)
    for i=1,nr do if m:geti((i-1)*nc+1)>(m:size())/2 then mref:seti(i,1) end end
    assertEquals( m:all( \x x>(m:size())/2, 'row'), mref )
    assertEquals( m:all( \x x< m:size()+1 , 'row'), vector(nr):fill(1) )
  end
end

function TestMatrixErr:testAny()
    local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'any', errMat, nil    )
  assertErrorMsgContains( msg[1], mth, 'any', errMat, ''     )
  assertErrorMsgContains( msg[1], mth, 'any', errMat, 1..2   )
  assertErrorMsgContains( msg[1], mth, 'any', errMat, 1      )
  assertErrorMsgContains( msg[1], mth, 'any', errMat, errMat )
  assertErrorMsgContains( msg[1], mth, 'any', errMat, { }    )
end

function TestMatrixSFolds:testAny() end

-- symplectic matrix ----------------------------------------------------------o

function TestMatrixSympl:testSympinv() end
function TestMatrixSympl:testSymperr() end

-- conjugate, transpose -------------------------------------------------------o

function TestMatrixLinAlg:testTranspose() end
function TestMatrixLinAlg:testTrace() end

-- inner, cross, mixed, outer -------------------------------------------------o

function TestMatrixLinAlg:testInner() end
function TestMatrixLinAlg:testCross() end
function TestMatrixLinAlg:testMixed() end
function TestMatrixLinAlg:testOuter() end

function TestMatrixErr:testInner()
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'inner', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'inner', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'inner', errMat, 1    )
  assertErrorMsgContains( msg[1], mth, 'inner', errMat, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'inner', errMat, {}   )
end

function TestMatrixErr:testCross() --TODO: check input(expected size!)
  local m = matrix(3)
  local msg = {
    "invalid argument #2 (matrix expected)",
    "invalid matrix sizes"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'cross', m     , nil  )
  assertErrorMsgContains( msg[1], mth, 'cross', m     , ''   )
  assertErrorMsgContains( msg[1], mth, 'cross', m     , 1    )
  assertErrorMsgContains( msg[1], mth, 'cross', m     , 1..2 )
  assertErrorMsgContains( msg[1], mth, 'cross', m     , {}   )
  assertErrorMsgContains( msg[2], mth, 'cross', errMat, m    )
end

function TestMatrixErr:testMixed() --TODO: check input(expected size!)
  local msg = {
    "invalid argument #2 (matrix expected)",
    "invalid argument #3 (matrix expected)",
    "invalid matrix sizes"                 ,
    "incompatible matrix sizes"            ,
  }
  local m1 = matrix(3,1)
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, nil  )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, ''   )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, 1    )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'mixed', m1, {}   )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , nil  )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , ''   )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , 1    )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , 1..2 )
  assertErrorMsgContains( msg[2], mth, 'mixed', m1, m1  , {}   )
  assertErrorMsgContains( msg[3], mth, 'mixed', matrix(2,1), m1, m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', matrix(3,2), m1, m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, matrix(2,1), m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, matrix(3,2), m1 )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, m1 ,matrix(2,1) )
  assertErrorMsgContains( msg[4], mth, 'mixed', m1, m1 ,matrix(3,2) )
end

function TestMatrixErr:testOuter() --TODO: check input(expected size!)
  local m = matrix(2,1)
  local msg = {
    "invalid argument #2 (matrix expected)",
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'outer', m          , nil  )
  assertErrorMsgContains( msg[1], mth, 'outer', m          , ''   )
  assertErrorMsgContains( msg[1], mth, 'outer', m          , {}   )
  assertErrorMsgContains( msg[1], mth, 'outer', m          , 1    )
  assertErrorMsgContains( msg[1], mth, 'outer', m          , 1..2 )
  assertErrorMsgContains( msg[2], mth, 'outer', matrix(1,2), matrix(2,2) )
end

-- norm, unit, center, angle (in place) ---------------------------------------o

function TestMatrixLinAlg:testNorm() end
function TestMatrixLinAlg:testDistance() end
function TestMatrixLinAlg:testUnit() end
function TestMatrixLinAlg:testCenter() end
function TestMatrixLinAlg:testAngle() end

function TestMatrixErr:testDistance()
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'distance', errMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'distance', errMat, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'distance', errMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'distance', errMat, {}   )
end

function TestMatrixErr:testUnit()
  local msg = {
    "null matrix norm",
  }
end

function TestMatrixErr:testAngle()
  local msg = {
    "null vector norm",
  }
end

-- operators ------------------------------------------------------------------o

function TestMatrixOps:testEq() end

function TestMatrixOps:testAddCPx() end

function TestMatrixErr:testAdd()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end
function TestMatrixOps:testAdd() end

function TestMatrixOps:testSubCPx() end

function TestMatrixErr:testSub()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end
function TestMatrixOps:testSub() end

function TestMatrixOps:testMulCPx() end

function TestMatrixErr:testMul()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end
function TestMatrixOps:testMul() end

function TestMatrixErr:testTmul()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end
function TestMatrixOps:testTmul() end

function TestMatrixOps:testDivCPx() end

function TestMatrixErr:testDiv()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
  }
end
function TestMatrixOps:testDiv() end

function TestMatrixErr:testEmul()
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
end
function TestMatrixOps:testEmul() end

function TestMatrixErr:testEdiv()
  local msg = {
    "invalid argument #2 (matrix expected)",
  }
end
function TestMatrixOps:tetEdiv() end

-- linear algebra -------------------------------------------------------------o

function TestMatrixLapack:testSolve() end
function TestMatrixLapack:testSvd() end

function TestMatrixLapack:testEigen() end
function TestMatrixErr:testEigen()
  local msg = {
    "matrix must be square",
  }
end

-- FFT, convolution, correlation, covrariance ---------------------------------o

function TestMatrixFFT:testFft() end
function TestMatrixFFT:testIfft() end

function TestMatrixErr:testRfft()
  local msg = {
    "incompatible matrix sizes",
  }
end
function TestMatrixFFT:testRfft() end

function TestMatrixErr:testIrfft()
  local msg = {
    "result matrix must be real",
    "incompatible matrix sizes" ,
  }
end
function TestMatrixFFT:testIrfft() end

 -- convolution theorem
function TestMatrixFFT:testConv() end

 -- correlation theorem
function TestMatrixFFT:testCorr() end
function TestMatrixFFT:testCovar() end

-- conversion -----------------------------------------------------------------o

function TestMatrixConv:testTosting()
  local tostring in MAD
  local m, c, r, nr, nc = matrix(2)
  assertTrue( is_string(tostring(m      )) )
  assertTrue( is_string(tostring(m, ''  )) )
  assertTrue( is_string(tostring(m, "\n")) )

  for i,m in ipairs(G.mat) do
    nr, nc = m:sizes()
    c, r = {}, {}
    for i=1,nr do for j=1,nc do c[j]=tostring((i-1)*nc+j) end r[i]=table.concat(c, ' ')  end
    assertEquals( tostring(m      ), table.concat(r, '\n') )
    for i=1,nr do for j=1,nc do c[j]=tostring((i-1)*nc+j) end r[i]=table.concat(c)       end
    assertEquals( tostring(m, ''  ), table.concat(r, '\n') )
    for i=1,nr do for j=1,nc do c[j]=tostring((i-1)*nc+j) end r[i]=table.concat(c, "\n") end
    assertEquals( tostring(m, '\n'), table.concat(r, '\n') )
  end
end

function TestMatrixErr:testTotable()
  local msg = {
    "invalid argument #2 (table expected)"          ,
    "invalid argument #2 (table of tables expected)",
  }
  assertErrorMsgContains( msg[1], totable, errMat, ''     )
  assertErrorMsgContains( msg[1], totable, errMat, 1      )
  assertErrorMsgContains( msg[1], totable, errMat, true   )
  assertErrorMsgContains( msg[1], totable, errMat, 1..2   )
  assertErrorMsgContains( msg[1], totable, errMat, errMat )
  assertErrorMsgContains( msg[2], totable, errMat, {{},5} )
end

function TestMatrixConv:testTotable() -- to be done with foldl
  assertTrue( is_table(totable( matrix(2))) )
  for i,m in ipairs(G.mat) do
    local tref = {}
    local nr, nc = m:sizes()
    if nc ~=1 then
      for i=1,nr do tref[i]={} for j=1,nc do  tref[i][j]=(i-1)*nc+j end end
    else
      for i=1,nr do tref[i]=(i-1)*nc+1 end
    end
    assertEquals( totable( m)        , tref )
    assertEquals( matrix(totable(m )), m    )
  end
end

-- concatenation --------------------------------------------------------------o

function TestMatrixErr:testConcat()
  local msg = {
    "invalid argument #1 (matrix expected)"               ,
    "invalid argument #2 (matrix expected)"               ,
    "incompatible matrix sizes"                           ,
    "invalid argument #3 (string 'row' or 'col' expected)",
  }
end
function TestMatrix:testConcat() end

-- end ------------------------------------------------------------------------o
