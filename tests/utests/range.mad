--[=[
 o-----------------------------------------------------------------------------o
 |
 | Range module regression tests
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

	Purpose:
	- Provide regression test suites for the range module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertEquals, assertAlmostEquals, assertTrue, assertFalse,
			assertErrorMsgContains, assertNil, assertNaN, assertIsString
			in require 'luaunit'

local range   , nrange   , irange   , is_range,
			logrange, nlogrange, ilogrange, is_logrange,
			tiny, eps, huge, inf, nan in MAD
local is_function in MAD

-- regression test suite ------------------------------------------------------o

TestRange = {}

local values = {
  limit = { huge, tiny, inf },
  num   = {0, 2^-64, 2^-63, 2^-53, eps, 2^-52, 2*eps, 2^-32, 2^-31, 1e-9,
          0.1-eps, 0.1, 0.1+eps, 0.5, 0.7-eps, 0.7, 0.7+eps, 1-eps, 1, 1+eps,
          1.1, 1.7, 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53,
          2^63, 2^64 },
  empty = {
				  { 1 , 10,-0.1}, { 1 ,-10, 0.1}, {-1 ,-10, 0.1}, {-1 , 10,-0.1},
				  { 10, 1 , 0.1}, { 10,-1 , 0.1}, {-10, 1 ,-0.1}, {-10,-1 ,-0.1},
				  },
  zeros = {
				  { 0 , 0 , 0  }, {-0 ,-0 ,-0  }, { 1 , 10, 0  }, { 1 , 10,-0  },
				  },
 nzeros = {
 					{ 1, 10, 0  },{ 1, 10,-0  },{ 1, 10,-1  },{ 1, 10, inf},{ 1, 10,-inf},
 					},
	rng   = {
			 	  { 1 , 10, 0.1}, { 1 ,-10,-0.1}, {-1 , 10, 0.1}, {-1 ,-10,-0.1},
			    { 10, 1 ,-0.1}, { 10,-1 ,-0.1}, {-10, 1 , 0.1}, {-10,-1 , 0.1},
			    { 10, 10, 0.1}, {-10,-10,-0.1},
			    },
}

function TestRange:testConstructor()
	local a = 2
	local msg = {
		"invalid argument #1 (number expected)",
		"cannot convert 'string' to 'double'",
	}
	assertErrorMsgContains( msg[1], range            )
	assertErrorMsgContains( msg[1], range, nil, 1    )
	assertErrorMsgContains( msg[1], range, 1..10..2  )
	assertErrorMsgContains( msg[1], range, ''        )
	assertErrorMsgContains( msg[2], range, 1, ''     )
	assertErrorMsgContains( msg[2], range, 1, 10, '' )

	assertTrue( is_range(range(1))    )
	assertTrue( is_range(range(1,10)) )
	assertTrue( is_range(range( 0, 1  , eps)) )
	assertTrue( is_range(range( 1, 0  ,-eps)) )
	assertTrue( is_range(range( 0, 0.5, eps)) )
	assertTrue( is_range(range( 1, 0.5,-eps)) )

	assertTrue( is_range( range( a, a)   ) )
	assertTrue( is_range( range(-a,-a)   ) )
	assertTrue( is_range( range( a, a, a)) )
	assertTrue( is_range( range(-a,-a,-a)) )

	for _,v in ipairs(values.rng) do
		assertTrue( is_range( range(v[1],v[2],v[3]) ) )
	end
	for _,v in ipairs(values.empty) do
		assertTrue( is_range( range(v[1],v[2],v[3]) ) )
	end
	for _,v in ipairs(values.zeros) do
		assertTrue( is_range( range(v[1],v[2],v[3]) ) )
	end
	for _,v in ipairs(values.num) do
		assertTrue( is_range(range( 1, 10, v)) )
		assertTrue( is_range(range( 1, 10,-v)) )
	end
  for _,v in ipairs(values.limit) do
		assertTrue( is_range(range( 1,  10, v)) )
		assertTrue( is_range(range( 10, 1 ,-v)) )
		assertTrue( is_range(range( 1 , v , v)) )
		assertTrue( is_range(range( 1 ,-v ,-v)) )
		assertTrue( is_range(range( v , v , v)) )
		assertTrue( is_range(range(-v ,-v ,-v)) )
	end

	assertTrue( is_range(range( 1  , 10 , nan)) )
	assertTrue( is_range(range( 10 , 1  ,-nan)) )
	assertTrue( is_range(range( 1  , nan, nan)) )
	assertTrue( is_range(range( 1  ,-nan,-nan)) )
	assertTrue( is_range(range( nan, nan, nan)) )
	assertTrue( is_range(range(-nan,-nan,-nan)) )
end

function TestRange:testConcatCtor()
	local a = 2
	assertTrue( is_range(0..9..0.5)      )
	assertTrue( is_range(0..9.. .5)      )
	assertTrue( is_range(0..0.9..0.5)    )
	assertTrue( is_range(0.. .9.. .5)    )
	assertTrue( is_range(0.1..0.9..0.5)  )
	assertTrue( is_range( .1.. .9.. .5)  )
	assertTrue( is_range(0..9..-0.5)     )
	assertTrue( is_range(0..9..- .5)     )
	assertTrue( is_range(0..-0.9..0.5)   )
	assertTrue( is_range(0..- .9.. .5)   )
	assertTrue( is_range(-0.1..0.9..0.5) )
	assertTrue( is_range(- .1.. .9.. .5) )
  assertEquals( 1..10     , range(1,10)     )
	assertEquals(  a..a     , range( a, a)    )
	assertEquals( -a..-a    , range(-a,-a)    )
	assertEquals(  a..a..a  , range( a, a, a) )
	assertEquals( -a..-a..-a, range(-a,-a,-a) )

	for _,v in ipairs(values.rng)do
		assertEquals( range(v[1],v[2],v[3]), v[1]..v[2]..v[3]  )
	end
	for _,v in ipairs(values.empty) do
		assertEquals( range(v[1],v[2],v[3]), v[1]..v[2]..v[3]  )
	end
	for _,v in ipairs(values.zeros)do
		assertEquals( range(v[1],v[2],v[3]), v[1]..v[2]..v[3]  )
	end
	for _,v in ipairs(values.num) do
		assertEquals( range( 1, 10, v),  1..10.. v )
		assertEquals( range( 1, 10,-v),  1..10..-v )
	end
  for _,v in ipairs(values.limit) do
		assertEquals( range( 1 , 10, v ),  1.. 10.. v )
		assertEquals( range( 10, 1 ,-v ),  10..1 ..-v )
		assertEquals( range( 1 , v , v ),  1.. v .. v )
		assertEquals( range( 1 ,-v ,-v ),  1..-v ..-v )
		assertEquals( range( v , v , v ),  v.. v .. v )
		assertEquals( range(-v ,-v ,-v ), -v..-v ..-v )
	end

	assertIsString( 1..''    )
	assertIsString( 1..10..'')
	assertIsString( a..a..'' )
end

function TestRange:testFields()
	assertEquals( {range( 1 )          :range()}, {1 ,1 ,1}    )
	assertEquals( {range( 10,1 )       :range()}, {10,1 ,1}    )
	assertEquals( {range( 0 ,1  , eps) :range()}, {0,1  , eps} )
	assertEquals( {range( 1 ,0  ,-eps) :range()}, {1,0  ,-eps} )
	assertEquals( {range( 0 ,0.5, eps) :range()}, {0,0.5, eps} )
	assertEquals( {range( 1 ,0.5,-eps) :range()}, {1,0.5,-eps} )

	for _,v in ipairs(values.rng)do
		assertEquals( {range(v[1],v[2],v[3]):range()}, {v[1],v[2],v[3]} )
	end
	for _,v in ipairs(values.empty) do
		assertEquals( {range(v[1],v[2],v[3]):range()}, {v[1],v[2],v[3]} )
	end
	for _,v in ipairs(values.zeros) do
		assertEquals( {range(v[1],v[2],v[3]):range()}, {v[1],v[2],v[3]} )
	end

	for _,v in ipairs(values.num) do
		assertEquals( {range( 1 ,10, v):range()}, {1 ,10, v} )
		assertEquals( {range( 10, 1,-v):range()}, {10, 1,-v} )
	end
	for _,v in ipairs(values.limit) do
		assertEquals( {range( 1 ,10, v):range()}, { 1,10, v} )
		assertEquals( {range( 10, 1,-v):range()}, {10, 1,-v} )
		assertEquals( {range( 1, v , v):range()}, { 1, v, v} )
		assertEquals( {range( 1,-v ,-v):range()}, { 1,-v,-v} )
		assertEquals( {range( v, v , v):range()}, { v, v, v} )
		assertEquals( {range(-v,-v ,-v):range()}, {-v,-v,-v} )
	end

	assertNaN( range( nan, nan, nan).start )
	assertNaN( range( nan, nan, nan).stop  )
	assertNaN( range( nan, nan, nan).step  )
	assertNaN( range(-nan,-nan,-nan).start )
	assertNaN( range(-nan,-nan,-nan).stop  )
	assertNaN( range(-nan,-nan,-nan).step  )

	assertEquals(  range( 1, nan, nan).start, 1  )
	assertNaN   (  range( 1, nan, nan).stop      )
	assertNaN   (  range( 1, nan, nan).step      )
	assertEquals(  range( 1, 10 , nan).start, 1  )
	assertEquals(  range( 1, 10 , nan).stop , 10 )
	assertNaN   (  range( 1, 10 , nan).step      )
	assertEquals(  range( 1, 10 ,-nan).start, 1  )
	assertEquals(  range( 1, 10 ,-nan).stop , 10 )
	assertNaN   (  range( 1, 10 ,-nan).step      )
	assertEquals(  range( 1, nan, 10 ).start, 1  )
	assertNaN   (  range( 1, nan, 10 ).stop      )
	assertEquals(  range( 1, nan, 10 ).step ,10  )
	assertEquals(  range( 1,-nan, 10 ).start, 1  )
	assertNaN   (  range( 1,-nan, 10 ).stop      )
	assertEquals(  range( 1,-nan, 10 ).step ,10  )
end

function TestRange:testReadonly()
	local f1, f2, f3
	local msg = {
		"attempt to write to constant location",
	}
	for _,v in ipairs(values.num) do
		f1=\r,v => r.start = v end
		assertErrorMsgContains( msg[1], f1, 1..10..0.1     , v )
		assertErrorMsgContains( msg[1], f1, range(1,10,0.1), v )
		assertErrorMsgContains( msg[1], f1, nrange(1,10,10), v )
		f2=\r,v => r.stop  = v end
		assertErrorMsgContains( msg[1], f2, 1..10..0.1     , v )
		assertErrorMsgContains( msg[1], f2, range(1,10,0.1), v )
		assertErrorMsgContains( msg[1], f2, nrange(1,10,10), v )
		f3=\r,v => r.step  = v end
		assertErrorMsgContains( msg[1], f3, 1..10..0.1     , v )
		assertErrorMsgContains( msg[1], f3, range(1,10,0.1), v )
		assertErrorMsgContains( msg[1], f3, nrange(1,10,10), v )
	end
end

function TestRange:testIsRange()
	assertFalse( is_range('') )
	assertFalse( is_range(2)  )
	assertFalse( is_range(logrange(1,10^6,10)) )
	assertFalse( is_range(nlogrange(1,10,10))  )
	assertTrue ( is_range(range(1)) )
	assertTrue ( is_range(1..10)    )
	assertTrue ( is_range(1..10..0.1) )
	assertTrue ( is_range(1..0)       )
	assertTrue ( is_range(1..0..10)   )
	assertTrue ( is_range(1..10..0)   )
	assertTrue ( is_range(nrange(1,10,10)) )
	assertTrue ( is_range(nrange(1,10,1))  )
	assertTrue ( is_range(nrange(1,10,0))  )
end

function TestRange:testRange()
	local r
  r =  range(1)      assertEquals( {r:range()}, {r.start, r.stop, r.step} )
  r =  range(1,10,1) assertEquals( {r:range()}, {r.start, r.stop, r.step} )
  r = nrange(1,10,1) assertEquals( {r:range()}, {r.start, r.stop, r.step} )

	for _,v in ipairs(values.rng) do
	  r = range(v[1],v[2],v[3]) assertEquals( {r:range()}, {r.start,r.stop,r.step} )
	end
	for _,v in ipairs(values.empty) do
	  r = range(v[1],v[2],v[3]) assertEquals( {r:range()}, {r.start,r.stop,r.step} )
	end
	for _,v in ipairs(values.zeros) do
	  r = range(v[1],v[2],v[3]) assertEquals( {r:range()}, {r.start,r.stop,r.step} )
	end
	for _,v in ipairs(values.nzeros) do
	  r = range(v[1],v[2],v[3]) assertEquals( {r:range()}, {r.start,r.stop,r.step} )
	end
	for _,v in ipairs(values.num) do
		r = range( 1 ,10, v)  assertEquals( {r:range()}, {r.start, r.stop, r.step} )
	  r = range( 10, 1,-v)  assertEquals( {r:range()}, {r.start, r.stop, r.step} )
	end
	for _,v in ipairs(values.limit) do
	  r = range( 1 ,10, v)  assertEquals( {r:range()}, {r.start, r.stop, r.step} )
		r = range( 10, 1,-v)  assertEquals( {r:range()}, {r.start, r.stop, r.step} )
		r = range( 1, v , v)  assertEquals( {r:range()}, {r.start, r.stop, r.step} )
		r = range( 1,-v ,-v)  assertEquals( {r:range()}, {r.start, r.stop, r.step} )
		r = range( v, v , v)  assertEquals( {r:range()}, {r.start, r.stop, r.step} )
		r = range(-v,-v ,-v)  assertEquals( {r:range()}, {r.start, r.stop, r.step} )
	end
end

function TestRange:testIsEmpty()
	for _,v in ipairs(values.empty) do
		assertTrue ( range(v[1],v[2],v[3]):is_empty() )
	end
	for _,v in ipairs(values.zeros) do
		assertFalse( range(v[1],v[2],v[3]):is_empty() )
	end
	for _,v in ipairs(values.nzeros) do
		assertFalse( nrange(v[1],v[2],v[3]):is_empty() )
	end

	for _,v in ipairs(values.rng) do
		assertFalse( range(v[1],v[2],v[3]):is_empty() )
	end
  assertFalse( range(1)          :is_empty() )
  assertFalse( range(1,10)       :is_empty() )
  assertFalse( (0.. 1.. eps)     :is_empty() )
	assertFalse( (0..-1..-eps)     :is_empty() )
  assertFalse( nrange(2, 10, 0.1):is_empty() )
  assertFalse( nrange(0, 9 , 10) :is_empty() )
  assertFalse( nrange(2, 10, nan):is_empty() )

	for _,v in ipairs(values.num) do
		if v~=0 then
			assertFalse( range( 1 , 10, v):is_empty() )
			assertFalse( range( 10, 1 ,-v):is_empty() )
			assertTrue ( range( 1 , 10,-v):is_empty() )
			assertFalse(nrange( 1 , 10, v):is_empty() )
		end
	end
  for _,v in ipairs(values.limit) do
  	assertFalse(  range( 1 , 10, v):is_empty() )
		assertFalse(  range( 10, 1 ,-v):is_empty() )
		assertFalse(  range( 1 ,-v ,-v):is_empty() )
		assertFalse(  range( v , v , v):is_empty() )
		assertFalse(  range(-v ,-v ,-v):is_empty() )
		assertFalse( nrange( 10, 1 ,-v):is_empty() )
	end

	assertFalse(  range( 1, inf , inf ):is_empty() )
	assertFalse(  range( 1, huge, huge):is_empty() )
	assertTrue (  range( 1, tiny, tiny):is_empty() )
  assertFalse( nrange( 2, 10  , inf ):is_empty() )
  assertFalse( nrange( 2, 10  , huge):is_empty() )
  assertFalse( nrange( 2, 10  , tiny):is_empty() )

	assertTrue ( range( 1  , 10 , nan) :is_empty() )
	assertTrue ( range( 1  , 10 ,-nan) :is_empty() )
	assertTrue ( range( 1  , nan, nan) :is_empty() )
	assertTrue ( range( 1  ,-nan,-nan) :is_empty() )
	assertTrue ( range( nan, nan, nan) :is_empty() )
	assertTrue ( range(-nan,-nan,-nan) :is_empty() )
end

function TestRange:testNConstructor()
	local a = 2
	local msg = {
		"invalid argument #1 or #2(number expected)",
	}
	assertErrorMsgContains( msg[1], nrange             )
	assertErrorMsgContains( msg[1], nrange, nil, 1     )
	assertErrorMsgContains( msg[1], nrange, nil, 1, 1  )
	assertErrorMsgContains( msg[1], nrange, ''         )
	assertErrorMsgContains( msg[1], nrange, '', ''     )
	assertErrorMsgContains( msg[1], nrange, '', 1 , 1  )
	assertErrorMsgContains( msg[1], nrange, '', '', 1  )
	assertErrorMsgContains( msg[1], nrange, (1..10..1) )

	assertTrue( is_range(nrange(1, 2, '')) )
	assertTrue( is_range(nrange(1,10))     )
	assertTrue( is_range(nrange(1,10,0))   )
	assertTrue( is_range(nrange(1,10,1))   )
	assertTrue( is_range(nrange(1,10,-1))  )
	assertTrue( is_range(nrange( a, a, a)) )
	assertTrue( is_range(nrange(-a,-a,-a)) )

  for _,v in ipairs(values.num) do
		assertTrue( is_range(nrange( 1, 10, v)) )
		assertTrue( is_range(nrange( 1, 10,-v)) )
	end
  for _,v in ipairs(values.limit) do
		assertTrue( is_range(nrange( 1 , 10, v)) )
		assertTrue( is_range(nrange( 10, 1 ,-v)) )
		assertTrue( is_range(nrange( 1 , v , v)) )
		assertTrue( is_range(nrange( 1 ,-v ,-v)) )
		assertTrue( is_range(nrange( v , v , v)) )
		assertTrue( is_range(nrange(-v ,-v ,-v)) )
	end
	for _,v in ipairs(values.nzeros) do
		assertTrue( is_range(nrange(v[1],v[2],v[3])) )
	end
	assertTrue( is_range(nrange( 1  , 10 , nan)) )
	assertTrue( is_range(nrange( 10 , 1  ,-nan)) )
	assertTrue( is_range(nrange( 1  , nan, nan)) )
	assertTrue( is_range(nrange( 1  ,-nan,-nan)) )
	assertTrue( is_range(nrange( nan, nan, nan)) )
	assertTrue( is_range(nrange(-nan,-nan,-nan)) )
end

function TestRange:testNCnstrFields()
	for _,v in ipairs(values.nzeros) do
		assertEquals( {nrange(v[1],v[2],v[3]):range()}, {v[1],v[2],0} )
  end
  assertEquals( {nrange( 1 ,10, 0  ):range()}, { 1, 10, 0 } )
  assertEquals( {nrange( 1 ,50     ):range()}, { 1, 50, 1 } )
	assertEquals( {nrange( 50, 1 )    :range()}, {50, 1 ,-1 } )
  assertEquals( {nrange( 1 ,10, 1.1):range()}, { 1, 10, 9 } )
  assertEquals( {nrange( 1 ,10, 0.5):range()}, { 1, 10, 10} )
  assertEquals( {nrange( 1 ,10, 1  ):range()}, { 1, 10, 10} )
  assertEquals( {nrange( 1 ,10, 10 ):range()}, { 1, 10, 1 } )
  assertEquals( {nrange( 10, 1, 1.5):range()}, { 10, 1,-9 } )
  assertEquals( {nrange( 10, 1, 10 ):range()}, { 10, 1,-1 } )

  assertEquals( {nrange( 1 , 10,-huge):range()}, {1 ,10, 0 } )
  assertEquals( {nrange( 1 , 0 , huge):range()}, {1 ,0 ,-0 } )
  assertEquals( {nrange( 1 , 10,-tiny):range()}, {1 ,10, 0 } )
  assertEquals( {nrange( 1 , 0 , tiny):range()}, {1 ,0 ,-2 } )

  assertEquals(  nrange( 1 ,32, 9).step, 3.875 )
  assertEquals(  nrange( 32,1 , 9).step,-3.875 )
	assertAlmostEquals( nrange(0,1  , 1/eps).step -  eps, 0, eps )
	assertAlmostEquals( nrange(1,0  ,-1/eps).step - -eps, 0, eps )
	assertAlmostEquals( nrange(0,0.5, 1/eps).step -  eps, 0, eps )
	assertAlmostEquals( nrange(1,0.5,-1/eps).step - -eps, 0, eps )

  assertEquals( {nrange( 1  , 10 ,-inf):range()}, { 1  , 10 ,0} )
  assertEquals( {nrange( 1  , 10 , inf):range()}, { 1  , 10 ,0} )
	assertEquals( {nrange(-inf,-inf,-inf):range()}, {-inf,-inf,0} )
	assertEquals(  nrange( inf, inf, inf).stop    , inf           )
	assertEquals(  nrange( inf, inf, inf).start   , inf           )
	assertNaN   (  nrange( inf, inf, inf).step    )

	assertNaN   ( nrange( nan, nan, nan).start    )
	assertNaN   ( nrange( nan, nan, nan).stop     )
	assertEquals( nrange( nan, nan, nan).step , 1 )
	assertNaN   ( nrange(-nan,-nan,-nan).start    )
	assertNaN   ( nrange(-nan,-nan,-nan).stop     )
	assertEquals( nrange(-nan,-nan,-nan).step , 1 )

	assertEquals( {nrange( 1, 10,  nan):range()}, {1,10,10} )
	assertEquals( {nrange( 1, 10, -nan):range()}, {1,10,10} )
	assertEquals(  nrange( 1, nan, nan).start, 1 )
	assertNaN   (  nrange( 1, nan, nan).stop     )
	assertEquals(  nrange( 1, nan, nan).step , 1 )
	assertEquals(  nrange( 1, nan, 10 ).start, 1 )
	assertNaN   (  nrange( 1, nan, 10 ).stop     )
	assertNaN   (  nrange( 1, nan, 10 ).step     )
	assertEquals(  nrange( 1,-nan, 10 ).start, 1 )
	assertNaN   (  nrange( 1,-nan, 10 ).stop     )
	assertNaN   (  nrange( 1,-nan, 10 ).step     )
end

function TestRange:testNCnstrSinglePoint()
	local ref = { 1 , 1 ,-1 ,-1 , 10, 10,-10,-10 }
	local nr  = {
  	nrange( 1,  10, 1),
  	nrange( 1 ,-10, 1),
  	nrange(-1 , 10, 1),
  	nrange(-1 ,-10, 1),
  	nrange( 10, 1 , 1),
  	nrange( 10,-1 , 1),
  	nrange(-10, 1 , 1),
  	nrange(-10,-1 , 1),
  }

	for i=1,#nr do assertEquals( nr[i]:size()    , 1      ) end
	for i=1,#nr do assertEquals( nr[i]:get(0)    , ref[i] ) end
	for i=1,#nr do assertFalse ( nr[i]:is_empty()         ) end
	for i=1,#nr do assertNil   ( nr[i]:get(1)             ) end
end

function TestRange:testValue()
  assertNaN   ( nrange(1,10,1)   :value(nan) )
  assertNaN   (  range(1,10,1)   :value(nan) )
  assertNaN   (  range(2,10, inf):value(0)   )
  assertNaN   (  range(2,10,-inf):value(0)   )
  assertEquals(  range(2,10, inf):value(1)   , inf )
  assertEquals(  range(2,10,-inf):value(2)   ,-inf )

	for _,v in ipairs(values.empty) do
		assertEquals( range(v[1],v[2],v[3]):value(0), v[1] )
	end
	for _,v in ipairs(values.zeros) do
		assertEquals( range(v[1],v[2],v[3]):value(0), v[1] )
	end
	for _,v in ipairs(values.rng) do
		assertEquals( range(v[1],v[2],v[3]):value(0), v[1] )
	end

	assertEquals(  range(1,10,0.1):value(-1), 0.9 )
	assertEquals(  range(1,10,0.1):value(11), 2.1 )
	assertEquals(  range(1,10,0  ):value(1) , 1   )
	assertEquals( nrange(1,10,1  ):value(1) , 11  )

  assertEquals( (-2..2 .. 0.1)   :value(0)  ,-2     )
  assertEquals( (-2..2 .. 0.1)   :value(-0) ,-2     )
	assertEquals( ( 1..20.. 0.1)   :value(1)  , 1.1   )
	assertEquals( ( 1..20.. 0.1)   :value(1.1), 1.11  )
	assertEquals( ( 1..10..-1  )   :value(0)  , 1     )
	assertEquals( ( 1..10..-1  )   :value(2)  ,-1     )
	assertEquals( range(1,100,1)   :value(99) , 100   )
	assertEquals( nrange(1,100,100):value(99) , 100   )
	assertEquals( range(0,1  ,eps) :value(1)  ,   eps )
	assertEquals( range(0,0.5,eps) :value(2)  , 2*eps )
	assertAlmostEquals( (2..-2..-0.1):value(22)- -0.2, 0, eps )

  for _,v in ipairs(values.num) do
    assertAlmostEquals( (0.. 1.. v):value(1)-  v, 0, eps )
    assertAlmostEquals( (0..-1..-v):value(1)- -v, 0, eps )
  end

	assertEquals( nrange(1,10,1):value( inf) , inf  )
  assertEquals(  range(10,1,1):value( inf) , inf  )
  assertEquals(  range(10,1,1):value(-inf) ,-inf  )
  assertEquals( (0..10)       :value( tiny), tiny )
  assertEquals( (0..10)       :value(-tiny),-tiny )
  assertEquals( (0..10)       :value( huge), huge )
	assertEquals( (0..10)       :value(-huge),-huge )
  assertEquals( (1..0..-0.1)  :value(-eps) , 1    )
  assertAlmostEquals( (0..1..0.1):value( eps) - eps, 0, eps )
end

function TestRange:testGet()
	local r, res, ref
	assertNil( range(2, 10, inf):get(0) )
  assertNil( range(2, 10,-inf):get(0) )
	assertNil( range(1, 10, 0.1):get( inf) )
	assertNil( range(1, 10, 0.1):get(-inf) )
	assertNil( range(1, 10, 0.1):get( nan) )
	assertNil( range(1, 10, 0.1):get(-nan) )

	assertNil( range(10,1 ,-1  ):get(11)   )
	assertNil( range(1 ,10, 0.1):get(-1)   )
	assertNil( range(1 ,10, 0.1):get(101)  )

	for _,v in ipairs(values.empty) do
		assertNil ( range(v[1],v[2],v[3]):get(0) )
	end
	for _,v in ipairs(values.zeros) do
		assertEquals( range(v[1],v[2],v[3]):get(0), v[1] )
		assertEquals( range(v[1],v[2],v[3]):get(1), v[1] )
	end
	for _,v in ipairs(values.nzeros) do
		assertEquals( nrange(v[1],v[2],v[3]):get(0), v[1] )
		assertEquals( nrange(v[1],v[2],v[3]):get(1), v[1] )
	end

	for _,v in ipairs(values.rng) do
		r = range(v[1],v[2],v[3])
		assertEquals( r:get(0), v[1] )
		assertAlmostEquals( r:get(#r-1) - v[2], 0, eps )
	end
  assertEquals( (-2..2..0.1)       :get(0)  ,-2    )
	assertEquals( (1..20..0.1)       :get(1.1), 1.11 )
	assertEquals( range(1,100,1)     :get(99) , 100  )
	assertEquals( nrange(1,100,100)  :get(99) , 100  )
	assertAlmostEquals( (2..-2..-0.1):get(22)- -0.2, 0, eps )
  assertAlmostEquals( (0..1..0.1)  :get(eps)- eps, 0, eps )

	res = 1..5
	ref = {1, 2, 3, 4, 5}
	for i=1,#res do assertEquals(res:get(i-1), ref[i]) end

	res = range(1,10,2)
	ref = {1, 3, 5, 7, 9}
	for i=1,#res do assertEquals(res:get(i-1), ref[i]) end

	res = 0.5..0..-0.1
	ref = {0.5, 0.4, 0.3, 0.2, 0.1, 0}
	for i=1,#res do assertAlmostEquals(res:get(i-1) - ref[i], 0, eps) end

	res =   range(10,-1,-0.7)
	ref = {10 , 9.3, 8.6, 7.9, 7.2, 6.5, 5.8, 5.1,
			   4.4, 3.7, 3  , 2.3, 1.6, 0.9, 0.2, -0.5 }
  for i=1,#res do
  	assertAlmostEquals(res[i] - ref[i], 0, 6*eps) -- 6 eps @ 1.6
  end
end

function TestRange:testIndex()
	local r, res, ref
	assertNil( range(1 , 10, 0.1)['']   )
	assertNil( range(1 , 10, 0.1)[nil]  )
	assertNil( range(1 , 10, 0.1)[0]    )
	assertNil( range(10, 1 ,-1  )[11]   )
	assertNil( range(1 , 10, 0.1)[101]  )
	assertNil( range(10, 1 ,-1  )[-1]   )
	assertNil( range(1 , 10, 0.1)[0.1]  )
	assertNil( range(1 , 10, 0.1)[ inf] )
	assertNil( range(1 , 10, 0.1)[-inf] )
	assertNil( range(1 , 10, 0.1)[ nan] )
	assertNil( range(1 , 10, 0.1)[-nan] )
	assertNil( nrange(1, 10, 1  )[10]   )

	for _,v in ipairs(values.empty) do
		assertNil (range(v[1],v[2],v[3])[1] )
	end
	for _,v in ipairs(values.zeros) do
		assertEquals( range(v[1],v[2],v[3])[1], v[1] )
		assertEquals( range(v[1],v[2],v[3])[2], v[1] )
	end
	for _,v in ipairs(values.nzeros) do
		assertEquals( nrange(v[1],v[2],v[3])[1], v[1] )
		assertEquals( nrange(v[1],v[2],v[3])[2], v[1] )
	end

	for _,v in ipairs(values.rng) do
		r = range(v[1],v[2],v[3])
		assertEquals( r[1], v[1] )
		assertAlmostEquals( r[#r] - v[2], 0, eps )
	end
	assertEquals( (1..20..0.1)       [2]   , 1.1  )
	assertEquals( (1..20..0.1)       [2.1] , 1.11 )
	assertEquals( range(1,100,1)     [100] , 100  )
	assertEquals( nrange(1,100,100)  [100] , 100  )
	assertAlmostEquals( (2..-2..-0.1)[23]- -0.2, 0, eps )

	res = 1..5
	ref = {1, 2, 3, 4, 5}
	for i=1,#res do assertEquals(res[i], ref[i]) end

	res = range(1,10,2)
	ref = {1, 3, 5, 7, 9}
	for i=1,#res do assertEquals(res[i], ref[i]) end

	res = 0.5..0..-0.1
	ref = {0.5, 0.4, 0.3, 0.2, 0.1, 0}
	for i=1,#res do assertAlmostEquals(res[i] - ref[i], 0, eps) end

	res =   range(10,-1,-0.7)
	ref = {10 , 9.3, 8.6, 7.9, 7.2, 6.5, 5.8, 5.1,
				 4.4, 3.7, 3  , 2.3, 1.6, 0.9, 0.2, -0.5 }
  for i=1,#res do
  	assertAlmostEquals(res[i] - ref[i], 0, 6*eps) -- 6 eps @ 1.6
  end
end

function TestRange:testSize()
	assertEquals( range(1)           :size(), 1 )
  assertEquals( range(2 ,10, inf)  :size(), 1 )
  assertEquals( range(2 ,10,-inf)  :size(), 1 )
  assertEquals( range(2 ,10, huge) :size(), 1 )
  assertEquals( range(10,2 ,-huge) :size(), 1 )

	for _,v in ipairs(values.empty) do
		assertEquals( range(v[1],v[2],v[3]):size(), 0 )
	end
	for _,v in ipairs(values.nzeros) do
		assertEquals( nrange(v[1],v[2],v[3]):size(), inf )
	end
	assertEquals( range( 1 , 10   )  :size(), 10 )
	assertEquals( range( 1 ,-10,-1)  :size(), 12 )
	assertEquals( range(-1 , 10   )  :size(), 12 )
	assertEquals( range(-1 ,-10,-1)  :size(), 10 )
	assertEquals( range( 10, 1 ,-1)  :size(), 10 )
	assertEquals( range( 10,-1 ,-1)  :size(), 12 )
	assertEquals( range(-10, 1    )  :size(), 12 )
	assertEquals( range(-10,-1    )  :size(), 10 )

	assertEquals( range( 1 , 10, 0.1):size(), 91  )
	assertEquals( range( 1 ,-10,-0.1):size(), 111 )
	assertEquals( range(-1 , 10, 0.1):size(), 111 )
	assertEquals( range(-1 ,-10,-0.1):size(), 91  )
	assertEquals( range( 10, 1 ,-0.1):size(), 91  )
	assertEquals( range( 10,-1 ,-0.1):size(), 111 )
	assertEquals( range(-10, 1 , 0.1):size(), 111 )
	assertEquals( range(-10,-1 , 0.1):size(), 91  )

	assertEquals( range( 1 , 10, 0.5):size(), 19 )
	assertEquals( range( 1 ,-10,-0.5):size(), 23 )
	assertEquals( range(-1 , 10, 0.5):size(), 23 )
	assertEquals( range(-1 ,-10,-0.5):size(), 19 )
	assertEquals( range( 10, 1 ,-0.5):size(), 19 )
	assertEquals( range( 10,-1 ,-0.5):size(), 23 )
	assertEquals( range(-10, 1 , 0.5):size(), 23 )
	assertEquals( range(-10,-1 , 0.5):size(), 19 )

  assertAlmostEquals( range(eps,1  , eps):size() - 1/eps  , 0, eps)
  assertAlmostEquals( range(1  ,eps,-eps):size() - 1/eps  , 0, eps)
  assertAlmostEquals( range(eps,0.5, eps):size() - 0.5/eps, 0, eps)
  assertAlmostEquals( range(0.5,eps,-eps):size() - 0.5/eps, 0, eps)
  assertAlmostEquals( range(0  ,1  , eps):size() - 1/eps - 1  , 0, eps)
  assertAlmostEquals( range(1  ,0  ,-eps):size() - 1/eps - 1  , 0, eps)
  assertAlmostEquals( range(0  ,0.5, eps):size() - 0.5/eps - 1, 0, eps)
  assertAlmostEquals( range(0.5,  0,-eps):size() - 0.5/eps - 1, 0, eps)

	assertTrue( (1 .. 20.. 1.9):size() == (-1..-20..-1.9):size() )
	assertTrue( (1 .. 22.. 2.1):size() == (-1..-22..-2.1):size() )

	assertEquals( (0..2.1 ..1) :size(), 3    )
  assertEquals( (0..2.9 ..1) :size(), 3    )
	assertEquals( (1..10^3..1) :size(), 10^3 )
	assertEquals( (1..10^3..2) :size(), 500  )
	assertEquals( (1..32  ..2) :size(), 16   )
	assertEquals( (1..31  ..2) :size(), 16   )
  assertEquals( nrange(2, 10, nil) :size(), 50 )
  assertEquals( nrange(2, 10, 1.1) :size(), 2  )
	assertEquals( nrange(1, 32, 9  ) :size(), 9  )
	assertEquals( nrange(1, 32, 10 ) :size(), 10 )
  assertEquals( nrange(2, 10, nan) :size(), 1  )
  assertEquals( nrange(2, 10,-nan) :size(), 1  )

  assertNaN( range( 2  , 10 , nan):size() )
  assertNaN( range( 2  , 10 ,-nan):size() )
  assertNaN( range( 2  , nan, nan):size() )
  assertNaN( range( 2  ,-nan,-nan):size() )
  assertNaN( range( nan, nan, nan):size() )
  assertNaN( range(-nan,-nan,-nan):size() )

  assertEquals( (0..24..4)        :size(), #(0..24..4)      )
  assertEquals( nrange(1,32,9)    :size(), #nrange(1,32,9)  )

	assertNaN   (  range( 0 , 0 , 0 ):size() )
	assertNaN   (  range(-0 ,-0 ,-0 ):size() )
	assertEquals(  range( 1 , 10, 0 ):size(), inf )
	assertEquals( nrange( 1 , 10,-0 ):size(), inf )
	assertEquals( nrange( 1 , 10,-0 ):size(), inf )
end

function TestRange:testEqual()
	local r, nr
  r = range( 1 , 10 )     assertTrue( range(r:range()) == r )
	r = range( 1 , 20, 0  ) assertTrue( range(r:range()) == r )
	r = range( 1 , 20, 0.1) assertTrue( range(r:range()) == r )
	r = nrange(1 , 20, 0  ) assertTrue( range(r:range()) == r )
	r = nrange(1 , 10, 1  ) assertTrue( range(r:range()) == r )
	r = nrange(1 , 10, nan) assertTrue( range(r:range()) == r )

	for _,v in ipairs(values.empty) do
		r = range(v[1],v[2],v[3])	assertTrue( range(r:range()) == r )
	end
	for _,v in ipairs(values.zeros) do
		r = range(v[1],v[2],v[3])	assertTrue( range(r:range()) == r )
	end
	for _,v in ipairs(values.nzeros) do
		nr = nrange(v[1],v[2],v[3])	assertTrue( range(nr:range()) == nr )
																assertTrue( range(nr:range()) ==  r )
	end
	for _,v in ipairs(values.rng) do
		r = range(v[1],v[2],v[3])	assertTrue( range(r:range()) == r )
	end

  for _,v in ipairs(values.num) do
  	r=range( 1 , 10, v) assertTrue( range(r:range()) == r )
  	r=range( 10, 1 ,-v) assertTrue( range(r:range()) == r )
  	r=range( 1 , v , v) assertTrue( range(r:range()) == r )
  	r=range( 1 ,-v ,-v) assertTrue( range(r:range()) == r )
  	r=range( v , v , v) assertTrue( range(r:range()) == r )
  	r=range(-v ,-v ,-v) assertTrue( range(r:range()) == r )
  	r=range(-v ,-v ,-v) assertTrue( range(r:range()) == r )
	end
  for _,v in ipairs(values.limit) do
  	r=range( 1 , 10, v) assertTrue( range(r:range()) == r )
  	r=range( 10, 1 ,-v) assertTrue( range(r:range()) == r )
  	r=range( 1 , v , v) assertTrue( range(r:range()) == r )
  	r=range( 1 ,-v ,-v) assertTrue( range(r:range()) == r )
  	r=range( v , v , v) assertTrue( range(r:range()) == r )
  	r=range(-v ,-v ,-v) assertTrue( range(r:range()) == r )
  	r=range(-v ,-v ,-v) assertTrue( range(r:range()) == r )
	end
end

function TestRange:testReverse()
	for _,v in ipairs(values.rng) do
		assertEquals( range(v[1],v[2],v[3]):reverse(), range(v[2],v[1],-v[3]) )
	end
	for _,v in ipairs(values.empty) do
		assertEquals( range(v[1],v[2],v[3]):reverse(), range(v[2],v[1],-v[3]) )
	end
	for _,v in ipairs(values.zeros) do
		assertEquals( range(v[1],v[2],v[3]):reverse(), range(v[2],v[1],-v[3]) )
	end
	for _,v in ipairs(values.nzeros) do
		assertEquals( nrange(v[1],v[2],v[3]):reverse(), nrange(v[2],v[1],v[3]) )
	end

	assertEquals( range( 1 )         :reverse(), ( 1.. 1..-1)   )
	assertEquals( range( 1 , 10, 0  ):reverse(), (10.. 1..-0)   )
	assertEquals( range( 1 , 10, 0.1):reverse(), (10.. 1..-0.1) )
	assertEquals( range( 2 , 20,-1  ):reverse(), (20.. 2.. 1)   )
	assertEquals( range(-20,-2 , 2  ):reverse(), (-2..-20..-2)  )
	assertEquals( nrange(0 , 9 , 10 ):reverse(), nrange(9,0,10) )
	assertEquals( nrange(0 , 9 , 0  ):reverse(), nrange(9,0,0 ) )
	assertEquals( nrange(0 , 9 , 1  ):reverse(), nrange(9,0,1 ) )

	for _,v in ipairs(values.limit) do
		assertEquals(	range(-1 , 2 ,-v) :reverse(), (2..-1..v) )
		assertEquals(	range( 1 , 2 , v) :reverse(), (2..1..-v) )
	end
	for _,v in ipairs(values.num) do
		assertEquals( ( 0.. 1.. v):reverse(), range( 1, 0,-  v) )
		assertEquals( ( 1.. 0..-v):reverse(), range( 0, 1,- -v) )
		assertEquals( ( 0.. v.. v):reverse(), range( v, 0,-  v) )
		assertEquals( ( 0..-v..-v):reverse(), range(-v, 0,- -v) )
		assertEquals( ( v.. v.. v):reverse(), range( v, v,-  v) )
		assertEquals( (-v..-v..-v):reverse(), range(-v,-v,- -v) )
	end
end

function TestRange:testBounds()
	for _,v in ipairs(values.num) do
		if v ~= 0 then
			assertEquals( { range(1 ,20, v):bounds()}, {1,20}  )
			assertEquals( { range(20,1 ,-v):bounds()}, {1,20}  )
			assertEquals( {nrange(1 ,20, v):bounds()}, {1,20}  )
			assertEquals( {nrange(20,1 , v):bounds()}, {1,20}  )
		end
	end
	for _,v in ipairs(values.rng) do
		if v[3] < 0 then
			assertEquals( {range(v[1],v[2],v[3]):bounds()}, {v[2],v[1]})
		else
			assertEquals( {range(v[1],v[2],v[3]):bounds()}, {v[1],v[2]})
		end
	end

	for _,v in ipairs(values.empty) do
		assertEquals( {range(v[1],v[2],v[3]):bounds()}, {nil,nil})
	end
	for _,v in ipairs(values.zeros) do
			assertEquals( {range(v[1],v[2],v[3]):bounds()}, {v[1],v[1]})
	end
	for _,v in ipairs(values.nzeros) do
			assertEquals( {nrange(v[1],v[2],v[3]):bounds()}, {v[1],v[1]})
	end
	assertEquals( {range(-inf,inf)    :bounds()}, {-inf,inf} )
	assertEquals( {range( 1 )         :bounds()}, {1  ,1}    )
	assertEquals( {range( 1 , 0 )     :bounds()}, {nil,nil}  )

	assertEquals( {nrange( 1, 20, 0  ):bounds()}, {1,1} )
	assertEquals( {nrange( 1, 20, 0  ):bounds()}, {1,1} )
	assertEquals( {nrange( 1, 20, inf):bounds()}, {1,1} )
	assertEquals( {nrange( 1, 20,-inf):bounds()}, {1,1} )

	assertEquals( {nrange(1 ,20, huge):bounds()}, {1  ,20 } )
	assertEquals( {nrange(1 ,20, tiny):bounds()}, {1  ,20 } )
	assertEquals( {nrange(1 ,20, nan ):bounds()}, {1  ,20 } )
	assertEquals( { range(1 ,20, huge):bounds()}, {1  ,20 } )
	assertEquals( { range(1 ,20, tiny):bounds()}, {1  ,20 } )
	assertEquals( { range(1 ,20, inf ):bounds()}, {1  ,20 } )
	assertEquals( { range(1 ,20, nan ):bounds()}, {nil,nil} )
end

function TestRange:testOverlap()
	local r, nr
	assertTrue( range(-inf,inf):overlap(0..9)       )
	assertTrue( range(1)   		 :overlap(1..1)       )
	assertTrue( (1..9)     		 :overlap(1..1)       )
	assertTrue( (1..9..0.7)		 :overlap(9..1..-0.7) )
	assertFalse( range(0,-10,1):overlap(0..9) 		  )
	assertFalse( range(0,10,-1):overlap(0..9) 		  )
  assertFalse( range(2,10,2) :overlap(12..20..2)  )

	for _,v in ipairs(values.rng) do
		assertTrue( range(v[1],v[2],v[3]):overlap(-10..10) )
	end
	for _,v in ipairs(values.empty) do
		assertFalse( range(v[1],v[2],v[3]):overlap(-10..10) )
	end

	for _,v in ipairs(values.zeros) do
		assertFalse( range(v[1],v[2],v[3]):overlap(2..10) )
		assertTrue ( range(v[1],v[2],v[3]):overlap(0..1)  )
	end

	for _,v in ipairs(values.nzeros) do
		assertTrue( nrange(v[1],v[2],v[3]):overlap(1..10) )
	end

	assertTrue ( (1..10):overlap( nrange(1,10,10)  ) )
	assertTrue ( (1..10):overlap( nrange(10,-1,10) ) )
end

function TestRange:testIrange()
	local msg = {
		"invalid argument #1 (number expected)",
		"cannot convert 'string' to 'double'",
	}
	assertErrorMsgContains( msg[1], irange              )
	assertErrorMsgContains( msg[1], irange, ''          )
	assertErrorMsgContains( msg[1], irange, nil, 1      )
	assertErrorMsgContains( msg[2], irange, 1  , ''     )
	assertErrorMsgContains( msg[2], irange, 1  , 10, '' )

	local s, r, ir
	ir = {irange(1,10,1)}
	assertTrue( is_function(ir[1]) )
	assertTrue( is_range(ir[2])    )
	assertTrue( ir[3] == 0         )

	r = range( 1 )           for i,v in irange(1)              do  assertEquals(r[i], v) end
	r = range( 1  , 5 )      for i,v in irange(1  , 5 )        do  assertEquals(r[i], v) end
	r = range( 1  , 10, 2  ) for i,v in irange(1  , 10, 2  )   do  assertEquals(r[i], v) end
	r = range( 0.5, 0 ,-0.1) for i,v in irange(0.5, 0 ,-0.1)   do  assertEquals(r[i], v) end
	r = range( 10 ,-1 ,-0.7) for i,v in irange(10 ,-1 ,-0.7)   do  assertEquals(r[i], v) end
	r = range( 1  , 10, nil) for i,v in irange( 1 , 10, nil)   do  assertEquals(r[i], v) end

	for _,v in ipairs(values.rng) do
		r = range(v[1],v[2],v[3]) for i,v in irange(v[1],v[2],v[3]) do assertEquals(r[i], v) end
	end

  r,s = range( nan, nan, nan),0 for i,v in irange( nan, nan, nan) do s=s+1 ; assertEquals(s, 0) end
	r,s = range(-nan,-nan,-nan),0 for i,v in irange(-nan,-nan,-nan) do s=s+1 ; assertEquals(s, 0) end
	r,s = range( 1, nan, nan)  ,0 for i,v in irange( 1, nan, nan)   do s=s+1 ; assertEquals(s, 0) end
	r,s = range( 1,-nan,-nan)  ,0 for i,v in irange( 1,-nan,-nan)   do s=s+1 ; assertEquals(s, 0) end
	r,s = range( 1, 10 , nan)  ,0 for i,v in irange( 1, 10 , nan)   do s=s+1 ; assertEquals(s, 0) end
	r,s = range( 1, 10 ,-nan)  ,0 for i,v in irange( 1, 10 ,-nan)   do s=s+1 ; assertEquals(s, 0) end
	r,s = range( 1, 10,  inf)  ,0 for i,v in irange( 1, 10,  inf)   do s=s+1 ; assertEquals(s, 0) end
	r,s = range( 1, 10, -inf)  ,0 for i,v in irange( 1, 10, -inf)   do s=s+1 ; assertEquals(s, 0) end
	r,s = range( 1, 10, huge)  ,0 for i,v in irange( 1, 10, huge)   do s=s+1 ; assertEquals(s, 1) end
	r,s = range( 1, 10,-huge)  ,0 for i,v in irange( 1, 10,-huge)   do s=s+1 ; assertEquals(s, 0) end

	for _,v in ipairs(values.empty) do
		r,s = range(v[1],v[2],v[3]),0 for i,v in irange(v[1],v[2],v[3]) do s=s+1; assertEquals(s, 0) end
	end
end

-- performance test suite -----------------------------------------------------o

Test_Range = {}

function Test_Range:testIrange()
	local s = 4e-8
	local r = 0..s..eps
	local t0 = os.clock()
	for i,v in irange(0,s,eps) do assert(r[i], v) end
	local dt = os.clock() - t0
	assertAlmostEquals( dt, 0.5, 1 )
end

function Test_Range:testGet()
	local s = 4e-8
	local res = 0..s..eps
	local ref = nrange(0, s, 180143986)
	local t0 = os.clock()
	for i=1,#res do	assertAlmostEquals(res:get(i-1) - ref:get(i-1), 0, eps) end
	local dt = os.clock() - t0
	assertAlmostEquals( dt, 0.5, 1 )
end

function Test_Range:testIndex()
	local s = 4e-8
	local res = 0..s..eps
	local ref = nrange(0, s, 180143986)
	local t0 = os.clock()
	for i=1,#res do	assertAlmostEquals(res[i] - ref[i], 0, eps) end
	local dt = os.clock() - t0
	assertAlmostEquals( dt, 0.5, 1 )
end

-- end ------------------------------------------------------------------------o
