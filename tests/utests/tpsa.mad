--[=[
 o-----------------------------------------------------------------------------o
 |
 | GTPSA module regression tests - real tpsa
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the tpsa module.

 o-----------------------------------------------------------------------------o
]=]

local vector, tpsa, gtpsad                                       in MAD
local eps, abs, pi                                               in MAD.constant
local abs                                                        in MAD.gmath
local ident                                                      in MAD.gfunc
local assertTrue, assertEquals, assertAlmostEquals               in MAD.utest

-- locals ---------------------------------------------------------------------o

local dat = assert(loadfile('data/tpsa.dat'))()
local dat2Var = assert(loadfile('data/2VarTPSA.dat'))()
local dat3Var = assert(loadfile('data/3VarTPSA.dat'))()
local dat4Var = assert(loadfile('data/4VarTPSA.dat'))()
local dat5Var = assert(loadfile('data/5VarTPSA.dat'))()

local ord = {1,2,3,4,5,6,7,10,12,15}
local ordNVar = {1,2,3,4,5,6}

-- regression test suites -----------------------------------------------------o

TestTPSAFun = {}

local function checkVal (r, c, neg, alt, trc)
  local tol = neg and c.n_eps or alt and c.a_eps or c.eps or eps
  neg = neg or ident
  trc = trc or 0
  if not r:isvalid() then r:debug() end
  for i=1,#r do
    local v = neg(c[i],i)
    if trc > 0 then
      local is, vs, rs, es = string.format("%-2d"  , i),
                             string.format("%+.17e", v),
                             string.format("%+.17e", r:get(i))
      if abs(v) > 2
      then es = math.ceil( abs(r:get(i)/v-1)/eps/i )
      else es = math.ceil( abs(r:get(i)-v  )/eps/i )
      end
      io.write('i=',is,', v=',vs,', r=',rs,', es=', es, es>99 and ' **\n' or '\n')
    end
    if trc < 2 then
      if abs(v) > 2
      then assertAlmostEquals(r:get(i)/v-1, 0, i*tol)
      else assertAlmostEquals(r:get(i)    , v, i*tol)
      end
    end
  end
end

local function checkFunXY(singleVarFnam, trc) 
  local d = gtpsad(2,6)
  local a = 0 --sets c = 0
  local multiVarFnams = {"axpbypc", "axypb"}
  for _, multiVarFnam in ipairs(multiVarFnams) do
    local fun, r, x, y, z = dat2Var[multiVarFnam .. "fun"][singleVarFnam]
    for _,c in ipairs(fun) do
      for _,o in ipairs(ordNVar) do
        x = tpsa(o):set(1,c.x0):set(2,1)
        y = tpsa(o):set(1,c.y0):set(3,1) --0 0 -> 1 0 -> 0 1 ...
        z = x[multiVarFnam](x, y, 1, 1, a) --Best way?
        r = z[singleVarFnam](z)  ; checkVal(r, c, nil, nil, trc) -- positive (r ~= t)
        r = z[singleVarFnam](z,z) ; checkVal(r, c, nil, nil, trc) -- aliased  (r == t)
      end
    end
    a = nil -- removes the last input for z; saves like 10 lines of code
  end
end

local function checkFun1 (fnam, trc)
  local d = gtpsad(1,15)
  local fun, t, r = dat.fun[fnam]
  if trc then io.write('\n') end
  for _,c in ipairs(fun) do
  for _,o in ipairs(ord) do
--  for o=1,d.mo do
    if fun.omin and o < fun.omin then break end -- limit order
    if fun.omax and o > fun.omax then break end -- limit order
    if c.omin   and o < c.omin   then break end -- limit order (local)
    if c.omax   and o > c.omax   then break end -- limit order (local)
    if trc then io.write('f=',fnam,'(',c.x0,') @ ',o,'\n') end
    t = tpsa(o):set(1,c.x0):set(2,1)
    r = t[fnam](t)   ; checkVal(r, c, nil, nil, trc) -- positive (r ~= t)
    if trc then io.write('f=',fnam,'_ref(',c.x0,') @ ',o,'\n') end
    r = t[fnam](t,t) ; checkVal(r, c, nil, nil, trc) -- aliased  (r == t)

    if fun.alt then
      if trc then io.write('f=',fnam,'_alt(',c.x0,') @ ',o,'\n') end
      t = tpsa(o):set(1,c.x0):set(2,1)
      r = fun.alt(t) ; checkVal(r, c, nil, fun.alt, trc) -- alternate function
    end

    if fun.neg and c.x0 ~= 0 then
      if trc then io.write('f=',fnam,'_neg(',-c.x0,') @ ',o,'\n') end
      t = tpsa(o):set(1,-c.x0):set(2,1)
      r = t[fnam](t) ; checkVal(r, c, fun.neg, nil, trc) -- negative
    end
  end end
end

local function checkFun3Var(singleVarFnam, trc) 
  local d = gtpsad(3,5)
  local multiVarFnams = {"axyzpb", "axypbzpc", "axpbypcz"}
  for _, multiVarFnam in ipairs(multiVarFnams) do
    local fun, r, s, x, y, z = dat3Var[multiVarFnam .. "fun"][singleVarFnam]
    for _,c in ipairs(fun) do
      for _,o in ipairs(ordNVar) do
        x = tpsa(o):set(1,c.x0):set(2,1)
        y = tpsa(o):set(1,c.y0):set(3,1) 
        z = tpsa(o):set(1,c.z0):set(4,1) --0 0 0 -> 1 0 0 -> 0 1 0 -> 0 0 1...
        if multiVarFnam == "axyzpb" then
          s = x:axypb(y, 1, 0)
          s = s:axypb(z, 1, 1)
        elseif multiVarFnam == "axpbypcz" then
          s = x:axpbypc(y, 1, 1, 0)
          s = s:axpbypc(z, 1, 1, 0)
        else
          s = x[multiVarFnam](x, y, z, 1, 1, 1) -- a = b = c = 1
        end
        r = s[singleVarFnam](s)  ; checkVal(r, c, nil, nil, trc) -- positive (r ~= t)
        r = s[singleVarFnam](s,s) ; checkVal(r, c, nil, nil, trc) -- aliased  (r == t)
      end
    end
  end
end

local function checkFun4Var(singleVarFnam, trc) 
  local d = gtpsad(4,5)
  local multiVarFnams = {"axypbvwpc", "avwxypb", "avpbwpcxpdy"}
  for _, multiVarFnam in ipairs(multiVarFnams) do
    local fun, r, s, v, w, x, y = dat4Var[multiVarFnam .. "fun"][singleVarFnam]
    for _,c in ipairs(fun) do
      for _,o in ipairs(ordNVar) do
        v = tpsa(o):set(1,c.v0):set(2,1)
        w = tpsa(o):set(1,c.w0):set(3,1) 
        x = tpsa(o):set(1,c.x0):set(4,1)
        y = tpsa(o):set(1,c.y0):set(5,1) --0 0 0 0 -> 1 0 0 0 -> 0 1 0 0 -> 0 0 1 0 -> 0 0 0 1...
        if multiVarFnam == "avwxypb" then
          s = v:axypb(w, 1, 0) -- s = v * w
          s = s:axypb(x, 1, 0) -- s = v * w * x
          s = s:axypb(y, 1, 1) -- s = v * w * y + 1
        elseif multiVarFnam == "avpbwpcxpdy" then
          s = v:axpbypc(w, 1, 1, 0) -- s = v + w
          s = s:axpbypc(x, 1, 1, 0) -- s = v + w + x
          s = s:axpbypc(y, 1, 1, 0) -- s = v + w + x + y
        else
          s = v[multiVarFnam](v, w, x, y, 1, 1, 1) -- a = b = 1
        end
        r = s[singleVarFnam](s)  ; checkVal(r, c, nil, nil, trc) -- positive (r ~= t)
        r = s[singleVarFnam](s,s) ; checkVal(r, c, nil, nil, trc) -- aliased  (r == t)
      end
    end
  end
end

local function checkFun5Var(singleVarFnam, trc) 
  local d = gtpsad(5,5)
  local multiVarFnams = {"avpbwpcxpdypez", "avwpbxypcz", "avwxyzpb"}
  for _, multiVarFnam in ipairs(multiVarFnams) do
    local fun, r, s, t, v, w, x, y, z = dat5Var[multiVarFnam .. "fun"][singleVarFnam]
    for _,c in ipairs(fun) do
      for _,o in ipairs(ordNVar) do
        v = tpsa(o):set(1,c.v0):set(2,1)
        w = tpsa(o):set(1,c.w0):set(3,1) 
        x = tpsa(o):set(1,c.x0):set(4,1)
        y = tpsa(o):set(1,c.y0):set(5,1) 
        z = tpsa(o):set(1,c.z0):set(6,1) --0 0 0 0 0-> 1 0 0 0 0 -> 0 1 0 0 0 -> 0 0 1 0 0 ...
        if multiVarFnam == "avpbwpcxpdypez" then
          s = v:axpbypc(w, 1, 1, 0) -- s = v + w
          s = s:axpbypc(x, 1, 1, 0) -- s = v + w + x
          s = s:axpbypc(y, 1, 1, 0) -- s = v + w + x + y
          s = s:axpbypc(z, 1, 1, 0) -- s = v + w + x + y + z
        elseif multiVarFnam == "avwpbxypcz" then
          s = v:axypb(w, 1, 0) -- s = v * w
          t = x:axypb(y, 1, 0) -- t = x * y
          s = s:axpbypc(t, 1, 1, 0) -- s =  v * w + x * y
          s = s:axpbypc(z, 1, 1, 0) -- s = v * w + x * y + z
        else
          s = v:axypb(w, 1, 0) -- s = v * w
          s = s:axypb(x, 1, 0) -- s = v * w * x
          s = s:axypb(y, 1, 0) -- s = v * w * x * y
          s = s:axypb(z, 1, 1) -- s = v * w * x * y * z + 1
        end
        r = s[singleVarFnam](s)  ; checkVal(r, c, nil, nil, trc) -- positive (r ~= t)
        r = s[singleVarFnam](s,s) ; checkVal(r, c, nil, nil, trc) -- aliased  (r == t)
      end
    end
  end
end

TestTPSAFun.testInv   = \s -> checkFun1('inv')
TestTPSAFun.testISqrt = \s -> checkFun1('invsqrt')
TestTPSAFun.testSqrt  = \s -> checkFun1('sqrt')
TestTPSAFun.testExp   = \s -> checkFun1('exp')
TestTPSAFun.testLog   = \s -> checkFun1('log')
TestTPSAFun.testSin   = \s -> checkFun1('sin')
TestTPSAFun.testCos   = \s -> checkFun1('cos')
TestTPSAFun.testTan   = \s -> checkFun1('tan')
TestTPSAFun.testCot   = \s -> checkFun1('cot')
TestTPSAFun.testSinc  = \s -> checkFun1('sinc')
TestTPSAFun.testSinh  = \s -> checkFun1('sinh')
TestTPSAFun.testCosh  = \s -> checkFun1('cosh')
TestTPSAFun.testTanh  = \s -> checkFun1('tanh')
TestTPSAFun.testCoth  = \s -> checkFun1('coth')
!TestTPSAFun.testSinhc = \s -> checkFun1('sinhc')
TestTPSAFun.testAsin  = \s -> checkFun1('asin')
TestTPSAFun.testAcos  = \s -> checkFun1('acos')
TestTPSAFun.testAtan  = \s -> checkFun1('atan')
TestTPSAFun.testAcot  = \s -> checkFun1('acot')
TestTPSAFun.testAsinh = \s -> checkFun1('asinh')
TestTPSAFun.testAcosh = \s -> checkFun1('acosh')
TestTPSAFun.testAtanh = \s -> checkFun1('atanh')
TestTPSAFun.testAcoth = \s -> checkFun1('acoth')
TestTPSAFun.testErf   = \s -> checkFun1('erf')
                                                              --eps = [avpbwpcxpdypez, avwpbxypcz, avwxyzpb]
TestTPSAFun.testInv5Var   = \s -> checkFun5Var('inv')         --eps = [1             , 2         , 4       ]
TestTPSAFun.testISqrt5Var = \s -> checkFun5Var('invsqrt')     --eps = [1             , 2         , 10       ]
TestTPSAFun.testSqrt5Var  = \s -> checkFun5Var('sqrt')        --eps = [1             , 1         , 2       ]
TestTPSAFun.testExp5Var   = \s -> checkFun5Var('exp')         --eps = [22            , 31        , 132      ]
TestTPSAFun.testLog5Var   = \s -> checkFun5Var('log')         --eps = [1             , 1         , 8       ]

TestTPSAFun.testInvXY   = \s -> checkFunXY("inv")     -- 1    * eps
TestTPSAFun.testISqrtXY = \s -> checkFunXY('invsqrt') -- 6    * eps
TestTPSAFun.testSqrtXY  = \s -> checkFunXY('sqrt')    -- 1    * eps
TestTPSAFun.testExpXY   = \s -> checkFunXY('exp')     -- 26   * eps
TestTPSAFun.testLogXY   = \s -> checkFunXY('log')     -- 1    * eps
TestTPSAFun.testSinXY   = \s -> checkFunXY('sin')     -- 170  * eps
TestTPSAFun.testCosXY   = \s -> checkFunXY('cos')     -- 115  * eps
TestTPSAFun.testTanXY   = \s -> checkFunXY('tan')     -- 23   * eps

TestTPSAFun.testInv3Var   = \s -> checkFun3Var('inv')     --4   *eps (axyz + b)
TestTPSAFun.testISqrt3Var = \s -> checkFun3Var('invsqrt') --1   *eps
TestTPSAFun.testSqrt3Var  = \s -> checkFun3Var('sqrt')    --2   *eps (axyz + b)
TestTPSAFun.testExp3Var   = \s -> checkFun3Var('exp')     --135 *eps (axyz + b); 18 * eps (axy + bz + c); 9 * eps (ax + by + cz)
TestTPSAFun.testLog3Var   = \s -> checkFun3Var('log')     --8   *eps (axyz + b)
TestTPSAFun.testSin3Var   = \s -> checkFun3Var('sin')     --3700*eps (axyz + b); 100* eps (axy + bz + c); 8 * eps (ax + by + cz)
TestTPSAFun.testCos3Var   = \s -> checkFun3Var('cos')     --695 *eps (axyz + b); 160* eps (axy + bz + c); 8 * eps (ax + by + cz)
TestTPSAFun.testTan3Var   = \s -> checkFun3Var('tan')     --345 *eps (axyz + b); 40 * eps (axy + bz + c); 34* eps (ax + by + cz)
TestTPSAFun.testInv4Var   = \s -> checkFun4Var('inv')     -- 2 * eps (avwxypb)
TestTPSAFun.testISqrt4Var = \s -> checkFun4Var('invsqrt') -- 4 * eps (avwxypb)
TestTPSAFun.testSqrt4Var  = \s -> checkFun4Var('sqrt')    -- 2 * eps (avwxypb)
TestTPSAFun.testExp4Var   = \s -> checkFun4Var('exp')     --28 * eps (axypbvwpc)      64 * eps (avwxypb)      16 * eps (avpbwpcxpdy)
TestTPSAFun.testLog4Var   = \s -> checkFun4Var('log')     -- 4 * eps (avwxypb)

-- TODO: operators

-- performance tests ----------------------------------------------------------o

Test_TPSAFun = {}

local ord_ = {1,2,3,6,7}
local div_ = 5 -- shrink the tests by factor 5

local function benchFun1 (fnam, x0, trc)
  local d = gtpsad(6,15)
  local fun, t, r = dat.fun[fnam]
  for _,o in ipairs(ord_) do
--  for o=1,d.mo do
    if fun.omin and o < fun.omin then break end -- limit order
    if fun.omax and o > fun.omax then break end -- limit order
    t = tpsa(o):setvar(x0):set(2,1):set(3,1):set(4,1):set(5,1):set(6,1):set(7,1)
    r = tpsa(o)
    if not trc then io.write(o," ") io.flush() end
    local t0 = os.clock()
    for i=1,fun.iter[o]/div_ do t[fnam](t,r) end
    local dt = os.clock()-t0
    assertAlmostEquals( dt, 0.5/div_, 1/div_ )
    if trc then
      local n = math.floor(0.5*fun.iter[o]/dt)
      io.write(string.format("\no=%-2d, dt=%.4f, n=%-8d, ", o, dt, n),
               "len=", t:length(o), "  ")
    end
  end
end

Test_TPSAFun.testInv   = \s -> benchFun1('inv'    , pi/5)
Test_TPSAFun.testSqrt  = \s -> benchFun1('sqrt'   , pi/5)
Test_TPSAFun.testExp   = \s -> benchFun1('exp'    , pi/5)
Test_TPSAFun.testLog   = \s -> benchFun1('log'    , pi/3)
Test_TPSAFun.testSin   = \s -> benchFun1('sin'    , pi/5)
Test_TPSAFun.testCos   = \s -> benchFun1('cos'    , pi/5)
Test_TPSAFun.testTan   = \s -> benchFun1('tan'    , pi/5)
Test_TPSAFun.testISqrt = \s -> benchFun1('invsqrt', pi/5)

-- end ------------------------------------------------------------------------o


