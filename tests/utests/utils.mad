--[=[
 o-----------------------------------------------------------------------------o
 |
 | Utils regression tests
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the utils module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertNil, assertNotNil, assertTrue, assertFalse, assertEquals,
      assertErrorMsgContains in require 'luaunit'

local is_nil, is_boolean, is_number, is_string, is_function, is_table,
      is_cdata, is_complex, is_xrange, is_inf, is_nan, is_integer, is_scalar,
      is_rawtable, is_metaname, is_iterable, is_indexable, is_callable,
      is_comparable, is_ordered, is_concatable, is_stringable,
      ident, forget, first, second, swap, rep, compose, compose_bottom,
      option, tostring, getmetatable in MAD

local sm, gm = setmetatable, getmetatable

-- regression test suite ------------------------------------------------------o

TestUtils = {}

local types = {
['nil']      = { nil, __, ___ },
  boolean    = { false, true, 1==1, 0<1, 1<0 },
  number     = { 0.1, 0.01, -0.1, -0.01, 2^-32, 2^-53, 2^52+1, -2^52-1 },
  string     = { '', '""', "''", "\"", '\'', '0', 'inf', 'nan', 'false' },
['function'] = { \ (), \ false, \ 0, \ '0', \\ (), \{}, \\{}, \ 0..0, \ 0i },
  table      = { {}, {false}, {0}, {'0'}, {\ ()}, {{}}, {\{}}, {0..0}, {0i} },
  xrange     = { 0..0, 0..0.1, 0.1..0, 1..2..0.1, -0.2..-0.1..0.1 },
  complex    = { 0i, 1i, 10i, 0.1i, -0i, -1i, -10i, -0.1i },
  integer    = { 0, 1, 2^32, 2^52, -0, -1, -2^32, -2^52, 2^52+0.1 },
  inf        = { 1/0, -1/0, tonumber('inf'), tonumber('Inf'), tonumber('INF'),
             tonumber('Infinity'), tonumber('infinity'), tonumber('INFINITY') },
  nan        = { 0/0, 1/0*0, (1/0)/(1/0), 1/0-1/0, 1/0+-1/0,
                 tonumber('nan'), tonumber('NaN') },
}

local function assertTypes (tkey, tfunc, tskip)
  tkey = is_string(tkey) and {tkey} or tkey
  tskip = is_nil(tskip) and {} or tskip
  for _,s in ipairs(tkey) do
    tkey[s] = assertTrue
  end
  for k,t in pairs(types) do
    if is_nil(tskip[k]) then
      for i,v in ipairs(t) do
        if tfunc(v) ~= (tkey[k] and true or false) then
          print(k,i,v,tfunc(v)) ! uncomment to find the faulty case
        end
        (tkey[k] or assertFalse) ( tfunc(v) )
      end
    end
  end
end

function TestUtils:testIsNil()
  assertTypes( 'nil', is_nil )
end

function TestUtils:testIsBoolean()
  assertTypes( 'boolean', is_boolean )
end

function TestUtils:testIsNumber()
  assertTypes( {'number', 'integer', 'inf', 'nan'}, is_number )
end

function TestUtils:testIsNumber2()
  local t = {'nil', 'number', 'complex', 'integer', 'inf', 'nan'}
  local f = compose(is_number, tonumber)
  assertTypes( t, f, {string=true} )

  assertFalse( f(types.string[1]) )
  assertFalse( f(types.string[2]) )
  assertFalse( f(types.string[3]) )
  assertFalse( f(types.string[4]) )
  assertFalse( f(types.string[5]) )
  assertTrue ( f(types.string[6]) )
  assertTrue ( f(types.string[7]) )
  assertTrue ( f(types.string[8]) )
  assertFalse( f(types.string[9]) )
end

function TestUtils:testIsString()
  assertTypes( 'string', is_string )
end

function TestUtils:testIsString2()
  local t = {} ; for k in pairs(types) do t[#t+1] = k end
  assertTypes( t, compose(is_string, tostring) )
end

function TestUtils:testIsFunction()
  assertTypes( 'function', is_function )
end

function TestUtils:testIsTable()
  assertTypes( 'table', is_table )
end

function TestUtils:testIsCData()
  assertTypes( {'complex', 'xrange'}, is_cdata )
end

function TestUtils:testIsComplex()
  assertTypes( 'complex', is_complex )
end

function TestUtils:testIsXRange()
  assertTypes( 'xrange', is_xrange )
end

function TestUtils:testIsInf()
  assertTypes( 'inf', is_inf )
  assertTrue ( is_inf( 1/0 ) )
  assertTrue ( is_inf(-1/0 ) )
  assertFalse( is_inf('inf') )
  assertFalse( is_inf('Inf') )
  assertFalse( is_inf('inf'*0) )
  assertFalse( is_inf('Inf'*0) )
  assertTrue ( is_inf('inf'/0) )
  assertTrue ( is_inf('Inf'/0) )
end

function TestUtils:testIsNan()
  assertTypes( 'nan', is_nan )
  assertFalse( is_nan( 1/0 ) )
  assertFalse( is_nan(-1/0 ) )
  assertFalse( is_nan('nan') )
  assertFalse( is_nan('NaN') )
  assertTrue ( is_nan('nan'*0) )
  assertTrue ( is_nan('NaN'*0) )
  assertTrue ( is_nan('nan'/0) )
  assertTrue ( is_nan('NaN'/0) )
end

function TestUtils:testIsInteger()
  assertTypes( 'integer', is_integer )
end

function TestUtils:testIsScalar()
  assertTypes( {'number', 'complex', 'integer', 'inf', 'nan'}, is_scalar )
end

function TestUtils:testIsRawtable()
  assertTypes( 'table', is_rawtable )
  assertFalse( is_rawtable(sm({},{})) )
end

function TestUtils:testIsMetaname()
  local meta = {
    '__add', '__call', '__concat', '__div', '__eq', '__gc', '__index', '__init',
    '__ipairs', '__le', '__len', '__lt', '__metatable', '__mod', '__mode',
    '__mul', '__new', '__newindex', '__pairs', '__pow', '__sub', '__tostring',
    '__unm',
  }
  for _,s in ipairs(meta) do
    assertTrue( is_metaname(s) )
  end
  for _,s in ipairs(meta) do
    assertFalse( is_metaname(s:sub(3)) )
  end
end

function TestUtils:testIsIterable()
  assertTypes( {'table', 'xrange'}, is_iterable )
  assertTrue ( is_iterable(sm({},{})) ) ! fake: tables are always iterable
  assertTrue ( is_iterable(sm({},{__ipair:=()})) )
  assertTrue ( is_iterable(sm({},{__pairs:=()})) )
end

function TestUtils:testIndexable()
  assertTypes( {'string', 'table', 'complex', 'xrange'}, is_indexable )
  assertTrue ( is_indexable(sm({},{})) ) ! fake: tables are always indexable
  assertTrue ( is_indexable(sm({},{__index:=()})) )
  assertTrue ( is_indexable(sm({},{__newindex:=()})) )
end

function TestUtils:testIsCallable()
  assertTypes( {'function'}, is_callable )
  assertFalse( is_callable(sm({},{})) )
  assertTrue ( is_callable(sm({},{__call:=()})) )
end

function TestUtils:testIsComparable()
  assertTypes( {'number','string','complex','xrange','integer','inf','nan'},
               is_comparable )
  assertFalse( is_comparable(sm({},{})) )
  assertTrue ( is_comparable(sm({},{__eq:=()})) )
end

function TestUtils:testIsOrdered()
  assertTypes( {'number', 'string', 'integer', 'inf', 'nan'}, is_ordered )
  assertFalse( is_ordered(sm({},{})) )
  assertTrue ( is_ordered(sm({},{__lt:=()})) )
  assertTrue ( is_ordered(sm({},{__le:=()})) )
end

function TestUtils:testIsConcatenable()
  assertTypes( 'string', is_concatable )
  assertFalse( is_concatable(sm({},{})) )
  assertTrue ( is_concatable(sm({},{__concat:=()})) )
end

function TestUtils:testIsStringable()
  assertTypes( 'complex', is_stringable )
  assertFalse( is_stringable(sm({},{})) )
  assertTrue ( is_stringable(sm({},{__tostring:=()})) )
end

function TestUtils:testIdent()
  local f=\ (1,2,3)
  assertEquals( ident(1)     , 1     )
  assertEquals( ident(1,nil) , 1     )
  assertEquals({ident(nil,1)}, {nil,1} )
  assertEquals( ident(1,2)   , 1,2   )
  assertEquals( ident(1,2,3) , 1,2,3 )
  assertEquals( ident(f())   , 1,2,3 )
end

function TestUtils:testForget()
  local f=\ (1,2,3)
  assertNil( forget(1)     )
  assertNil( forget(1,nil) )
  assertNil( forget(nil,1) )
  assertNil( forget(1,2)   )
  assertNil( forget(1,2,3) )
  assertNil( forget(f())   )
end

function TestUtils:testFirst()
  local f=\ (1,2,3)
  assertEquals( first(1)    , 1   )
  assertEquals( first(1,nil), 1   )
  assertEquals( first(nil,1), nil )
  assertEquals( first(1,2)  , 1   )
  assertEquals( first(1,2,3), 1   )
  assertEquals( first(f())  , 1   )
end

function TestUtils:testSecond()
  local f=\ (1,2,3)
  assertEquals( second(1)    , nil )
  assertEquals( second(1,nil), nil )
  assertEquals( second(nil,1), 1   )
  assertEquals( second(1,2)  , 2   )
  assertEquals( second(1,2,3), 2   )
  assertEquals( second(f())  , 2   )
end

function TestUtils:testSwap()
  local f=\ (1,2,3)
  assertEquals( {swap(1)}    , {nil,1} )
  assertEquals( {swap(nil,1)}, {1}     )
  assertEquals( {swap(1,2)}  , {2,1} )
  assertEquals( {swap(1,2,3)}, {2,1} )
  assertEquals( {swap(f())}  , {2,1} )
end

function TestUtils:testRep()
  local msg = {
    "invalid argument #2 (size or nil expected)",
  }

  assertEquals( #rep(9), 2^31 )
  assertEquals(  rep(9)[1], 9 )
  assertEquals(  rep(9)[1e9], 9 )
  assertEquals(  rep(9)[-1], 9 )
  assertEquals(  rep(9)[nil], 9 )

  assertErrorMsgContains(msg[1], rep, 9, -1)
  assertEquals( rep(9,0), {} )
  assertEquals( rep(9,1), {9} )
  assertEquals( rep(9,2), {9,9} )
  assertEquals( rep(9,3), {9,9,9} )

  assertEquals( #rep(9,0), 0 )
  assertEquals( #rep(9,3), 3 )
  assertEquals( #rep(9,500), 500 )
  assertEquals( #rep(9,1e9), 1e9 )

  assertEquals( rep(9,  1)[ 1] , 9 )
  assertEquals( rep(9,500)[500], 9 )
  assertNil   ( rep(9,1e9)[-1] )
  assertNil   ( rep(9,1e9)[ 0] )
  assertEquals( rep(9,1e9)[ 1] , 9 )
  assertEquals( rep(9,1e9)[1e9], 9 )
  assertNil   ( rep(9,1e9)[1e9+1]  )

  for _,v in ipairs(rep(3,10)) do assertEquals( v, 3 ) end
  for _,v in  pairs(rep(3,10)) do assertEquals( v, 3 ) end

  local a
  a=rep(3)    for i=1,10 do assertEquals( a[i], 3 ) end
  a=rep(3,10) for i=1,#a do assertEquals( a[i], 3 ) end
end

function TestUtils:testCompose()
  local id, id1, id4 = \n,...(n+1,...), \...(1,...), \n n==4
  local f = compose(id4,compose(id,compose(id,compose(id,id1))))
  local t = {} ; for k in pairs(types) do t[#t+1] = k end
  assertTypes( t, f )
end

function TestUtils:testComposeBottom()
  local id, id1, id4, _ = \n,...(n+1,...), \...(1,...), \n n==4, compose_bottom
  local f = id4^id^id^id^id1^_
  local t = {} ; for k in pairs(types) do t[#t+1] = k end
  assertTypes( t, f )
end

function TestUtils:testOptionFormat()
  local format = option.format
  option.format = '%.10f'
  assertEquals ( tostring(1/3 ),  '0.3333333333')
  assertEquals ( tostring(1/3i), '-0.3333333333i')
  option.format = '%.13f'
  assertEquals ( tostring(1/3 ),  '0.3333333333333')
  assertEquals ( tostring(1/3i), '-0.3333333333333i')
  option.format = '%-2.4e'
  assertEquals ( tostring(1/(0.5+3i)), '5.4054e-02-3.2432e-01i')
  assertEquals ( tostring(0.5+ 1/3i ), '5.0000e-01-3.3333e-01i')
  option.format = format
end

function TestUtils:testGetmetatable()
  local t = {
    'nil', 'boolean', 'number', 'function', 'table', 'integer', 'inf', 'nan'
  }
  assertTypes( t, compose(is_nil, gm) )
  assertTypes( {'string', 'complex', 'xrange'}, \a gm(a)~=nil )
  assertTypes( 'complex', \a gm(a)==gm(0i) )
  assertTypes( 'xrange' , \a gm(a)==gm(0..0) )
end

-- end ------------------------------------------------------------------------o
