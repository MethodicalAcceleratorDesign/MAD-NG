--[=[
 o-----------------------------------------------------------------------------o
 |
 | Gmath regression tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: A.Z. Teska, aleksandra.teska at cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the gmath module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertFalse, assertTrue, assertEquals, assertNotEquals,
      assertAlmostEquals, assertNaN, assertAllAlmostEquals, assertInf in MAD.utest

local tonumber = tonumber

local ceil, floor, frac, trunc, round, abs, sqrt,  -- (generic functions)
      sin, cos, tan, asin, acos, atan, sinh, cosh, tanh, acosh,
      asinh, atanh, exp, log, log10, erf, erfc, erfi, erfcx, tgamma, lgamma,
      cot, coth, acot, acoth,
      sinhc, asinc, asinhc, invsqrt, hypot, hypot3, wf, erfi, erfcx, dawson,
      atan2, powi, fact,-- (non-generic functions)
      sign, sign1, step, step1, sinc,
      carg, real, imag, conj, proj, rect, polar, cplx, cabs,
      reim, -- (generic complex functions)
      unit, --(non-generic complex functions)
      rangle, cord2arc, arc2cord, len2cord, cord2len, len2arc, arc2len,
      sumsqr, sumabs, minabs, maxabs, sumsqrl, sumabsl,
      minabsl, maxabsl, sumsqrr, sumabsr, minabsr, maxabsr,
      randnew, xrandnew, randset, randseed, rand, randi, randn, randtn, randp in MAD.gmath   -- extra functions that relies on gmath itself
  
local deg, fmod, max, min, modf, frexp, rad, ldexp, rad, deg, randomseed, random in math

local tostring, complex, matrix, totable     in MAD
local strtrim                                in MAD.utility
local is_nan                                 in MAD.typeid
local eps, huge, tiny, inf, nan, pi          in MAD.constant
local unm, add, sub, mul, div, mod, pow, inv,
      sqr, eq, ne, lt, le, gt, ge, first,
      second, emul, ediv, emod, epow         in MAD.gfunc  -- (operators as functions)

local infi = MAD.complex(0,inf)

-- regression test suite ------------------------------------------------------o

TestGmath = {}

local values = {
  num  = {0, tiny, 2^-64, 2^-63, 2^-53, eps, 2^-52, 2*eps, 2^-32, 2^-31, 1e-9,
          0.1-eps, 0.1, 0.1+eps, 0.5, 0.7-eps, 0.7, 0.7+eps, 1-eps, 1, 1+eps,
          1.1, 1.7, 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53,
          2^63, 2^64, huge, inf},
  rad  = {0, eps, 2*eps, pi/180, pi/90, pi/36, pi/18, pi/12, pi/6, pi/4, pi/3, pi/2,
          pi-pi/3, pi-pi/4, pi-pi/6, pi-pi/12, pi},
  rad2 = {0, eps, 2*eps, pi/180, pi/90, pi/36, pi/18, pi/12, pi/6, pi/4, pi/3, pi/2},

  deg  = {0, eps, 2*eps, 1, 2, 5, 10, 15, 30, 45, 60, 90,
          120, 135, 150, 165, 180},
  deg2 = {0, eps, 2*eps, 1, 2, 5, 10, 15, 30, 45, 60, 90},
}

-- keep the order of the import above

-- constant

function TestGmath:testConstant()
  assertEquals(  pi , 3.1415926535897932385 )
  assertEquals(  pi , atan(1)*4 )

  assertNotEquals(  tiny,  2.2250738585072011e-308 )
  assertEquals   (  tiny,  2.2250738585072012e-308 ) -- reference
  assertEquals   (  tiny,  2.2250738585072013e-308 )
  assertEquals   (  tiny,  2.2250738585072014e-308 )
  assertEquals   (  tiny,  2.2250738585072015e-308 )
  assertEquals   (  tiny,  2.2250738585072016e-308 )
  assertNotEquals(  tiny,  2.2250738585072017e-308 )

  assertNotEquals( -tiny, -2.2250738585072011e-308 )
  assertEquals   ( -tiny, -2.2250738585072012e-308 )
  assertEquals   ( -tiny, -2.2250738585072013e-308 )
  assertEquals   ( -tiny, -2.2250738585072014e-308 )
  assertEquals   ( -tiny, -2.2250738585072015e-308 )
  assertEquals   ( -tiny, -2.2250738585072016e-308 )
  assertNotEquals( -tiny, -2.2250738585072017e-308 )

  assertNotEquals(  huge,  1.7976931348623156e+308 )
  assertEquals   (  huge,  1.7976931348623157e+308 )
  assertEquals   (  huge,  1.7976931348623158e+308 ) -- reference
  assertNotEquals(  huge,  1.7976931348623159e+308 )

  assertNotEquals( -huge, -1.7976931348623156e+308 )
  assertEquals   ( -huge, -1.7976931348623157e+308 )
  assertEquals   ( -huge, -1.7976931348623158e+308 )
  assertNotEquals( -huge, -1.7976931348623159e+308 )

  assertNotEquals(  eps ,  2.2204460492503129e-16  )
  assertEquals   (  eps ,  2.2204460492503130e-16  ) -- reference
  assertEquals   (  eps ,  2.2204460492503131e-16  )
  assertEquals   (  eps ,  2.2204460492503132e-16  )
  assertEquals   (  eps ,  2.2204460492503133e-16  )
  assertNotEquals(  eps ,  2.2204460492503134e-16  )

  assertNotEquals( -eps , -2.2204460492503129e-16  )
  assertEquals   ( -eps , -2.2204460492503130e-16  )
  assertEquals   ( -eps , -2.2204460492503131e-16  )
  assertEquals   ( -eps , -2.2204460492503132e-16  )
  assertEquals   ( -eps , -2.2204460492503133e-16  )
  assertNotEquals( -eps , -2.2204460492503134e-16  )

  assertEquals   ( imag( infi),  inf )
  assertEquals   ( imag(-infi), -inf )

  assertNaN      (  nan )
  assertNaN      ( -nan )

  assertFalse( is_nan( inf)  )
  assertFalse( is_nan(-inf)  )
  assertTrue ( is_nan( nan)  )
  assertTrue ( is_nan(-nan)  )
  assertFalse( is_nan('nan') )
  assertFalse( is_nan('NaN') )
end

function TestGmath:testCeil()
  assertEquals( ceil( tiny) ,     1 )
  assertEquals( ceil(  0.1) ,     1 )
  assertEquals( ceil(  0.5) ,     1 )
  assertEquals( ceil(  0.7) ,     1 )
  assertEquals( ceil(    1) ,     1 )
  assertEquals( ceil(  1.1) ,     2 )
  assertEquals( ceil(  1.5) ,     2 )
  assertEquals( ceil(  1.7) ,     2 )
  assertEquals( ceil( huge) ,  huge )
  assertEquals( ceil(-tiny) , -   0 )
  assertEquals( ceil(- 0.1) , -   0 )
  assertEquals( ceil(- 0.5) , -   0 )
  assertEquals( ceil(- 0.7) , -   0 )
  assertEquals( ceil(-   1) , -   1 )
  assertEquals( ceil(- 1.1) , -   1 )
  assertEquals( ceil(- 1.5) , -   1 )
  assertEquals( ceil(- 1.7) , -   1 )
  assertEquals( ceil(-huge) , -huge )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( 1/ceil(-  0 ) , -inf ) -- check for -0 :: jit(rand) -> inf [BUG]
  assertEquals( 1/ceil(   0 ) ,  inf ) -- check for +0
  assertEquals(   ceil(- inf) , -inf )
  assertEquals(   ceil(  inf) ,  inf )
  assertNaN   (   ceil(  nan) )
end

function TestGmath:testFloor()
  assertEquals( floor( tiny) ,     0 )
  assertEquals( floor(  0.1) ,     0 )
  assertEquals( floor(  0.5) ,     0 )
  assertEquals( floor(  0.7) ,     0 )
  assertEquals( floor(    1) ,     1 )
  assertEquals( floor(  1.1) ,     1 )
  assertEquals( floor(  1.5) ,     1 )
  assertEquals( floor(  1.7) ,     1 )
  assertEquals( floor( huge) ,  huge )
  assertEquals( floor(-tiny) , -   1 )
  assertEquals( floor(- 0.1) , -   1 )
  assertEquals( floor(- 0.5) , -   1 )
  assertEquals( floor(- 0.7) , -   1 )
  assertEquals( floor(-   1) , -   1 )
  assertEquals( floor(- 1.1) , -   2 )
  assertEquals( floor(- 1.5) , -   2 )
  assertEquals( floor(- 1.7) , -   2 )
  assertEquals( floor(-huge) , -huge )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( 1/floor(- 0 ) , -inf ) -- check for -0 :: jit(rand) -> inf [BUG]
  assertEquals( 1/floor(  0 ) ,  inf ) -- check for +0
  assertEquals(   floor(-inf) , -inf )
  assertEquals(   floor( inf) ,  inf )
  assertNaN   (   floor( nan) )
end

function TestGmath:testFrac()
  for _,v in ipairs(values.num) do
    if v == inf then break end -- pb, see below
    assertEquals( frac( v+eps), second(modf( v+eps)) )
    assertEquals( frac( v-eps), second(modf( v-eps)) )
    assertEquals( frac(-v+eps), second(modf(-v+eps)) )
    assertEquals( frac(-v-eps), second(modf(-v-eps)) )
    assertEquals( frac( v+0.1), second(modf( v+0.1)) )
    assertEquals( frac( v-0.1), second(modf( v-0.1)) )
    assertEquals( frac(-v+0.1), second(modf(-v+0.1)) )
    assertEquals( frac(-v-0.1), second(modf(-v-0.1)) )
    assertEquals( frac( v+0.7), second(modf( v+0.7)) )
    assertEquals( frac( v-0.7), second(modf( v-0.7)) )
    assertEquals( frac(-v+0.7), second(modf(-v+0.7)) )
    assertEquals( frac(-v-0.7), second(modf(-v-0.7)) )
  end

  assertEquals( frac(    0) ,     0 )
  assertEquals( frac( tiny) ,  tiny )
  assertEquals( frac(  0.1) ,   0.1 )
  assertEquals( frac(  0.5) ,   0.5 )
  assertEquals( frac(  0.7) ,   0.7 )
  assertEquals( frac(    1) ,     0 )
  assertEquals( frac(  1.5) ,   0.5 )
  assertEquals( frac(  1.7) ,   0.7 )
  assertEquals( frac( huge) ,     0 )
  assertEquals( frac(-   0) , -   0 )
  assertEquals( frac(-tiny) , -tiny )
  assertEquals( frac(- 0.1) , - 0.1 )
  assertEquals( frac(- 0.5) , - 0.5 )
  assertEquals( frac(- 0.7) , - 0.7 )
  assertEquals( frac(-   1) , -   0 )
  assertEquals( frac(- 1.5) , - 0.5 )
  assertEquals( frac(- 1.7) , - 0.7 )
  assertEquals( frac(-huge) , -   0 )

  assertAlmostEquals( frac( 1.1)-0.1, 0, eps/2 )
  assertAlmostEquals( frac(-1.1)+0.1, 0, eps/2 )

  assertNaN( frac(nan) )

  local n,f
  n,f = modf( inf) assertEquals( 1/f ,  inf )
  n,f = modf(-inf) assertEquals( 1/f , -inf )
-- The problem is coming from combining second() and modf() in frac()
--  if false then -- expected
  assertEquals( frac(  inf) , 0 ) -- interpreter -> nan, pb with modf [BUG] (Passes on Ubuntu 22.04.1 LTS)
  assertEquals( frac(- inf) , 0 ) -- interpreter -> nan, pb with modf [BUG]
--  else          -- actual [BUG]
--    assertNaN( frac(  inf) )        -- jit ->  0 [CORRECT]
--    assertNaN( frac(- inf) )        -- jit -> -0 [CORRECT]
--  end
end

function TestGmath:testTrunc()
  for _,v in ipairs(values.num) do
    assertEquals( trunc( v+eps), first(modf( v+eps)) )
    assertEquals( trunc( v-eps), first(modf( v-eps)) )
    assertEquals( trunc(-v+eps), first(modf(-v+eps)) )
    assertEquals( trunc(-v-eps), first(modf(-v-eps)) )
    assertEquals( trunc( v+0.1), first(modf( v+0.1)) )
    assertEquals( trunc( v-0.1), first(modf( v-0.1)) )
    assertEquals( trunc(-v+0.1), first(modf(-v+0.1)) )
    assertEquals( trunc(-v-0.1), first(modf(-v-0.1)) )
    assertEquals( trunc( v+0.7), first(modf( v+0.7)) )
    assertEquals( trunc( v-0.7), first(modf( v-0.7)) )
    assertEquals( trunc(-v+0.7), first(modf(-v+0.7)) )
    assertEquals( trunc(-v-0.7), first(modf(-v-0.7)) )
  end

  assertEquals( trunc( tiny) ,     0 )
  assertEquals( trunc(  0.1) ,     0 )
  assertEquals( trunc(  0.5) ,     0 )
  assertEquals( trunc(  0.7) ,     0 )
  assertEquals( trunc(    1) ,     1 )
  assertEquals( trunc(  1.1) ,     1 )
  assertEquals( trunc(  1.5) ,     1 )
  assertEquals( trunc(  1.7) ,     1 )
  assertEquals( trunc( huge) ,  huge )
  assertEquals( trunc(-tiny) , -   0 )
  assertEquals( trunc(- 0.1) , -   0 )
  assertEquals( trunc(- 0.5) , -   0 )
  assertEquals( trunc(- 0.7) , -   0 )
  assertEquals( trunc(-   1) , -   1 )
  assertEquals( trunc(- 1.1) , -   1 )
  assertEquals( trunc(- 1.5) , -   1 )
  assertEquals( trunc(- 1.7) , -   1 )
  assertEquals( trunc(-huge) , -huge )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( 1/trunc(-  0 ) , -inf ) -- check for -0
  assertEquals( 1/trunc(   0 ) ,  inf ) -- check for +0
  assertEquals(   trunc(- inf) , -inf )
  assertEquals(   trunc(  inf) ,  inf )
  assertNaN   (   trunc(  nan) )
end

function TestGmath:testRound()
  local c = 0x1.fffffffffffffp-2 ! 0.49999999999999994
  assertEquals( 1/round( tiny) ,   inf ) -- check for +0
  assertEquals( 1/round(  0.1) ,   inf ) -- check for +0
  assertEquals( 1/round(   c ) ,   inf ) -- check for +0
  assertEquals(   round(  0.5) ,     1 )
  assertEquals(   round(  0.7) ,     1 )
  assertEquals(   round(    1) ,     1 )
  assertEquals(   round(  1.1) ,     1 )
  assertEquals(   round(  1.5) ,     2 )
  assertEquals(   round(  1.7) ,     2 )
  assertEquals(   round( huge) ,  huge )
  assertEquals( 1/round(-tiny) , - inf ) -- check for -0
  assertEquals( 1/round(- 0.1) , - inf ) -- check for -0
  assertEquals( 1/round(-  c ) , - inf ) -- check for -0
  assertEquals(   round(- 0.5) , -   1 )
  assertEquals(   round(- 0.7) , -   1 )
  assertEquals(   round(-   1) , -   1 )
  assertEquals(   round(- 1.1) , -   1 )
  assertEquals(   round(- 1.5) , -   2 )
  assertEquals(   round(- 1.7) , -   2 )
  assertEquals(   round(-huge) , -huge )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( 1/round(-  0 ) , -inf ) -- check for -0 :: jit(rand) -> inf [BUG]
  assertEquals( 1/round(   0 ) ,  inf ) -- check for +0
  assertEquals(   round(- inf) , -inf )
  assertEquals(   round(  inf) ,  inf )
  assertNaN   (   round(  nan) )
end

function TestGmath:testAbs()
  for _,v in ipairs(values.num) do
    assertEquals(  abs( v),  v )
    assertEquals(  abs(-v),  v )
    assertEquals( -abs(-v), -v )
  end

  assertEquals( abs( tiny) ,  tiny )
  assertEquals( abs(  0.1) ,   0.1 )
  assertEquals( abs(    1) ,     1 )
  assertEquals( abs( huge) ,  huge )
  assertEquals( abs(-tiny) ,  tiny )
  assertEquals( abs(- 0.1) ,   0.1 )
  assertEquals( abs(-   1) ,     1 )
  assertEquals( abs(-huge) ,  huge )
  assertNaN   ( abs(  nan) )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( 1/abs(- 0 ), inf ) -- check for +0
  assertEquals( 1/abs(  0 ), inf ) -- check for +0
  assertEquals(   abs(-inf), inf )
  assertEquals(   abs( inf), inf )

  assertNaN( abs(nan) )
end

function TestGmath:testSqrt()
  for _,v in ipairs(values.num) do
    if v > 0 and v < inf then
      assertAlmostEquals( sqrt(v)*sqrt(v) / v - 1, 0, eps )
    end
  end
  assertNaN( sqrt(-inf) )
  assertNaN( sqrt(-1  ) )
  assertNaN( sqrt(-0.1) )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( 1/sqrt(- 0  ) , -inf ) -- check for -0
  assertEquals( 1/sqrt(  0  ) ,  inf ) -- check for +0
  assertEquals(   sqrt( inf ) ,  inf )
  assertNaN   (   sqrt(-tiny) )
  assertNaN   (   sqrt(-inf ) )
  assertNaN   (   sqrt( nan ) )
end

function TestGmath:testInvsqrt()
  for _,v in ipairs(values.num) do
    if v > 0 and v < inf then
      assertAlmostEquals( v*invsqrt(v)*invsqrt(v) - 1, 0, eps )
    end
  end
  assertNaN( invsqrt(-inf) )
  assertNaN( invsqrt(-1  ) )
  assertNaN( invsqrt(-0.1) )

  assertEquals( invsqrt(- 0  ) , -inf ) -- check for -0
  assertEquals( invsqrt(  0  ) ,  inf ) -- check for +0
  assertEquals( invsqrt( inf ) ,  0 )
  assertNaN   ( invsqrt(-tiny) )
  assertNaN   ( invsqrt( nan ) )
end

function TestGmath:testHypot()
  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      if x > tiny and y > tiny and x < huge and y < huge then
        if x > 1 or y > 1 then --relative error
          assertAlmostEquals((hypot(x, y) - sqrt(sqr(x) + sqr(y)))/sqrt(sqr(x) + sqr(y)), 0, eps)
        else --absolute error
          assertAlmostEquals(hypot(x, y) - sqrt(sqr(x) + sqr(y)), 0, eps)
        end
        -- Check for IEEE:IEC 60559 compliance (all 7 below)
        assertEquals(hypot(x, y), hypot(y,x))
        assertEquals(hypot(x, y), hypot(x,-y))
      end
    end
    assertEquals(hypot(x, 0), abs(x))
    assertEquals(hypot(inf, x), inf)
    assertEquals(hypot(-inf, x), inf)
  end
  assertEquals(hypot(inf,nan), inf)
  assertEquals(hypot(-inf,nan), inf)
end

--
function TestGmath:testHypot3() -- 215 K asserts, takes 10-20 ms
  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      for _,z in ipairs(values.num) do
        if x > tiny and y > tiny and z > tiny and x < huge and y < huge and z < huge then
          local err = hypot3(x,y,z) - sqrt(sqr(x)+sqr(y)+sqr(z))
          if x > 1 or y > 1 or z > 1 then
            err = err/sqrt(sqr(x)+sqr(y)+sqr(z)) -- use relative error
          end
          assertAlmostEquals( err, 0, 2*eps)

          -- Check for IEEE:IEC 60559 compliance (all below)
          assertAlmostEquals(hypot3(x, y, z) / hypot3(y, x, z), 1, 2*eps) --relative error
          assertAlmostEquals(hypot3(x, y, z) / hypot3(y, z, x), 1, 2*eps)
          assertAlmostEquals(hypot3(x, y, z) / hypot3(z, y, x), 1, 2*eps)
          assertEquals      (hypot3(x, y, z) / hypot3(x,-y, z), 1,     0)
          assertEquals      (hypot3(x, y, z) / hypot3(x, y,-z), 1,     0)
        end
      end
    end
    assertEquals(hypot3(0, x, 0), abs(x))
    assertEquals(hypot3(inf, x, x), inf)
    assertEquals(hypot3(x, x, -inf), inf)
  end
  assertEquals(hypot3(inf,nan, 0), inf)
  assertEquals(hypot3(-inf,nan, 0), inf)
end

function TestGmath:testExp()
  -- SetPrecision[Table[Exp[x],{x, -1, 1, 0.1}],20]
  local val1 = {0.36787944117144233402, 0.40656965974059910973,
  0.44932896411722156316, 0.49658530379140952693, 0.54881163609402638937,
  0.60653065971263342426, 0.67032004603563932754, 0.74081822068171787610,
  0.81873075307798193201, 0.90483741803595962860, 1, 1.1051709180756477124,
  1.2214027581601698547, 1.3498588075760031835, 1.4918246976412703475,
  1.6487212707001281942, 1.8221188003905091080, 2.0137527074704766328,
  2.2255409284924678737, 2.4596031111569498506, 2.7182818284590450908}
  -- SetPrecision[Table[Exp[x],{x, -10, -1, 1}],20]
  local val2 = {0.00004539992976248485154, 0.0001234098040866795495,
  0.0003354626279025118388, 0.0009118819655545162080, 0.002478752176666358423,
  0.006737946999085467097, 0.018315638888734180294, 0.04978706836786394298,
  0.13533528323661269189, 0.36787944117144232160}
  -- SetPrecision[Table[Exp[x],{x, 1, 10, 1}],20]
  local val3 = {2.7182818284590452354, 7.389056098930650227,
  20.085536923187667741, 54.59815003314423908, 148.41315910257660342,
  403.4287934927351226, 1096.6331584284585993, 2980.957987041728275,
  8103.083927575384008, 22026.46579480671652}

  local i
  i=0 for v=-1,1,0.1 do i=i+1 -- should be done with ranges...
    v = -1+(i-1)*0.1
    assertAlmostEquals( exp(v) - val1[i], 0, 2*eps )
  end
  i=0 for v=-10,-1 do i=i+1
    assertAlmostEquals( exp(v) - val2[i], 0, eps )
  end
  i=0 for v=1,10 do i=i+1
    assertAlmostEquals( exp(v) - val3[i], 0, eps )
  end

  for i,v in ipairs(values.num) do
    if v > 1/709.78 and v < 709.78 then
      assertAlmostEquals( exp(v+1/v) / (exp(v)*exp(1/v)) - 1, 0, 25*eps ) -- 64*eps?
      assertAlmostEquals( exp(log(v)) / v - 1, 0, 2*eps )
      assertAlmostEquals( log(exp(v)) / v - 1, 0, 4*eps )
    end
  end

  assertEquals      ( exp(-inf) , 0   )
  assertEquals      ( exp(-  1) , 0.36787944117144232159 )
  assertEquals      ( exp(-0.5) , 0.60653065971263342360 )
  assertAlmostEquals( exp(-0.1) - 0.90483741803595957316, 0, eps )
  assertEquals      ( exp(   0) , 1   )
  assertEquals      ( exp( 0.1) , 1.10517091807564762481 )
  assertEquals      ( exp( 0.5) , 1.64872127070012814684 )
  assertEquals      ( exp(   1) , 2.71828182845904523536 )
  assertEquals      ( exp( inf) , inf )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( exp(-0  ) ,  1  )
  assertEquals( exp( 0  ) ,  1  )
  assertEquals( exp(-inf) ,  0  )
  assertEquals( exp( inf) , inf )
  assertNaN   ( exp( nan) )
end

function TestGmath:testLog()
  -- also used/tested in testExp
  for _,x in ipairs(values.num) do
  for _,y in ipairs(values.num) do
    if x > eps and y > eps  and x < 1/eps and y < 1/eps then
      assertAlmostEquals(log(x*y) - (log(x)+log(y)), 0, 40*eps)
    end
  end end
  for i=0,200 do
    assertAlmostEquals( log(2^ i) -  i*log(2), 0, 150*eps)
    assertAlmostEquals( log(2^-i) - -i*log(2), 0, 150*eps)
  end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( log(-   0) , -inf )
  assertEquals( log(    0) , -inf )
  assertEquals( log(    1) ,   0  )
  assertEquals( log(  inf) ,  inf )
  assertNaN   ( log(-tiny) )
  assertNaN   ( log(- inf) )
  assertNaN   ( log(  nan) )
end

function TestGmath:testLog10()
  for i,v in ipairs(values.num) do
    if v > 0 and v < inf then
      assertAlmostEquals( log10(v) - log(v)/log(10), 0, 300*eps)
    end
  end
  for i=0,200 do
    assertAlmostEquals( log10(10^ i) -  i, 0, 150*eps)
    assertAlmostEquals( log10(10^-i) - -i, 0, 150*eps)
  end
  assertEquals( log10( 10), 1   )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( log10(-   0) ,-inf )
  assertEquals( log10(    0) ,-inf )
  assertEquals( log10(    1) ,  0  )
  assertEquals( log10(  inf) , inf )
  assertNaN   ( log10(-tiny) )
  assertNaN   ( log10(- inf) )
  assertNaN   ( log10(  nan) )
end

function TestGmath:testSin()
  for _,v in ipairs(values.rad) do
    assertAlmostEquals( sin(v)           - -sin(-v)             , 0, eps )
    assertAlmostEquals( sin(v)           -  cos(pi/2-v)         , 0, eps )
    assertAlmostEquals( sin(v)           - (2*sin(v/2)*cos(v/2)), 0, eps )
    assertAlmostEquals( sin(asin( v/pi)) -  v/pi                , 0, eps )
    assertAlmostEquals( sin(asin(-v/pi)) - -v/pi                , 0, eps )
  end
  local r3, r4, r12 = sqrt(3)/2, sqrt(2)/2, sqrt(2)*(sqrt(3)-1)/4
  assertAlmostEquals( sin(    pi   ) -  0  , 0,   eps )
  assertAlmostEquals( sin( 11*pi/12) -  r12, 0, 2*eps )
  assertAlmostEquals( sin(  5*pi/6 ) -  0.5, 0,   eps )
  assertAlmostEquals( sin(  3*pi/4 ) -  r4 , 0,   eps )
  assertAlmostEquals( sin(  2*pi/3 ) -  r3 , 0,   eps )
  assertAlmostEquals( sin(    pi/2 ) -  1  , 0,   eps )
  assertAlmostEquals( sin(    pi/3 ) -  r3 , 0,   eps )
  assertAlmostEquals( sin(    pi/4 ) -  r4 , 0,   eps )
  assertAlmostEquals( sin(    pi/6 ) -  0.5, 0,   eps )
  assertAlmostEquals( sin(    pi/12) -  r12, 0,   eps )
  assertEquals      ( sin(    0    ) -  0  , 0        )
  assertAlmostEquals( sin(-   pi/12) - -r12, 0,   eps )
  assertAlmostEquals( sin(-   pi/6 ) - -0.5, 0,   eps )
  assertAlmostEquals( sin(-   pi/4 ) - -r4 , 0,   eps )
  assertAlmostEquals( sin(-   pi/3 ) - -r3 , 0,   eps )
  assertAlmostEquals( sin(-   pi/2 ) - -1  , 0,   eps )
  assertAlmostEquals( sin(- 2*pi/3 ) - -r3 , 0,   eps )
  assertAlmostEquals( sin(- 3*pi/4 ) - -r4 , 0,   eps )
  assertAlmostEquals( sin(- 5*pi/6 ) - -0.5, 0,   eps )
  assertAlmostEquals( sin(-11*pi/12) - -r12, 0, 2*eps )
  assertAlmostEquals( sin(-   pi   ) - -0  , 0,   eps )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( 1/sin( -0 ) , -inf  ) -- check for -0
  assertEquals( 1/sin(  0 ) ,  inf  ) -- check for +0
  assertNaN   (   sin(-inf) )
  assertNaN   (   sin( inf) )
  assertNaN   (   sin( nan) )
end

function TestGmath:testCos()
  for _,v in ipairs(values.rad) do
    assertAlmostEquals( cos(v)           - cos(-v)         , 0, eps )
    assertAlmostEquals( cos(v)           - sin(pi/2-v)     , 0, eps )
    assertAlmostEquals( cos(v)           - (1-2*sin(v/2)^2), 0, eps )
    assertAlmostEquals( cos(acos( v/pi)) -  v/pi           , 0, eps )
    assertAlmostEquals( cos(acos(-v/pi)) - -v/pi           , 0, eps )
  end
  local r4, r6, r12 = sqrt(2)/2, sqrt(3)/2, sqrt(2)*(sqrt(3)+1)/4
  assertEquals      ( cos(    pi   ) - -1  , 0      )
  assertAlmostEquals( cos( 11*pi/12) - -r12, 0, eps )
  assertAlmostEquals( cos(  5*pi/6 ) - -r6 , 0, eps )
  assertAlmostEquals( cos(  3*pi/4 ) - -r4 , 0, eps )
  assertAlmostEquals( cos(  2*pi/3 ) - -0.5, 0, eps )
  assertAlmostEquals( cos(    pi/2 ) -  0  , 0, eps )
  assertAlmostEquals( cos(    pi/3 ) -  0.5, 0, eps )
  assertAlmostEquals( cos(    pi/4 ) -  r4 , 0, eps )
  assertAlmostEquals( cos(    pi/6 ) -  r6 , 0, eps )
  assertAlmostEquals( cos(    pi/12) -  r12, 0, eps )
  assertAlmostEquals( cos(-   pi/12) -  r12, 0, eps )
  assertAlmostEquals( cos(-   pi/6 ) -  r6 , 0, eps )
  assertAlmostEquals( cos(-   pi/4 ) -  r4 , 0, eps )
  assertAlmostEquals( cos(-   pi/3 ) -  0.5, 0, eps )
  assertAlmostEquals( cos(-   pi/2 ) -  0  , 0, eps )
  assertAlmostEquals( cos(- 2*pi/3 ) - -0.5, 0, eps )
  assertAlmostEquals( cos(- 3*pi/4 ) - -r4 , 0, eps )
  assertAlmostEquals( cos(- 5*pi/6 ) - -r6 , 0, eps )
  assertAlmostEquals( cos(-11*pi/12) - -r12, 0, eps )
  assertEquals      ( cos(-   pi   ) - -1  , 0      )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( cos( -0 ) ,   1   )
  assertEquals( cos(  0 ) ,   1   )
  assertNaN   ( cos(-inf) )
  assertNaN   ( cos( inf) )
  assertNaN   ( cos( nan) )
end

function TestGmath:testTan()
  for _,v in ipairs(values.rad) do
    assertEquals      (tan( v) - -tan(-v)        , 0     )
    assertAlmostEquals(tan( v) -  sin( v)/cos( v), 0, eps)
    assertAlmostEquals(tan(-v) -  sin(-v)/cos(-v), 0, eps)
  end
  local r3, r6, r12 = sqrt(3), 1/sqrt(3), 2-sqrt(3)
  assertAlmostEquals(  tan(-pi )            , 0,   eps )
  assertAlmostEquals(  tan(-pi+pi/12) -  r12, 0,   eps )
  assertAlmostEquals(  tan(-pi+pi/6 ) -  r6 , 0,   eps )
  assertAlmostEquals(  tan(-pi+pi/4 ) -  1  , 0,   eps )
  assertAlmostEquals(  tan(-pi+pi/3 ) -  r3 , 0, 3*eps )
  assertAlmostEquals(1/tan(-pi/2    )       , 0,   eps )
  assertAlmostEquals(  tan(-pi/3    ) - -r3 , 0, 2*eps )
  assertAlmostEquals(  tan(-pi/4    ) - -1  , 0,   eps )
  assertAlmostEquals(  tan(-pi/6    ) - -r6 , 0,   eps )
  assertAlmostEquals(  tan(-pi/12   ) - -r12, 0,   eps )
  assertEquals      (  tan( 0       ) -  0  , 0        )
  assertAlmostEquals(  tan( pi/12   ) -  r12, 0,   eps )
  assertAlmostEquals(  tan( pi/6    ) -  r6 , 0,   eps )
  assertAlmostEquals(  tan( pi/4    ) -  1  , 0,   eps )
  assertAlmostEquals(  tan( pi/3    ) -  r3 , 0, 2*eps )
  assertAlmostEquals(1/tan( pi/2    )       , 0,   eps )
  assertAlmostEquals(  tan( pi-pi/3 ) - -r3 , 0, 3*eps )
  assertAlmostEquals(  tan( pi-pi/4 ) - -1  , 0,   eps )
  assertAlmostEquals(  tan( pi-pi/6 ) - -r6 , 0,   eps )
  assertAlmostEquals(  tan( pi-pi/12) - -r12, 0,   eps )
  assertAlmostEquals(  tan( pi )            , 0,   eps )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( 1/tan( -0 ) , -inf  ) -- check for -0
  assertEquals( 1/tan(  0 ) ,  inf  ) -- check for +0
  assertNaN   (   tan(-inf) )
  assertNaN   (   tan( inf) )
  assertNaN   (   tan( nan) )
end

function TestGmath:testCot()
  local nums = {
    3, pi/2, pi/3, pi/4, pi/5, pi/6, 0.1
  }
  local expected = {
    inf, 4.5035996273704960000e15, 2.2517998136852480000e15, 57.289961630759424687, 
    28.636253282915603551, 11.430052302761343067, 5.6712818196177095310,
    3.7320508075688772935, 1.7320508075688772935, 1.0000000000000000000,
    0.57735026918962576451, 0, -0.57735026918962576451,-1.0000000000000000000,
    -1.7320508075688772935, -3.7320508075688772935, inf
  }
  for i,v in ipairs(values.rad) do
    if v > 0 then
      assertEquals      (cot( v) - -cot(-v)       , 0         )
      assertEquals      (cot( v) - 1/tan(v)       , 0         )      
      assertAlmostEquals(cot( v) - cos( v)/sin( v), 0, 16*eps )
      assertAlmostEquals(cot(-v) - cos(-v)/sin(-v), 0, 16*eps )
      if expected[i] < inf then 
        assertAlmostEquals(   1   /tan( v), expected[i], 32*eps )
        assertAlmostEquals(cos( v)/sin( v), expected[i], 32*eps )
      end
    end
  end
end
function TestGmath:testSinh()
  for _,v in ipairs(values.num) do
    assertEquals( sinh(v), -sinh(-v) )
    if v < 3e-8 then
      assertEquals( sinh(v), v )
    end
    if v > 19.0006 then
      assertEquals( sinh(v), cosh(v) )
    end
    if v < 1e-5 then
      assertAlmostEquals( sinh(v) - v , 0, eps )
    end
    if v > 1e-5 and v < 19.0006 then
      assertAlmostEquals( sinh(v) / (2*sinh(v/2)*cosh(v/2))  - 1, 0,   eps )
      assertAlmostEquals( sinh(v) / (exp(-v)*(exp(2*v)-1)/2) - 1, 0, 2*eps )
      assertAlmostEquals(  exp(v) / (cosh(v) + sinh(v))      - 1, 0,   eps )
    end
  end
  assertEquals( sinh(-711), -inf )
  assertEquals( sinh( 711),  inf )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( 1/sinh(-0  ), -inf ) -- check for -0
  assertEquals( 1/sinh( 0  ),  inf ) -- check for +0
  assertEquals(   sinh(-inf), -inf )
  assertEquals(   sinh( inf),  inf )
  assertNaN   (   sinh( nan))
end

function TestGmath:testCosh()
  for _,v in ipairs(values.num) do
    assertEquals( cosh(v), cosh(-v) )
    if cosh(v) <= huge then
      assertAlmostEquals( cosh(v) / ((exp(v)+exp(-v))/2), 1,   eps )
      assertAlmostEquals( cosh(v) / ( 1 + 2*sinh(v/2)^2), 1,   eps )
      assertAlmostEquals( cosh(v) / (-1 + 2*cosh(v/2)^2), 1, 2*eps )
      assertAlmostEquals(  exp(v) / (cosh(v) + sinh(v)) , 1,   eps )
    end
  end
  assertEquals( cosh(-711), inf )
  assertEquals( cosh( 711), inf )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( cosh(-0  ) , 1   )
  assertEquals( cosh( 0  ) , 1   )
  assertEquals( cosh(-inf) , inf )
  assertEquals( cosh( inf) , inf )
  assertNaN   ( cosh( nan) )
end

function TestGmath:testTanh()
  for _,v in ipairs(values.num) do
    assertEquals( tanh(v), -tanh(-v) )
    if v < 2e-8 then
      assertEquals( tanh(v), v )
    end
    if v > 19.06155 then
      assertEquals( tanh(v), 1 )
    end
    if v < 8.74e-06 then
      assertAlmostEquals( tanh(v) - v , 0, eps )
    end
    if v > 8.74e-06 and v < 19.06155 then
      assertAlmostEquals( tanh( v) -  sinh( v)/cosh( v), 0, eps )
      assertAlmostEquals( tanh(-v) -  sinh(-v)/cosh(-v), 0, eps )
    end
  end
  assertEquals( tanh(-inf     ), -1 )
  assertEquals( tanh(-19.06155), -1 )
  assertEquals( tanh(  0      ),  0 )
  assertEquals( tanh( 19.06155),  1 )
  assertEquals( tanh( inf)     ,  1 )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( 1/tanh(-0  ) , -inf ) -- check for -0
  assertEquals( 1/tanh( 0  ) ,  inf ) -- check for +0
  assertEquals(   tanh(-inf) , -1   )
  assertEquals(   tanh( inf) ,  1   )
  assertNaN   (   tanh( nan) )
end

function TestGmath:testCoth()
  for _,v in ipairs(values.num) do
    assertEquals( coth(v), -coth(-v) )
    if v < 2e-8 then
      assertEquals( coth(v), 1/v )
    end
    if v > 19.06155 then
      assertEquals( coth(v), 1 )
    end
    if v < 8.74e-06 and v ~= 0 then
      assertAlmostEquals( coth(v) - 1/v , 0, eps )
    end
    if v > 8.74e-06 and v < 19.06155 then
      assertAlmostEquals( coth( v) -  cosh( v)/sinh( v), 0, 8*eps )
      assertAlmostEquals( coth(-v) -  cosh(-v)/sinh(-v), 0, 8*eps )
    end
  end
  assertEquals( coth(-inf     ), -1 )
  assertEquals( coth(-19.06155), -1 )
  assertEquals( coth(  0      ), inf)
  assertEquals( coth( -0      ),-inf)
  assertEquals( coth( 19.06155),  1 )
  assertEquals( coth( inf)     ,  1 )
end

function TestGmath:testAsin()
  for _,v in ipairs(values.rad2) do
    assertAlmostEquals( asin(v/pi)    - -asin(-v/pi)     , 0, eps )
    assertAlmostEquals( asin(v/pi)    - (pi/2-acos(v/pi)), 0, eps )
    assertAlmostEquals( asin(sin( v)) -  v               , 0, eps )
    assertAlmostEquals( asin(sin(-v)) - -v               , 0, eps )
  end
  local r3, r4, r12 = sqrt(3)/2, sqrt(2)/2, sqrt(2)*(sqrt(3)-1)/4
  assertEquals      ( asin( r12) -  pi/12, 0      )
  assertAlmostEquals( asin( 0.5) -  pi/6 , 0, eps )
  assertAlmostEquals( asin( r4 ) -  pi/4 , 0, eps )
  assertEquals      ( asin( r3 ) -  pi/3 , 0      )
  assertEquals      ( asin( 1  ) -  pi/2 , 0      )
  assertEquals      ( asin( r3 ) -  pi/3 , 0      )
  assertAlmostEquals( asin( r4 ) -  pi/4 , 0, eps )
  assertAlmostEquals( asin( 0.5) -  pi/6 , 0, eps )
  assertEquals      ( asin( r12) -  pi/12, 0      )
  assertEquals      ( asin(-r12) - -pi/12, 0      )
  assertAlmostEquals( asin(-0.5) - -pi/6 , 0, eps )
  assertAlmostEquals( asin(-r4 ) - -pi/4 , 0, eps )
  assertEquals      ( asin(-r3 ) - -pi/3 , 0      )
  assertEquals      ( asin(-1  ) - -pi/2 , 0      )
  assertEquals      ( asin(-r3 ) - -pi/3 , 0      )
  assertAlmostEquals( asin(-r4 ) - -pi/4 , 0, eps )
  assertAlmostEquals( asin(-0.5) - -pi/6 , 0, eps )
  assertEquals      ( asin(-r12) - -pi/12, 0      )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( 1/asin( 0    ) ,  inf  ) -- check for +0
  assertEquals( 1/asin(-0    ) , -inf  ) -- check for -0
  assertNaN   (   asin(-1-eps) )
  assertNaN   (   asin( 1+eps) )
  assertNaN   (   asin(nan   ) )
end

function TestGmath:testAcos()
  for _,v in ipairs(values.rad) do
    assertAlmostEquals( acos(v/pi)    - (pi-acos(-v/pi)) , 0,  2*eps )
    assertAlmostEquals( acos(v/pi)    - (pi/2-asin(v/pi)), 0,  2*eps )
    assertAlmostEquals( acos(cos( v)) - v                , 0, 16*eps ) -- 8eps @ 1deg (16eps c -10)
    assertAlmostEquals( acos(cos(-v)) - v                , 0, 16*eps ) -- 8eps @ 1deg (16eps c -10)
  end
  local r4, r6, r12 = sqrt(2)/2, sqrt(3)/2, sqrt(2)*(sqrt(3)+1)/4
  assertEquals      ( acos(-1  ) -    pi   , 0        )
  assertAlmostEquals( acos(-r12) - 11*pi/12, 0, 2*eps )
  assertAlmostEquals( acos(-r6 ) -  5*pi/6 , 0,   eps )
  assertAlmostEquals( acos(-r4 ) -  3*pi/4 , 0,   eps )
  assertAlmostEquals( acos(-0.5) -  2*pi/3 , 0, 2*eps )
  assertAlmostEquals( acos( 0  ) -    pi/2 , 0,   eps )
  assertAlmostEquals( acos( 0.5) -    pi/3 , 0,   eps )
  assertAlmostEquals( acos( r4 ) -    pi/4 , 0,   eps )
  assertAlmostEquals( acos( r6 ) -    pi/6 , 0,   eps )
  assertAlmostEquals( acos( r12) -    pi/12, 0,   eps )
  assertAlmostEquals( acos( r12) -    pi/12, 0,   eps )
  assertAlmostEquals( acos( r6 ) -    pi/6 , 0,   eps )
  assertAlmostEquals( acos( r4 ) -    pi/4 , 0,   eps )
  assertAlmostEquals( acos( 0.5) -    pi/3 , 0,   eps )
  assertAlmostEquals( acos( 0  ) -    pi/2 , 0,   eps )
  assertAlmostEquals( acos(-0.5) -  2*pi/3 , 0, 2*eps )
  assertAlmostEquals( acos(-r4 ) -  3*pi/4 , 0,   eps )
  assertAlmostEquals( acos(-r6 ) -  5*pi/6 , 0,   eps )
  assertAlmostEquals( acos(-r12) - 11*pi/12, 0, 2*eps )
  assertEquals      ( acos(-1  ) -    pi   , 0        )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( acos( 1    ) ,   0   )
  assertNaN   ( acos(-1-eps) )
  assertNaN   ( acos( 1+eps) )
  assertNaN   ( acos(nan   ) )
end

function TestGmath:testAtan()
  for _,v in ipairs(values.num) do
    assertAlmostEquals( atan(v) - -atan(-v), 0, eps) -- randomly not equal ±eps
  end
  for _,v in ipairs(values.rad2) do
    assertAlmostEquals( atan(tan( v)) -  v, 0, eps )
    assertAlmostEquals( atan(tan(-v)) - -v, 0, eps )
  end
  local r3, r6, r12 = sqrt(3), 1/sqrt(3), 2-sqrt(3)
  assertAlmostEquals( atan(-r3 ) - -pi/3 , 0, eps )
  assertEquals      ( atan(-1  ) - -pi/4 , 0      )
  assertAlmostEquals( atan(-r6 ) - -pi/6 , 0, eps )
  assertAlmostEquals( atan(-r12) - -pi/12, 0, eps )
  assertAlmostEquals( atan( r12) -  pi/12, 0, eps )
  assertAlmostEquals( atan( r6 ) -  pi/6 , 0, eps )
  assertEquals      ( atan( 1  ) -  pi/4 , 0      )
  assertAlmostEquals( atan( r3 ) -  pi/3 , 0, eps )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( 1/atan( 0  ) ,  inf  ) -- check for -0
  assertEquals( 1/atan(-0  ) , -inf  ) -- check for +0
  assertEquals(   atan(-inf) , -pi/2 )
  assertEquals(   atan( inf) ,  pi/2 )
  assertNaN   (   atan( nan) )
end

function TestGmath:testAcot()
  for _,v in ipairs(values.num) do
    assertAlmostEquals( acot(v) - -acot(-v), 0, eps)
  end
  for _,v in ipairs(values.rad2) do
    assertAlmostEquals( acot(cot( v)) -  v, 0, eps )
    assertAlmostEquals( acot(cot(-v)) - -v, 0, eps )
  end
  local r3, r6, r12 = sqrt(3), 1/sqrt(3), 2-sqrt(3)
  assertAlmostEquals( acot(-r3 ) - -pi/6 , 0, eps )
  assertEquals      ( acot(-1  ) - -pi/4 , 0      )
  assertAlmostEquals( acot(-r6 ) - -pi/3 , 0, eps )
  assertAlmostEquals( acot(-r12) - -5*pi/12, 0, eps )
  assertAlmostEquals( acot( r12) -  5*pi/12, 0, eps )
  assertAlmostEquals( acot( r6 ) -  pi/3 , 0, eps )
  assertEquals      ( acot( 1  ) -  pi/4 , 0      )
  assertAlmostEquals( acot( r3 ) -  pi/6 , 0, eps )
end

function TestGmath:testAsinh()
  for _,v in ipairs(values.num) do
    if v < inf then
      assertAlmostEquals( asinh(v) - -asinh(-v), 0, eps )
    end
    if v > 0 and asinh(v) < 710 then -- skip huge
      assertAlmostEquals( sinh(asinh(v)) / v - 1       , 0, 15*eps )
      assertAlmostEquals( log(v+sqrt(v^2+1)) - asinh(v), 0, 16*eps )
    end
  end

  assertAlmostEquals( sinh(asinh(huge)) / huge - 1, 0, 400*eps )

  assertEquals( asinh(-inf), -inf )
  assertEquals( asinh(   0),    0 )
  assertEquals( asinh( inf),  inf )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( 1/asinh(-0  ) , -inf  ) -- check for -0
  assertEquals( 1/asinh( 0  ) ,  inf  ) -- check for +0
  assertEquals(   asinh(-inf) , -inf  )
  assertEquals(   asinh( inf) ,  inf  )
  assertNaN   (   asinh( nan) )
end

function TestGmath:testAcosh()
  for _,v in ipairs(values.num) do
    v = v+1
    if v < inf then
      assertAlmostEquals( cosh(acosh(v)) / v, 1, v*eps )
    end
    if v > 1+1e-9 and v < huge then
      assertAlmostEquals( log(v+sqrt(v^2-1)) / acosh(v), 1 , eps )
    end
  end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( 1/acosh( 1    ) ,  inf  ) -- check for +0
  assertEquals(   acosh(inf   ) ,  inf  )
  assertNaN   (   acosh( 1-eps) )
  assertNaN   (   acosh( 0    ) )
  assertNaN   (   acosh(nan   ) )
end

function TestGmath:testAtanh()
  for _,v in ipairs(values.rad) do
    if v/pi < 1 then -- skip inf
      assertAlmostEquals( atanh(v/pi) - -atanh(-v/pi), 0, eps )
    end
  end
  for _,v in ipairs(values.rad2) do
    assertAlmostEquals( atanh(tanh( v)) -  v, 0, 2*eps )
    assertAlmostEquals( atanh(tanh(-v)) - -v, 0, 2*eps )
  end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( 1/atanh(-0), -inf ) -- check for -0
  assertEquals( 1/atanh( 0),  inf ) -- check for +0
  assertEquals(   atanh(-1), -inf )
  assertEquals(   atanh( 1),  inf )

  assertNaN   (   atanh(-1-eps) )
  assertNaN   (   atanh( 1+eps) )
  assertNaN   (   atanh(   nan) )
end

function TestGmath:testAcoth()
  for _,v in ipairs(values.rad) do
    if v > 1 then --Keep in domain
      assertAlmostEquals( acoth(v) - -acoth(-v), 0, eps )
    end
  end
  for _,v in ipairs(values.rad2) do
    assertAlmostEquals( acoth(coth( v)) -  v, 0, 2*eps )
    assertAlmostEquals( acoth(coth(-v)) - -v, 0, 2*eps )
  end
  assertEquals( 1/acoth(-inf), -inf ) -- check for -0
  assertEquals( 1/acoth( inf),  inf ) -- check for +0
  assertEquals(   acoth(-1), -inf )
  assertEquals(   acoth( 1),  inf )

  assertNaN   (   acoth(-1+eps) )
  assertNaN   (   acoth( 1-eps) )
  assertNaN   (   acoth(   nan) )
end

function TestGmath:testSinc()
  for _,v in ipairs(values.num) do
    if v < 1e-7 then
      assertEquals( sinc( v), 1 )
      assertEquals( sinc(-v), 1 )
    elseif v < inf then
      assertEquals( sinc( v), sinc(-v) )
      assertEquals( sinc( v), sin(v) / v )
      assertEquals( sinc(-v), sin(-v)/-v )
    end
  end

  assertNaN( sinc(-inf) )
  assertNaN( sinc( inf) )
  assertNaN( sinc( nan) )
end

function TestGmath:testSinhc()
  for _,v in ipairs(values.num) do
    if v < 1e-7 then
      assertEquals( sinhc( v), 1 )
      assertEquals( sinhc(-v), 1 )
    elseif v < inf then
      assertEquals( sinhc( v), sinhc(-v) )
      assertEquals( sinhc( v), sinh(v) / v )
      assertEquals( sinhc(-v), sinh(-v)/-v )
    end
  end

  assertNaN( sinhc(-inf) )
  assertNaN( sinhc( inf) )
  assertNaN( sinhc( nan) )
end

function TestGmath:testAsinc()
  for _,v in ipairs(values.num) do
    if v < 1e-7 then
      assertEquals( asinc( v), 1 )
      assertEquals( asinc(-v), 1 )
    elseif v < 1 then
      assertAlmostEquals( asinc(v/pi)    - asinc(-v/pi)    ,  0, eps )
      assertEquals( asinc( v), asinc(-v) )
      assertEquals( asinc( v), asin(v) / v )
      assertEquals( asinc(-v), asin(-v)/-v )
    end
  end

  assertEquals(asinc(-1), pi/2)
  assertEquals(asinc( 1), pi/2)

  assertNaN( asinc(-1 - eps) )
  assertNaN( asinc( 1 + eps) )
  assertNaN( asinc( nan) )
end

function TestGmath:testAsinhc() 
  for _,v in ipairs(values.num) do
    if v < 1e-7 then
      assertEquals( asinhc( v), 1 )
      assertEquals( asinhc(-v), 1 )
    elseif v < inf then
      assertEquals( asinhc( v), asinhc(-v) )
      assertEquals( asinhc( v), asinh(v) / v )
      assertEquals( asinhc(-v), asinh(-v)/-v )
    end
  end

  assertNaN( asinhc(-inf) )
  assertNaN( asinhc( inf) )
  assertNaN( asinhc( nan) )
end

function TestGmath:testErf()
  -- SetPrecision[Table[Erf[x],{x, 0, 0.1, 0.002}],20]
  local val1 = {0, 0.0022567553251835242509, 0.0045134925964086976269,
  0.0067701937601504658809, 0.0090268407637503350616, 0.011283415555849619569,
  0.013539900086822627759, 0.015796276309209784233, 0.018052526178150646308,
  0.020308631651816868441, 0.022564574691844942883, 0.024820337263768959407,
  0.027075901337453026768, 0.029331248887523666408, 0.031586361893801956358,
  0.033841222341735428814, 0.036095812222829884441, 0.038350113535080727900,
  0.040604108283404306834, 0.042857778480068768612, 0.045111106145124750533,
  0.047364073306835702271, 0.049616662002107868312, 0.051868854276919972024,
  0.054120632186752504200, 0.056371977797016629974, 0.058622873183482727966,
  0.060873300432708506158, 0.063123241642466618173, 0.065372678922171981175,
  0.067621594393308448456, 0.069869970189855162834, 0.072117788458712334121,
  0.074365031360126412907, 0.076611681068114972915, 0.078857719770890760680,
  0.081103129671285412172, 0.083347892987172433887, 0.085591991951889698220,
  0.087835408814661175558, 0.090078125841018152897, 0.092320125313219897345,
  0.094561389530673264914, 0.096801900810352198290, 0.099041641487215878459,
  0.10128059391462689021, 0.10351874046476788882, 0.10575606352905811414,
  0.10799254551856884987, 0.11022816886443817519, 0.11246291601828489748}
  -- SetPrecision[Table[Erf[x],{x, 0.1, 5, 0.1}],20]
  local val2 = {0.11246291601828489748, 0.22270258921047847434,
  0.32862675945912750430, 0.42839235504666856036, 0.52049987781304662970,
  0.60385609084792601919, 0.67780119383741843642, 0.74210096470766051535,
  0.79690821242283216286, 0.84270079294971489414, 0.88020506957408173321,
  0.91031397822963544542, 0.93400794494065242368, 0.95228511976264884620,
  0.96610514647531076093, 0.97634838334464402188, 0.98379045859077451919,
  0.98909050163573075665, 0.99279042923525750997, 0.99532226501895271209,
  0.99702053334366702586, 0.99813715370201816501, 0.99885682340264336787,
  0.99931148610335496230, 0.99959304798255499414, 0.99976396558347069288,
  0.99986566726005943195, 0.99992498680533459243, 0.99995890212190052804,
  0.99997790950300136092, 0.99998835134263275304, 0.99999397423884828218,
  0.99999694229020352765, 0.99999847800663710373, 0.99999925690162760894,
  0.99999964413700703769, 0.99999983284894211621, 0.99999992299607254331,
  0.99999996520775136233, 0.99999998458274208524, 0.99999999329997235620,
  0.99999999714450582555, 0.99999999880652823414, 0.9999999995108289630,
  0.9999999998033839432, 0.9999999999225039904, 0.9999999999700474040,
  0.9999999999886478586, 0.9999999999957810415, 0.9999999999984625632}

  local i
  i=0 for v=0,0.1,0.002 do i=i+1
    assertAlmostEquals( erf(v) - val1[i], 0, eps )
  end
  i=0 for v=0.1,5,0.1 do i=i+1
    assertAlmostEquals( erf(v) - val2[i], 0, eps )
  end

  for _,v in ipairs(values.num) do
    assertAlmostEquals( erf(v) - -erf(-v), 0, eps )
  end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( 1/erf(-  0) , -inf ) -- check for -0
  assertEquals( 1/erf(   0) ,  inf ) -- check for +0
  assertEquals(   erf(-inf) , - 1  )
  assertEquals(   erf( inf) ,   1  )
  assertNaN   (   erf( nan) )
end

function TestGmath:testErfc()
  for _,v in ipairs(values.num) do
    assertAlmostEquals( erfc(v) - -erfc(-v) , 2, eps )
    assertAlmostEquals( erfc(v) - (1- erf(v)), 0, eps )
  end
  -- Check for IEEE:IEC 60559 compliance
  assertEquals( erfc( -inf) , 2 )
  assertEquals( erfc(  inf) , 0 )
end

function TestGmath:testErfcx()
  for _,v in ipairs(values.num) do
    if sqr(v) < 700 then --ln(1e308) = 709.196...
      assertAlmostEquals(erfcx(v) - (exp(sqr(v)) * erfc(v)), 0, 4*eps )
      if v < 2 then
        assertAlmostEquals(erfcx(v) - (exp(sqr(v)) * (1 - erf(v))), 0, 6*eps )
      end
    end
  end
  assertEquals( erfcx( -inf) , inf )
  assertEquals( erfcx(  inf) , 0 )
end

function TestGmath:testWf()
  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      local z = x + y * 1i
      if abs(z) < inf then
        assertEquals( wf(z) - erfcx(-1i*z), 0 + 0*1i)
        if real(sqr(z)) > -700 and abs(sqr(-1i*z)) < 700 then --ln(1e308) = 709.196...  For real(sqr(z)) < -700, exp(-sqr(z)) = inf and for abs(sqr(-1i*z)) > 700, erfc(-1i*z) = 1+infi
          local result = wf(z) - (exp(-sqr(z)) * erfc(-1i*z))
          assertAlmostEquals(real(result), 0, eps )
          assertAlmostEquals(imag(result), 0, eps)
        end
      end
    end
    assertEquals( wf(complex(x, 0)) - erfcx(-1i*x), 0 + 0*1i)
    assertEquals( wf(x) - imag(erfcx(-1i*x)), 0) --The evaluation of purely real values returns im(w(z))
  end
end

function TestGmath:testErfi()
  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      local z = x + y * 1i
      if x < 26 and abs(z) < inf then --see https://www.wolframalpha.com/input?i=erfi%2826%29
        assertEquals(-1i * erf(1i*z) - erfi(z), 0+0*1i)
      end
    end
  end
end

function TestGmath:testDawson()
  for _,x in ipairs(values.num) do
    if erfi(x) < inf then
      if x > 2 or x < 1 and x > tiny then --for x = tiny dawson(x) = x but exp(-sqr(x)) = 0
        assertAlmostEquals((dawson(x) - 0.5 * sqrt(pi) * exp(-sqr(x)) * erfi(x))/dawson(x), eps) --relative error
      else
        assertAlmostEquals((dawson(x) - 0.5 * sqrt(pi) * exp(-sqr(x)) * erfi(x)), 0, eps) --absolute error
      end
    end
    
    for _,y in ipairs(values.num) do
      local z = x + y * 1i
      if abs(z) < sqrt(log(huge)) then
        local result = dawson(z) - 0.5 * sqrt(pi) * exp(-sqr(z)) * erfi(z)
        if abs(dawson(z)) > 2 or abs(dawson(z)) < 1 and abs(dawson(z)) > 0 and real(z) ~= tiny then --for x = tiny dawson(x) = x but exp(-sqr(x)) = 0
          result = result / dawson(z)               --relative error
          assertAlmostEquals(real(result), 0, 16*eps)
          assertAlmostEquals(imag(result), 0, 16*eps)
        elseif real(z) ~= tiny then
          assertAlmostEquals(real(result), 0, 3*eps)
          assertAlmostEquals(imag(result), 0, 3*eps)
        end
      end
    end
  end
end

function TestGmath:testTGamma()
  local fact
  fact = \n n <= 1 and 1 or n*fact(n-1)

  -- SetPrecision[Table[Gamma[x],{x, 0.01, 1, 0.03}],20]
  local val1 = {99.432585119150616038, 24.460955022856119001,
  13.773600607733806456, 9.5135076986687305833, 7.2302419210119861503,
  5.8112691664561264560, 4.8467633533349454567, 4.1504815795927783029,
  3.6256099082219082064, 3.2168517018296229892, 2.8903360540117146726,
  2.6241632564984840315, 2.4035500200786530378, 2.2181595437576882013,
  2.0605493863359747309, 1.9252268183155301084, 1.8080512889238926633,
  1.7058438140839640162, 1.6161242687335750645, 1.5369302649435188091,
  1.4666895221797529025, 1.4041281721350677980, 1.3482037306042777836,
  1.2980553326475579023, 1.2529662618990031753, 1.2123353744883700323,
  1.1756550511468120135, 1.1424940039550788295, 1.1124837369484652516,
  1.0853077874677194981, 1.0606931055726904756, 1.0384030930559640105,
  1.0182319420865892923, 1}
  -- SetPrecision[Table[Gamma[x],{x, 1, 10, 0.3}],20]
  local val2 = {1, 0.89747069630627729353,
  0.89351534928769016375, 0.96176583190738740292, 1.1018024908797128258,
  1.3293403881791370225, 1.6764907877644363854, 2.1976202783924772000,
  2.9812064268103326548, 4.1706517837966021744, 6.0000000000000000000,
  8.8553433604540359170, 13.381285870932442705, 20.667385961857860366,
  32.578096050331353695, 52.342777784553518927, 85.621737512705280437,
  142.45194406567867418, 240.83377998344568027, 413.40751676527088421,
  720.00000000000000000, 1271.4236336639089586, 2275.0326986324494101,
  4122.7094842854376111, 7562.2882799713024724, 14034.407293483413014,
  26339.986354508604563, 49973.708949624793604, 95809.457688134469208,
  185550.93597230646992, 362880}
  -- http://oeis.org/A030169
  local xmin, ymin = 1.46163214496836234126, 0.88560319441088870028

  local i
  i=0 for v=0.01,1,0.03 do i=i+1 -- should be done with range
    v=0.01+0.03*(i-1)
    assertAlmostEquals( tgamma(v)/val1[i] -1, 0,   eps )
  end
  i=0 for v=1,10,0.3 do i=i+1 -- should be done with range
    v=1+0.3*(i-1)
    assertAlmostEquals( tgamma(v)/val2[i] -1, 0, 3*eps )
  end

  for n=1,20 do
    assertAlmostEquals( tgamma(n)/fact(n-1)       -1, 0, log(fact(n)) *   eps )
  end
  i=0 for v=1,171.6,0.1 do i=i+1 -- should be done with range
    v=1+0.1*(i-1)
    assertAlmostEquals( tgamma(v)/(tgamma(1+v)/v) -1, 0, log(fact(v)) *11*eps )
  end

  assertEquals( tgamma(  1),    1 )
  assertEquals( tgamma(  2),    1 )
  assertEquals( tgamma(  3),    2 )
  assertEquals( tgamma(  4),    6 )
  assertEquals( tgamma(xmin), ymin )
  assertAlmostEquals( tgamma( 0.5), sqrt(pi), eps )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( tgamma(-  0 ) , -inf )
  assertEquals( tgamma(   0 ) ,  inf )
  assertEquals( tgamma(  inf) ,  inf )
  assertNaN   ( tgamma(-   1) )
  assertNaN   ( tgamma(-   2) )
  assertNaN   ( tgamma(-2^52) )
  assertNaN   ( tgamma(- inf) )
  assertNaN   ( tgamma(  nan) )
end

function TestGmath:testLGamma()
  local lfact
  lfact = \n -> n <= 1 and 0 or log(n)+lfact(n-1)

  -- Note: This test is failing on Ubuntu 14.04 but passes on Ubuntu 22.04.1 LTS
  -- The C function lgamma is returning incorrect values. This might be a
  -- linking problem between mad (luajit) and libm because printing the value
  -- returned in mad_num.c already shows the problem, while a free standing C
  -- application gives correct values, i.e. lgamma itself works fine.

  for n=3,100 do
    assertAlmostEquals( lgamma(n)/lfact(n-1)           -1, 0, 2*eps )
  end
  for v=3,171,0.1 do
    assertAlmostEquals( lgamma(v)/(lgamma(1+v)-log(v)) -1, 0, 4*eps )
  end

  assertEquals( lgamma(-0), inf ) -- could be -inf, fixed in Mac OS 10.14
  assertEquals( lgamma( 0), inf )

  assertAlmostEquals( lgamma(-0.5), 1.265512123484645297, 0)
  assertAlmostEquals( lgamma( 0.5), log(sqrt(pi)), eps )
  assertAlmostEquals( lgamma( 3  ), log(2)       , eps )
  assertAlmostEquals( lgamma( 4  ), log(6)       , eps )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( lgamma(    1) ,    0 )
  assertEquals( lgamma(    2) ,    0 )
  assertEquals( lgamma(- inf) ,  inf )
  assertEquals( lgamma(-2^52) ,  inf )
  assertEquals( lgamma(-   2) ,  inf )
  assertEquals( lgamma(-   1) ,  inf )
  assertEquals( lgamma(  inf) ,  inf )
  assertNaN   ( lgamma(  nan) )
end

function TestGmath:testCarg()
  assertEquals( carg(    0) ,  0 )
  assertEquals( carg( tiny) ,  0 )
  assertEquals( carg(  0.1) ,  0 )
  assertEquals( carg(    1) ,  0 )
  assertEquals( carg( huge) ,  0 )
  assertEquals( carg(  inf) ,  0 )
  assertEquals( carg(-   0) ,  0 )
  assertEquals( carg(-tiny) , pi )
  assertEquals( carg(- 0.1) , pi )
  assertEquals( carg(-   1) , pi )
  assertEquals( carg(-huge) , pi )
  assertEquals( carg(- inf) , pi )
  assertNaN   ( carg(  nan) )
end

function TestGmath:testReal()
  assertEquals( real(    0) ,     0 )
  assertEquals( real( tiny) ,  tiny )
  assertEquals( real(  0.1) ,   0.1 )
  assertEquals( real(    1) ,     1 )
  assertEquals( real( huge) ,  huge )
  assertEquals( real(  inf) ,   inf )
  assertEquals( real(-   0) , -   0 )
  assertEquals( real(-tiny) , -tiny )
  assertEquals( real(- 0.1) , - 0.1 )
  assertEquals( real(-   1) , -   1 )
  assertEquals( real(-huge) , -huge )
  assertEquals( real(- inf) , - inf )
  assertNaN   ( real(  nan) )
end

function TestGmath:testImag()
  assertEquals( imag(    0) , 0 )
  assertEquals( imag( tiny) , 0 )
  assertEquals( imag(  0.1) , 0 )
  assertEquals( imag(    1) , 0 )
  assertEquals( imag( huge) , 0 )
  assertEquals( imag(  inf) , 0 )
  assertEquals( imag(-   0) , 0 )
  assertEquals( imag(-tiny) , 0 )
  assertEquals( imag(- 0.1) , 0 )
  assertEquals( imag(-   1) , 0 )
  assertEquals( imag(-huge) , 0 )
  assertEquals( imag(- inf) , 0 )
  assertEquals( imag(  nan) , 0 )
end

function TestGmath:testConj()
  assertEquals( conj(    0) ,     0 )
  assertEquals( conj( tiny) ,  tiny )
  assertEquals( conj(  0.1) ,   0.1 )
  assertEquals( conj(    1) ,     1 )
  assertEquals( conj( huge) ,  huge )
  assertEquals( conj(  inf) ,   inf )
  assertEquals( conj(-   0) , -   0 )
  assertEquals( conj(-tiny) , -tiny )
  assertEquals( conj(- 0.1) , - 0.1 )
  assertEquals( conj(-   1) , -   1 )
  assertEquals( conj(-huge) , -huge )
  assertEquals( conj(- inf) , - inf )
  assertNaN   ( conj(  nan) )
end

function TestGmath:testProj()
  assertEquals( proj(    0) ,     0+0i )
  assertEquals( proj( tiny) ,  tiny+0i )
  assertEquals( proj(  0.1) ,   0.1+0i )
  assertEquals( proj(    1) ,     1+0i )
  assertEquals( proj( huge) ,  huge+0i )
  assertEquals( proj(  inf) ,   inf+0i )
  assertEquals( proj(-   0) ,     0+0i )
  assertEquals( proj(-tiny) , -tiny+0i )
  assertEquals( proj(- 0.1) , - 0.1+0i )
  assertEquals( proj(-   1) , -   1+0i )
  assertEquals( proj(-huge) , -huge+0i )
  assertEquals( proj(- inf) ,   inf+0i )

  assertEquals( strtrim(tostring(proj(nan))), 'nan+0i' )

  assertEquals( proj(    0+1i) ,     0+1i )
  assertEquals( proj( tiny+1i) ,  tiny+1i )
  assertEquals( proj(  0.1+1i) ,   0.1+1i )
  assertEquals( proj(    1+1i) ,     1+1i )
  assertEquals( proj( huge+1i) ,  huge+1i )
  assertEquals( proj(  inf+1i) ,   inf+0i )
  assertEquals( proj(-   0+1i) ,     0+1i )
  assertEquals( proj(-tiny+1i) , -tiny+1i )
  assertEquals( proj(- 0.1+1i) , - 0.1+1i )
  assertEquals( proj(-   1+1i) , -   1+1i )
  assertEquals( proj(-huge+1i) , -huge+1i )
  assertEquals( proj(- inf+1i) ,   inf+0i )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( proj(inf+2i) , inf+0i )
  assertEquals( proj(inf-2i) , inf-0i )
  assertEquals( proj(2+infi) , inf+0i )
  assertEquals( proj(2-infi) , inf-0i )

  assertEquals( proj(nan+infi), inf+0i )
  assertEquals( proj(nan-infi), inf+0i )
end

function TestGmath:testRect()
  assertEquals( 1/rect(    0) ,   inf ) -- check for +0
  assertEquals(   rect( tiny) ,  tiny )
  assertEquals(   rect(  0.1) ,   0.1 )
  assertEquals(   rect(    1) ,     1 )
  assertEquals(   rect( huge) ,  huge )
  assertEquals(   rect(  inf) ,   inf )
  assertEquals( 1/rect(-   0) , - inf ) -- check for -0 :: jit(rand) -> inf [BUG]
  assertEquals(   rect(-tiny) , -tiny )
  assertEquals(   rect(- 0.1) , - 0.1 )
  assertEquals(   rect(-   1) , -   1 )
  assertEquals(   rect(-huge) , -huge )
  assertEquals(   rect(- inf) , - inf )
  assertNaN   ( rect(  nan) )
end

function TestGmath:testPolar()
  assertEquals( polar(    0) ,    0+0i )
  assertEquals( polar( tiny) , tiny+0i )
  assertEquals( polar(  0.1) ,  0.1+0i )
  assertEquals( polar(    1) ,    1+0i )
  assertEquals( polar( huge) , huge+0i )
  assertEquals( polar(  inf) ,  inf+0i )
  assertEquals( polar(-   0) ,    0+0i )
  assertEquals( polar(-tiny) , tiny+pi*1i )
  assertEquals( polar(- 0.1) ,  0.1+pi*1i )
  assertEquals( polar(-   1) ,    1+pi*1i )
  assertEquals( polar(-huge) , huge+pi*1i )
  assertEquals( polar(- inf) ,  inf+pi*1i )

  assertEquals( strtrim(tostring(polar(nan))), 'nan+nani' )
end

function TestGmath:testAtan2()
  for _,v in ipairs(values.rad2) do
    local x, y = cos(v), sin(v)
    assertAlmostEquals( atan2(y,x) - (pi/2-atan2( x,  y)), 0,   eps )
    assertAlmostEquals( atan2(y,x) - (pi  -atan2( y, -x)), 0, 2*eps )
    assertAlmostEquals( atan2(y,x) -      -atan2(-y,  x) , 0,   eps )
    assertAlmostEquals( atan2(y,x) - (pi  +atan2(-y, -x)), 0, 2*eps )
    if v > 0 then
      assertAlmostEquals( atan2(y,x) / atan (y/x), 1, eps )
    end
  end

  for _,x in ipairs(values.num) do
  for _,y in ipairs(values.num) do
    if x > 0 or y > 0 then
    assertAlmostEquals( atan2(y,x) - (pi/2-atan2( x,  y)), 0, 2*eps )
    end
    assertAlmostEquals( atan2(y,x) - (pi  -atan2( y, -x)), 0, 2*eps )
    assertAlmostEquals( atan2(y,x) -      -atan2(-y,  x) , 0,   eps )
    assertAlmostEquals( atan2(y,x) - (pi  +atan2(-y, -x)), 0, 2*eps )
  end end

  assertEquals( atan2(    1,    0),  pi/2   )
  assertEquals( atan2( -  1,    0), -pi/2   )
  assertEquals( atan2(  inf,    0),  pi/2   )
  assertEquals( atan2( -inf,    0), -pi/2   )
  assertEquals( atan2(    0,    1),  0      )
  assertEquals( atan2(    1,    1),  pi/4   )
  assertEquals( atan2( -  1,    1), -pi/4   )
  assertEquals( atan2(  inf,    1),  pi/2   )
  assertEquals( atan2( -inf,    1), -pi/2   )
  assertEquals( atan2(    0, -  1),  pi     )
  assertEquals( atan2(    1, -  1),  pi/4*3 )
  assertEquals( atan2( -  1, -  1), -pi/4*3 )
  assertEquals( atan2(  inf, -  1),  pi/2   )
  assertEquals( atan2( -inf, -  1), -pi/2   )
  assertEquals( atan2(    0,  inf),  0      )
  assertEquals( atan2(    1,  inf),  0      )
  assertEquals( atan2( -  1,  inf),  0      )
  assertEquals( atan2(    0, -inf),  pi     )
  assertEquals( atan2(    1, -inf),  pi     )
  assertEquals( atan2( -  1, -inf), -pi     )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals(  atan2(-0 ,-0   ) , -pi   )
  assertEquals(  atan2( 0 ,-0   ) ,  pi   )
  assertEquals(1/atan2(-0 , 0   ) , -inf  ) -- check for -0
  assertEquals(1/atan2( 0 , 0   ) ,  inf  ) -- check for +0
  assertEquals(  atan2(-0 ,-tiny) , -pi   )
  assertEquals(  atan2( 0 ,-tiny) ,  pi   )
  assertEquals(  atan2(-0 ,-1   ) , -pi   )
  assertEquals(  atan2( 0 ,-1   ) ,  pi   )
  assertEquals(  atan2(-0 ,-huge) , -pi   )
  assertEquals(  atan2( 0 ,-huge) ,  pi   )
  assertEquals(1/atan2(-0 , tiny) , -inf  ) -- check for -0
  assertEquals(1/atan2( 0 , tiny) ,  inf  ) -- check for +0
  assertEquals(1/atan2(-0 , 1   ) , -inf  ) -- check for -0
  assertEquals(1/atan2( 0 , 1   ) ,  inf  ) -- check for +0
  assertEquals(1/atan2(-0 , huge) , -inf  ) -- check for -0
  assertEquals(1/atan2( 0 , huge) ,  inf  ) -- check for +0
  assertEquals(  atan2(-tiny, -0) , -pi/2 )
  assertEquals(  atan2(-tiny,  0) , -pi/2 )
  assertEquals(  atan2(-1   , -0) , -pi/2 )
  assertEquals(  atan2(-1   ,  0) , -pi/2 )
  assertEquals(  atan2(-huge, -0) , -pi/2 )
  assertEquals(  atan2(-huge,  0) , -pi/2 )
  assertEquals(  atan2( tiny, -0) ,  pi/2 )
  assertEquals(  atan2( tiny,  0) ,  pi/2 )
  assertEquals(  atan2( 1   , -0) ,  pi/2 )
  assertEquals(  atan2( 1   ,  0) ,  pi/2 )
  assertEquals(  atan2( huge, -0) ,  pi/2 )
  assertEquals(  atan2( huge,  0) ,  pi/2 )

  assertEquals(  atan2(-tiny, -inf) , -pi )
  assertEquals(  atan2(-1   , -inf) , -pi )
  assertEquals(  atan2(-huge, -inf) , -pi )
  assertEquals(  atan2( tiny, -inf) ,  pi )
  assertEquals(  atan2( 1   , -inf) ,  pi )
  assertEquals(  atan2( huge, -inf) ,  pi )
  assertEquals(1/atan2(-tiny,  inf) , -inf ) -- check for -0
  assertEquals(1/atan2(-1   ,  inf) , -inf ) -- check for +0
  assertEquals(1/atan2(-huge,  inf) , -inf ) -- check for -0
  assertEquals(1/atan2( tiny,  inf) ,  inf ) -- check for +0
  assertEquals(1/atan2( 1   ,  inf) ,  inf ) -- check for -0
  assertEquals(1/atan2( huge,  inf) ,  inf ) -- check for +0
  assertEquals(  atan2(-inf, -0   ) , -pi/2 )
  assertEquals(  atan2(-inf, -tiny) , -pi/2 )
  assertEquals(  atan2(-inf, -1   ) , -pi/2 )
  assertEquals(  atan2(-inf, -huge) , -pi/2 )
  assertEquals(  atan2(-inf,  0   ) , -pi/2 )
  assertEquals(  atan2(-inf,  tiny) , -pi/2 )
  assertEquals(  atan2(-inf,  1   ) , -pi/2 )
  assertEquals(  atan2(-inf,  huge) , -pi/2 )
  assertEquals(  atan2( inf, -0   ) ,  pi/2 )
  assertEquals(  atan2( inf, -tiny) ,  pi/2 )
  assertEquals(  atan2( inf, -1   ) ,  pi/2 )
  assertEquals(  atan2( inf, -huge) ,  pi/2 )
  assertEquals(  atan2( inf,  0   ) ,  pi/2 )
  assertEquals(  atan2( inf,  tiny) ,  pi/2 )
  assertEquals(  atan2( inf,  1   ) ,  pi/2 )
  assertEquals(  atan2( inf,  huge) ,  pi/2 )
  assertEquals(  atan2( inf,  -inf) , 3*pi/4 )
  assertEquals(  atan2(-inf,  -inf) ,-3*pi/4 )
  assertEquals(  atan2( inf,   inf) ,   pi/4 )
  assertEquals(  atan2(-inf,   inf) ,-  pi/4 )

  assertNaN   (  atan2( nan,  0 ) )
  assertNaN   (  atan2(  0 , nan) )
  assertNaN   (  atan2( nan, nan) )
end

function TestGmath:testRangle()
  for _,a in ipairs(values.rad) do
    for _,r in ipairs(values.num) do
      assertEquals(rangle(a, r), a + 2*pi*round((r - a)/(2*pi)))
    end
  end
end

function TestGmath:testArc2cord()
  for _,a in ipairs(values.rad) do
    for _,l in ipairs(values.num) do
      assertEquals(arc2cord(l, a), l*sinc(a/2))
      if a ~= 0 and l > tiny and l < huge then --For a == 0, sinc(a) = 1 and for l = huge and a << 1, 2*l/a = inf, but arc2cord == l as sinc(a) = 1; also for l=0, can't for relative error
        assertAlmostEquals((arc2cord(l, a) - 2*l/a * sin(a/2)) / arc2cord(l, a), 0)
      elseif l < huge then --for when a == 0 and l is tiny, we get l
        assertAlmostEquals(arc2cord(l, a), l)
      end
    end
  end
end

function TestGmath:testArc2len()
  for _,a in ipairs(values.rad) do
    for _,l in ipairs(values.num) do
      assertEquals(arc2len(l, a), l*sinc(a/2)*cos(a))
      if a ~= 0 and l > tiny and l < huge then 
        assertAlmostEquals((arc2len(l, a) - 2*l/a * sin(a/2) * cos(a)) / arc2len(l, a), 0)
      elseif l < huge then
        assertAlmostEquals(arc2len(l, a), l)
      end
    end
  end
end

function TestGmath:testCord2Arc()
  for _,a in ipairs(values.rad) do
    for _,l in ipairs(values.num) do
      assertEquals(cord2arc(l, a), l/sinc(a/2))
      if a ~= 0 and l > tiny and l < huge then 
        assertAlmostEquals((cord2arc(l, a) - (l * a / 2) / sin(a/2)) / cord2arc(l, a), 0)
      elseif l < huge then --for when a == 0 and l is tiny, we get l
        assertAlmostEquals(cord2arc(l, a), l)
      end
    end
  end
end

function TestGmath:testCord2len()
  for _,a in ipairs(values.rad) do
    for _,l in ipairs(values.num) do
      assertEquals(cord2len(l, a), l*cos(a))
    end
  end
end

function TestGmath:testLen2arc()
  for _,a in ipairs(values.rad) do
    for _,l in ipairs(values.num) do
      assertEquals(len2arc(l, a), l/(sinc(a/2)*cos(a)))
      if a ~= 0 and l > tiny and l < huge then 
        assertAlmostEquals((len2arc(l, a) - l / ( 2 / a * sin(a/2) * cos(a))) / len2arc(l, a), 0)
      elseif l < huge then
        assertAlmostEquals(len2arc(l, a), l)
      end
    end
  end
end

function TestGmath:testLen2cord()
  for _,a in ipairs(values.rad) do
    for _,l in ipairs(values.num) do
      assertEquals(len2cord(l, a), l/cos(a))
    end
  end
end

function TestGmath:testSumsqr()
  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      if x > tiny or y > tiny or x < huge or y < huge then
        assertEquals(sumsqr(x,y), x^2 + y^2)
        assertEquals(sumsqr(x,-y), x^2 + y^2)
      end
    end
    assertEquals(sumsqr(-x, 0), x*x)  
  end
  assertEquals(sumsqr(inf, 23), inf)
  assertNaN(sumsqr(inf, nan))
end

function TestGmath:testSumabs()
  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      if x < huge or y < huge then
        assertEquals(sumabs(x,y), abs(x) + abs(y))
        assertEquals(sumabs(-x,y), abs(x) + abs(y))
        assertEquals(sumabs(x,-y), abs(x) + abs(y))
      end
    end
    assertEquals(sumabs(-x, 0), x)  
  end
  assertEquals(sumabs(inf, 23), inf)
  assertNaN(sumabs(inf, nan))
end

function TestGmath:testDeg2rad()
  for _,x in ipairs(values.deg) do
    assertEquals(rad(x), x * pi/180)
  end
end

function TestGmath:testRad2deg()
  for _,x in ipairs(values.rad) do
    local expected = x * 180/pi
    if x > 0 then
      assertAlmostEquals((deg(x) - expected)/expected, 0, eps) -- Relative error
    else
      assertAlmostEquals(deg(x) - expected, 0, eps)
    end
  end
end

function TestGmath:testLdexp()
  for i,v in ipairs(values.num) do
    assertEquals( ldexp(v,  i), v*2^ i )
    assertEquals( ldexp(v, -i), v*2^-i )
    assertEquals( ldexp(v,  0), v )
    assertEquals( ldexp(0,  i), 0 )
  end
  for i,v in ipairs(values.rad) do
    assertEquals( ldexp(v,  i), v*2^ i )
    assertEquals( ldexp(v, -i), v*2^-i )
    assertEquals( ldexp(v,  0), v )
    assertEquals( ldexp(0,  i), 0 )
  end

  assertEquals( ldexp( 3  , 1.9),    6 )
  assertEquals( ldexp( 3  , 2.1),   12 )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( 1/ldexp(-   0,    0) , - inf )
  assertEquals( 1/ldexp(    0,    0) ,   inf )
  assertEquals( 1/ldexp(-   0, tiny) , - inf )
  assertEquals( 1/ldexp(    0, tiny) ,   inf )
  assertEquals( 1/ldexp(-   0, huge) , - inf )
  assertEquals( 1/ldexp(    0, huge) ,   inf )
  assertEquals(   ldexp(-tiny,    0) , -tiny )
  assertEquals(   ldexp( tiny,    0) ,  tiny )
  assertEquals(   ldexp(-huge,    0) , -huge )
  assertEquals(   ldexp( huge,    0) ,  huge )
  assertEquals(   ldexp(- inf,    0) , - inf )
  assertEquals(   ldexp(  inf,    0) ,   inf )
  assertEquals(   ldexp(- inf, tiny) , - inf )
  assertEquals(   ldexp(  inf, tiny) ,   inf )
  assertEquals(   ldexp(- inf, huge) , - inf )
  assertEquals(   ldexp(  inf, huge) ,   inf )
  assertNaN   (   ldexp(  nan,    0) )
  assertNaN   (   ldexp(  nan,    1) )
  assertNaN   (   ldexp(  nan,  inf) )
  assertNaN   (   ldexp(  nan,  nan) )
end

function TestGmath:testFrexp()
  assertEquals( {frexp(0)}, {0,0} )
  assertEquals( {frexp(1)}, {0.5,1} )

  for i=-100,100 do
    assertEquals( ldexp(frexp(2^i)), 2^i )
  end
  for x=-100,100,0.1 do
    assertEquals( ldexp(frexp(x)), x )
  end

  assertEquals( {frexp(- 0.2)}, {-0.8  , -   2} )
  assertEquals( {frexp( tiny)}, { 0.5  , -1021} )
  assertEquals( {frexp(  eps)}, { 0.5  , -  51} )
  assertEquals( {frexp(  0.1)}, { 0.8  , -   3} )
  assertEquals( {frexp(  0.7)}, { 0.7  ,     0} )
  assertEquals( {frexp(  1  )}, { 0.5  ,     1} )
  assertEquals( {frexp(  1.1)}, { 0.55 ,     1} )
  assertEquals( {frexp(  1.7)}, { 0.85  ,    1} )
  assertEquals( {frexp(  2.1)}, { 0.525,     2} )

  local f,e
  f,e = frexp(1-eps)
  assertEquals( 1 , 1 )
  assertEquals( 0 , 0 )
  f,e = frexp(1+eps)
  assertEquals( 1 , 1 )
  assertEquals( 0 , 0 )
  f,e = frexp(huge)
  assertAlmostEquals( f - 1    , 0, eps)
  assertEquals      ( e - 1024 , 0     )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( 1/frexp(- 0) ,  -inf     ) -- check for -0
  assertEquals( 1/frexp(  0) ,   inf     ) -- check for +0
  assertEquals( {frexp(-  0)}, {   0, 0} )
  assertEquals( {frexp(   0)}, {   0, 0} )
  assertEquals( {frexp(-inf)}, {-inf, 0} )
  assertEquals( {frexp( inf)}, { inf, 0} )

  assertNaN   (  frexp(nan,   0) )
  assertNaN   (  frexp(nan, inf) )
  assertNaN   (  frexp(nan, nan) )
end

function TestGmath:testFPow()
  local pow = math.pow

  for _,x in ipairs(values.num) do
  for _,y in ipairs(values.num) do
    if x > 1/709.78 and y > 1/709.78 and x < 709.78 and y < 709.78 then
      assertAlmostEquals( log(pow(x,y)) - y*log(x), 0, max(abs(y*log(x)) * eps, 4*eps) ) -- 64*eps?
    end
  end end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals(   pow(  0 , - 11),  inf )
  assertEquals(   pow(- 0 , - 11), -inf )

  assertEquals(   pow(  0 , - .5),  inf )
  assertEquals(   pow(- 0 , - .5),  inf )
  assertEquals(   pow(  0 , -  2),  inf )
  assertEquals(   pow(- 0 , -  2),  inf )
  assertEquals(   pow(  0 , - 10),  inf )
  assertEquals(   pow(- 0 , - 10),  inf )

  assertEquals( 1/pow(  0 ,    1),  inf ) -- check for +0
  assertEquals( 1/pow(- 0 ,    1), -inf ) -- check for -0
  assertEquals( 1/pow(  0 ,   11),  inf ) -- check for +0
  assertEquals( 1/pow(- 0 ,   11), -inf ) -- check for -0

  assertEquals( 1/pow(  0 ,  0.5),  inf ) -- check for +0
  assertEquals( 1/pow(- 0 ,  0.5),  inf ) -- check for +0
  assertEquals( 1/pow(  0 ,    2),  inf ) -- check for +0
  assertEquals( 1/pow(- 0 ,    2),  inf ) -- check for +0
  assertEquals( 1/pow(  0 ,   10),  inf ) -- check for +0
  assertEquals( 1/pow(- 0 ,   10),  inf ) -- check for +0
  assertEquals( 1/pow(  0 ,  inf),  inf ) -- check for +0
  assertEquals( 1/pow(- 0 ,  inf),  inf ) -- check for +0

  assertEquals(   pow(- 1 ,  inf),   1  )
  assertEquals(   pow(- 1 , -inf),   1  )

  assertEquals(   pow(  1 ,   0 ),   1  )
  assertEquals(   pow(  1 , - 0 ),   1  )
  assertEquals(   pow(  1 ,  0.5),   1  )
  assertEquals(   pow(  1 , -0.5),   1  )
  assertEquals(   pow(  1 ,   1 ),   1  )
  assertEquals(   pow(  1 , - 1 ),   1  )
  assertEquals(   pow(  1 ,  inf),   1  )
  assertEquals(   pow(  1 , -inf),   1  )
  assertEquals(   pow(  1 ,  nan),   1  )
  assertEquals(   pow(  1 , -nan),   1  )

  assertEquals(   pow(  0 ,   0 ),   1  )
  assertEquals(   pow(- 0 ,   0 ),   1  )
  assertEquals(   pow( 0.5,   0 ),   1  )
  assertEquals(   pow(-0.5,   0 ),   1  )
  assertEquals(   pow(  1 ,   0 ),   1  )
  assertEquals(   pow(- 1 ,   0 ),   1  )
  assertEquals(   pow( inf,   0 ),   1  )
  assertEquals(   pow(-inf,   0 ),   1  )
  assertEquals(   pow( nan,   0 ),   1  )
  assertEquals(   pow(-nan,   0 ),   1  )

  assertEquals(   pow(  0 , - 0 ),   1  )
  assertEquals(   pow(- 0 , - 0 ),   1  )
  assertEquals(   pow( 0.5, - 0 ),   1  )
  assertEquals(   pow(-0.5, - 0 ),   1  )
  assertEquals(   pow(  1 , - 0 ),   1  )
  assertEquals(   pow(- 1 , - 0 ),   1  )
  assertEquals(   pow( inf, - 0 ),   1  )
  assertEquals(   pow(-inf, - 0 ),   1  )
  assertEquals(   pow( nan, - 0 ),   1  )
  assertEquals(   pow(-nan, - 0 ),   1  )

  assertNaN   (   pow(- 1 ,  0.5))
  assertNaN   (   pow(- 1 , -0.5))
  assertNaN   (   pow(- 1 ,  1.5))
  assertNaN   (   pow(- 1 , -1.5))

  assertEquals(   pow(  0   , -inf),  inf )
  assertEquals(   pow(- 0   , -inf),  inf )
  assertEquals(   pow( 0.5  , -inf),  inf )
  assertEquals(   pow(-0.5  , -inf),  inf )
  assertEquals(   pow( 1-eps, -inf),  inf )
  assertEquals(   pow(-1+eps, -inf),  inf )

  assertEquals( 1/pow( 1+eps, -inf),  inf ) -- check for +0
  assertEquals( 1/pow(-1-eps, -inf),  inf ) -- check for +0
  assertEquals( 1/pow( 1.5  , -inf),  inf ) -- check for +0
  assertEquals( 1/pow(-1.5  , -inf),  inf ) -- check for +0
  assertEquals( 1/pow( inf  , -inf),  inf ) -- check for +0
  assertEquals( 1/pow(-inf  , -inf),  inf ) -- check for +0

  assertEquals( 1/pow(  0   ,  inf),  inf ) -- check for +0
  assertEquals( 1/pow(- 0   ,  inf),  inf ) -- check for +0
  assertEquals( 1/pow( 0.5  ,  inf),  inf ) -- check for +0
  assertEquals( 1/pow(-0.5  ,  inf),  inf ) -- check for +0
  assertEquals( 1/pow( 1-eps,  inf),  inf ) -- check for +0
  assertEquals( 1/pow(-1+eps,  inf),  inf ) -- check for +0

  assertEquals(   pow( 1+eps,  inf),  inf )
  assertEquals(   pow(-1-eps,  inf),  inf )
  assertEquals(   pow( 1.5  ,  inf),  inf )
  assertEquals(   pow(-1.5  ,  inf),  inf )
  assertEquals(   pow( inf  ,  inf),  inf )
  assertEquals(   pow(-inf  ,  inf),  inf )

  assertEquals( 1/pow(-inf, -  1), -inf ) -- check for -0
  assertEquals( 1/pow(-inf, - 11), -inf ) -- check for -0
  assertEquals( 1/pow(-inf, -0.5),  inf ) -- check for +0
  assertEquals( 1/pow(-inf, -  2),  inf ) -- check for +0
  assertEquals( 1/pow(-inf, - 10),  inf ) -- check for +0

  assertEquals(   pow(-inf,    1), -inf )
  assertEquals(   pow(-inf,   11), -inf )
  assertEquals(   pow(-inf,  0.5),  inf )
  assertEquals(   pow(-inf,    2),  inf )
  assertEquals(   pow(-inf,   10),  inf )

  assertEquals( 1/pow( inf, -0.5),  inf ) -- check for +0
  assertEquals( 1/pow( inf, -  1),  inf ) -- check for +0
  assertEquals( 1/pow( inf, -  2),  inf ) -- check for +0
  assertEquals( 1/pow( inf, - 10),  inf ) -- check for +0
  assertEquals( 1/pow( inf, - 11),  inf ) -- check for +0

  assertEquals(   pow( inf,  0.5),  inf )
  assertEquals(   pow( inf,    1),  inf )
  assertEquals(   pow( inf,    2),  inf )
  assertEquals(   pow( inf,   10),  inf )
  assertEquals(   pow( inf,   11),  inf )

  assertNaN   (   pow( 0  ,  nan) )
  assertNaN   (   pow(-0  ,  nan) )
  assertNaN   (   pow( 0  , -nan) )
  assertNaN   (   pow(-0  , -nan) )
  assertNaN   (   pow(-1  ,  nan) )
  assertNaN   (   pow(-1  , -nan) )
  assertNaN   (   pow( nan,   1 ) )
  assertNaN   (   pow(-nan,   1 ) )
  assertNaN   (   pow( nan, - 1 ) )
  assertNaN   (   pow(-nan, - 1 ) )
  assertNaN   (   pow( inf,  nan) )
  assertNaN   (   pow(-inf,  nan) )
  assertNaN   (   pow( inf, -nan) )
  assertNaN   (   pow(-inf, -nan) )
  assertNaN   (   pow( nan,  inf) )
  assertNaN   (   pow(-nan,  inf) )
  assertNaN   (   pow( nan, -inf) )
  assertNaN   (   pow(-nan, -inf) )
  assertNaN   (   pow( nan,  nan) )
  assertNaN   (   pow(-nan,  nan) )
  assertNaN   (   pow( nan, -nan) )
  assertNaN   (   pow(-nan, -nan) )
end

function TestGmath:testFMod()
  local e, n, f, r
  for _,x in ipairs(values.num) do
  for _,y in ipairs(values.num) do
    if x < y then
      assertEquals( fmod( x, y),  x )
      assertEquals( fmod(-x, y), -x )
      assertEquals( fmod( x,-y),  x )
      assertEquals( fmod(-x,-y), -x )
    elseif y/x >= tiny/eps and x < inf and y < inf then
      n = floor(x/y)
      f = fmod(x,y)
      r = x - (n*y + f)
      if r < 0 then r = r+y end
      e = n * eps / 10
      assertTrue( 0 <= f and f < y )
      assertTrue( r < e )
    end
  end end

  assertAlmostEquals( fmod(-5.1, -3  ) - -2.1, 0, 2*eps)
  assertAlmostEquals( fmod(-5.1,  3  ) - -2.1, 0, 2*eps)
  assertAlmostEquals( fmod( 5.1, -3  ) -  2.1, 0, 2*eps)
  assertAlmostEquals( fmod( 5.1,  3  ) -  2.1, 0, 2*eps)

  assertAlmostEquals( fmod(-5.1, -3.1) - -2  , 0, 2*eps)
  assertAlmostEquals( fmod(-5.1,  3.1) - -2  , 0, 2*eps)
  assertAlmostEquals( fmod( 5.1, -3.1) -  2  , 0, 2*eps)
  assertAlmostEquals( fmod( 5.1,  3.1) -  2  , 0, 2*eps)

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( 1/fmod(- 0,  0.5), -inf) -- check for -0 :: jit -> inf [BUG]
  assertEquals( 1/fmod(  0,  0.5),  inf) -- check for +0
  assertEquals( 1/fmod(- 0, -0.5), -inf) -- check for -0 :: jit -> inf [BUG]
  assertEquals( 1/fmod(  0, -0.5),  inf) -- check for +0
  assertEquals( 1/fmod(- 0,  1  ), -inf) -- check for -0 :: jit -> inf [BUG]
  assertEquals( 1/fmod(  0,  1  ),  inf) -- check for +0
  assertEquals( 1/fmod(- 0, -1  ), -inf) -- check for -0 :: jit -> inf [BUG]
  assertEquals( 1/fmod(  0, -1  ),  inf) -- check for +0
  assertEquals( 1/fmod(- 0,  10 ), -inf) -- check for -0 :: jit -> inf [BUG]
  assertEquals( 1/fmod(  0,  10 ),  inf) -- check for +0
  assertEquals( 1/fmod(- 0, -10 ), -inf) -- check for -0 :: jit -> inf [BUG]
  assertEquals( 1/fmod(  0, -10 ),  inf) -- check for +0

  assertEquals(  fmod( 0.5,  inf),  0.5)
  assertEquals(  fmod(-0.5,  inf), -0.5)
  assertEquals(  fmod( 0.5, -inf),  0.5)
  assertEquals(  fmod(-0.5, -inf), -0.5)
  assertEquals(  fmod( 1  ,  inf),  1  )
  assertEquals(  fmod(-1  ,  inf), -1  )
  assertEquals(  fmod( 1  , -inf),  1  )
  assertEquals(  fmod(-1  , -inf), -1  )
  assertEquals(  fmod( 10 ,  inf),  10 )
  assertEquals(  fmod(-10 ,  inf), -10 )
  assertEquals(  fmod( 10 , -inf),  10 )
  assertEquals(  fmod(-10 , -inf), -10 )

  assertNaN   ( fmod( inf,  0.5) )
  assertNaN   ( fmod( inf, -0.5) )
  assertNaN   ( fmod(-inf,  0.5) )
  assertNaN   ( fmod(-inf, -0.5) )
  assertNaN   ( fmod( inf,  1  ) )
  assertNaN   ( fmod( inf, -1  ) )
  assertNaN   ( fmod(-inf,  1  ) )
  assertNaN   ( fmod(-inf, -1  ) )
  assertNaN   ( fmod( inf,  10 ) )
  assertNaN   ( fmod( inf, -10 ) )
  assertNaN   ( fmod(-inf,  10 ) )
  assertNaN   ( fmod(-inf, -10 ) )
  assertNaN   ( fmod( 0.5,  0  ) )
  assertNaN   ( fmod(-0.5,  0  ) )
  assertNaN   ( fmod( 0.5, -0  ) )
  assertNaN   ( fmod(-0.5, -0  ) )
  assertNaN   ( fmod( 1  ,  0  ) )
  assertNaN   ( fmod(-1  ,  0  ) )
  assertNaN   ( fmod( 1  , -0  ) )
  assertNaN   ( fmod(-1  , -0  ) )
  assertNaN   ( fmod( 10 ,  0  ) )
  assertNaN   ( fmod(-10 ,  0  ) )
  assertNaN   ( fmod( 10 , -0  ) )
  assertNaN   ( fmod(-10 , -0  ) )
  assertNaN   ( fmod( inf,  inf) )
  assertNaN   ( fmod(-inf,  inf) )
  assertNaN   ( fmod( inf, -inf) )
  assertNaN   ( fmod(-inf, -inf) )
  assertNaN   ( fmod( nan,  nan) )
  assertNaN   ( fmod(-nan,  nan) )
  assertNaN   ( fmod( nan, -nan) )
  assertNaN   ( fmod(-nan, -nan) )
end

function TestGmath:testModf()
  local s=\n,f n+f

  for _,v in ipairs(values.num) do
    if v == inf then break end
    assertEquals( s(modf( v+eps)),  v+eps )
    assertEquals( s(modf( v-eps)),  v-eps )
    assertEquals( s(modf(-v+eps)), -v+eps )
    assertEquals( s(modf(-v-eps)), -v-eps )
    assertEquals( s(modf( v+0.1)),  v+0.1 )
    assertEquals( s(modf( v-0.1)),  v-0.1 )
    assertEquals( s(modf(-v+0.1)), -v+0.1 )
    assertEquals( s(modf(-v-0.1)), -v-0.1 )
    assertEquals( s(modf( v+0.7)),  v+0.7 )
    assertEquals( s(modf( v-0.7)),  v-0.7 )
    assertEquals( s(modf(-v+0.7)), -v+0.7 )
    assertEquals( s(modf(-v-0.7)), -v-0.7 )
  end
  assertEquals( {modf(    0)} , {    0,     0} )
  assertEquals( {modf( tiny)} , {    0,  tiny} )
  assertEquals( {modf(  0.1)} , {    0,   0.1} )
  assertEquals( {modf(  0.5)} , {    0,   0.5} )
  assertEquals( {modf(  0.7)} , {    0,   0.7} )
  assertEquals( {modf(    1)} , {    1,     0} )
  assertEquals( {modf(  1.5)} , {    1,   0.5} )
  assertEquals( {modf(  1.7)} , {    1,   0.7} )
  assertEquals( {modf( huge)} , { huge,     0} )
  assertEquals( {modf(  inf)} , {  inf,     0} )
  assertEquals( {modf(-   0)} , {    0, -   0} )
  assertEquals( {modf(-tiny)} , {    0, -tiny} )
  assertEquals( {modf(- 0.1)} , {-   0, - 0.1} )
  assertEquals( {modf(- 0.5)} , {-   0, - 0.5} )
  assertEquals( {modf(- 0.7)} , {-   0, - 0.7} )
  assertEquals( {modf(-   1)} , {-   1, -   0} )
  assertEquals( {modf(- 1.5)} , {-   1, - 0.5} )
  assertEquals( {modf(- 1.7)} , {-   1, - 0.7} )
  assertEquals( {modf(-huge)} , {-huge, -   0} )
  assertEquals( {modf(- inf)} , {- inf, -   0} )

  local n,f
  n,f=modf( 1.1) assertEquals(n,  1) assertAlmostEquals( f-0.1, 0, eps/2 )
  n,f=modf(-1.1) assertEquals(n, -1) assertAlmostEquals( f+0.1, 0, eps/2 )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals(    first(modf(-huge)) , -huge )
  assertEquals(    first(modf( huge)) ,  huge )
  assertEquals( 1/second(modf(-huge)) , -inf  ) -- check for -0
  assertEquals( 1/second(modf( huge)) ,  inf  ) -- check for +0
  assertEquals(    first(modf(-inf )) , -inf  )
  assertEquals(    first(modf( inf )) ,  inf  )
  assertEquals( 1/second(modf(-inf )) , -inf  ) -- check for -0
  assertEquals( 1/second(modf( inf )) ,  inf  ) -- check for +0
  assertNaN   (    first(modf( nan )) )
  assertNaN   (   second(modf( nan )) )
end

function TestGmath:testMax()
  assertEquals( max(table.unpack(values.num )), inf  )
  assertEquals( max(table.unpack(values.rad )),  pi  )
  assertEquals( max(table.unpack(values.deg )), 180  )
  assertEquals( max(table.unpack(values.rad2)),  pi/2)
  assertEquals( max(table.unpack(values.deg2)),  90  )
  local t1, t2, t3, t4, t5 = {}, {}, {}, {}, {}
  for i,v in ipairs(values.num ) do t1[i] = -v end
  for i,v in ipairs(values.rad ) do t2[i] = -v end
  for i,v in ipairs(values.deg ) do t3[i] = -v end
  for i,v in ipairs(values.rad2) do t4[i] = -v end
  for i,v in ipairs(values.deg2) do t5[i] = -v end
  assertEquals( max(table.unpack(t1)), 0 )
  assertEquals( max(table.unpack(t2)), 0 )
  assertEquals( max(table.unpack(t3)), 0 )
  assertEquals( max(table.unpack(t4)), 0 )
  assertEquals( max(table.unpack(t5)), 0 )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( max(nan, -inf), -inf )
  assertEquals( max(nan,   0 ),   0  )
  assertEquals( max(nan,  inf),  inf )
  assertEquals( max(nan, 0, 1),   1  )
  assertEquals( max(nan,nan,0),   0  )
  assertNaN   ( max(nan)         )
  assertNaN   ( max(nan,nan)     )
  assertNaN   ( max(nan,nan,nan) )
  if false then -- expected
    assertEquals( max(0  ,  nan), 0 )
    assertEquals( max(nan,0,nan), 0 )
    assertEquals( max(0,nan,nan), 0 )
  else          -- actual [BUG]
    assertNaN ( max(0  ,  nan) )
    assertNaN ( max(nan,0,nan) )
    assertNaN ( max(0,nan,nan) )
  end
end

function TestGmath:testMin()
  assertEquals( min(table.unpack(values.num )), 0 )
  assertEquals( min(table.unpack(values.rad )), 0 )
  assertEquals( min(table.unpack(values.deg )), 0 )
  assertEquals( min(table.unpack(values.rad2)), 0 )
  assertEquals( min(table.unpack(values.deg2)), 0 )
  local t1, t2, t3, t4, t5 = {}, {}, {}, {}, {}
  for i,v in ipairs(values.num ) do t1[i] = -v end
  for i,v in ipairs(values.rad ) do t2[i] = -v end
  for i,v in ipairs(values.deg ) do t3[i] = -v end
  for i,v in ipairs(values.rad2) do t4[i] = -v end
  for i,v in ipairs(values.deg2) do t5[i] = -v end
  assertEquals( min(table.unpack(t1)), -inf  )
  assertEquals( min(table.unpack(t2)), - pi  )
  assertEquals( min(table.unpack(t3)), -180  )
  assertEquals( min(table.unpack(t4)), - pi/2)
  assertEquals( min(table.unpack(t5)), - 90  )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( min(nan, -inf), -inf )
  assertEquals( min(nan,   0 ),   0  )
  assertEquals( min(nan,  inf),  inf )
  assertEquals( min(nan, 0,-1),  -1  )
  assertEquals( min(nan,nan,0),   0  )
  assertNaN   ( min(nan)         )
  assertNaN   ( min(nan,nan)     )
  assertNaN   ( min(nan,nan,nan) )

  if false then -- expected
    assertEquals( min(0  ,  nan),   0  )
    assertEquals( min(nan,0,nan),   0  )
    assertEquals( min(0,nan,nan),   0  )
  else          -- actual [BUG]
    assertNaN ( min(0  ,  nan) )
    assertNaN ( min(nan,0,nan) )
    assertNaN ( min(0,nan,nan) )
  end
end

function TestGmath:testDeg()
  local r = 57.29577951308232 !08768 -- 180/pi, see LJ lib_math.c math_deg
  for _,v in ipairs(values.rad) do
    assertEquals( deg( v) ,  v*r )
    assertEquals( deg(-v) , -v*r )
  end
  assertEquals      ( deg(-inf    )       , -inf      )
  assertEquals      ( deg(-2*pi   ) - -360, 0         )
  assertEquals      ( deg(-  pi   ) - -180, 0         )
  assertEquals      ( deg(-  pi/2 ) - - 90, 0         )
  assertAlmostEquals( deg(-  pi/3 ) - - 60, 0, 32*eps )
  assertEquals      ( deg(-  pi/4 ) - - 45, 0         )
  assertAlmostEquals( deg(-  pi/6 ) - - 30, 0, 16*eps )
  assertAlmostEquals( deg(-  pi/12) - - 15, 0,  8*eps )
  assertEquals      ( deg(-  pi/18) - - 10, 0         )
  assertEquals      ( deg(   0    ) -    0, 0         )
  assertEquals      ( deg(   pi/18) -   10, 0         )
  assertAlmostEquals( deg(   pi/12) -   15, 0,  8*eps )
  assertAlmostEquals( deg(   pi/6 ) -   30, 0, 16*eps )
  assertEquals      ( deg(   pi/4 ) -   45, 0         )
  assertAlmostEquals( deg(   pi/3 ) -   60, 0, 32*eps )
  assertEquals      ( deg(   pi/2 ) -   90, 0         )
  assertEquals      ( deg(   pi   ) -  180, 0         )
  assertEquals      ( deg( 2*pi   ) -  360, 0         )
  assertEquals      ( deg( inf    )       ,  inf      )

  assertAlmostEquals( deg(-  pi/3 ) / - 60, 1, eps )
  assertAlmostEquals( deg(-  pi/6 ) / - 30, 1, eps )
  assertAlmostEquals( deg(   pi/6 ) /   30, 1, eps )
  assertAlmostEquals( deg(   pi/3 ) /   60, 1, eps )

  assertNaN( deg(nan) )
end

function TestGmath:testRad()
  local r = 0.017453292519943295 !8 -- pi/180, see LJ lib_math.c math_rad
  for _,v in ipairs(values.deg) do
    assertEquals( rad( v) ,  v*r )
    assertEquals( rad(-v) , -v*r )
  end
  assertEquals( rad(-inf), -inf   )
  assertEquals( rad(-360), -2*pi  )
  assertEquals( rad(-180), -pi    )
  assertEquals( rad(- 90), -pi/2  )
  assertEquals( rad(- 60), -pi/3  )
  assertEquals( rad(- 45), -pi/4  )
  assertEquals( rad(- 30), -pi/6  )
  assertEquals( rad(- 10), -pi/18 )
  assertEquals( rad(   0),  0     )
  assertEquals( rad(  10),  pi/18 )
  assertEquals( rad(  30),  pi/6  )
  assertEquals( rad(  45),  pi/4  )
  assertEquals( rad(  60),  pi/3  )
  assertEquals( rad(  90),  pi/2  )
  assertEquals( rad( 180),  pi    )
  assertEquals( rad( 360),  2*pi  )
  assertEquals( rad( inf),  inf   )

  assertNaN( rad(nan) )
end

function TestGmath:testRandom()
  for i=1,1000 do
    assertTrue( random()        >=  0   )
    assertTrue( random()        <   1   )
    assertTrue( random(100)     >=  1   )
    assertTrue( random(100)     <= 100  )
    assertTrue( random(-1,1)    >= -1   )
    assertTrue( random(-1,1)    <=  1   )
    assertTrue( random(-1,2^52) >= -1   )
    assertTrue( random(-1,2^52) <= 2^52 )
  end

  assertNaN( random(nan,  0 ) )
  assertNaN( random( 0 , nan) )
  assertNaN( random(nan, nan) )
end

function TestGmath:testRandomseed()
  local val  = {}
  local oldVal = {}
  for j=1,10 do
    randomseed( j )
    for i=1,500 do
      val[i] = random(0,2^52)
      assertTrue ( val[i] >= 0    )
      assertTrue ( val[i] <= 2^52 )
      assertFalse( val[i] == oldVal[i] )
      oldVal[i] = val[i]
    end
  end
end

function TestGmath:testSign()
  assertEquals( 1/sign(    0) ,  inf )
  assertEquals(   sign( tiny) ,  1   )
  assertEquals(   sign(  0.1) ,  1   )
  assertEquals(   sign(    1) ,  1   )
  assertEquals(   sign( huge) ,  1   )
  assertEquals(   sign(  inf) ,  1   )
  assertEquals( 1/sign(-   0) ,  inf ) -- sign returns an int
  assertEquals(   sign(-tiny) , -1   )
  assertEquals(   sign(- 0.1) , -1   )
  assertEquals(   sign(-   1) , -1   )
  assertEquals(   sign(-huge) , -1   )
  assertEquals(   sign(- inf) , -1   )

  assertNaN( sign(nan) )
end

function TestGmath:testSign1()
  assertEquals( sign1(    0) ,  1 )
  assertEquals( sign1( tiny) ,  1 )
  assertEquals( sign1(  0.1) ,  1 )
  assertEquals( sign1(    1) ,  1 )
  assertEquals( sign1( huge) ,  1 )
  assertEquals( sign1(  inf) ,  1 )
  assertEquals( sign1(-tiny) , -1 )
  assertEquals( sign1(- 0.1) , -1 )
  assertEquals( sign1(-   1) , -1 )
  assertEquals( sign1(-huge) , -1 )
  assertEquals( sign1(- inf) , -1 )

  assertNaN( sign1(nan) )
  --Note: The assert below is failing on Ubuntu 22.04.1 LTS specifically for -0.0
  --In a standalone c file, using the same compiling options, -0.0 gives the
  --correct result. 
  assertEquals( sign1(-   0.0) , -1 )
end

function TestGmath:testMulOp()
  for _,x in ipairs(values.num) do
  for _,y in ipairs(values.num) do
    if x > tiny and y > tiny and x < huge and y < huge then
      assertEquals      (  mul(x,y), mul(y,x) )
      assertAlmostEquals( (mul(x,y)/y - x)/x, 0, eps )
    end
  end end

  assertEquals( mul(   0,   1),    0 )
  assertEquals( mul(   0,-  1), -  0 )
  assertEquals( mul(-  0,   1), -  0 )
  assertEquals( mul(-  0,-  1),    0 )

  assertEquals( mul(   1, inf),  inf )
  assertEquals( mul(   1,-inf), -inf )
  assertEquals( mul(-  1, inf), -inf )
  assertEquals( mul(-  1,-inf),  inf )

  assertEquals( mul( inf,   1),  inf )
  assertEquals( mul(-inf,   1), -inf )
  assertEquals( mul( inf,-  1), -inf )
  assertEquals( mul(-inf,-  1),  inf )

  assertEquals( mul( inf, inf),  inf )
  assertEquals( mul(-inf, inf), -inf )
  assertEquals( mul( inf,-inf), -inf )
  assertEquals( mul(-inf,-inf),  inf )

  assertNaN   ( mul(   0, inf) )
  assertNaN   ( mul(   0,-inf) )
  assertNaN   ( mul(-  0, inf) )
  assertNaN   ( mul(-  0,-inf) )
  assertNaN   ( mul( inf,   0) )
  assertNaN   ( mul(-inf,   0) )
  assertNaN   ( mul( inf,-  0) )
  assertNaN   ( mul(-inf,-  0) )
  assertNaN   ( mul(  0 , nan) )
  assertNaN   ( mul( nan,  0 ) )
  assertNaN   ( mul(  1 , nan) )
  assertNaN   ( mul( nan,  1 ) )
end

function TestGmath:testDivOp()
  for _,x in ipairs(values.num) do
  for _,y in ipairs(values.num) do
    if x > tiny and y > tiny and x < huge and y < huge then
      assertAlmostEquals( (div(x,y)*y - x)/x, 0, eps )
    end
  end end

  assertEquals( 1/div(   0,   1),  inf ) -- check for +0
  assertEquals( 1/div(   0,-  1), -inf ) -- check for -0
  assertEquals( 1/div(-  0,   1), -inf ) -- check for -0
  assertEquals( 1/div(-  0,-  1),  inf ) -- check for +0

  assertEquals(   div(   1,   0),  inf )
  assertEquals(   div(-  1,   0), -inf )
  assertEquals(   div(   1,-  0), -inf )
  assertEquals(   div(-  1,-  0),  inf )

  assertEquals( 1/div(   0, inf),  inf ) -- check for +0
  assertEquals( 1/div(   0,-inf), -inf ) -- check for -0
  assertEquals( 1/div(-  0, inf), -inf ) -- check for -0
  assertEquals( 1/div(-  0,-inf),  inf ) -- check for +0

  assertEquals(   div( inf,   0),  inf )
  assertEquals(   div(-inf,   0), -inf )
  assertEquals(   div( inf,-  0), -inf )
  assertEquals(   div(-inf,-  0),  inf )

  assertEquals( 1/div(   1, inf),  inf ) -- check for +0
  assertEquals( 1/div(   1,-inf), -inf ) -- check for -0
  assertEquals( 1/div(-  1, inf), -inf ) -- check for -0
  assertEquals( 1/div(-  1,-inf),  inf ) -- check for +0

  assertEquals(   div( inf,   1),  inf )
  assertEquals(   div(-inf,   1), -inf )
  assertEquals(   div( inf,-  1), -inf )
  assertEquals(   div(-inf,-  1),  inf )

  assertNaN   (   div( inf, inf) )
  assertNaN   (   div(-inf, inf) )
  assertNaN   (   div( inf,-inf) )
  assertNaN   (   div(-inf,-inf) )
  assertNaN   (   div(   0,   0) )
  assertNaN   (   div(   0,-  0) )
  assertNaN   (   div(-  0,   0) )
  assertNaN   (   div(-  0,-  0) )
  assertNaN   (   div(  0 , nan) )
  assertNaN   (   div( nan,  0 ) )
  assertNaN   (   div(  1 , nan) )
  assertNaN   (   div( nan,  1 ) )
end

function TestGmath:testModOp()
  -- Lua: a % b == a - math.floor(a/b)*b
  for _,x in ipairs(values.num) do
  for _,y in ipairs(values.num) do
    if x ~= 0 and y ~= 0 and y < inf and x < inf then
      assertEquals(  x% y,  x - floor( x/ y)* y )
      assertEquals( -x% y, -x - floor(-x/ y)* y )
      assertEquals(  x%-y,  x - floor( x/-y)*-y )
      assertEquals( -x%-y, -x - floor(-x/-y)*-y )
    end
  end end

  assertAlmostEquals( mod(-5.1, -3  ) - -2.1, 0, 2*eps)
  assertAlmostEquals( mod(-5.1,  3  ) -  0.9, 0, 2*eps)
  assertAlmostEquals( mod( 5.1, -3  ) - -0.9, 0, 2*eps)
  assertAlmostEquals( mod( 5.1,  3  ) -  2.1, 0, 2*eps)

  assertAlmostEquals( mod(-5.1, -3.1) - -2  , 0, 2*eps)
  assertAlmostEquals( mod(-5.1,  3.1) -  1.1, 0, 2*eps)
  assertAlmostEquals( mod( 5.1, -3.1) - -1.1, 0, 2*eps)
  assertAlmostEquals( mod( 5.1,  3.1) -  2  , 0, 2*eps)

  assertNaN( mod(   1,  inf) )
  assertNaN( mod(-  1,  inf) )
  assertNaN( mod(   1, -inf) )
  assertNaN( mod(-  1, -inf) )
  assertNaN( mod( inf,  inf) )
  assertNaN( mod(-inf, -inf) )
  assertNaN( mod( inf,  nan) )
  assertNaN( mod(-inf,  nan) )
  assertNaN( mod(   1,    0) )
  assertNaN( mod(   1,  - 0) )
  assertNaN( mod( nan,  nan) )
end

function TestGmath:testPow()
  for _,x in ipairs(values.num) do
  for _,y in ipairs(values.num) do
    if x > 1/709.78 and y > 1/709.78 and x < 709.78 and y < 709.78 then
      assertAlmostEquals( log(pow(x,y)) - y*log(x), 0, max(abs(y*log(x)) * eps, 4*eps) ) -- 64*eps?
    end
  end end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals(   pow(  0 , - 11),  inf )
  assertEquals(   pow(- 0 , - 11), -inf )

  assertEquals(   pow(  0 , - .5),  inf )
  assertEquals(   pow(- 0 , - .5),  inf )
  assertEquals(   pow(  0 , -  2),  inf )
  assertEquals(   pow(- 0 , -  2),  inf )
  assertEquals(   pow(  0 , - 10),  inf )
  assertEquals(   pow(- 0 , - 10),  inf )

  assertEquals( 1/pow(  0 ,    1),  inf ) -- check for +0
  assertEquals( 1/pow(- 0 ,    1), -inf ) -- check for -0
  assertEquals( 1/pow(  0 ,   11),  inf ) -- check for +0
  assertEquals( 1/pow(- 0 ,   11), -inf ) -- check for -0

  assertEquals( 1/pow(  0 ,  0.5),  inf ) -- check for +0
  assertEquals( 1/pow(- 0 ,  0.5),  inf ) -- check for +0
  assertEquals( 1/pow(  0 ,    2),  inf ) -- check for +0
  assertEquals( 1/pow(- 0 ,    2),  inf ) -- check for +0
  assertEquals( 1/pow(  0 ,   10),  inf ) -- check for +0
  assertEquals( 1/pow(- 0 ,   10),  inf ) -- check for +0
  assertEquals( 1/pow(  0 ,  inf),  inf ) -- check for +0
  assertEquals( 1/pow(- 0 ,  inf),  inf ) -- check for +0

  assertEquals(   pow(- 1 ,  inf),   1  )
  assertEquals(   pow(- 1 , -inf),   1  )

  assertEquals(   pow(  1 ,   0 ),   1  )
  assertEquals(   pow(  1 , - 0 ),   1  )
  assertEquals(   pow(  1 ,  0.5),   1  )
  assertEquals(   pow(  1 , -0.5),   1  )
  assertEquals(   pow(  1 ,   1 ),   1  )
  assertEquals(   pow(  1 , - 1 ),   1  )
  assertEquals(   pow(  1 ,  inf),   1  )
  assertEquals(   pow(  1 , -inf),   1  )
  assertEquals(   pow(  1 ,  nan),   1  )
  assertEquals(   pow(  1 , -nan),   1  )

  assertEquals(   pow(  0 ,   0 ),   1  )
  assertEquals(   pow(- 0 ,   0 ),   1  )
  assertEquals(   pow( 0.5,   0 ),   1  )
  assertEquals(   pow(-0.5,   0 ),   1  )
  assertEquals(   pow(  1 ,   0 ),   1  )
  assertEquals(   pow(- 1 ,   0 ),   1  )
  assertEquals(   pow( inf,   0 ),   1  )
  assertEquals(   pow(-inf,   0 ),   1  )
  assertEquals(   pow( nan,   0 ),   1  )
  assertEquals(   pow(-nan,   0 ),   1  )

  assertEquals(   pow(  0 , - 0 ),   1  )
  assertEquals(   pow(- 0 , - 0 ),   1  )
  assertEquals(   pow( 0.5, - 0 ),   1  )
  assertEquals(   pow(-0.5, - 0 ),   1  )
  assertEquals(   pow(  1 , - 0 ),   1  )
  assertEquals(   pow(- 1 , - 0 ),   1  )
  assertEquals(   pow( inf, - 0 ),   1  )
  assertEquals(   pow(-inf, - 0 ),   1  )
  assertEquals(   pow( nan, - 0 ),   1  )
  assertEquals(   pow(-nan, - 0 ),   1  )

  assertNaN   (   pow(- 1 , 0.5) )
  assertNaN   (   pow(- 1 ,-0.5) )
  assertNaN   (   pow(- 1 , 1.5) )
  assertNaN   (   pow(- 1 ,-1.5) )

  assertEquals(   pow(  0   , -inf),  inf )
  assertEquals(   pow(- 0   , -inf),  inf )
  assertEquals(   pow( 0.5  , -inf),  inf )
  assertEquals(   pow(-0.5  , -inf),  inf )
  assertEquals(   pow( 1-eps, -inf),  inf )
  assertEquals(   pow(-1+eps, -inf),  inf )

  assertEquals( 1/pow( 1+eps, -inf),  inf ) -- check for +0
  assertEquals( 1/pow(-1-eps, -inf),  inf ) -- check for +0
  assertEquals( 1/pow( 1.5  , -inf),  inf ) -- check for +0
  assertEquals( 1/pow(-1.5  , -inf),  inf ) -- check for +0
  assertEquals( 1/pow( inf  , -inf),  inf ) -- check for +0
  assertEquals( 1/pow(-inf  , -inf),  inf ) -- check for +0

  assertEquals( 1/pow(  0   ,  inf),  inf ) -- check for +0
  assertEquals( 1/pow(- 0   ,  inf),  inf ) -- check for +0
  assertEquals( 1/pow( 0.5  ,  inf),  inf ) -- check for +0
  assertEquals( 1/pow(-0.5  ,  inf),  inf ) -- check for +0
  assertEquals( 1/pow( 1-eps,  inf),  inf ) -- check for +0
  assertEquals( 1/pow(-1+eps,  inf),  inf ) -- check for +0

  assertEquals(   pow( 1+eps,  inf),  inf )
  assertEquals(   pow(-1-eps,  inf),  inf )
  assertEquals(   pow( 1.5  ,  inf),  inf )
  assertEquals(   pow(-1.5  ,  inf),  inf )
  assertEquals(   pow( inf  ,  inf),  inf )
  assertEquals(   pow(-inf  ,  inf),  inf )

  assertEquals( 1/pow(-inf, -  1), -inf ) -- check for -0
  assertEquals( 1/pow(-inf, - 11), -inf ) -- check for -0
  assertEquals( 1/pow(-inf, -0.5),  inf ) -- check for +0
  assertEquals( 1/pow(-inf, -  2),  inf ) -- check for +0
  assertEquals( 1/pow(-inf, - 10),  inf ) -- check for +0

  assertEquals(   pow(-inf,    1), -inf )
  assertEquals(   pow(-inf,   11), -inf )
  assertEquals(   pow(-inf,  0.5),  inf )
  assertEquals(   pow(-inf,    2),  inf )
  assertEquals(   pow(-inf,   10),  inf )

  assertEquals( 1/pow( inf, -0.5),  inf ) -- check for +0
  assertEquals( 1/pow( inf, -  1),  inf ) -- check for +0
  assertEquals( 1/pow( inf, -  2),  inf ) -- check for +0
  assertEquals( 1/pow( inf, - 10),  inf ) -- check for +0
  assertEquals( 1/pow( inf, - 11),  inf ) -- check for +0

  assertEquals(   pow( inf,  0.5),  inf )
  assertEquals(   pow( inf,    1),  inf )
  assertEquals(   pow( inf,    2),  inf )
  assertEquals(   pow( inf,   10),  inf )
  assertEquals(   pow( inf,   11),  inf )

  assertNaN   (   pow( 0  ,  nan) )
  assertNaN   (   pow(-0  ,  nan) )
  assertNaN   (   pow( 0  , -nan) )
  assertNaN   (   pow(-0  , -nan) )
  assertNaN   (   pow(-1  ,  nan) )
  assertNaN   (   pow(-1  , -nan) )
  assertNaN   (   pow( nan,   1 ) )
  assertNaN   (   pow(-nan,   1 ) )
  assertNaN   (   pow( nan, - 1 ) )
  assertNaN   (   pow(-nan, - 1 ) )
  assertNaN   (   pow( inf,  nan) )
  assertNaN   (   pow(-inf,  nan) )
  assertNaN   (   pow( inf, -nan) )
  assertNaN   (   pow(-inf, -nan) )
  assertNaN   (   pow( nan,  inf) )
  assertNaN   (   pow(-nan,  inf) )
  assertNaN   (   pow( nan, -inf) )
  assertNaN   (   pow(-nan, -inf) )
  assertNaN   (   pow( nan,  nan) )
  assertNaN   (   pow(-nan,  nan) )
  assertNaN   (   pow( nan, -nan) )
  assertNaN   (   pow(-nan, -nan) )
end

function TestGmath:testPowOp()
  for _,x in ipairs(values.num) do
  for _,y in ipairs(values.num) do
    if x > 1/709.78 and y > 1/709.78 and x < 709.78 and y < 709.78 then
      assertAlmostEquals( log(x^y) - y*log(x), 0, max(abs(y*log(x)) * eps, 4*eps) ) -- 64*eps?
    end
  end end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals(      0 ^ - 11,  inf )
  assertEquals(    - 0 ^ - 11, -inf )

  assertEquals(      0 ^ - .5,  inf )
  assertEquals(   (- 0)^ - .5,  inf )
  assertEquals(      0 ^ -  2,  inf )
  assertEquals(   (- 0)^ -  2,  inf )
  assertEquals(      0 ^ - 10,  inf )
  assertEquals(   (- 0)^ - 10,  inf )

  assertEquals( 1/   0 ^    1,  inf ) -- check for +0
  assertEquals( 1/(- 0)^    1, -inf ) -- check for -0
  assertEquals( 1/   0 ^   11,  inf ) -- check for +0
  assertEquals( 1/(- 0)^   11, -inf ) -- check for -0

  assertEquals( 1/   0 ^  0.5,  inf ) -- check for +0
  assertEquals( 1/(- 0)^  0.5,  inf ) -- check for +0
  assertEquals( 1/   0 ^    2,  inf ) -- check for +0
  assertEquals( 1/(- 0)^    2,  inf ) -- check for +0
  assertEquals( 1/   0 ^   10,  inf ) -- check for +0
  assertEquals( 1/(- 0)^   10,  inf ) -- check for +0
  assertEquals( 1/   0 ^  inf,  inf ) -- check for +0
  assertEquals( 1/(- 0)^  inf,  inf ) -- check for +0

  assertEquals(   (- 1)^  inf,   1  )
  assertEquals(   (- 1)^ -inf,   1  )

  assertEquals(      1 ^   0 ,   1  )
  assertEquals(      1 ^ - 0 ,   1  )
  assertEquals(      1 ^  0.5,   1  )
  assertEquals(      1 ^ -0.5,   1  )
  assertEquals(      1 ^   1 ,   1  )
  assertEquals(      1 ^ - 1 ,   1  )
  assertEquals(      1 ^  inf,   1  )
  assertEquals(      1 ^ -inf,   1  )
  assertEquals(      1 ^  nan,   1  )
  assertEquals(      1 ^ -nan,   1  )

  assertEquals(      0  ^  0 ,   1  )
  assertEquals(   (- 0 )^  0 ,   1  )
  assertEquals(     0.5 ^  0 ,   1  )
  assertEquals(   (-0.5)^  0 ,   1  )
  assertEquals(      1  ^  0 ,   1  )
  assertEquals(   (- 1 )^  0 ,   1  )
  assertEquals(     inf ^  0 ,   1  )
  assertEquals(   (-inf)^  0 ,   1  )
  assertEquals(     nan ^  0 ,   1  )
  assertEquals(   (-nan)^  0 ,   1  )

  assertEquals(      0  ^- 0 ,   1  )
  assertEquals(   (- 0 )^- 0 ,   1  )
  assertEquals(     0.5 ^- 0 ,   1  )
  assertEquals(   (-0.5)^- 0 ,   1  )
  assertEquals(      1  ^- 0 ,   1  )
  assertEquals(   (- 1 )^- 0 ,   1  )
  assertEquals(     inf ^- 0 ,   1  )
  assertEquals(   (-inf)^- 0 ,   1  )
  assertEquals(     nan ^- 0 ,   1  )
  assertEquals(   (-nan)^- 0 ,   1  )

  assertNaN   (   (- 1)^ 0.5 )
  assertNaN   (   (- 1)^-0.5 )
  assertNaN   (   (- 1)^ 1.5 )
  assertNaN   (   (- 1)^-1.5 )

  assertEquals(      0    ^ -inf , inf )
  assertEquals(   (- 0   )^ -inf , inf )
  assertEquals(     0.5   ^ -inf , inf )
  assertEquals(   (-0.5  )^ -inf , inf )
  assertEquals(   ( 1-eps)^ -inf , inf )
  assertEquals(   (-1+eps)^ -inf , inf )

  assertEquals(1/(( 1+eps)^ -inf), inf ) -- check for +0
  assertEquals(1/((-1-eps)^ -inf), inf ) -- check for +0
  assertEquals(1/( 1.5    ^ -inf), inf ) -- check for +0
  assertEquals(1/((-1.5  )^ -inf), inf ) -- check for +0
  assertEquals(1/( inf    ^ -inf), inf ) -- check for +0
  assertEquals(1/((-inf  )^ -inf), inf ) -- check for +0

  assertEquals(1/(     0  ^  inf), inf ) -- check for +0
  assertEquals(1/((-   0 )^  inf), inf ) -- check for +0
  assertEquals(1/(    0.5 ^  inf), inf ) -- check for +0
  assertEquals(1/((-  0.5)^  inf), inf ) -- check for +0
  assertEquals(1/(( 1-eps)^  inf), inf ) -- check for +0
  assertEquals(1/((-1+eps)^  inf), inf ) -- check for +0

  assertEquals(   ( 1+eps)^  inf,  inf )
  assertEquals(   (-1-eps)^  inf,  inf )
  assertEquals(     1.5   ^  inf,  inf )
  assertEquals(   (-1.5  )^  inf,  inf )
  assertEquals(     inf   ^  inf,  inf )
  assertEquals(   (-inf  )^  inf,  inf )

  assertEquals( 1/((-inf) ^ -  1), -inf ) -- check for -0
  assertEquals( 1/((-inf) ^ - 11), -inf ) -- check for -0
  assertEquals( 1/((-inf) ^ -0.5),  inf ) -- check for +0
  assertEquals( 1/((-inf) ^ -  2),  inf ) -- check for +0
  assertEquals( 1/((-inf) ^ - 10),  inf ) -- check for +0

  assertEquals(    (-inf) ^    1 , -inf )
  assertEquals(    (-inf) ^   11 , -inf )
  assertEquals(    (-inf) ^  0.5 ,  inf )
  assertEquals(    (-inf) ^    2 ,  inf )
  assertEquals(    (-inf) ^   10 ,  inf )

  assertEquals( 1/(  inf  ^ -0.5),  inf ) -- check for +0
  assertEquals( 1/(  inf  ^ -  1),  inf ) -- check for +0
  assertEquals( 1/(  inf  ^ -  2),  inf ) -- check for +0
  assertEquals( 1/(  inf  ^ - 10),  inf ) -- check for +0
  assertEquals( 1/(  inf  ^ - 11),  inf ) -- check for +0

  assertEquals(      inf  ^  0.5 ,  inf )
  assertEquals(      inf  ^    1 ,  inf )
  assertEquals(      inf  ^    2 ,  inf )
  assertEquals(      inf  ^   10 ,  inf )
  assertEquals(      inf  ^   11 ,  inf )

  assertNaN   (       0   ^  nan )
  assertNaN   (     (-0  )^  nan )
  assertNaN   (       0   ^ -nan )
  assertNaN   (     (-0  )^ -nan )
  assertNaN   (     (-1  )^  nan )
  assertNaN   (     (-1  )^ -nan )
  assertNaN   (       nan ^   1  )
  assertNaN   (     (-nan)^   1  )
  assertNaN   (       nan ^ - 1  )
  assertNaN   (     (-nan)^ - 1  )
  assertNaN   (       inf ^  nan )
  assertNaN   (     (-inf)^  nan )
  assertNaN   (       inf ^ -nan )
  assertNaN   (     (-inf)^ -nan )
  assertNaN   (       nan ^  inf )
  assertNaN   (     (-nan)^  inf )
  assertNaN   (       nan ^ -inf )
  assertNaN   (     (-nan)^ -inf )
  assertNaN   (       nan ^  nan )
  assertNaN   (     (-nan)^  nan )
  assertNaN   (       nan ^ -nan )
  assertNaN   (     (-nan)^ -nan )
end

function TestGmath:testEmul()
  for _, x in ipairs(values.num) do 
    local mat = matrix(3, 3):fill(x)
    for _, y in ipairs(values.num) do 
      if x * y < inf then
        assertAllAlmostEquals(totable(emul(mat, y)), totable(matrix(3,3):fill(x*y)), x*y*eps)
      end
    end
    for i, v in ipairs(emul(mat, nan)) do 
      assertNaN(v)
    end
  end
end

function TestGmath:testEdiv()
  for _, x in ipairs(values.num) do 
    local mat = matrix(3, 3):fill(x)
    for _, y in ipairs(values.num) do 
      if y ~= 0 and y < huge then 
        if not (x / y == inf) then
          assertAllAlmostEquals(totable(ediv(mat, y)), totable(matrix(3,3):fill(x/y)), x/y*eps)
        else
          for i, v in ipairs(ediv(mat, y)) do
            assertInf(v)
          end
        end
      end
    end
  end
end

function TestGmath:testEmod()
  for _, x in ipairs(values.num) do 
    if x < inf then
      local mat = matrix(3, 3):fill(x)
      for _, y in ipairs(values.num) do 
        if y ~= 0 and y < inf then
          assertEquals(emod(mat, y), matrix(3,3):fill(x%y))
        end
      end
    end
  end
end

function TestGmath:testEpow()
  for _, x in ipairs(values.num) do 
    local mat = matrix(3, 3):fill(x)
    for _, y in ipairs(values.num) do 
      if x^y < inf then
        assertAllAlmostEquals(totable(epow(mat, y)), totable(matrix(3,3):fill(x^y)), 45 * x^y * eps) --Sometimes fails for 1e-100 at 10 eps on Linux
      else
        for _, val in ipairs(epow(mat, y)) do
          assertInf(val)
        end
      end
    end
  end
end

function TestGmath:testPowi()
  for _, x in ipairs(values.deg) do
    if x > 2*eps then
      assertEquals(powi(2, x), 2^x)
      assertEquals(powi(x, 2), x^2)
      assertEquals(powi(x, 5), x^5)
      assertAlmostEquals(powi(5, x), 5^x, 2*eps * 5^x) --Only one to get big enough to need relative error
    end
  end
end

function TestGmath:testSqr()
  for _,x in ipairs(values.num) do
    if x > tiny and x < huge then
      assertEquals(sqr(x), x*x)
    end
  end
end

function TestGmath:testInv()
  for _,x in ipairs(values.num) do
    if x > tiny and x < huge then
      assertEquals(inv(x), 1/x)
    end
  end
  assertEquals(  inv(0)   , inf   )
  assertEquals(  inv(-0)  ,-inf   )
  assertEquals( inv(-inf) , -0    )
  assertEquals( inv(inf)  ,  0    )

  assertNaN   (  inv(nan) )
  assertNaN   (   inv(-nan) )
end

function TestGmath:testUnit()
  for _,x in ipairs(values.num) do
    if x > tiny and x < huge then
      assertEquals(unit(x), 1)
      assertEquals(unit(-x), -1) 
    end
  end
end

function TestGmath:testMinabs()
  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      local z = random(0,1)
      assertEquals(minabs(x * (-1^z), y * (-1^z)), min(x, y))
    end
  end
end

function TestGmath:testMaxabs()
  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      local z = random(0,1)
      assertEquals(maxabs(x * (-1^z), y * (-1^z)), max(x, y))
    end
  end
end

function TestGmath:testSumsqrl()
  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      local z = random(0,1)
      assertEquals(sumsqrl(x, y * (-1^z)), x + y^2)
    end
  end
end

function TestGmath:testSumabsl()
  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      local z = random(0,1)
      assertEquals(sumabsl(x, y * (-1^z)), x + y)
    end
  end
end

function TestGmath:testMinabsl()
  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      local z = random(0,1)
      assertEquals(minabsl(x * (-1^z), y * (-1^z)), min(x * (-1^z), y))
    end
  end
end

function TestGmath:testMaxabsl()
  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      local z = random(0,1)
      assertEquals(maxabsl(x * (-1^z), y * (-1^z)), max(x* (-1^z), y))
    end
  end
end

function TestGmath:testsumsqrr()
  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      local z = random(0,1)
      assertEquals(sumsqrr(x * (-1^z), y), x^2 + y)
    end
  end
end

function TestGmath:testsumabsr()
  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      local z = random(0,1)
      assertEquals(sumabsr(x * (-1^z), y), x + y)
    end
  end
end

function TestGmath:testminabsr()
  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      local z = random(0,1)
      assertEquals(minabsr(x * (-1^z), y * (-1^z)), min(x, y * (-1^z)))
    end
  end
end

function TestGmath:testmaxabsr()
  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      local z = random(0,1)
      assertEquals(maxabsr(x * (-1^z), y * (-1^z)), max(x, y * (-1^z)))
    end
  end
end


function TestGmath:testRand()
  local actual = {}
  local expected = {
    0.64790572115133815423, 0.63996214375622351156, 0.66062163503512216778, 
    0.42195014423780574653, 0.50296307961382935581, 0.50501842683784370358, 
    0.50799003979142587362, 0.33732449165468403329, 0.26206206699016920680, 
    0.64155925876471542324, 0.88266386953719400132, 0.27554277699449758465
  }
  local expected2 = {
    0.96211623335140106228, 0.72345516061227899129, 0.31720586678753925902, 
    0.97106970668738279429, 0.74843939418889871007, 0.62768797702781742309, 
    0.37922874628676139785, 0.94358733993352594815, 0.81856159186609045442, 
    0.58755273288951737065, 0.40904885059279583182, 0.40835934685829200497,
  }
  local prng = randnew()
  prng:randseed(483)
  for x = 1, 12 do
    actual[x] = prng:rand()
  end
  assertEquals(actual, expected)
  assertNotEquals(actual, expected2) --Check for no overlap
  local actual = {}
  prng = randnew() --Check that this does not overlapp with other prngs
  for x = 1, 12 do
    actual[x] = prng:rand()
  end
  assertNotEquals(actual, expected) --Check for no overlap
  assertEquals(actual, expected2) --Should work given the initial seed for randnew is the same everytime

end

function TestGmath:testXrand()
  local actual1 = {}
  local expected1 = {
    0.54963091900000005108, 0.65469465900000001213, 0.44267782000000005516, 
    0.99510112400000005906, 0.73531900400000005380, 0.22085843600000001907, 
    0.65031164200000002307, 0.82019688500000009768, 0.25121093500000002408, 
    0.90104713700000005350, 0.75053997000000005624, 0.20812389900000000109
  }
  local expected2 = {
    0.34899324400000003576, 0.36013278900000000871, 0.02462939500000000184, 
    0.35273848900000004392, 0.97948683900000010905, 0.36037473100000000370, 
    0.22338015700000002361, 0.52204461000000002002, 0.81736849000000000309, 
    0.99618244200000005684, 0.32739817000000004388, 0.99471062900000006834
  }
  local actual2 = {}
  local xprng = xrandnew()
  for x = 1, 12 do 
    actual1[x] = xprng:rand()
  end
  assertEquals(actual1, expected1)
  randseed(xprng, 624)
  for x = 1, 12 do 
    actual2[x] = xprng:rand()
  end
  assertEquals(actual2, expected2)
end

function TestGmath:testRandi()
  local expected = {
    {
      508008169, 310561559, 712407570,
      510513574, 370982554, 535041786, 
      299823592, 59476135 , 281578085,
      892771787, 229505970, 493508799,
    },
    {
      8724807201191480320,  16345006621140707328, 13393809530026002432,
      4623895209947006976,  17537333822906152960, 3194046545254066688 ,
      14961495535654010880, 12946537368613869568, 13047077506793996288,
      17564877036839120896, 225880487763389440  , 4976666538349998080
    },
  }
  for prngType = 1, 2 do
    local prng
    if prngType == 1 then prng = xrandnew() else prng = randnew() end
    prng:randseed(339)
    local actual = {}
    for x = 1, 12 do
      actual[x] = tonumber(prng:randi())
    end
    for x = 1, 12 do
      assertEquals(frac((actual[x])), 0) -- Int
      assertEquals(sign1((actual[x])), 1) -- >= 0
      assertEquals(sign1((actual[x]) - (2^32)^prngType), -1) -- > 0
    end
    assertEquals(actual, expected[prngType])
  end
end

function TestGmath:testRandn()
  local expected = {-0.59367759959787891333,  0.47214364743257331014,  1.91987525000020720078,
                     1.41011968242511032123,  0.27280488692564197617,  0.43302395404008592328, 
                     0.71984890346562513397,  0.45254445813950616717,  0.59272217168690422007, 
                     1.11977944494989722912, -1.28496612375013841145, -1.41819385647631701630}
  local actual = {}
  local prng = randnew()
  prng:randseed(478)
  for x = 1, 12 do
    actual[x] = prng:randn()
  end
  assertEquals(expected, actual)
end

function TestGmath:testRandtn()
  local actual1 = {}
  local expected1 = {
    -0.17433050961207705032,  0.91640130935937591516,  1.25264044476623825908,
     0.09460046918422167217,  0.56264862316656683028, -0.76473539212898278272, 
    -0.73504656819177183191, -0.88204239462497513458, -0.24998558619038196982, 
    -0.30663770909688797817, -0.81735798792262825962, -0.92991061375151351509
  }
  local actual2 = {}
  local expected2 = {
     0.05751560244279935868, -1.75122425324587194240, 0.05677259742661162900,
    -0.60996728155055912612,  0.30330420331927032684, 0.50811655426052582119, 
    -1.91011478861435168852,  1.37878152223321959191, 1.21854317024685010473, 
     0.38248131669308188529,  1.27207118107000827223, 1.72893848985886422476,
  }
  local prng = randnew()
  prng:randseed(656)
  local prng2 = randnew()
  prng2:randseed(779)
  for x = 1, 12 do
    actual1[x] = prng:randtn(2)
    actual2[x] = prng2:randtn(7)
  end
  for x = 1, 12 do
    assertEquals(sign1(actual1[x] - 2), -1)     --Check less than x - 2 < 0
    assertEquals(sign1(actual1[x] + 2), 1)      --Check that x + 2 > 0
    assertEquals(sign1(actual2[x] - 7), -1)     --Check less than x - 7 < 0
    assertEquals(sign1(actual2[x] + 7), 1)      --Check that x + 7 > 0
  end
  assertEquals(expected1, actual1)
  assertEquals(expected2, actual2)
end


function TestGmath:testRandp()
  local actual = {}
  local expected = {
    0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1
  }
  local actual2 = {}
  local expected2 = {
    22, 26, 27, 27, 23, 22, 23, 22, 22, 21, 25, 21
  }
  local prng = randnew()
  prng:randseed(637)
  for x = 1, 12 do
    actual[x] = prng:randp()
  end
  prng:randseed(725)
  for x = 1, 12 do
    actual2[x] = prng:randp(23)
  end
  assertEquals(actual , expected )
  assertEquals(actual2, expected2)
end

function TestGmath:testFact()
  local expected = { --Results from https://www.wolframalpha.com/ (to 20 s.f.)
    1, 3628800, 2432902008176640000, 2.6525285981219105864e32,
    8.1591528324789773434e47 , 3.0414093201713378044e64 ,
    8.3209871127413901443e81 , 1.1978571669969891796e100,
    7.1569457046263802295e118, 1.4857159644817614973e138,
    9.3326215443944152682e157
  }
  for x = 0, 100, 10 do
    local index = x/10 + 1
    assertAlmostEquals((fact(x) - expected[index])/expected[index], 0, 3*eps)
  end
  expected = { --Results from https://www.wolframalpha.com/ (to 20 s.f.)
  1.2265202031961379394e172, 2.5435597334721875571e186,
  8.0942985252734437397e200, 3.8562048236258042174e215,
  2.6904727073180504836e230
  }
  for x = 107, 135, 7 do
    local index = (x-100)/7
    assertAlmostEquals((fact(x) - expected[index])/expected[index], 0, 3*eps)
  end
  expected = { --Results from https://www.wolframalpha.com/ (to 20 s.f.)
  3.8543707171800727705e247, 1.3113358856834525456e267,
  7.5907050539472187291e286, 7.2574156153079989674e306,
  }
  for x = 143, 170, 9 do -- 171! > huge
    local index = (x-134)/9
    assertAlmostEquals((fact(x) - expected[index])/expected[index], 0, 4*eps)
  end
  for x = 171, 1e4, 5e2 do
    assertEquals(fact(171), inf)
  end
end

-- delegation --

function TestGmath:testDelegation()
  local mock, mock2 = {}, {}

  mock.ceil   = \ 'mock.ceil  '       assertEquals(ceil  (mock), 'mock.ceil  ')
  mock.floor  = \ 'mock.floor '       assertEquals(floor (mock), 'mock.floor ')
  mock.round  = \ 'mock.round '       assertEquals(round (mock), 'mock.round ')
  mock.frac   = \ 'mock.frac  '       assertEquals(frac  (mock), 'mock.frac  ')
  mock.trunc  = \ 'mock.trunc '       assertEquals(trunc (mock), 'mock.trunc ')
  mock.sign1  = \ 'mock.sign1 '       assertEquals(sign1 (mock), 'mock.sign1 ')
  mock.sign   = \ 'mock.sign  '       assertEquals(sign  (mock), 'mock.sign  ')
  mock.unit   = \ 'mock.unit  '       assertEquals(unit  (mock), 'mock.unit  ')

  mock.abs    = \ 'mock.abs   '       assertEquals(abs   (mock), 'mock.abs   ')
  mock.sqrt   = \ 'mock.sqrt  '       assertEquals(sqrt  (mock), 'mock.sqrt  ')
  mock.exp    = \ 'mock.exp   '       assertEquals(exp   (mock), 'mock.exp   ')
  mock.log    = \ 'mock.log   '       assertEquals(log   (mock), 'mock.log   ')
  mock.log10  = \ 'mock.log10 '       assertEquals(log10 (mock), 'mock.log10 ')
  mock.powi   = \ 'mock.powi  '       assertEquals(powi  (mock), 'mock.powi  ')

  mock.sin    = \ 'mock.sin   '       assertEquals(sin   (mock), 'mock.sin   ')
  mock.cos    = \ 'mock.cos   '       assertEquals(cos   (mock), 'mock.cos   ')
  mock.tan    = \ 'mock.tan   '       assertEquals(tan   (mock), 'mock.tan   ')
  mock.cot    = \ 'mock.cot   '       assertEquals(cot   (mock), 'mock.cot   ')
  mock.sinh   = \ 'mock.sinh  '       assertEquals(sinh  (mock), 'mock.sinh  ')
  mock.cosh   = \ 'mock.cosh  '       assertEquals(cosh  (mock), 'mock.cosh  ')
  mock.tanh   = \ 'mock.tanh  '       assertEquals(tanh  (mock), 'mock.tanh  ')
  mock.asin   = \ 'mock.asin  '       assertEquals(asin  (mock), 'mock.asin  ')

  mock.asin   = \ 'mock.asin  '       assertEquals(asin  (mock), 'mock.asin  ')
  mock.acos   = \ 'mock.acos  '       assertEquals(acos  (mock), 'mock.acos  ')
  mock.atan   = \ 'mock.atan  '       assertEquals(atan  (mock), 'mock.atan  ')
  mock.atan2  = \ 'mock.atan2 '       assertEquals(atan2 (mock), 'mock.atan2 ')
  mock.acot   = \ 'mock.acot  '       assertEquals(acot  (mock), 'mock.acot  ')
  mock.asinh  = \ 'mock.asinh '       assertEquals(asinh (mock), 'mock.asinh ')
  mock.acosh  = \ 'mock.acosh '       assertEquals(acosh (mock), 'mock.acosh ')
  mock.atanh  = \ 'mock.atanh '       assertEquals(atanh (mock), 'mock.atanh ')
  mock.acoth  = \ 'mock.acoth '       assertEquals(acoth (mock), 'mock.acoth ')
  
  mock.asinc  = \ 'mock.asinc '       assertEquals(asinc (mock), 'mock.asinc ')
  mock.asinhc = \ 'mock.asinhc'       assertEquals(asinhc(mock), 'mock.asinhc')
  mock.sinc   = \ 'mock.sinc  '       assertEquals(sinc  (mock), 'mock.sinc  ')
  mock.sinhc  = \ 'mock.sinhc '       assertEquals(sinhc (mock), 'mock.sinhc ')

  mock.erf    = \ 'mock.erf   '       assertEquals(erf   (mock), 'mock.erf   ')
  mock.erfc   = \ 'mock.erfc  '       assertEquals(erfc  (mock), 'mock.erfc  ')
  mock.erfcx  = \ 'mock.erfcx '       assertEquals(erfcx (mock), 'mock.erfcx ')
  mock.erfi   = \ 'mock.erfi  '       assertEquals(erfi  (mock), 'mock.erfi  ')
  mock.wf     = \ 'mock.wf    '       assertEquals(wf    (mock), 'mock.wf    ')
  mock.dawson = \ 'mock.dawson'       assertEquals(dawson(mock), 'mock.dawson')
  mock.tgamma = \ 'mock.tgamma'       assertEquals(tgamma(mock), 'mock.tgamma')
  mock.lgamma = \ 'mock.lgamma'       assertEquals(lgamma(mock), 'mock.lgamma')

  mock.cabs   = \ 'mock.cabs  '       assertEquals(cabs  (mock), 'mock.cabs  ')
  mock.carg   = \ 'mock.carg  '       assertEquals(carg  (mock), 'mock.carg  ')
  mock.real   = \ 'mock.real  '       assertEquals(real  (mock), 'mock.real  ')
  mock.imag   = \ 'mock.imag  '       assertEquals(imag  (mock), 'mock.imag  ')
  mock.conj   = \ 'mock.conj  '       assertEquals(conj  (mock), 'mock.conj  ')
  mock.proj   = \ 'mock.proj  '       assertEquals(proj  (mock), 'mock.proj  ')
  mock.rect   = \ 'mock.rect  '       assertEquals(rect  (mock), 'mock.rect  ')
  mock.reim   = \ 'mock.reim  '       assertEquals({reim  (mock)}, {'mock.real  ', 'mock.imag  '}) 
  mock.polar  = \ 'mock.polar '       assertEquals(polar (mock), 'mock.polar ')

  mock.hypot  = \ 'mock.hypot '       assertEquals(hypot (mock), 'mock.hypot ')
  mock.hypot3 = \ 'mock.hypot3'       assertEquals(hypot3(mock), 'mock.hypot3')

  local mmock = {}
  setmetatable(mock , mmock)
  setmetatable(mock2, mmock)

  local set = \a,k => a[k] = (a[k] or 0) + 1 end
  local get = \a,k -> a[k]
  local inc = \a,k => set(a,k) return get(a,k) end

  mmock.__unm = \a   inc(a, 'unm')    assertEquals(     -  mock , get(mock, 'unm'))
  mmock.__len = \a   inc(a, 'len')    assertEquals(     #  mock , get(mock, 'len'))
  mmock.__add = \a,b inc(a, 'add')    assertEquals(mock +  mock2, get(mock, 'add'))
  mmock.__sub = \a,b inc(a, 'sub')    assertEquals(mock -  mock2, get(mock, 'sub'))
  mmock.__mul = \a,b inc(a, 'mul')    assertEquals(mock *  mock2, get(mock, 'mul'))
  mmock.__div = \a,b inc(a, 'div')    assertEquals(mock /  mock2, get(mock, 'div'))
  mmock.__mod = \a,b inc(a, 'mod')    assertEquals(mock %  mock2, get(mock, 'mod'))
  mmock.__pow = \a,b inc(a, 'pow')    assertEquals(mock ^  mock2, get(mock, 'pow'))
  mmock.__eq  = \a,b inc(a, 'eq')     assertEquals(mock == mock2, true)
  mmock.__lt  = \a,b inc(a, 'lt')     assertEquals(mock <  mock2, true)
  mmock.__le  = \a,b inc(a, 'le')     assertEquals(mock <= mock2, true)
                                      assertEquals(mock ~= mock2, false)
                                      assertEquals(mock >  mock2, true)
                                      assertEquals(mock >= mock2, true)

                                      assertEquals(get(mock, 'unm'), 1)
                                      assertEquals(get(mock, 'len'), 1)
                                      assertEquals(get(mock, 'add'), 1)
                                      assertEquals(get(mock, 'sub'), 1)
                                      assertEquals(get(mock, 'mul'), 1)
                                      assertEquals(get(mock, 'div'), 1)
                                      assertEquals(get(mock, 'mod'), 1)
                                      assertEquals(get(mock, 'pow'), 1)

                                      assertEquals(get(mock , 'eq'), 2)
                                      assertEquals(get(mock , 'lt'), 1)
                                      assertEquals(get(mock , 'le'), 1)
                                      assertEquals(get(mock2, 'lt'), 1)
                                      assertEquals(get(mock2, 'le'), 1)
end

-- end ------------------------------------------------------------------------o
