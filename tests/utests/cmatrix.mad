--[=[
 o-----------------------------------------------------------------------------o
 |
 | Matrix module regression tests -  complex matrices
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the matrix module.

 o-----------------------------------------------------------------------------o
]=]

local assertEquals, assertAlmostEquals, assertInf, assertFalse, assertNotEquals,
      assertErrorMsgContains, assertNil, assertNaN, assertIsString, assertTrue,
      assertAllAlmostEquals in MAD.utest

local complex, range, nrange, nlogrange, vector, cvector, matrix, cmatrix,
      linspace, logspace in MAD
local is_vector, is_matrix, is_cvector, is_cmatrix, isa_vector, isa_matrix,
      is_complex, is_cdata, is_table, is_nil, is_string in MAD.typeid

local infi, tiny, eps, huge, inf, nan, pi, sqrt, abs, log, exp, min, random,
      randomseed, floor, round, sin, cos, tan, sinh, cosh, tanh, asin, acos,
      atan, asinh, acosh, atanh, atan2, hypot in MAD.gmath
local totable, tostring in MAD
local concat in MAD

local rep in MAD.utility

-- locals ---------------------------------------------------------------------o

local datC = require 'cmatrix_dat'
local dat  = require 'matrix_dat'
local mth  = \f,s,... s[f](s,...)
local idx  = \i,j,nc ( (i-1)*nc+j )
local toC  = \x complex(x,x)
local idxC = \i,j,nc toC(idx(i,j,nc))

local errCMat = cmatrix(2)

local G   = {}
G.cmatidx = {}
G.cmattmp = {}
G.matidx  = {}
G.size    = {}
G.vi      = {}
G.vj      = {}

for nr=1,5 do
  G.vi[nr] = vector(nr):fill(1..nr)
  G.vj[nr] = vector(nr):fill(1..nr)
  for nc=1,5 do
    G.cmatidx[#G.cmatidx+1] = cmatrix(nr,nc):fill(1..nr*nc):map( toC )
    G.cmattmp[#G.cmattmp+1] = cmatrix(nr,nc)
    G.matidx [#G.matidx+1]  =  matrix(nr,nc):fill(1..nr*nc)
    G.size   [#G.size+1]    = {nr,nc}
  end
end

randomseed( os.clock() )

-- regression test suites -----------------------------------------------------o

TestCMatrix    = {}
TestCMatrixErr = {}

TestCMatrixGet = {}
TestCMatrixSet = {}

TestCMatrixInPlace   = {}
TestCMatrixInPlaceII = {}
TestCMatrixFun       = {}

TestCMatrixSMaps  = {}
TestCMatrixSFolds = {}
TestCMatrixSScans = {}

TestCMatrixSympl  = {}
TestCMatrixLinAlg = {}
TestCMatrixOps    = {}
TestCMatrixLapack = {}
TestCMatrixFFT    = {}
TestCMatrixConv   = {}

function TestCMatrixErr:testCtor()
  local msg = {
  "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
   "matrix too large"                                                        ,
  }
  assertErrorMsgContains( msg[1], cmatrix, ''     )
  assertErrorMsgContains( msg[1], cmatrix, nil    )
  assertErrorMsgContains( msg[1], cmatrix, 0      )
  assertErrorMsgContains( msg[1], cmatrix, tiny   )
  assertErrorMsgContains( msg[1], cmatrix, eps    )
  assertErrorMsgContains( msg[1], cmatrix, 1..2   )
  assertErrorMsgContains( msg[1], cmatrix, infi   )
  assertErrorMsgContains( msg[1], cmatrix, nan    )
  assertErrorMsgContains( msg[1], cmatrix,-1      )
  assertErrorMsgContains( msg[1], cmatrix,-eps    )
  assertErrorMsgContains( msg[2], cmatrix, inf    )
  assertErrorMsgContains( msg[2], cmatrix, huge   )
  assertErrorMsgContains( msg[2], cmatrix, 2^15   )
  assertErrorMsgContains( msg[2], cvector, 2^29+1 )
end

function TestCMatrix:testCtor()
  for ii,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    for j=1,#cm do
      assertEquals( cm.data[j-1], j+j*1i )
    end
    assertTrue( is_cmatrix(cm) )
    if nc==1 then
      assertTrue  ( is_cvector(cm) )
      assertEquals( nc, 1 )
    else
    assertEquals( nr, G.size[ii][1] )
    assertEquals( nc, G.size[ii][2] )
    end
  end
end

function TestCMatrixErr:testCtorFromtable()
  local msg = {
  "invalid argument #1 (non-empty table expected)",
  "cannot convert 'string' to 'complex'"          ,
  }
  assertErrorMsgContains( msg[1], cmatrix, {nil} )
  assertErrorMsgContains( msg[2], cmatrix, {''}  )
end

function TestCMatrix:testCtorFromtable()
  local cv = cvector{1,2,3,4,5,6}
  local cm = cmatrix{{1,2,3},{4,5,6}}
  for j=1,#cm do assertEquals( cm.data[j-1], j+0i ) end
  for j=1,#cv do assertEquals( cv.data[j-1], j+0i ) end
  assertTrue  ( is_cmatrix( cmatrix{2}            ) )
  assertTrue  ( is_cvector( cmatrix{2}            ) )
  assertTrue  ( is_cmatrix( cmatrix{complex(0,0)} ) )
  assertEquals( cmatrix{complex(0,0)}, cmatrix(1)   )
end

function TestCMatrix:testCdataType()
  local cm, cv = cmatrix(2), cvector(2)
  assertFalse( is_matrix ( cm ) )
  assertFalse( is_matrix ( cv ) )
  assertFalse( is_vector ( cm ) )
  assertFalse( is_vector ( cv ) )
  assertTrue ( is_cmatrix( cm ) )
  assertTrue ( is_cmatrix( cv ) )
  assertFalse( is_cvector( cm ) )
  assertTrue ( is_cvector( cv ) )
  assertFalse( isa_vector( cm ) )
  assertTrue ( isa_vector( cv ) )
  assertTrue ( isa_matrix( cm ) )
  assertTrue ( isa_matrix( cv ) )
end

-- get, set, same -------------------------------------------------------------o

function TestCMatrixSet:setUp()
  for _,cm in ipairs(G.cmattmp) do cm:zeros() end
  for _,m  in ipairs(G.matidx)  do m :fill(1..m:size())  end
  for _,cm in ipairs(G.cmatidx) do cm:fill(1..cm:size()):map( toC, 'in') end
end

function TestCMatrixSet:tearDown()
  for _,cm in ipairs(G.cmattmp) do cm:zeros() end
  for _,m  in ipairs(G.matidx)  do m :fill(1..m:size())  end
  for _,cm in ipairs(G.cmatidx) do cm:fill(1..cm:size()):map( toC, 'in') end
end

function TestCMatrixErr:testGeti0()
    local msg = {
    "attempt to compare nil with number",
    }
  assertErrorMsgContains( msg[1], mth, 'geti0', errCMat, nil )
end

function TestCMatrixGet:testGeti0()
  for _,cm in ipairs(G.cmatidx) do
    for j=1,cm:size() do assertEquals( cm:geti0(j-1), j+j*1i ) end
  end
end

function TestCMatrixErr:testGeti()
  local msg = {
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'geti', errCMat, nil )
end

function TestCMatrixGet:testGeti()
  for _,cm in ipairs(G.cmatidx) do
    for j=1,cm:size() do assertEquals( cm:geti(j), j+j*1i ) end
  end
end

function TestCMatrixErr:testGet0()
  local msg = {
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'get0', errCMat, 0  , nil )
  assertErrorMsgContains( msg[1], mth, 'get0', errCMat, nil, 0   )
end

function TestCMatrixGet:testGet0()
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    for i=1,nr do
    for j=1,nc do
      assertEquals( cm:get0(i-1,j-1), idxC(i,j,nc) )
    end end
  end
end

function TestCMatrixErr:testGet()
  local msg = {
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'get0', errCMat, 1  , nil )
  assertErrorMsgContains( msg[1], mth, 'get0', errCMat, nil, 1   )
end

function TestCMatrixGet:testGet()
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    for i=1,nr do
    for j=1,nc do
      assertEquals( cm:get(i,j), idxC(i,j,nc) )
    end end
  end
end

function TestCMatrixErr:testSeti0()
  local msg = {
    "0-index out of bounds"             ,
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'seti0', errCMat, nan, 1i )
  assertErrorMsgContains( msg[1], mth, 'seti0', errCMat,-1  , 1i )
  assertErrorMsgContains( msg[1], mth, 'seti0', errCMat,-eps, 1i )
  assertErrorMsgContains( msg[1], mth, 'seti0', errCMat, 4  , 1i )
  assertErrorMsgContains( msg[2], mth, 'seti0', errCMat, nil, 1i )
end

function TestCMatrixSet:testSeti0()
  for _,cm in ipairs(G.cmattmp) do
    for i=1,cm:size() do
      cm:seti0((i-1), complex(i,i) )
      assertEquals( cm:geti0(i-1), complex(i,i) )
    end
  end
end

function TestCMatrixErr:testSeti()
  local msg = {
    "1-index out of bounds"             ,
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'seti', errCMat, nan  , 1i )
  assertErrorMsgContains( msg[1], mth, 'seti', errCMat, 0    , 1i )
  assertErrorMsgContains( msg[1], mth, 'seti', errCMat, 1-eps, 1i )
  assertErrorMsgContains( msg[1], mth, 'seti', errCMat, 5    , 1i )
  assertErrorMsgContains( msg[2], mth, 'seti', errCMat, nil  , 1i )
end

function TestCMatrixSet:testSeti()
  for _,cm in ipairs(G.cmattmp) do
    for i=1,cm:size() do
      cm:seti((i), complex(i,i))
      assertEquals( cm:geti(i), complex(i,i) )
    end
  end
end

function TestCMatrixErr:testSet0()
  local msg = {
    "0-index out of bounds"             ,
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'set0', errCMat, nan  , 1    , 1i )
  assertErrorMsgContains( msg[1], mth, 'set0', errCMat,-1    , 0    , 1i )
  assertErrorMsgContains( msg[1], mth, 'set0', errCMat,-1+eps, 0    , 1i )
  assertErrorMsgContains( msg[1], mth, 'set0', errCMat, 0    ,-1+eps, 1i )
  assertErrorMsgContains( msg[1], mth, 'set0', errCMat, 2    , 1    , 1i )
  assertErrorMsgContains( msg[1], mth, 'set0', errCMat, 1    , 2    , 1i )
  assertErrorMsgContains( msg[2], mth, 'set0', errCMat, nil  , 1    , 1i )
  assertErrorMsgContains( msg[2], mth, 'set0', errCMat, 1    , nil  , 1i )
end

function TestCMatrixSet:testSet0()
  for _,cm in ipairs(G.cmattmp) do
    local nr, nc = cm:sizes()
    for i=1,nr do
    for j=1,nc do
      cm:set0( i-1,j-1, idxC(i,j,nc) )
      assertEquals( cm:get0(i-1,j-1), idxC(i,j,nc) )
    end end
  end
end

function TestCMatrixErr:testSet()
  local msg = {
    "1-index out of bounds"             ,
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], mth, 'set', errCMat, nan  , 1    , 1i )
  assertErrorMsgContains( msg[1], mth, 'set', errCMat, 0    , 1    , 1i )
  assertErrorMsgContains( msg[1], mth, 'set', errCMat, 1    , 0    , 1i )
  assertErrorMsgContains( msg[1], mth, 'set', errCMat, 1-eps, 1    , 1i )
  assertErrorMsgContains( msg[1], mth, 'set', errCMat, 1    , 1-eps, 1i )
  assertErrorMsgContains( msg[2], mth, 'set', errCMat, nil  , 1    , 1i )
end

function TestCMatrixSet:testSet()
  for _,cm in ipairs(G.cmattmp) do
    local nr, nc = cm:sizes()
    for i=1,nr do
    for j=1,nc do
      cm:set( i, j, idxC(i,j,nc) )
      assertEquals( cm:get(i,j), idxC(i,j,nc) )
    end end
  end
end

function TestCMatrixErr:testSame()
  local msg = {
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
    "invalid argument #1 (non-empty table expected)"                           ,
  }
  assertErrorMsgContains( msg[1], mth, 'same', errCMat, 1   , ''      )
  assertErrorMsgContains( msg[1], mth, 'same', errCMat, 1   , 1..2    )
  assertErrorMsgContains( msg[1], mth, 'same', errCMat, 1   , nan     )
  assertErrorMsgContains( msg[2], mth, 'same', errCMat, 1   , {}      )
end

function TestCMatrixSet:testSame()
  local cm, _ = cmatrix(2)
  assertEquals( cm:same( nan), cmatrix(cm:sizes()) )
  assertEquals( cm:same( inf), cmatrix(cm:sizes()) )
  assertEquals( cm:same( 0  ), cmatrix(cm:sizes()) )
  for i,cm in ipairs(G.cmatidx) do
     --                   e ,nr,nc
    assertEquals( cm:same(        ), cmatrix(cm:sizes())           ) -- 1) x:same(               )
    assertEquals( cm:same(1       ), cmatrix(cm:sizes())           ) -- 5) x:same(   e           )
    -- two arg: nr, nc
    assertEquals( cm:same(2 , 2   ), cmatrix(2)                    ) -- 4')x:same( nr , nc       )
    assertEquals( cm:same(6 , 5   ), cmatrix(6,5)                  )
    assertEquals( cm:same(_ , 2 ,2), cmatrix(2)                    ) -- 4) x:same( nil, nr , nc  )
    -- three arg: e_, nr, nc
    assertEquals( cm:same(0i, 2, 2), cmatrix(2)                    ) -- 8) x:same(   e, nr , nc  )
    assertEquals( cm:same(1 , 2, 2), cmatrix(2)                    )
    -- one sizse defined
    assertEquals( cm:same(_ , 1   ), cmatrix(1        , cm:ncol()) ) -- 2) x:same( nil, nr       )
    assertEquals( cm:same(_ , _, 1), cmatrix(cm:nrow(), 1        ) ) -- 3) x:same( nil, nil, nc  )
    assertEquals( cm:same(0i, _, 1), cmatrix(cm:nrow(), 1        ) ) -- 7) x:same(   e, nil, nc  )
  end
end

-- getx, setx -----------------------------------------------------------------o

function TestCMatrixErr:testGetsub()
  local C = complex(1,1)
  local msg = {
    "invalid argument #2 (iterable expected)"                                  ,
    "invalid argument #3 (iterable expected)"                                  ,
    "invalid argument #4 (iterable expected)"                                  ,
    "invalid range member '1'"                                                 ,
    "cannot convert 'nil' to 'complex'"                                        ,
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'getsub', errCMat, nil              )
  assertErrorMsgContains( msg[1], mth, 'getsub', errCMat, ''               )
  assertErrorMsgContains( msg[1], mth, 'getsub', errCMat, \x x             )
  assertErrorMsgContains( msg[1], mth, 'getsub', errCMat, C                )
  assertErrorMsgContains( msg[2], mth, 'getsub', errCMat, 1   , nil        )
  assertErrorMsgContains( msg[2], mth, 'getsub', errCMat, 1   , ''         )
  assertErrorMsgContains( msg[2], mth, 'getsub', errCMat, 1   , \x x       )
  assertErrorMsgContains( msg[3], mth, 'getsub', errCMat, 0   , 0   , 1    )
  assertErrorMsgContains( msg[3], mth, 'getsub', errCMat, 1   , 1   , \x x )
  assertErrorMsgContains( msg[4], mth, 'getsub', errCMat, 1   , 1   , 1..4 )
  assertErrorMsgContains( msg[5], mth, 'getsub', errCMat, 0   , 0          )
  assertErrorMsgContains( msg[5], mth, 'getsub', errCMat, 0   , 1          )
  assertErrorMsgContains( msg[5], mth, 'getsub', errCMat, 1   , 0          )
  assertErrorMsgContains( msg[5], mth, 'getsub', errCMat, 3   , 1          )
  assertErrorMsgContains( msg[5], mth, 'getsub', errCMat, 1   , 3          )
  assertErrorMsgContains( msg[5], mth, 'getsub', errCMat, {0}       , 1    )
  assertErrorMsgContains( msg[5], mth, 'getsub', errCMat, vector(1) , 1    )
  assertErrorMsgContains( msg[6], mth, 'getsub', errCMat, 2..1      , 1    )
end

function TestCMatrixGet:testGetsub()
  local cm, r = G.cmatidx[25]
  assertEquals( cm:getsub(2,2          ):geti(1)  , cm:get(2,2) )
  assertEquals( cm:getsub(2,2,{}       )[1]       , cm:get(2,2) )
  assertEquals( cm:getsub(2,2,cvector(2)):get(1,1), cm:get(2,2) )
  assertEquals( cm:getsub(2,2,cvector(2)):get(2,1), 0+0i        )
  assertEquals( cm:getsub(2,2, vector(2)):get(2,1), 0           )
  r = cm:getsub( 1..2, 1..3) for i=1,2 do for j=1,3 do assertEquals( r:get(i,j), idxC(i,j,5) ) end end
  r = cm:getsub({1}  ,{1,2}) for i=1,1 do for j=1,2 do assertEquals( r:get(i,j), idxC(i,j,5) ) end end

  for _,cm in ipairs(G.cmatidx) do  -- 25  (all shapes over 5x5)
    local nr, nc = cm:sizes()
    for li=1,nr do                  -- 625 (all sub-shapes over 5x5)
    for lj=1,nc do
      local vi, vj = G.vi[li], G.vj[lj]
      vi:perm(); vj:perm()
      local r = cm:getsub(vi, vj)
      for i=1,li do
      for j=1,lj do
        assertEquals( r:get(i,j), cm:get(vi[i], vj[j]) )
      end end
    end end
  end
end

function TestCMatrixErr:testSetsub()
  local C = complex(1,1)
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (iterable expected)"          ,
    "invalid argument #4 (scalar or iterable expected)",
    "1-index out of bounds"                            ,
    "cannot convert 'nil' to 'double'"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'setsub', errCMat, nil , 1  , 1i  )
  assertErrorMsgContains( msg[1], mth, 'setsub', errCMat, ''  , 1  , 1i  )
  assertErrorMsgContains( msg[1], mth, 'setsub', errCMat, NaN , 1  , 1i  )
  assertErrorMsgContains( msg[1], mth, 'setsub', errCMat, \x x, 1  , 1i  )
  assertErrorMsgContains( msg[2], mth, 'setsub', errCMat, 1              )
  assertErrorMsgContains( msg[2], mth, 'setsub', errCMat, 1   , nil, 1i  )
  assertErrorMsgContains( msg[2], mth, 'setsub', errCMat, 1   , '' , 1i  )
  assertErrorMsgContains( msg[2], mth, 'setsub', errCMat, 1   , NaN, 1i  )
  assertErrorMsgContains( msg[3], mth, 'setsub', errCMat, 1   , 1  , nil )
  assertErrorMsgContains( msg[3], mth, 'setsub', errCMat, 1   , 1  , ''  )
  assertErrorMsgContains( msg[3], mth, 'setsub', errCMat, 1   , 1  , NaN )
  assertErrorMsgContains( msg[4], mth, 'setsub', errCMat, 0   , 1  , 1i  )
  assertErrorMsgContains( msg[4], mth, 'setsub', errCMat, 1   , 0  , 1i  )
  assertErrorMsgContains( msg[1], mth, 'setsub', errCMat, C   , 1  , 1i  )
  assertErrorMsgContains( msg[2], mth, 'setsub', errCMat, 1   , C  , 1i  )
end

function TestCMatrixSet:testSetsub()
  local cm = G.cmattmp[25]
  cm:setsub( 1..5, 1, {1,1,1,1,1}) assertEquals( cm:getsub( 1..5, 1   ), cm:same(5,1):fill(1)    )
                                   assertEquals( cm:getsub( 1..5, 2..5), cm:same(5,4)            )
  cm:setsub( 1..5, 1, 1..5       ) assertEquals( cm:getsub( 1..5, 1   ), cm:same(5,1):fill(1..5) )
                                   assertEquals( cm:getsub( 1..5, 2..5), cm:same(5,4)            )
  cm:setsub( 1..5, 1..5, 1       ) assertEquals( cm:getsub( 1..5, 1..5), cm:same(5,5):fill(1)    )
  cm:zeros()
-- recycling
  cm:setsub( 1..5, 1   , {1i} ) assertEquals( cm:getsub( 1..5, 1   ), cm:same(5,1):fill(1):map\x x*1i )
                                assertEquals( cm:getsub( 1..5, 2..5), cm:same(5,4)            )
  cm:setsub( 1..5, 1   , 1..3 ) assertEquals( cm:getsub( 1..3, 1   ), cm:same(3,1):fill(1..3) )
                                assertEquals( cm:getsub( 4..5, 1   ), cm:same(2,1):fill(1..2) )
                                assertEquals( cm:getsub( 1..5, 2..5), cm:same(5,4)            )
  cm:setsub( 1..5, 1..5, 1..5 )
  for i =1,5 do assertEquals( cm:getsub( i, 1..5), cm:same(1,5):fill(1..5) ) end

  for i,cm in ipairs(G.cmattmp) do
    local nr, nc = cm:sizes()
    for li=1,nr do
    for lj=1,nc do
      local vi, vj = G.vi[li], G.vj[lj]
      cm:zeros()
      vi:perm(); vj:perm()
      local cmtemp = cm:same(#vi,#vj):fill(1..#vi*#vj):map(toC)
      cm:setsub(vi,vj,cmtemp)
      if     #vi ~= nr and #vj ~= nc then  assertEquals( cm:getsub(1    ..nr, #vj+1..nc), cm:same(nr    , nc-#vj) )
                                           assertEquals( cm:getsub(#vi+1..nr, 1    ..nc), cm:same(nr-#vi, nc    ) )
      elseif #vi == nr and #vj ~= nc then  assertEquals( cm:getsub(1    ..nr, #vj+1..nc), cm:same(nr    , nc-#vj) )
      elseif #vi ~= nr and #vj == nc then  assertEquals( cm:getsub(#vi+1..nr, 1    ..nc), cm:same(nr-#vi, nc    ) ) end

      local rset  = cm:getsub(vi, vj)
      for i=1,li do
      for j=1,lj do
        assertEquals( rset:get(i,j), idxC(i,j,lj) )
      end end
    end end
  end
end

function TestCMatrixErr:testGetv()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'complex"       ,
    "invalid range member '1'"               ,
  }
  assertErrorMsgContains( msg[1], mth, 'getv', errCMat, nil             )
  assertErrorMsgContains( msg[1], mth, 'getv', errCMat, ''              )
  assertErrorMsgContains( msg[1], mth, 'getv', errCMat, NaN             )
  assertErrorMsgContains( msg[2], mth, 'getv', errCMat, 1        , ''   )
  assertErrorMsgContains( msg[2], mth, 'getv', errCMat, 1        , 1    )
  assertErrorMsgContains( msg[2], mth, 'getv', errCMat, 1        , \x x )
  assertErrorMsgContains( msg[3], mth, 'getv', errCMat, 0               )
  assertErrorMsgContains( msg[4], mth, 'getv', errCMat, 1        , 1..2 )
  assertErrorMsgContains( msg[3], mth, 'getv', errCMat, matrix(2)       )
end

function TestCMatrixGet:testGetv()
  local cm = cmatrix(4):fill(1..16)
  assertEquals( cm:getv(1   , {}       ), {1+0i}                )
  assertEquals( cm:getv(1   , vector(2)), cvector{1+0i,0+0i}    )
  assertEquals( cm:getv(1..2           ), cvector(2):fill(1..2):map\x x+0i )
  assertEquals( cm:getv({1,2}          ), cvector(2):fill(1..2):map\x x+0i )

  for _,cm in ipairs(G.cmatidx) do
    local cmn, nr, nc = cm:size(), cm:sizes()
    for j=1,cmn do assertEquals( cm:getv(j), cvector{j}:map(toC) ) end
    for li=1,nr do
      local vi = G.vi[li]:copy()
      vi:random(nil,1,cmn):perm()
      assertEquals( cm:getv(vi), vi:map(toC) )
    end
  end
  cm:getv(1..5,'in') assertEquals( cm, cmatrix(4):fill(1..16) ) -- same output - to documentation
end

function TestCMatrixErr:testSetv()
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'setv', errCMat, nil , 0    )
  assertErrorMsgContains( msg[1], mth, 'setv', errCMat, ''  , 0    )
  assertErrorMsgContains( msg[1], mth, 'setv', errCMat, NaN , 0    )
  assertErrorMsgContains( msg[1], mth, 'setv', errCMat, \x x, 0    )
  assertErrorMsgContains( msg[2], mth, 'setv', errCMat, 1   , ''   )
  assertErrorMsgContains( msg[2], mth, 'setv', errCMat, 1   , nil  )
  assertErrorMsgContains( msg[2], mth, 'setv', errCMat, 1   , NaN  )
  assertErrorMsgContains( msg[2], mth, 'setv', errCMat, 1   , \x x )
end

function TestCMatrixSet:testSetv()
  local cm = G.cmattmp[25]
  cm:setv(1..5, 1          ) assertEquals( cm:getv(1..5 ), cm:same(5 ,1):fill(1   ) )
                             assertEquals( cm:getv(6..25), cm:same(20,1)            )
  cm:setv(1..5, 1..5       ) assertEquals( cm:getv(1..5 ), cm:same(5 ,1):fill(1..5) )
                             assertEquals( cm:getv(6..25), cm:same(20,1)            )
  cm:setv(1..5, {0,0,0,0,0}) assertEquals( cm            , cm:same(5   )            )
-- recycling
  cm:setv(1..6, 1..3       ) assertEquals( cm:getv(1..3 ), cm:same(3 ,1):fill(1..3) )
                             assertEquals( cm:getv(4..6 ), cm:same(3 ,1):fill(1..3) )
  cm:setv(1..6, 1..7       ) assertEquals( cm:getv(1..6 ), cm:same(6 ,1):fill(1..6) )
                             assertEquals( cm:getv(7    ), cm:same(1 ,1)            )
  cm:zeros()

  for _,c in ipairs(G.cmattmp) do
    local nr, nc = cm:sizes()
    for j=1,cm:size() do
      cm:setv(j,j)
      assertEquals( cm:getv(j), cvector{j} )
    end
    for li=1,nr do
      local vi = G.vi[li]
      vi:perm()
      local cmt = cm:getv(vi)
      cm:setv(vi, 1..li)
      assertEquals( cm:getv(vi), vi:same(li):fill(1..li) )
      cm:setv(vi, cmt   )
    end
  end
end

function TestCMatrixErr:testGetdiag()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid range member '1'"               ,
  }
  assertErrorMsgContains( msg[1], mth, 'getdiag', errCMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'getdiag', errCMat, \x x )
  assertErrorMsgContains( msg[1], mth, 'getdiag', errCMat, 1    )
  assertErrorMsgContains( msg[2], mth, 'getdiag', errCMat, 1..2 )
end

function TestCMatrixGet:testGetdiag()
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    local n , d  = min(nr,nc), cm:getdiag()
    assertEquals( {d:sizes()}, {n,1} )
    for i=1,n do assertEquals( d[i], cm:get(i,i) ) end
  end
end

function TestCMatrixErr:testSetdiag()
  local msg = {
    "invalid argument #2 (scalar or iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'setdiag', errCMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'setdiag', errCMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'setdiag', errCMat, \x x )
end

function TestCMatrixSet:testSetdiag()
  for _,cm in ipairs(G.cmattmp) do
    local nr, nc = cm:sizes()
    local n = min(nr,nc)
    for i=1,n do
      local ra = cm:same(i,1):fill(1..i):map(toC)
      cm:setdiag(ra)
      local d = cm:getdiag()
      assertEquals( {cm:getdiag():sizes()}, {n,1} )
      for i=1,n do assertEquals( d[i], cm:get(i,i) ) end
    end
  end
  local cm = G.cmattmp[25]
  cm:setdiag(1..3) assertEquals( cm:getdiag(), cvector{1,2,3,1,2} )
  cm:setdiag(1..6) assertEquals( cm:getdiag(), cvector{1,2,3,4,5} )
end

function TestCMatrixErr:testGetrow()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'complex'"       ,
    "invalid range member '1'"               ,
    "1-index out of bounds"                  ,
  }
  assertErrorMsgContains( msg[1], mth, 'getrow', errCMat, ''               )
  assertErrorMsgContains( msg[1], mth, 'getrow', errCMat, nil              )
  assertErrorMsgContains( msg[1], mth, 'getrow', errCMat, NaN              )
  assertErrorMsgContains( msg[1], mth, 'getrow', errCMat, \x x             )
  assertErrorMsgContains( msg[2], mth, 'getrow', errCMat, 1   , ''         )
  assertErrorMsgContains( msg[2], mth, 'getrow', errCMat, 1   , 1          )
  assertErrorMsgContains( msg[3], mth, 'getrow', errCMat, 0                )
  assertErrorMsgContains( msg[3], mth, 'getrow', errCMat, 5                )
  assertErrorMsgContains( msg[4], mth, 'getrow', errCMat, 1   , 1..2       )
  assertErrorMsgContains( msg[5], mth, 'getrow', errCMat, 1   , cvector(1) )
end

function TestCMatrixGet:testGetrow()
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    for i=1,nr do
    for a=1,i  do
      for li=1,i-a+1 do
        local ra = a..i..li
        assertEquals( cm:getrow(ra), cm:getsub(ra, 1..nc) )
      end
    end end
  end
end

function TestCMatrixErr:testSetrow()
  local m = matrix(3)
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
    "1-index out of bounds"                            ,
    "cannot convert 'nil' to 'complex'"                ,
  }
  assertErrorMsgContains( msg[1], mth, 'setrow', errCMat, ''         )
  assertErrorMsgContains( msg[1], mth, 'setrow', errCMat, nil        )
  assertErrorMsgContains( msg[1], mth, 'setrow', errCMat, NaN        )
  assertErrorMsgContains( msg[1], mth, 'setrow', errCMat, \x x       )
  assertErrorMsgContains( msg[2], mth, 'setrow', errCMat, 1   , nil  )
  assertErrorMsgContains( msg[2], mth, 'setrow', errCMat, 1   , ''   )
  assertErrorMsgContains( msg[3], mth, 'setrow', errCMat, 0   , 1    )
  assertErrorMsgContains( msg[3], mth, 'setrow', errCMat, 3   , 1    )
end

function TestCMatrixSet:testSetrow()
  local cm = G.cmattmp[25]
  cm:setrow(1, 1)           assertEquals( cm:getrow(1   ), cm:same(1,5):fill(1)    )
                            assertEquals( cm:getrow(2..5), cm:same(4,5)            )
  cm:setrow(1, 1..5)        assertEquals( cm:getrow(1   ), cm:same(1,5):fill(1..5) )
                            assertEquals( cm:getrow(2..5), cm:same(4,5)            )
  cm:setrow(1, {0,0,0,0,0}) assertEquals( cm:getrow(1..5), cm:same(5,5)            )
-- recycling
  cm:setrow(1, 1..3)        assertEquals( cm:getrow(1   ), cm:same(1,5):fill({1,2,3,1,2}) )
                            assertEquals( cm:getrow(2..5), cm:same(4,5)                   )
  cm:setrow(1, {0} )        assertEquals( cm:getrow(1..5), cm:same(5,5)                   )

  for _,cm in ipairs(G.cmattmp) do
    local nr, nc = cm:sizes()
    for i=1,nr do
    for a=1,i  do
      for li=1,i-a+1 do
        local ra = a..i..li
        local r = 1..nc*#ra
        cm:setrow(ra,r)
        for ii=1,#ra do
        for jj=1,nc  do
          assertEquals( cm:getrow(ra):get(ii,jj), idx(ii,jj,nc)+0i )
        end end
        cm:setrow(ra,0)
      end
    end end
  end
end

function TestCMatrixErr:testGetcol()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'complex'"      ,
    "invalid range member '1'"               ,
    "1-index out of bounds"                  ,
  }
  assertErrorMsgContains( msg[1], mth, 'getcol', errCMat, ''               )
  assertErrorMsgContains( msg[1], mth, 'getcol', errCMat, nil              )
  assertErrorMsgContains( msg[1], mth, 'getcol', errCMat, NaN              )
  assertErrorMsgContains( msg[1], mth, 'getcol', errCMat, \x x             )
  assertErrorMsgContains( msg[2], mth, 'getcol', errCMat, 1   , ''         )
  assertErrorMsgContains( msg[2], mth, 'getcol', errCMat, 1   , 1          )
  assertErrorMsgContains( msg[3], mth, 'getcol', errCMat, 0                )
  assertErrorMsgContains( msg[3], mth, 'getcol', errCMat, 3                )
  assertErrorMsgContains( msg[4], mth, 'getcol', errCMat, 1   , 1..2       )
  assertErrorMsgContains( msg[5], mth, 'getcol', errCMat, 1   , cvector(1) )
end

function TestCMatrixGet:testGetcol()
  local cm = G.cmatidx[25]
  assertEquals( cm:getcol({1,2}          ), cm:getsub(1..5,{1,2}    ) )
  assertEquals( cm:getcol(vector{1,2}    ), cm:getsub(1..5,{1,2}    ) )
  assertEquals( cm:getcol(vector{1}  , {}), cm:getsub(1..5,{1}  , {}) )

  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    for j=1,nc do
    for b=1,j  do
      for lj = 1,j-b+1 do
        local rb = b..j..lj
        assertEquals( cm:getcol(rb) , cm:getsub(1..nr,rb) )
      end
    end end
  end
end

function TestCMatrixErr:testSetcol()
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
    "1-index out of bounds"                            ,
    "cannot convert 'nil' to 'double'"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'setcol', errCMat, ''         )
  assertErrorMsgContains( msg[1], mth, 'setcol', errCMat, nil        )
  assertErrorMsgContains( msg[1], mth, 'setcol', errCMat, NaN        )
  assertErrorMsgContains( msg[1], mth, 'setcol', errCMat, \x x       )
  assertErrorMsgContains( msg[2], mth, 'setcol', errCMat, 1   ,  ''  )
  assertErrorMsgContains( msg[2], mth, 'setcol', errCMat, 1   ,  nil )
  assertErrorMsgContains( msg[3], mth, 'setcol', errCMat, 0   ,  1   )
  assertErrorMsgContains( msg[3], mth, 'setcol', errCMat, 3   ,  1   )
end

function TestCMatrixSet:testSetcol()
  local cm = G.cmattmp[25]
  cm:setcol(1, 1)           assertEquals( cm:getcol(1   ), cm:same(5,1):fill(1   )        )
                            assertEquals( cm:getcol(2..5), cm:same(5,4)                   )
  cm:setcol(1, 1..5)        assertEquals( cm:getcol(1   ), cm:same(5,1):fill(1..5)        )
                            assertEquals( cm:getcol(2..5), cm:same(5,4)                   )
  cm:setcol(1, {0,0,0,0,0}) assertEquals( cm:getcol(1..5), cm:same(5,5)                   )
-- recycling
  cm:setcol(1, 1..3)        assertEquals( cm:getcol(1   ), cm:same(5,1):fill({1,2,3,1,2}) )
                            assertEquals( cm:getcol(2..5), cm:same(5,4)                   )
  cm:setcol(1, {0} )        assertEquals( cm:getcol(1..5), cm:same(5,5)                   )
  for _,cm in ipairs(G.cmattmp) do
    local nr, nc = cm:sizes()
    for j=1,nc do
    for b=1,j  do
      for lj = 1,j-b+1 do
        local rb = b..j..lj
        local r = 1..nr*#rb
        cm:setcol(rb,r)
        for ii=1,nr  do
        for jj=1,#rb do
          assertEquals( cm:getcol(rb):get(ii,jj), idx(jj,ii,nr)+0i )
        end end
        cm:setcol(rb,0)
      end
    end end
  end
end

-- size -----------------------------------------------------------------------o

function TestCMatrix:testNrow()
  for i,cm in ipairs(G.cmatidx) do
    assertEquals( cm:nrow(), G.size[i][1] )
  end
end

function TestCMatrix:testNcol()
  for i,cm in ipairs(G.cmatidx) do
    assertEquals( cm:ncol(), G.size[i][2] )
  end
end

function TestCMatrix:testSize()
  for i,cm in ipairs(G.cmatidx) do
    assertEquals( cm:size(), G.size[i][1]*G.size[i][2] )
  end
end

function TestCMatrix:testSizes()
  for i,cm in ipairs(G.cmatidx) do
    assertEquals( {cm:sizes()}, G.size[i] )
  end
end

function TestCMatrix:testTsizes()
  for i,cm in ipairs(G.cmatidx) do
    assertEquals( {cm:tsizes()}, {G.size[i][2], G.size[i][1]} )
  end
end

-- in place -------------------------------------------------------------------o

function TestCMatrixInPlace:setUp()
  for _,cm in ipairs(G.cmatidx) do cm:fill(1..cm:size()):map( toC, 'in') end
end

function TestCMatrixInPlace:tearDown()
  for _,cm in ipairs(G.cmatidx) do cm:fill(1..cm:size()):map( toC, 'in') end
end

function TestCMatrixErr:testRandom()
  local msg, s = {
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
    "invalid argument #1 (non-empty table expected)"                           ,
  }
  assertErrorMsgContains( msg[1], mth, 'same', errCMat, 1, ''   )
  assertErrorMsgContains( msg[1], mth, 'same', errCMat, 1, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'same', errCMat, 1, nan  )
  assertErrorMsgContains( msg[2], mth, 'same', errCMat, 1, {}   )
end

function TestCMatrixInPlace:testRandom()
  local oldVal, val = {}, {}
  for _,cm in ipairs(G.cmatidx) do
    local mn = cm:size()
    local oldVal, val = table.new(mn,0), table.new(mn,0)
    cm:random()
    oldVal[0] = complex(1,1)
    for i = 1,mn do
      val[i] = cm:geti(i)
      assertTrue ( val[i]:imag() <  1                  )
      assertTrue ( val[i]:real() <  1                  )
      assertTrue ( val[i]:imag() >= 0                  )
      assertTrue ( val[i]:real() >= 0                  )
      assertTrue ( val[i]:imag() ~= val[i]:real()      )
      assertFalse( val[i]:imag() == oldVal[i-1]:imag() )
      assertFalse( val[i]:real() == oldVal[i-1]:real() )
      oldVal[i] = val[i]
    end
    cm:random(nil,1,mn)
    for i = 1,mn do
      assertTrue ( cm:geti(i):imag() <= mn )
      assertTrue ( cm:geti(i):real() <= mn )
      assertTrue ( cm:geti(i):imag() >= 1  )
      assertTrue ( cm:geti(i):real() >= 1  )
    end
  end
end

function TestCMatrixInPlaceII:testPerm()
  local oldCV = {}
  local cv = cvector(25):fill(1..25):map(toC)
  oldCV[0] = 0
  for i=1,10 do
    cv = cv:perm()
    for is=1,cv:size() do
      assertTrue( cv:geti(is):imag() <= 25 )
      assertTrue( cv:geti(is):real() <= 25 )
      assertTrue( cv:geti(is):imag() >= 1  )
      assertTrue( cv:geti(is):real() >= 1  )
    end
    assertFalse( cv == oldCV[i-1] )
    oldCV[i] = cv:copy()
  end
end

function TestCMatrixErr:testFill()
  local msg = {
    "invalid argument #2 (scalar, callable or indexable expected)",
    "incompatible container size"                                 ,
    "invalid container (iterable expected)"                       ,
  }
  assertErrorMsgContains( msg[1], mth,'fill', errCMat, nil  )
  assertErrorMsgContains( msg[1], mth,'fill', errCMat, true )
  assertErrorMsgContains( msg[1], mth,'fill', errCMat, ''   )
  assertErrorMsgContains( msg[2], mth,'fill', errCMat, {}   )
end

function TestCMatrixInPlace:testFill()
  for _,cm in ipairs(G.cmatidx) do
    local mn = cm:size()
    --scalar
    cm:fill(nan   )                  for j=1,mn do assertNaN   ( cm:geti(j):real()      )
                                                   assertEquals( cm:geti(j):imag(), 0   ) end
    cm:fill(nan*1i)                  for j=1,mn do assertNaN   ( cm:geti(j):real()      )
                                                   assertNaN   ( cm:geti(j):imag()      ) end
    cm:fill(inf)                     for j=1,mn do assertEquals( cm:geti(j), inf + 0i   ) end
    cm:fill(1  )                     for j=1,mn do assertEquals( cm:geti(j), 1   + 0i   ) end
    cm:fill(2i )                     for j=1,mn do assertEquals( cm:geti(j), 0   + 2i   ) end
    cm:fill(complex(1,1))            for j=1,mn do assertEquals( cm:geti(j), 1   + 1i   ) end
    --generator
    cm:fill(1..mn)                   for j=1,mn do assertEquals( cm:geti(j), j   + 0i   ) end
    cm:fill(1..mn):fill\x  x*1i      for j=1,mn do assertEquals( cm:geti(j), 0   + 1i*j ) end
    cm:fill(1..mn):fill\x (x^2)      for j=1,mn do assertEquals( cm:geti(j), j^2 + 0i   ) end
    cm:fill(1..mn):fill\x ((x*1i)^2) for j=1,mn do assertEquals( cm:geti(j),-j^2 + 0i   ) end
    --2D container
    cm:fill( cm:same() )             for j=1,mn do assertEquals( cm:geti(j), 0   + 0i   ) end
    --1D container
    t={} for i=1,mn do t[i]=i end
    cm:fill(t)                       for j=1,mn do assertEquals( cm:geti(j), j   + 0i   ) end
    cm:fill(vector(mn))              for j=1,mn do assertEquals( cm:geti(j), 0   + 0i   ) end
  end
end

function TestCMatrixErr:testCopy()
  local msg = {
    "invalid argument #1 (cmatrix expected)",
  }
  assertErrorMsgContains( msg[1], mth,'copy', errCMat, 1         )
  assertErrorMsgContains( msg[1], mth,'copy', errCMat, matrix(2) )
end

function TestCMatrixInPlaceII:testCopy()
  for i,cm in ipairs(G.cmatidx) do
    local cmcopy = cmatrix( cm:sizes() )
    cmcopy:copy(cm)
    assertEquals( cm       , cmcopy )
    assertEquals( cm:copy(), cm     )
  end
end

function TestCMatrixInPlaceII:testResize()
  local cmres, minr, minc, cm, cm1, _
  for i,cm in ipairs(G.cmatidx) do
    local nr,nc = cm:sizes()
    for ic=nc+1,nc+3 do
    for ir=nr+1,nr+3 do
      cmres      = cm:resize(ir, ic)
      minr, minc = min(nr,ir), min(nc,ic)
      assertEquals( {cmres:sizes()}                    , {ir, ic}                     )
      assertEquals( cmres:getsub(1..minr   ,1..minc   ), cm:getsub(1..minr ,1..minc ) )
      assertEquals( cmres:getsub(minr+1..ir,1..minc   ), cm:same(_, ir-minr, minc   ) )
      assertEquals( cmres:getsub(1..minr   ,minc+1..ic), cm:same(_, minr   , ic-minc) )
    end
    end
    for ic=1,nc do
    for ir=1,nr do
      cmres      = cm:resize(ir, ic)
      minr, minc = min(nr,ir), min(nc,ic)
      assertEquals( {cmres:sizes()}, {ir, ic}                   )
      assertEquals( cmres          , cm:getsub(1..minr,1..minc) )
    end
    end
  end
  cm , cm1 = cmatrix(2):fill(1..4):map(toC), cmatrix(3)
  cmres = cm:resize(cm1)
  assertEquals({cmres:sizes()}          ,{cm1:sizes()}           )
  assertEquals( cmres:getsub(1..2, 1..2), cm :getsub(1..2, 1..2) )
  assertEquals( cmres:getsub(3   , 1..3), cm1:getsub(3   , 1..3) )
  assertEquals( cmres:getsub(1..3, 3   ), cm1:getsub(1..3, 3   ) )
end

function TestCMatrixInPlace:testZeros()
  for _,cm in ipairs(G.cmatidx) do
    cm:zeros()
    assertEquals( cm, cm:same() )
  end
end

function TestCMatrixInPlace:testOnes()
  for _,cm in ipairs(G.cmatidx) do
    cm:ones(    ) assertEquals( cm, cm:same():fill(1   ) )
    cm:ones(2   ) assertEquals( cm, cm:same():fill(2   ) )
    cm:ones(  1i) assertEquals( cm, cm:same():fill(  1i) )
    cm:ones(1+1i) assertEquals( cm, cm:same():fill(1+1i) )
  end
end

function TestCMatrixInPlace:testEye()
  for i,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    local min = min(nr,nc)
    cm:eye()
    assertEquals( cm:getdiag(), cm:same(min,1):fill(1) )
    for i=1,nr do
    for j=1,nc do
      if i~=j then assertEquals( cm:get(i,j), 0+0i ) end
    end end
    cm:eye(2 ) assertEquals( cm:getdiag(), cm:same(min,1):fill(2 ) )
    cm:eye(1i) assertEquals( cm:getdiag(), cm:same(min,1):fill(1i) )
  end
end

function TestCMatrixErr:testSymp()
  local msg = {
    "invalid argument #1 (2n matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth,'symp',  cmatrix(3)   )
  assertErrorMsgContains( msg[1], mth,'symp',  cvector(2)   )
  assertErrorMsgContains( msg[1], mth,'symp',  cmatrix(4,3) )
end

function TestCMatrixInPlaceII:testSymp()
  for i=2,6,2 do
    local cm = cmatrix(i):symp()
    assertTrue( cm:t() == -cm )
    for ii=1,cm:ncol() do
    for jj=1,cm:nrow() do
      if     ii==2 and jj==1 then assertEquals( cm:get(ii,jj),-1 + 0i )
      elseif ii==4 and jj==3 then assertEquals( cm:get(ii,jj),-1 + 0i )
      elseif ii==6 and jj==5 then assertEquals( cm:get(ii,jj),-1 + 0i )
      elseif ii==1 and jj==2 then assertEquals( cm:get(ii,jj), 1 + 0i )
      elseif ii==3 and jj==4 then assertEquals( cm:get(ii,jj), 1 + 0i )
      elseif ii==5 and jj==6 then assertEquals( cm:get(ii,jj), 1 + 0i )
      else                        assertEquals( cm:get(ii,jj), 0 + 0i ) end
    end end
  end
end

function TestCMatrixErr:testCirc()
  local msg = {
    "invalid argument #2 (iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth,'circ', errCMat, nil  )
  assertErrorMsgContains( msg[1], mth,'circ', errCMat, 1    )
  assertErrorMsgContains( msg[1], mth,'circ', errCMat, \x x )
end

function TestCMatrixInPlaceII:testCirc()
  for ii=1,5 do
    local cm = cmatrix(ii)
    local t = {} for j=1,ii do t[j]=j+j*1i end
    --'row'
    cm:circ(t)
    for j=1,ii   do assertEquals( cm:get(j  ,j  ), 1    +       1i ) end
    for j=1,ii-1 do assertEquals( cm:get(j+1,j  ), 2    +       2i )
                    assertEquals( cm:get(j  ,j+1), ii   + ii   *1i ) end
    for j=1,ii-2 do assertEquals( cm:get(j+2,j  ), 3    +       3i )
                    assertEquals( cm:get(j  ,j+2), ii-1 +(ii-1)*1i ) end
    for j=1,ii-3 do assertEquals( cm:get(j+3,j  ), 4    +       4i )
                    assertEquals( cm:get(j  ,j+3), ii-2 +(ii-2)*1i ) end
    cm:fill(0):circ(cvector(ii):fill(1..ii))
    for j=1,ii   do assertEquals( cm:get(j  ,j  ), 1    +       0i ) end
    for j=1,ii-1 do assertEquals( cm:get(j+1,j  ), 2    +       0i )
                    assertEquals( cm:get(j  ,j+1), ii   +       0i ) end
    for j=1,ii-2 do assertEquals( cm:get(j+2,j  ), 3    +       0i )
                    assertEquals( cm:get(j  ,j+2), ii-1 +       0i ) end
    for j=1,ii-3 do assertEquals( cm:get(j+3,j  ), 4    +       0i )
                    assertEquals( cm:get(j  ,j+3), ii-2 +       0i ) end
    --'col'
    cm:fill(0):circ(cmatrix(1,ii):fill(1..ii):map(toC))
    for j=1,ii   do assertEquals( cm:get(j  ,j  ), 1    +       1i ) end
    for j=1,ii-1 do assertEquals( cm:get(j+1,j  ), ii   + ii   *1i )
                    assertEquals( cm:get(j  ,j+1), 2    +       2i ) end
    for j=1,ii-2 do assertEquals( cm:get(j+2,j  ), ii-1 +(ii-1)*1i )
                    assertEquals( cm:get(j  ,j+2), 3    +       3i ) end
    for j=1,ii-3 do assertEquals( cm:get(j+3,j  ), ii-2 +(ii-2)*1i )
                    assertEquals( cm:get(j  ,j+3), 4    +       4i ) end
  end
end

function TestCMatrixInPlaceII:testShift()
  local cm = cvector(4):fill(1..4)
  assertEquals( cm:shift( 0  , 0  ), cm )
  assertEquals( cm:shift( 4  , 0  ), cm )
  assertEquals( cm:shift( 0  , 1  ), cm )
  assertEquals( cm:shift( 0  , 2  ), cm )
  assertEquals( cm:shift( nil, 0  ), cm )
  assertEquals( cm:shift( 0  , nil), cm )
  assertEquals( cm:shift( nil, nil), cm )

  cm = cmatrix(2):fill(1..4)
  assertEquals( cm:shift( 0  , 0  ), cm )
  assertEquals( cm:shift( 3  , 0  ), cm )
  assertEquals( cm:shift(-3  , 0  ), cm )

  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc):map(toC)
    for inc=0,nc do
    for inr=0,nr do
      cm:shift(inr,inc)
      for jnr=1,nr do
      for jnc=1,nc do
        if     jnc<=inc and jnr<=inr then assertEquals( cm:get(jnr,jnc), idxC(jnr+(nr-inr),jnc+(nc-inc),nc) )
        elseif jnc<=inc and jnr> inr then assertEquals( cm:get(jnr,jnc), idxC(jnr-inr     ,jnc+(nc-inc),nc) )
        elseif jnc> inc and jnr<=inr then assertEquals( cm:get(jnr,jnc), idxC(jnr+(nr-inr),jnc- inc    ,nc) )
        else                              assertEquals( cm:get(jnr,jnc), idxC(jnr-inr     ,jnc- inc    ,nc) ) end
      end end
      cm:shift(-inr,-inc)
    end end
  end end
end

function TestCMatrixErr:testReshape()
  local msg = {
    "invalid matrix new sizes",
  }
  assertErrorMsgContains( msg[1], mth,'reshape', errCMat, nil, 2 )
  assertErrorMsgContains( msg[1], mth,'reshape', errCMat, 0  , 1 )
  assertErrorMsgContains( msg[1], mth,'reshape', errCMat, 1  , 0 )
  assertErrorMsgContains( msg[1], mth,'reshape', errCMat, 3  , 2 )
  assertErrorMsgContains( msg[1], mth,'reshape', errCMat, 1  , 5 )
end

function TestCMatrixInPlaceII:testReshape()
  local cm
  cm = matrix(2,2) assertEquals( {cm:reshape() :sizes()}, {4,1} )
  cm = matrix(2,2) assertEquals( {cm:reshape(1):sizes()}, {1,1} )
  for nr=1,5 do
  for nc=1,5 do
    for i=1,nr do
    for j=1,nc do
      cm = matrix(nr,nc):fill(1..nr*nc)
      cm:reshape(i,j)
      assertEquals( {cm:sizes()}, {i,j}                     )
      assertEquals( cm          , cmatrix(i,j):fill(1..i*j) )
    end end
  end end
end

-- foreach, filter, map, fold, scan -------------------------------------------o

function TestCMatrixFun:setUp()
  for _,cm in ipairs(G.cmatidx) do cm:fill(1..cm:size()):map(\x x+x*1i,'in') end
end

function TestCMatrixFun:tearDown()
  for _,cm in ipairs(G.cmatidx) do cm:fill(1..cm:size()):map(\x x+x*1i,'in') end
end

function TestCMatrixErr:testForeach()
  local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'foreach', errCMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'foreach', errCMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'foreach', errCMat, 1         )
  assertErrorMsgContains( msg[1], mth, 'foreach', errCMat, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'foreach', errCMat, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'foreach', errCMat, { }       )
end

function TestCMatrixFun:testForeach()
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    local t = table.new(nr,nc)
    local f = \x,i,j => t[i][j] = x  end
    for i=0,nr-1 do local c = t[i+1] or table.new(nc,0); t[i+1] = c end
    cm:foreach(f)
    for i=1,nr do for j=1,nc do assertEquals( t[i][j], idxC(i,j,nc) ) end end
  end
end

function TestCMatrixErr:testMap()
  local msg = {
    "invalid argument #2 (callable expected)"          ,
    "invalid argument #2 (scalar function expected)"   ,
    "invalid argument #3 (iterable expected)"          ,
    "invalid arguments (unsupported complex operation)",
    "invalid range member '1'"                         ,
    "attempt to compare 'complex' with 'number'"       ,
    "attempt to compare 'complex' with 'complex'"      ,
  }
  assertErrorMsgContains( msg[1], mth, 'map', errCMat, ''              )
  assertErrorMsgContains( msg[1], mth, 'map', errCMat, 1..2            )
  assertErrorMsgContains( msg[1], mth, 'map', errCMat, 1               )
  assertErrorMsgContains( msg[1], mth, 'map', errCMat, matrix(1)       )
  assertErrorMsgContains( msg[1], mth, 'map', errCMat, {}              )
  assertErrorMsgContains( msg[2], mth, 'map', errCMat, '!'             )
  assertErrorMsgContains( msg[4], mth, 'map', errCMat, '+'             )
  assertErrorMsgContains( msg[3], mth, 'map', errCMat, \x x+1   , ''   )
  assertErrorMsgContains( msg[3], mth, 'map', errCMat, \x x+1   , 1    )
  assertErrorMsgContains( msg[5], mth, 'map', errCMat, \x x+1   , 1..2 )
  assertErrorMsgContains( msg[6], mth, 'map', errCMat, \x x<2          )
  assertErrorMsgContains( msg[7], mth, 'map', errCMat, \x x<2+2i       )
end

function TestCMatrixFun:testMap()
  for i,cm in ipairs(G.cmatidx) do
    local mn, nr, nc = cm:size(), cm:sizes()
    assertEquals( cm:map('~'      ), cm:same():fill(-1..-mn..-1):fill(toC) )
    assertEquals( cm:map(\x x-x   ), cm:same()                             )
    --totable test
    assertEquals( cm:map(\x x-x,{}), rep(0+0i , mn) )
    assertEquals( cm:map('!'   ,{}), rep(false, mn) )
    --'in' place test
    cm:map('~'   , 'in') assertEquals( cm, cm:same():fill(-1..-mn..-1):fill(toC) )
    cm:map(\x x-x, 'in') assertEquals( cm, cm:same()                             )
  end
end

function TestCMatrixErr:testMap2()
  local cm = cmatrix(1)
  local msg = {
    "invalid argument #2 (scalar or iterable expected)",
    "invalid argument #3 (callable expected)"          ,
    "invalid argument #3 (scalar function expected)"   ,
    "invalid argument #4 (iterable expected)"          ,
    "invalid range member '1'"                         ,
    "invalid arguments (unsupported complex operation)",
    "attempt to compare 'complex' with 'complex'"      ,
  }
  assertErrorMsgContains( msg[1], mth, 'map2', errCMat, nil               )
  assertErrorMsgContains( msg[1], mth, 'map2', errCMat, ''                )
  assertErrorMsgContains( msg[1], mth, 'map2', errCMat, NaN               )
  assertErrorMsgContains( msg[1], mth, 'map2', errCMat, \x x              )
  assertErrorMsgContains( msg[2], mth, 'map2', errCMat, cm   , nil        )
  assertErrorMsgContains( msg[2], mth, 'map2', errCMat, cm   , ''         )
  assertErrorMsgContains( msg[2], mth, 'map2', errCMat, cm   , 1..2       )
  assertErrorMsgContains( msg[2], mth, 'map2', errCMat, cm   , 1          )
  assertErrorMsgContains( msg[3], mth, 'map2', errCMat, cm   , '!'        )
  assertErrorMsgContains( msg[4], mth, 'map2', errCMat, cm   , \x x, 1    )
  assertErrorMsgContains( msg[5], mth, 'map2', errCMat, cm   , \x x, 1..2 )
  assertErrorMsgContains( msg[6], mth, 'map2', errCMat, cm   , \x,y  x+y  )
  assertErrorMsgContains( msg[7], mth, 'map2', errCMat, cm   , '<'        )
end

function TestCMatrixFun:testMap2()
  for _,cm in ipairs(G.cmatidx) do
    local mn, nr, nc = cm:size(), cm:sizes()
    local m = matrix(nr,nc):fill(1..mn)
    assertEquals( cm:map2(1 , '+'         ), cm:same():fill(1..mn):map(\x ((x+1)+x*1i)) )
    assertEquals( cm:map2(1 , \x,y x-y    ), cm:same():fill(1..mn):map(\x ((x-1)+x*1i)) )
    assertEquals( cm:map2(cm, '~'         ), cm:same():fill(1..mn):map(\x  -x-x*1i    ) )
    assertEquals( cm:map2(cm, '+'         ), cm:copy()            :map(\x  2*x        ) )
    assertEquals( cm:map2(cm, \x,y x-y    ), cm:same()                                  )
    assertEquals( cm:map2(cm, '-'     , {}), cm:same()            :map(\x  x      , {}) )  --totable test
    assertEquals( cm:map2(cm, '!'     , {}), rep(false, mn)                             )  --totable test

    local ir = { m, 1..mn, totable(1..mn) }
    for d=1,#ir do
      assertEquals( cm:map2(ir[d], '+'         ), cm:same():fill(1..mn):map(\x (x*2+x   *1i)    ) )
      assertEquals( cm:map2(ir[d], \x,y x-y    ), cm:copy()            :map(\x  x:imag()*1i     ) )
      assertEquals( cm:map2(ir[d], '-'     , {}), cm:same():fill(1..mn):map(\x  x       *1i, {} ) ) --totable test
    end
    --'in' place test
    for d=1,#ir do
      cm:map2(ir[d], '~'     , 'in') for j=1,mn do assertEquals( cm:geti(j), j*((-1)^d)*(1+1i) ) end
    end
      cm:map2(cm   , \x,y x-y, 'in') assertEquals( cm, cm:same() )
  end
end

function TestCMatrixErr:testMap3()
  local cm = cmatrix(1)
  local msg = {
    "invalid argument #2 (scalar or iterable expected)",
    "invalid argument #3 (scalar or iterable expected)",
    "invalid argument #4 (callable expected)"          ,
    "invalid argument #4 (scalar function expected)"   ,
    "invalid argument #5 (iterable expected)"          ,
    "invalid range member '1'"                         ,
    "invalid arguments (unsupported complex operation)",
    "attempt to compare 'complex' with 'complex'"      ,
  }
  assertErrorMsgContains( msg[1], mth, 'map3', errCMat, nil                            )
  assertErrorMsgContains( msg[1], mth, 'map3', errCMat, ''                             )
  assertErrorMsgContains( msg[1], mth, 'map3', errCMat, NaN                            )
  assertErrorMsgContains( msg[1], mth, 'map3', errCMat, \x x                           )
  assertErrorMsgContains( msg[2], mth, 'map3', errCMat, errCMat, nil                   )
  assertErrorMsgContains( msg[2], mth, 'map3', errCMat, errCMat, ''                    )
  assertErrorMsgContains( msg[2], mth, 'map3', errCMat, errCMat, NaN                   )
  assertErrorMsgContains( msg[2], mth, 'map3', errCMat, errCMat, \x x                  )
  assertErrorMsgContains( msg[3], mth, 'map3', errCMat, errCMat, errCMat, nil          )
  assertErrorMsgContains( msg[3], mth, 'map3', errCMat, errCMat, errCMat, 1..2         )
  assertErrorMsgContains( msg[3], mth, 'map3', errCMat, errCMat, errCMat, 1            )
  assertErrorMsgContains( msg[4], mth, 'map3', errCMat, cm     , cm     , '!'          )
  assertErrorMsgContains( msg[5], mth, 'map3', errCMat, errCMat, errCMat, \x x, 1      )
  assertErrorMsgContains( msg[6], mth, 'map3', errCMat, errCMat, errCMat, \x x, 1..2   )
  assertErrorMsgContains( msg[7], mth, 'map3', errCMat, cm     , errCMat, \x,y,z x+y+z )
  assertErrorMsgContains( msg[7], mth, 'map3', errCMat, cm     , cm     , \x,y,z x+y+z )
  assertErrorMsgContains( msg[7], mth, 'map3', errCMat, errCMat, cm     , \x,y,z x+y+z )
  assertErrorMsgContains( msg[8], mth, 'map3', errCMat, cm     , cm     ,  '<'         )
end

function TestCMatrixFun:testMap3()
  for _,cm1 in ipairs(G.cmatidx) do
    local mn, nr, nc = cm1:size(), cm1:sizes()
    local m = matrix(nr,nc):fill(1..mn)
    assertEquals( cm1:map3(cm1, cm1, '~'             ), cm1:same():fill(-1.. -mn..-1):map(toC       ) )
    assertEquals( cm1:map3(cm1, cm1, '+'             ), cm1:same():fill( 2..2*mn.. 2):map(toC       ) )
    assertEquals( cm1:map3(cm1, cm1, \x,y,z x+y+z    ), cm1:copy()                   :map(\x 3*x    ) )
    assertEquals( cm1:map3(cm1, cm1, \x,y,z x+y+z, {}), cm1:copy()                   :map(\x 3*x, {}) ) -- totable test

    local cm2 = { m, 1..mn, totable(1..mn) }
    local cm3 = { m, 1..mn, totable(1..mn) }
    for i=1,#cm2 do
    for j=1,#cm3 do
      assertEquals( cm1:map3(cm2[i], cm3[j], \x,y,z x+y+z    ), cm1:same():fill(1..mn):map(\x x*3+x*1i)     )
      assertEquals( cm1:map3(cm2[i], cm3[j], \x,y,z x+y+z, {}), cm1:same():fill(1..mn):map(\x x*3+x*1i, {}) ) -- totable test
    end end
    --'in' place test
    cm1:map3(cm1, cm1, '~'         , 'in') assertEquals( cm1, cm1:copy():fill(-1..  -mn..-1):map(toC) )
    cm1:map3(cm1, cm1, \x,y,z x+y+z, 'in') assertEquals( cm1, cm1:same():fill(-3..-3*mn..-3):map(toC) )
  end
end

function TestCMatrixErr:testMapij()
  local msg = {
    "invalid argument #2 (callable expected)"    ,
    "invalid argument #3 (iterable expected)"    ,
    "attempt to compare 'complex' with 'number'" ,
    "attempt to compare 'complex' with 'complex'",
  }
  assertErrorMsgContains( msg[1], mth, 'mapij', errCMat, nil             )
  assertErrorMsgContains( msg[1], mth, 'mapij', errCMat, ''              )
  assertErrorMsgContains( msg[1], mth, 'mapij', errCMat, 1..2            )
  assertErrorMsgContains( msg[1], mth, 'mapij', errCMat, 1               )
  assertErrorMsgContains( msg[1], mth, 'mapij', errCMat, cmatrix(1)      )
  assertErrorMsgContains( msg[1], mth, 'mapij', errCMat, { }             )
  assertErrorMsgContains( msg[2], mth, 'mapij', errCMat, \x x+1   , ''   )
  assertErrorMsgContains( msg[2], mth, 'mapij', errCMat, \x x+1   , \x x )
  assertErrorMsgContains( msg[3], mth, 'mapij', errCMat, \x x<2          )
  assertErrorMsgContains( msg[4], mth, 'mapij', errCMat, \x x<2+2i       )
end

function TestCMatrixFun:testMapij()
  for i,cm in ipairs(G.cmatidx) do
    local mn, nr, nc = cm:size(), cm:sizes()
    assertEquals( cm:mapij('~'        ), cm:copy():map(\x -1*x) )
    assertEquals( cm:mapij(\x x-x     ), cm:same()              )
    assertEquals( cm:mapij('!'    , {}), rep(false, mn)         ) --totable test
    assertEquals( cm:mapij(\x x-x , {}), rep(0+0i , mn)         ) --totable test
    --'in' place test
    cm:mapij('~'          , 'in') assertEquals( cm, cm:same():fill(-1..-mn..-1):map(toC) )
    cm:mapij(\x x-x       , 'in') assertEquals( cm, cm:same()                            )
    cm:mapij(\x,i,j i+j   , 'in') for i=1,nr do for j=1,nc do assertEquals( cm:get(i,j), i+j+0i ) end end
    cm:fill(1..mn):map(toC, 'in'):mapij(\x,i,j i+j+x, 'in')
    for i=1,nr do for j=1,nc do assertEquals( cm:get(i,j), i+j+idxC(i,j,nc) ) end end

    cm:fill(1..mn):map(toC, 'in')
    cm = cm:mapij( \x,i,j => if j>3 then x=3 end return x end, {} )
    for i=1,nr do
    for j=1,nc do
      if j > 3 then assertEquals( cm[idx(i,j,nc)], 3            )
               else assertEquals( cm[idx(i,j,nc)], idxC(i,j,nc) ) end
    end end
  end
end

function TestCMatrixErr:testMapat()
  local msg = {
    "invalid argument #2 (callable expected)"                 ,
    "invalid argument #3 (iterable expected)"                 ,
    "invalid argument #4 (iterable expected)"                 ,
    "invalid range member '1'"                                ,
    "invalid arguments (unsupported complex operation)"       ,
    "attempt to perform arithmetic on local 'x' (a nil value)",
    "attempt to compare 'complex' with 'number'"              ,
    "attempt to compare 'complex' with 'complex'"             ,
    "cannot convert 'bool' to 'complex'"                      ,
  }
  assertErrorMsgContains( msg[1], mth, 'mapat', errCMat, nil                     )
  assertErrorMsgContains( msg[1], mth, 'mapat', errCMat, ''                      )
  assertErrorMsgContains( msg[1], mth, 'mapat', errCMat, 1..2                    )
  assertErrorMsgContains( msg[1], mth, 'mapat', errCMat, 1                       )
  assertErrorMsgContains( msg[1], mth, 'mapat', errCMat, cmatrix(1)              )
  assertErrorMsgContains( msg[1], mth, 'mapat', errCMat, { }                     )
  assertErrorMsgContains( msg[2], mth, 'mapat', errCMat, \x x+1    , ''          )
  assertErrorMsgContains( msg[2], mth, 'mapat', errCMat, \x x+1    , nil         )
  assertErrorMsgContains( msg[2], mth, 'mapat', errCMat, \x x+1    , NaN         )
  assertErrorMsgContains( msg[2], mth, 'mapat', errCMat, \x x+1    , \x x        )
  assertErrorMsgContains( msg[3], mth, 'mapat', errCMat, \x x+1    , 1    , ''   )
  assertErrorMsgContains( msg[3], mth, 'mapat', errCMat, \x x+1    , 1    , \x x )
  assertErrorMsgContains( msg[4], mth, 'mapat', errCMat, \x x+1    , 1    , 1..2 )
  assertErrorMsgContains( msg[5], mth, 'mapat', errCMat, '+'       , 1           )
  assertErrorMsgContains( msg[6], mth, 'mapat', errCMat, \x x+1    , 0           )
  assertErrorMsgContains( msg[6], mth, 'mapat', errCMat, \x x+1    , 5           )
  assertErrorMsgContains( msg[7], mth, 'mapat', errCMat, \x x<2    , 1           )
  assertErrorMsgContains( msg[8], mth, 'mapat', errCMat, \x x<2+2i , 1           )
  assertErrorMsgContains( msg[9], mth, 'mapat', errCMat, '!'       , 1           )
end

function TestCMatrixFun:testMapat()
  for _,cm in ipairs(G.cmatidx) do
    local mn, nr, nc = cm:size(), cm:sizes()
    for li=1,nr do
      local vi = G.vi[li]:copy()
      for j=1,li do vi[j] = random(1,mn) end
      vi:perm()
      assertEquals( cm:mapat('~',vi):getv(vi), cvector(#vi):fill(-vi):map(toC) )
    end
  end
  local cm  = G.cmatidx[5]
  local res = {-1,-2,-3, 4, 5}
  assertEquals         ( cm:mapat('~',vector{1,2,3}    )  , cvector(res):t():map( toC    ) )
  assertEquals         ( cm:mapat('~',      {1,2,3}    )  , cvector(res):t():map( toC    ) )
  assertAllAlmostEquals( cm:mapat('~',vector{1,2,3}, {})  , cvector(res):t():map( toC, {}) )
  res = { 2, 3, 4, 4, 5}
  cm:mapat(\x x+1+1i,vector{1,2,3}, 'in') assertEquals( cm,  vector(res):t():map( toC    ) )
end

function TestCMatrixErr:testFoldl()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
    "invalid arguments (unsupported complex operation)"          ,
  }
  local m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'foldl', errCMat, nil                   )
  assertErrorMsgContains( msg[1], mth, 'foldl', errCMat, NaN                   )
  assertErrorMsgContains( msg[1], mth, 'foldl', errCMat, ''                    )
  assertErrorMsgContains( msg[1], mth, 'foldl', errCMat, {}                    )
  assertErrorMsgContains( msg[1], mth, 'foldl', errCMat, 1                     )
  assertErrorMsgContains( msg[1], mth, 'foldl', errCMat, 1..2                  )
  assertErrorMsgContains( msg[1], mth, 'foldl', errCMat, m                     )
  assertErrorMsgContains( msg[1], mth, 'foldl', errCMat, cm                    )
  assertErrorMsgContains( msg[3], mth, 'foldl', errCMat, \x x, ''              )
  assertErrorMsgContains( msg[3], mth, 'foldl', errCMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', errCMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', errCMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'foldl', errCMat, \x x, 1 , 'vec', ''   )
  assertErrorMsgContains( msg[2], mth, 'foldl', errCMat, \x x, 1 , 'vec', 1    )
  assertErrorMsgContains( msg[2], mth, 'foldl', errCMat, \x x, 1 , 'vec', \x x )
  assertErrorMsgContains( msg[5], mth, 'foldl', errCMat, '+' , {}              )
end

--[[
parameters:
  f: callable, x0: initial value, d: ['vec', 'row', 'col'], r: iterable
  r:{}, cmatrix(2), matrix(2), 1..2

fold cases:
  1) x:fold( f )
  2) x:fold( f, nil, d )      and 2') x:fold( f, d   )
  3) x:fold( f, nil, nil, r ) and 3') x:fold( f, r   ) and  3") x:fold( f, nil, r)
  4) x:fold( f, nil, d, r )   and 4') x:fold( f, d, r) and  4") x:fold( f, d, nil, r )
  5) x:fold( f, x0 )
  6) x:fold( f, x0 , d )
  7) x:fold( f, x0, nil, r ) and 7') x:fold( f, x0, r )
  8) x:fold( f, x0 , d, r )
]]
local sum = \r =>local x = 0    for i=1,r:size() do x = x + r[i] end return x end
local sub = \r =>local x = r[1] for i=2,r:size() do x = x - r[i] end return x end

function TestCMatrixFun:testFoldl()
  local _ = nil
  for i,cm in ipairs(G.cmatidx) do
    local mn, nr, nc = cm:size(), cm:sizes()
    local s = sum(1..mn)
    --                      f  , x0 , d    , r
    assertEquals( cm:foldl(\r r                ) , 1+1i       ) -- 1)
    assertEquals( cm:foldl('+' , 2  , nil  , {}) , s+s*1i + 2 ) -- 7)
    assertEquals( cm:foldl('+'                 ) , s+s*1i     ) -- 1)
    assertEquals( cm:foldl('+'      , 'vec'    ) , s+s*1i     ) -- 2)
    assertEquals( cm:foldl('+' , nil, 'vec'    ) , s+s*1i     ) -- 2)
    assertEquals( cm:foldl('+'      , 'vec', {}) , s+s*1i     ) -- 4)
    assertEquals( cm:foldl('+' , 2             ) , s+s*1i + 2 ) -- 5)
    assertEquals( cm:foldl('+' , 2  , 'vec'    ) , s+s*1i + 2 ) -- 6)
    assertEquals( cm:foldl('+' , nil       , {}) , s+s*1i     ) -- 3)
    assertEquals( cm:foldl('+' , nil, nil  , {}) , s+s*1i     ) -- 3)

    local t ={} for i=1,nc do local x=sum(idx(1,i,nc)..idx(nr,i,nc)..nc); t [i]=toC(x) end
    local tr={} for i=1,nr do local x=sum(idx(i,1,nc)..idx(i,nc,nc)..1 ); tr[i]=toC(x) end
    assertAllAlmostEquals( cm:foldl('+', 0, 'col', {}) , t                    ) -- 8)
    assertAllAlmostEquals( cm:foldl('+', 0, 'row', {}) , tr                   ) -- 8)
    assertEquals         ( cm:foldl('+'   , 'col'    ) , cmatrix(t ):t(false) ) -- 2)
    assertEquals         ( cm:foldl('+'   , 'row'    ) , cmatrix(tr)          ) -- 2)
    assertEquals         ( cm:foldl('+', 0, 'col'    ) , cmatrix(t ):t(false) ) -- 6)
    assertEquals         ( cm:foldl('+', 0, 'row'    ) , cmatrix(tr)          ) -- 6)

  -- non-commutative operations
    local cmrefC = cm:same(_,1  ):mapij(\x,i,j sub(idx(1,j,nc)..idx(nr,j,nc)..nc)):map(toC)
    local cmrefR = cm:same(_,_,1):mapij(\x,i,j sub(idx(i,1,nc)..idx(i,nc,nc)..1 )):map(toC)
    if mn%2 == 0 then assertEquals( cm:foldl '~',-1-1i )
                 else assertEquals( cm:foldl '~', 1+1i ) end
    assertEquals( cm:foldl('-'       ) , sub(1..mn)+sub(1..mn)*1i  )
    assertEquals( cm:foldl('-', 'col') , cmrefC                    )
    assertEquals( cm:foldl('-', 'row') , cmrefR                    )
  end
  assertAlmostEquals( cvector(4):fill(4..1..-1):foldl('^'):real() - (4^3)^2, 0, 2e4*eps )
  assertEquals      ( cvector(4):fill(4..1..-1):foldl('^'):imag()          , 0          )
end

function TestCMatrixErr:testFoldr()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  local m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'foldr', errCMat, nil                   )
  assertErrorMsgContains( msg[1], mth, 'foldr', errCMat, NaN                   )
  assertErrorMsgContains( msg[1], mth, 'foldr', errCMat, ''                    )
  assertErrorMsgContains( msg[1], mth, 'foldr', errCMat, {}                    )
  assertErrorMsgContains( msg[1], mth, 'foldr', errCMat, 1                     )
  assertErrorMsgContains( msg[1], mth, 'foldr', errCMat, 1..2                  )
  assertErrorMsgContains( msg[1], mth, 'foldr', errCMat, m                     )
  assertErrorMsgContains( msg[1], mth, 'foldr', errCMat, cm                    )
  assertErrorMsgContains( msg[3], mth, 'foldr', errCMat, \x x, ''              )
  assertErrorMsgContains( msg[3], mth, 'foldr', errCMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', errCMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', errCMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'foldr', errCMat, \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'foldr', errCMat, \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'foldr', errCMat, \x x, 1 , "vec", \x x )
end

function TestCMatrixFun:testFoldr()
  for _,cm in ipairs(G.cmatidx) do
    local mn, nr, nc = cm:size(), cm:sizes()
    local s = sum(1..mn)
    --                     f   , x0 , d   , r
    assertEquals( cm:foldr(\r r               ) , 1+1i     ) -- 1)
    assertEquals( cm:foldr('+' , 2 , nil  , {}) , s+s*1i+2 ) -- 7)
    assertEquals( cm:foldr('+'                ) , s+s*1i   ) -- 1)
    assertEquals( cm:foldr('+'     , 'vec'    ) , s+s*1i   ) -- 2)
    assertEquals( cm:foldr('+', nil, 'vec'    ) , s+s*1i   ) -- 2)
    assertEquals( cm:foldr('+'     , 'vec', {}) , s+s*1i   ) -- 4)
    assertEquals( cm:foldr('+', 2             ) , s+s*1i+2 ) -- 5)
    assertEquals( cm:foldr('+', 2  , 'vec'    ) , s+s*1i+2 ) -- 6)
    assertEquals( cm:foldr('+', nil       , {}) , s+s*1i   ) -- 3)
    assertEquals( cm:foldr('+', nil, nil  , {}) , s+s*1i   ) -- 3)

    local t ={} for i=1,nc do local x=sum(idx(1,i,nc)..idx(nr,i,nc)..nc); t [i]=toC(x) end
    local tr={} for i=1,nr do local x=sum(idx(i,1,nc)..idx(i,nc,nc)..1 ); tr[i]=toC(x) end
    assertEquals         ( cm:foldr('+'   , 'col'    ) , cmatrix(t ):t(false) ) -- 2)
    assertEquals         ( cm:foldr('+'   , 'row'    ) , cmatrix(tr)          ) -- 2)
    assertEquals         ( cm:foldr('+', 0, 'col'    ) , cmatrix(t ):t(false) ) -- 6)
    assertEquals         ( cm:foldr('+', 0, 'row'    ) , cmatrix(tr)          ) -- 6)
    assertAllAlmostEquals( cm:foldr('+', 0, 'col', {}) , t                    ) -- 8)
    assertAllAlmostEquals( cm:foldr('+', 0, 'row', {}) , tr                   ) -- 8)

  -- non-commutative operations
    local cmrefC = cm:same(_,1 ,nc):mapij(\x,i,j sum(idx(1,j,nc)..idx(nr,j,nc)..2*nc) - sum(idx(2,j,nc)..idx(nr,j,nc)..2*nc)):map(toC)
    local cmrefR = cm:same(_,nr,1 ):mapij(\x,i,j sum(idx(i,1,nc)..idx(i,nc,nc)..2   ) - sum(idx(i,2,nc)..idx(i,nc,nc)..2   )):map(toC)
    local cv = cvector( cm:size() ):fill(1..cm:size()):map(\x => if x%2==0 then x=-x end return x end)
    if mn == 1 then assertEquals( cm:foldr '~', 1+1i )
               else assertEquals( cm:foldr '~',-1-1i ) end
    assertEquals( cm:foldr '-'        , cv:map(toC):foldr('+') )
    assertEquals( cm:foldr('-', 'col'), cmrefC                       )
    assertEquals( cm:foldr('-', 'row'), cmrefR                       )
  end
  assertAlmostEquals( cvector(4):fill(4..1..-1):foldr('^'):real()- 4^(3^2), 0, 2e6*eps )
  assertEquals      ( cvector(4):fill(4..1..-1):foldr('^'):imag()         , 0          )
end

--[[ scan cases:
1) x:scan( f )
2) x:scan( f, nil, d )      and 2') x:scan( f, d )
3) x:scan( f, nil, nil, r ) and 3') x:scan( f, r ) and  3") x:scan( f, nil, r)
4) x:scan( f, nil, d, r )   and 4') x:scan( f, d, r) and  4")x:scan( f, d, nil, r )
5) x:scan( f, x0 )
6) x:scan( f, x0 , d )
7) x:scan( f, x0 , nil, r ) and 7') x:scan( f, x0, r )
8) x:scan( f, x0 , d, r )              ]]
function TestCMatrixErr:testScanl()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  local m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'scanl', errCMat, nil                   )
  assertErrorMsgContains( msg[1], mth, 'scanl', errCMat, NaN                   )
  assertErrorMsgContains( msg[1], mth, 'scanl', errCMat, ''                    )
  assertErrorMsgContains( msg[1], mth, 'scanl', errCMat, {}                    )
  assertErrorMsgContains( msg[1], mth, 'scanl', errCMat, 1                     )
  assertErrorMsgContains( msg[1], mth, 'scanl', errCMat, 1..2                  )
  assertErrorMsgContains( msg[1], mth, 'scanl', errCMat, m                     )
  assertErrorMsgContains( msg[1], mth, 'scanl', errCMat, cm                    )
  assertErrorMsgContains( msg[3], mth, 'scanl', errCMat, \x x, ''              )
  assertErrorMsgContains( msg[3], mth, 'scanl', errCMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', errCMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', errCMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'scanl', errCMat, \x x, 1 , 'vec', ''   )
  assertErrorMsgContains( msg[2], mth, 'scanl', errCMat, \x x, 1 , 'vec', 1    )
  assertErrorMsgContains( msg[2], mth, 'scanl', errCMat, \x x, 1 , 'vec', \x x )
end

function TestCMatrixFun:testScanl()
  for _,cm in ipairs(G.cmatidx) do
    local mn, nr, nc = cm:size(), cm:sizes()
    local t={} for i=1,mn do local x=sum(1..i); t[i]=toC(x) end
    local cmref  = cm:same():fill(1..mn):map(\x sum(1..x:real())):map(toC)
    local cmref2 = cmref:copy():map(\x x+2)
    assertEquals         ( cm:scanl(\x x               ), cm:same():fill(1):map(toC) ) -- 1)
    assertEquals         ( cm:scanl('+'                ), cmref                      ) -- 1)
    assertEquals         ( cm:scanl('+','vec'          ), cmref                      ) -- 2)
    assertEquals         ( cm:scanl('+', 2             ), cmref2                     ) -- 5)
    assertEquals         ( cm:scanl('+', 2   ,'vec'    ), cmref2                     ) -- 6)
    assertAllAlmostEquals( cm:scanl('+','vec', {}      ), t                          ) -- 4)
    assertAllAlmostEquals( cm:scanl('+', 0   ,'vec', {}), t                          ) -- 8)
    assertAllAlmostEquals( cm:scanl('+', nil       , {}), t                          ) -- 3)
    assertAllAlmostEquals( cm:scanl('+', nil , nil , {}), t                          ) -- 3)
    assertAllAlmostEquals( cm:scanl('+', 0   , nil , {}), t                          ) -- 7)

    cmref  = cm:copy():mapij(\x,i,j sum(idx(1,j,nc)..idx(i,j,nc)..nc)):map(toC)
    cmref2 = cm:copy():mapij(\x,i,j sum(idx(i,1,nc)..idx(i,j,nc)..1 )):map(toC)
    assertEquals( cm:scanl('+', 'col'), cmref  ) -- 2)
    assertEquals( cm:scanl('+', 'row'), cmref2 ) -- 2)
  -- non-commutative operations
    cmref  = cm:same():fill(1..mn):map(\x sub(1..x:real()))           :map(toC)
    cmref2 = cm:copy():mapij(\x,i,j sub(idx(i,1,nc)..idx(i,j,nc)..1 )):map(toC)
    assertEquals( cm:scanl '-'        , cmref  )
    assertEquals( cm:scanl('-', 'row'), cmref2 )
  end
end

function TestCMatrixErr:testScanr()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  local m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'scanr', errCMat, nil                   )
  assertErrorMsgContains( msg[1], mth, 'scanr', errCMat, NaN                   )
  assertErrorMsgContains( msg[1], mth, 'scanr', errCMat, ''                    )
  assertErrorMsgContains( msg[1], mth, 'scanr', errCMat, {}                    )
  assertErrorMsgContains( msg[1], mth, 'scanr', errCMat, 1                     )
  assertErrorMsgContains( msg[1], mth, 'scanr', errCMat, 1..2                  )
  assertErrorMsgContains( msg[1], mth, 'scanr', errCMat, m                     )
  assertErrorMsgContains( msg[1], mth, 'scanr', errCMat, cm                    )
  assertErrorMsgContains( msg[3], mth, 'scanr', errCMat, \x x, ''              )
  assertErrorMsgContains( msg[3], mth, 'scanr', errCMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', errCMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', errCMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'scanr', errCMat, \x x, 1 , 'vec', ''   )
  assertErrorMsgContains( msg[2], mth, 'scanr', errCMat, \x x, 1 , 'vec', 1    )
  assertErrorMsgContains( msg[2], mth, 'scanr', errCMat, \x x, 1 , 'vec', \x x )
end

function TestCMatrixFun:testScanr()
  local function subR(r)
    local s = r:size()
    local x = table.new(s,1)
    x[s] = toC(r[s])
    for i=r:size()-1,1,-1 do
      if i%2 == 0 then x[i]= -(x[i+1] - toC(r[i]))
                  else x[i]= - x[i+1] + toC(r[i] ) end
    end
    return x
  end
  for _,cm in ipairs(G.cmatidx) do
    local mn, nr, nc = cm:size(), cm:sizes()
    local cmref  = cm:same():fill(1..mn):map(\x sum(x:real()..mn)):map(toC)
    local cmref2 = cmref:copy():map(\x x+2)
    local t={} for i=1,mn do local x=sum(i..mn); t[i]=toC(x) end
    assertEquals         ( cm:scanr(\x x               ) , cm:same():fill(1..mn):map(toC) ) -- 1)
    assertEquals         ( cm:scanr('+'                ) , cmref                          ) -- 1)
    assertEquals         ( cm:scanr('+','vec'          ) , cmref                          ) -- 2)
    assertEquals         ( cm:scanr('+', 2             ) , cmref2                         ) -- 5)
    assertEquals         ( cm:scanr('+', 2   ,'vec'    ) , cmref2                         ) -- 6)
    assertAllAlmostEquals( cm:scanr('+','vec', {}      ) , t                              ) -- 4)
    assertAllAlmostEquals( cm:scanr('+', 0   ,'vec', {}) , t                              ) -- 8)
    assertAllAlmostEquals( cm:scanr('+', nil       , {}) , t                              ) -- 3)
    assertAllAlmostEquals( cm:scanr('+', nil , nil , {}) , t                              ) -- 3)
    assertAllAlmostEquals( cm:scanr('+', 0   , nil , {}) , t                              ) -- 7)

    cmref  = cm:copy():mapij(\x,i,j sum(idx(nr,j,nc)..idx(i,j,nc)..-nc)):map(toC)
    cmref2 = cm:copy():mapij(\x,i,j sum(idx(i,nc,nc)..idx(i,j,nc)..-1 )):map(toC)
    assertEquals( cm:scanr('+', 'col'), cmref  )
    assertEquals( cm:scanr('+', 'row'), cmref2 )
    -- non-commutative operations
    cmref  = cm:copy():mapij(\x,i,j sum(idx(i,j,nc)..idx(nr,j,nc)..2*nc)-sum(idx(i+1,j,nc)..idx(nr,j,nc)..2*nc)):map(toC)
    cmref2 = cm:copy():mapij(\x,i,j sum(idx(i,j,nc)..idx(i,nc,nc)..2   )-sum(idx(i,j+1,nc)..idx(i,nc,nc)..2   )):map(toC)
    assertEquals         ( cm:scanr('-'          ) , cm:same():fill(subR(1..mn)):map(toC) )
    assertAllAlmostEquals( cm:scanr('-', nil , {}) , subR(1..mn)  )
    assertEquals         ( cm:scanr('-','col'    ) , cmref        )
    assertEquals         ( cm:scanr('-','row'    ) , cmref2       )
  end
end

function TestCMatrixErr:testFilter()
  local msg = {
    "invalid argument #2 (callable expected)"    ,
    "invalid argument #3 (iterable expected)"    ,
    "invalid matrix new sizes"                   ,
    "attempt to compare 'number' with 'complex'" ,
    "attempt to compare 'complex' with 'complex'",
  }
  assertErrorMsgContains( msg[1], mth, 'filter', errCMat   , nil              )
  assertErrorMsgContains( msg[1], mth, 'filter', errCMat   , ''               )
  assertErrorMsgContains( msg[1], mth, 'filter', errCMat   , 1..2             )
  assertErrorMsgContains( msg[1], mth, 'filter', errCMat   , 1                )
  assertErrorMsgContains( msg[1], mth, 'filter', errCMat   , cmatrix(1)       )
  assertErrorMsgContains( msg[1], mth, 'filter', errCMat   , { }              )
  assertErrorMsgContains( msg[2], mth, 'filter', errCMat   , \x x      , ''   )
  assertErrorMsgContains( msg[2], mth, 'filter', errCMat   , \x x      , 1    )
  assertErrorMsgContains( msg[2], mth, 'filter', errCMat   , \x x      , \x x )
  assertErrorMsgContains( msg[3], mth, 'filter', matrix{1}, \x x~=1           )
  assertErrorMsgContains( msg[4], mth, 'filter', errCMat   , \x x>1           )
  assertErrorMsgContains( msg[5], mth, 'filter', errCMat   , \x x>1+1i        )
end

function TestCMatrixFun:testFilter()
 for _,cm in ipairs(G.cmatidx) do
    local mn = cm:size()
    assertEquals( cm:filter(\x x==1+1i             ), cvector(1) :fill(1+1i)           )
    assertEquals( cm:filter(\x x~=0+0i             ), cvector(mn):fill(1..mn):map(toC) )
    assertEquals( cm:filter(\x x==1+1i, {}         ), {1+1i}                           )
    assertEquals( cm:filter(\x x==1+1i, cvector(25)), cvector(1):seti(1,1+1i)          )
    local cmc = cm:copy()
    cmc:filter(\x x==1+1i, 'in' ) assertEquals( cmc , cvector(1) :fill(1+1i)           )
  end
end

function TestCMatrixErr:testFilter_out()
  local msg = {
    "invalid argument #2 (callable expected)"    ,
    "attempt to compare 'number' with 'complex'" ,
    "attempt to compare 'complex' with 'complex'",
  }
  assertErrorMsgContains( msg[1], mth, 'filter_out', errCMat, nil        )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errCMat, ''         )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errCMat, 1..2       )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errCMat, 1          )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errCMat, cmatrix(1) )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errCMat, {}         )
  assertErrorMsgContains( msg[2], mth, 'filter_out', errCMat, \x x>1     )
  assertErrorMsgContains( msg[3], mth, 'filter_out', errCMat, \x x>1+1i  )
end

function TestCMatrixFun:testFilter_out()
  for _,cm in ipairs(G.cmatidx) do
    local mn = cm:size()
    assertEquals( cm:filter_out(\x x~=1+1i    ), cm:filter(\x x==1+1i    ) )
    assertEquals( cm:filter_out(\x x==0+0i    ), cm:filter(\x x~=0+0i    ) )
    assertEquals( cm:filter_out(\x x~=1+1i, {}), cm:filter(\x x==1+1i, {}) )
  end
end

-- special maps ---------------------------------------------------------------o

function TestCMatrixSMaps:setUp()
  for _,cm in ipairs(G.cmattmp) do cm:zeros()           :map( toC, 'in') end
  for _,cm in ipairs(G.cmatidx) do cm:fill(1..cm:size()):map( toC, 'in') end
end

function TestCMatrixSMaps:tearDown()
  for _,cm in ipairs(G.cmattmp) do cm:zeros()           :map( toC, 'in') end
  for _,cm in ipairs(G.cmatidx) do cm:fill(1..cm:size()):map( toC, 'in') end
end

function TestCMatrixSMaps:testCeil ()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(0.01, 1, cm:size())
    cm:fill(r):map(toC,'in'):ceil('in')
    assertEquals( cm, cm:same():fill(1):map(toC) )
  end
end

function TestCMatrixSMaps:testFloor()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(0, 1-0.01, cm:size())
    cm:fill(r):map(toC,'in'):floor('in')
    assertEquals( cm, cm:same():map(toC) )
  end
end

function TestCMatrixSMaps:testFrac()
  for _,cm in ipairs(G.cmattmp) do
    local mn = cm:size()
    local r  = range(0.1,(mn)/10,0.1)
    cm:fill(r):map(toC,'in'):frac('in')
    for i=1,mn do
      if     r[i] < 1 then assertAlmostEquals( cm:geti(i):real() -  i/10   , 0,   eps )
                           assertAlmostEquals( cm:geti(i):imag() -  i/10   , 0,   eps )
      elseif r[i] < 2 then assertAlmostEquals( cm:geti(i):real() - (i/10-1), 0,   eps )
                           assertAlmostEquals( cm:geti(i):real() - (i/10-1), 0,   eps )
                      else assertAlmostEquals( cm:geti(i):real() - (i/10-2), 0, 2*eps )
                           assertAlmostEquals( cm:geti(i):real() - (i/10-2), 0, 2*eps ) end
    end
  end
end

function TestCMatrixSMaps:testTrunc()
  for _,cm in ipairs(G.cmattmp) do
    local mn = cm:size()
    local r = nrange(0, 3-0.01, mn)
    cm:fill(r):map(toC,'in'):trunc('in')
    for i=1,mn do
      if     r[i] < 1 then assertEquals( cm:geti(i), 0+0i )
      elseif r[i] < 2 then assertEquals( cm:geti(i), 1+1i )
                      else assertEquals( cm:geti(i), 2+2i ) end
    end
  end
end

function TestCMatrixSMaps:testRound()
  for _,cm in ipairs(G.cmattmp) do
    local mn = cm:size()
    local r = nrange(0, 1, mn)
    cm:fill(r):map(toC,'in'):round('in')
    for i=1,mn do
    if r[i] < 0.5 then assertEquals( cm:geti(i), 0+0i )
                  else assertEquals( cm:geti(i), 1+1i ) end
    end
  end
end

function TestCMatrixSMaps:testAbs()
  for _,cm in ipairs(G.cmattmp) do
    local mn, res = cm:size()
    local r = nrange(-3, 3, mn)
    cm:fill(r):map(toC,'in'):abs('in')
    res = cm:map(\x x:real()>=0, {})  assertEquals( res, rep(true, mn) )
    res = cm:map(\x x:imag()>=0, {})  assertEquals( res, rep(true, mn) )
  end
end

function TestCMatrixSMaps:testSqrt()
  for _,cm in ipairs(G.cmatidx) do
    local mn = cm:size()
    cm:map(\x x*x):map(toC,'in'):sqrt('in')
    assertEquals( cm, cm:same():fill(1..mn):map(toC) )
  end
end

function TestCMatrixSMaps:testExp()
  for _,cm in ipairs(G.cmatidx) do
    local mn = cm:size()
    local cref = cm:copy()
    cm:exp('in')
    assertEquals( cm, cref:map(\x exp(x:real()) * complex(cos(x:imag()), sin(x:imag()))) )
  end
end

function TestCMatrixSMaps:testLog()
  for _,cm in ipairs(G.cmatidx) do
    local mn = cm:size()
    cm:map(toC,'in'):log('in')
    local res = cm:map(\x exp(x), 'in' )
    assertTrue( res:eq( cm:same():fill(1..mn):map(toC,'in'), 58*eps ) )
  end
end

function TestCMatrixSMaps:testLog10()
  for _,cm in ipairs(G.cmatidx) do
    local mres = cm:copy():map(\x log(x)/log(10) )
    cm:map(toC,'in'):log10('in')
    assertTrue( cm:eq( mres, eps) )
  end
end

function TestCMatrixSMaps:testSin()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1, pi/2, cm:size())
    cm:fill(r):map(toC,'in')
    assertEquals( cm:sin(), cm:copy():map(\x -sin(-x)) )
  end
end

function TestCMatrixSMaps:testCos()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1, pi/2, cm:size())
    cm:fill(r):map(toC,'in')
    assertEquals( cm:cos(),    cm:copy():map(\x cos(-x    ))          )
    assertTrue  ( cm:cos():eq( cm:copy():map(\x sin(pi/2-x)), 3*eps ) )
  end
end

function TestCMatrixSMaps:testTan()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,cm:size())
    cm:fill(r):map(toC,'in')
    assertTrue( cm:tan():eq( cm:copy():map(\x sin(x)/cos(x)), 32*eps ) )
  end
end

function TestCMatrixSMaps:testSinh()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,cm:size())
    cm:fill(r):map(toC,'in')
    assertTrue( cm:sinh():eq( cm:copy():map(\x 2*sinh(x/2)*cosh(x/2)), 5*eps ) )
  end
end

function TestCMatrixSMaps:testCosh()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,cm:size())
    cm:fill(r):map(toC,'in')
    assertTrue( cm:cosh():eq( cm:copy():map(\x 2*sinh(x/2)^2 + 1), 5*eps ) )
  end
end

function TestCMatrixSMaps:testTanh()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,cm:size())
    cm:fill(r):map(toC,'in')
    assertTrue( cm:tanh():eq( cm:copy():map(\x sinh(x)/cosh(x)), 3*eps) )
  end
end

function TestCMatrixSMaps:testAsin()
  for _,cm in ipairs(G.cmatidx) do
    local r = nrange(1,pi/2,cm:size())
    cm:fill(r):map(toC,'in')
    local cref = cm:copy()
    assertTrue( cm:sin():asin('in'):eq( cref, 8*eps) ) -- linux err: 6*eps
  end
end

function TestCMatrixSMaps:testAcos()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,cm:size())
    cm:fill(r):map(toC,'in')
    local cref = cm:copy()
    assertTrue( cm:cos():acos('in'):eq( cref, 2*eps ) )
  end
end

function TestCMatrixSMaps:testAtan()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,cm:size())
    cm:fill(r):map(toC,'in')
    local cref = cm:copy()
    assertTrue( cm:tan():atan('in'):eq( cref, 9*eps ) )
  end
end

function TestCMatrixSMaps:testAsinh()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,cm:size())
    cm:fill(r):map(toC,'in')
    local cref = cm:copy()
    assertTrue( cm:asinh():sinh('in'):eq( cref, 3*eps ) )
  end
end

function TestCMatrixSMaps:testAcosh()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,cm:size())
    cm:fill(r):map(toC,'in')
    local cref = cm:copy()
    assertTrue( cm:acosh():cosh('in'):eq( cref, 4*eps ) )
  end
end

function TestCMatrixSMaps:testAtanh()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,cm:size())
    cm:fill(r):map(toC,'in')
    local cref = cm:copy()
    assertTrue( cm:tanh():atanh('in'):eq( cref, 9*eps ) )
  end
end

--function TestCMatrixSMaps:testErf()    end
--function TestCMatrixSMaps:testTgamma() end
--function TestCMatrixSMaps:testLgamma() end

function TestCMatrixSMaps:testCarg()
  for _,cm in ipairs(G.cmatidx) do
    local r = nrange(1,pi/2,cm:size())
    local cref = cm:fill(r):map(toC,'in'):copy()
    cm:carg('in')
    assertEquals( cm, cref:copy():map(\x atan2(x:imag(),x:real())) )
  end
end

function TestCMatrixSMaps:testReal()
  for _,cm in ipairs(G.cmatidx) do
    local mn = cm:size()
    local m  = matrix(cm:sizes())
    cm:real('in')
    assertEquals( cm          , cm:same():fill(1..mn) )
    assertEquals( cm:real( m ),  m:same():fill(1..mn) )
  end
end

function TestCMatrixSMaps:testImag()
  for _,cm in ipairs(G.cmatidx) do
    local mn = cm:size()
    local m  = matrix(cm:sizes())
    cm:imag('in')
    assertEquals( cm          , cm:same():fill(1..mn) )
    assertEquals( cm:real( m ),  m:same():fill(1..mn) )
  end
end

function TestCMatrixSMaps:testConj()
  for _,cm in ipairs(G.cmatidx) do
    local mn = cm:size()
    cm:conj('in')
    assertEquals( cm, cm:same():fill(1..mn):map(\x x-x*1i) )
  end
end

function TestCMatrixSMaps:testProj()
  for _,cm in ipairs(G.cmatidx) do
    local mn = cm:size()
    assertEquals( cm:proj(), cm:same():fill(1..mn):map(toC) )
  end
end

function TestCMatrixSMaps:testRect()
  for _,cm in ipairs(G.cmatidx) do
    local mn = cm:size()
    local cref = cm:copy():map(\x x:real()*cos(x:imag())+ x:real()*sin(x:imag())*1i )
    cm:rect('in')
    assertEquals( cm, cref )
  end
end

function TestCMatrixSMaps:testPolar()
  for _,cm in ipairs(G.cmatidx) do
    local mn = cm:size()
    local cref = cm:copy():map(\x hypot(x:real(),x:imag()) + atan2( x:real(),x:imag())*1i )
    cm:polar('in')
    assertEquals( cm, cref )
  end
end

-- special folds --------------------------------------------------------------o

function TestCMatrixSFolds:testSum()
  for _,cm in ipairs(G.cmatidx) do
    local mn, _, nr, nc = cm:size(), nil, cm:sizes()
    assertEquals( cm:sum()     , sum(1..mn) + sum(1..mn)*1i )
    assertEquals( cm:sum('col'), cm:same(_,1 ,nc):mapij(\x,i,j sum(idx(1,j,nc)..idx(nr,j,nc)..nc)):map(toC) )
    assertEquals( cm:sum('row'), cm:same(_,nr,1 ):mapij(\x,i,j sum(idx(i,1,nc)..idx(i,nc,nc)..1 )):map(toC) )
  end
end

function TestCMatrixSFolds:testSumabs()
  local sumabs = \r =>local x = 0 for i=1,r:size() do x = x + abs(r[i] + r[i]*1i) end return x end
  for _,cm in ipairs(G.cmatidx) do
    local mn, _, nr, nc = cm:size(), nil, cm:sizes()
    local cm1 = cm:copy():map(\x -x)
    assertEquals( cm1:sumabs()     , sumabs(1..mn) )
    assertEquals( cm1:sumabs('col'), cm:same(_,1 ,nc):mapij(\x,i,j sumabs(idx(1,j,nc)..idx(nr,j,nc)..nc)) )
    assertEquals( cm1:sumabs('row'), cm:same(_,nr,1 ):mapij(\x,i,j sumabs(idx(i,1,nc)..idx(i,nc,nc)..1 )) )
  end
end

function TestCMatrixSFolds:testSumsqr()
  local sumsqr = \r =>local x = 0 for i=1,r:size() do x = x + (r[i]+r[i]*1i)^2 end return x end
  for _,cm in ipairs(G.cmatidx) do
    local nr,nc,_ = cm:sizes()
    assertEquals( cm:sumsqr()     , sumsqr(1..cm:size()) )
    assertEquals( cm:sumsqr('col'), cm:same(_,1 ,nc):mapij\x,i,j sumsqr(idx(1,j,nc)..idx(nr,j,nc)..nc) )
    assertEquals( cm:sumsqr('row'), cm:same(_,nr,1 ):mapij\x,i,j sumsqr(idx(i,1,nc)..idx(i,nc,nc)..1 ) )
  end
end

function TestCMatrixSFolds:testProduct()
  local prod = \r =>local x = 1 for i=1,r:size() do x = x * (r[i]+r[i]*1i) end return x end
  for _,cm in ipairs(G.cmatidx) do
    local nr,nc,_ = cm:sizes()
    assertEquals( cm:product()     , prod(1..cm:size()) )
    assertEquals( cm:product('col'), cm:same(_,1 ,nc):mapij\x,i,j prod(idx(1,j,nc)..idx(nr,j,nc)..nc) )
    assertEquals( cm:product('row'), cm:same(_,nr,1 ):mapij\x,i,j prod(idx(i,1,nc)..idx(i,nc,nc)..1 ) )
  end
end

function TestCMatrixErr:testAll()
  local msg = {
    "invalid argument #2 (callable expected)"    ,
    "attempt to compare 'complex' with 'number'" ,
    "attempt to compare 'complex' with 'complex'",
    "cannot convert 'bool' to 'complex'"         ,
  }
  assertErrorMsgContains( msg[1], mth, 'all', errCMat, nil               )
  assertErrorMsgContains( msg[1], mth, 'all', errCMat, ''                )
  assertErrorMsgContains( msg[1], mth, 'all', errCMat, 1..2              )
  assertErrorMsgContains( msg[1], mth, 'all', errCMat, 1                 )
  assertErrorMsgContains( msg[1], mth, 'all', errCMat, errCMat           )
  assertErrorMsgContains( msg[1], mth, 'all', errCMat, { }               )
  assertErrorMsgContains( msg[2], mth, 'all', errCMat, \x x< 2           )
  assertErrorMsgContains( msg[3], mth, 'all', errCMat, \x x< 2+2i        )
  assertErrorMsgContains( msg[4], mth, 'all', errCMat, \x x==2+2i, 'col' )
  assertErrorMsgContains( msg[4], mth, 'all', errCMat, \x x==2   , 'row' )
end

function TestCMatrixSFolds:testAll()
  for _,cm in ipairs(G.cmatidx) do
    local mn, t, nr, nc = cm:size(), nil, cm:sizes()
    assertFalse ( cm:all \x x==cm:size()           )
    assertTrue  ( cm:all \x x~=cm:size()+1         )
    assertTrue  ( cm:all(\x x~=cm:size()+1, 'vec') )
    assertEquals( cm:all(\x x==16), cm:all( \x x==16, 'vec')  )

    t = table.new(nc,1); for i=2,nc do t[i]=true end; t[1]=false
    assertEquals( cm:all(\x x~=1+1i, 'col', {}), t )
    t = table.new(nr,1); for i=2,nr do t[i]=true end; t[1]=false
    assertEquals( cm:all(\x x~=1+1i, 'row', {}), t )
  end
end

function TestCMatrixErr:testAny()
  local msg = {
    "invalid argument #2 (callable expected)"    ,
    "attempt to compare 'complex' with 'number'" ,
    "attempt to compare 'complex' with 'complex'",
    "cannot convert 'bool' to 'complex'"         ,
  }
  assertErrorMsgContains( msg[1], mth, 'any', errCMat, nil               )
  assertErrorMsgContains( msg[1], mth, 'any', errCMat, ''                )
  assertErrorMsgContains( msg[1], mth, 'any', errCMat, 1..2              )
  assertErrorMsgContains( msg[1], mth, 'any', errCMat, 1                 )
  assertErrorMsgContains( msg[1], mth, 'any', errCMat, errCMat           )
  assertErrorMsgContains( msg[1], mth, 'any', errCMat, { }               )
  assertErrorMsgContains( msg[2], mth, 'any', errCMat, \x x< 2           )
  assertErrorMsgContains( msg[3], mth, 'any', errCMat, \x x< 2+2i        )
  assertErrorMsgContains( msg[4], mth, 'any', errCMat, \x x==2+2i, 'col' )
  assertErrorMsgContains( msg[4], mth, 'any', errCMat, \x x==2   , 'row' )
end

function TestCMatrixSFolds:testAny()
  for _,cm in ipairs(G.cmatidx) do
    local mn, t, nr, nc = cm:size(), nil, cm:sizes()
    assertTrue  ( cm:any \x x~=cm:size()+1         )
    assertFalse ( cm:any \x x==1                   )
    assertTrue  ( cm:any(\x x~=cm:size()+1, 'vec') )
    assertEquals( cm:any(\x x==16), cm:any( \x x==16, 'vec')  )

    t = table.new(nc,1); for i=2,nc do t[i]=true end; t[1]=false
    assertEquals( cm:all(\x x~=1+1i, 'col', {}), t )
    t = table.new(nr,1); for i=2,nr do t[i]=true end; t[1]=false
    assertEquals( cm:all(\x x~=1+1i, 'row', {}), t )
  end
end

-- special scans --------------------------------------------------------------o

function TestCMatrixSScans:setUp()
  for _,cm in ipairs(G.cmatidx) do cm:fill(1..cm:size()):map( toC, 'in') end
end

function TestCMatrixSScans:tearDown()
  for _,cm in ipairs(G.cmatidx) do cm:fill(1..cm:size()):map( toC, 'in') end
end

-- left accumulation
function TestCMatrixSScans:testAccsum()
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    assertEquals( cm:accsum()     , cm:copy():map(\x sum(1..x:real()))                       :map(toC) )
    assertEquals( cm:accsum('col'), cm:copy():mapij(\x,i,j sum(idx(1,j,nc)..idx(i,j,nc)..nc)):map(toC) )
    assertEquals( cm:accsum('row'), cm:copy():mapij(\x,i,j sum(idx(i,1,nc)..idx(i,j,nc)..1 )):map(toC) )
  end
end

function TestCMatrixSScans:testAccsumabs()
  local sumabs = \r =>local x = 0 for i=1,r:size() do x = x + abs(r[i] + r[i]*1i) end return x end
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    assertEquals( cm:accsumabs()     , cm:copy():map(\x sumabs(1..x:real())) )
    assertEquals( cm:accsumabs('col'), cm:copy():mapij(\x,i,j sumabs(idx(1,j,nc)..idx(i,j,nc)..nc)) )
    assertEquals( cm:accsumabs('row'), cm:copy():mapij(\x,i,j sumabs(idx(i,1,nc)..idx(i,j,nc)..1 )) )
  end
end

function TestCMatrixSScans:testAccsumsqr()
  local sumsqr = \r =>local x = 0 for i=1,r:size() do x = x + (r[i]+r[i]*1i)^2 end return x end
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    assertEquals( cm:accsumsqr()     , cm:copy():map(\x sumsqr(1..x:real())) )
    assertEquals( cm:accsumsqr('col'), cm:copy():mapij(\x,i,j sumsqr(idx(1,j,nc)..idx(i,j,nc)..nc)) )
    assertEquals( cm:accsumsqr('row'), cm:copy():mapij(\x,i,j sumsqr(idx(i,1,nc)..idx(i,j,nc)..1 )) )
  end
end

function TestCMatrixSScans:testAccprod()
  local prod = \r =>local x = 1 for i=1,r:size() do x = x * (r[i]+r[i]*1i) end return x end
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    assertEquals( cm:accprod()     , cm:copy():map(\x prod(1..x:real())) )
    assertEquals( cm:accprod('col'), cm:copy():mapij(\x,i,j prod(idx(1,j,nc)..idx(i,j,nc)..nc)) )
    assertEquals( cm:accprod('row'), cm:copy():mapij(\x,i,j prod(idx(i,1,nc)..idx(i,j,nc)..1 )) )
  end
end

-- right accumulation
function TestCMatrixSScans:testRaccsum()
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    assertEquals( cm:raccsum()     , cm:copy():mapij(\x sum(x:real()..nr*nc))                    :map(toC) )
    assertEquals( cm:raccsum('col'), cm:copy():mapij(\x,i,j sum(idx(nr,j,nc)..idx(i,j ,nc)..-nc)):map(toC) )
    assertEquals( cm:raccsum('row'), cm:copy():mapij(\x,i,j sum(idx(i ,j,nc)..idx(i,nc,nc))     ):map(toC) )
  end
end

function TestCMatrixSScans:testRaccsumabs()
  local sumabs = \r =>local x = 0 for i=1,r:size() do x = x + abs(r[i]*1i) end return x end
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    cm:map(\x x:imag()*1i, 'in' )
    assertEquals( cm:raccsumabs()     , cm:copy():mapij\x sumabs(x:imag()..nr*nc) )
    assertEquals( cm:raccsumabs('col'), cm:copy():mapij\x,i,j sumabs(idx(nr,j,nc)..idx(i,j ,nc)..-nc) )
    assertEquals( cm:raccsumabs('row'), cm:copy():mapij\x,i,j sumabs(idx(i ,j,nc)..idx(i,nc,nc)     ) )
  end
end

function TestCMatrixSScans:testRaccsumsqr()
  local sumsqr = \r =>local x = 0 for i=1,r:size() do x = x + (r[i]+r[i]*1i)^2 end return x end
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    assertEquals( cm:raccsumsqr()     , cm:copy():map\x sumsqr(x:real()..nr*nc) )
    assertEquals( cm:raccsumsqr('col'), cm:copy():mapij\x,i,j sumsqr(idx(nr,j,nc)..idx(i,j ,nc)..-nc) )
    assertEquals( cm:raccsumsqr('row'), cm:copy():mapij\x,i,j sumsqr(idx(i ,j,nc)..idx(i,nc,nc)     ) )
  end
end

function TestCMatrixSScans:testRaccprod()
  local prod = \r =>local x = 1 for i=1,r:size() do x = x * (r[i]+r[i]*1i) end return x end
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    if nr*nc < 25 then
      assertTrue( cm:raccprod()   :eq( cm:copy():map\x prod(x:real()..nr*nc) ) )
    end
    assertTrue( cm:raccprod('col'):eq( cm:copy():mapij\x,i,j prod(idx(nr,j,nc)..idx(i,j ,nc)..-nc), eps) )
    assertTrue( cm:raccprod('row'):eq( cm:copy():mapij\x,i,j prod(idx(i ,j,nc)..idx(i,nc,nc))     , eps) )
  end
end

-- symplectic matrix ----------------------------------------------------------o

function TestCMatrixErr:testSympinv()
  local msg = {
   "invalid argument #1 (2n matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth,'sympinv', cmatrix(3)   )
  assertErrorMsgContains( msg[1], mth,'sympinv', cmatrix(4,3) )
end

function TestCMatrixSympl:testSympinv()
-- -J M' J
--[[ M' J M = J => M^-1 = J^-1 M'      det(M)  = ±1 (i.e. Sp(n))
     symp M = {{A,B},{C,D}} <=> A'D - C'B = 1, A'C = C'A, B'D = D'B ]]
  local cmat = cmatrix(2)
  local j    = cmatrix(2):symp()
  local cm1  = { cmatrix{{1,0},{0,1}},
                 cmatrix{{1,0},{1,1}},
                 cmatrix{{1,1},{0,1}}, }
  for _,cm in ipairs(cm1) do
    assertEquals( cm:t()*j*cm      , j          )
    assertEquals( cm:sympinv()    , -j*cm:t()*j )
    assertEquals( cm:sympinv(cmat), -j*cm:t()*j )
  end
end

function TestCMatrixErr:testSymperr()
  local msg = {
    "invalid argument #1 (2n matrix expected)"       ,
    "invalid argument #2 (different matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth,'symperr', cmatrix(3)   )
  assertErrorMsgContains( msg[1], mth,'symperr', cmatrix(4,3) )
end

function TestCMatrixSympl:testSymperr()
  -- M' J M - J
  --assertEquals( cm:symperr(), cm:t()*j*cm-j )
  local j  = cmatrix(2):symp()
  local cm1 = { cmatrix{{1,0},{0,1}},
                cmatrix{{1,0},{1,1}},
                cmatrix{{1,1},{0,1}}, }
  for _,cm in ipairs(cm1) do
    assertEquals( cm:map(toC):symperr(), 2 )
  end
  local cm1 = { cmatrix{{0,0},{0,1}},
                cmatrix{{0,1},{0,1}}, }
  for _,cm in ipairs(cm1) do
    assertTrue( cm:map(toC):symperr() ~= 0 )
  end
end

function TestCMatrixErr:testSymplectify() end
function TestCMatrixSympl:testSymplectify() end

-- conjugate, transpose -------------------------------------------------------o
function TestCMatrixLinAlg:testConjugate()
  for _,cm in ipairs(G.cmatidx) do
    assertEquals( cm:conj(), cm:copy():map(\x x:real()-x:imag()*1i) )
  end
  for _,cm in ipairs(G.cmattmp) do
    assertEquals( cm:conj(), cm:copy():map(\x x:real()-x:imag()*1i) )
  end
end

function TestCMatrixLinAlg:testTranspose()
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    local cmc = cm:copy()
    assertEquals( {cm:t():sizes()}, {nc,nr}          )
    assertEquals(  cm:t()   :t()  , cm               )
    assertEquals( (cm + cmc):t()  , cm:t() + cmc:t() )
    assertEquals( (2  * cm ):t()  , 2 * cm:t()       )
    if nr == nc then
      assertEquals( (cm*cmc):t(), cm:t()*cmc:t() )
      cmc:t('in')     for i=1,nr do for j=1,nc do assertEquals( cmc:get(i,j), cm:conj():get(j,i) ) end end
    end
    cmc = cm:t()      for i=1,nr do for j=1,nc do assertEquals( cmc:get(i,j), cm:conj():get(j,i) ) end end
    cmc = cm:t(false) for i=1,nr do for j=1,nc do assertEquals( cmc:get(i,j), cm       :get(j,i) ) end end
  end
end

function TestCMatrixLinAlg:testTrace()
  for _,cm in ipairs(G.cmatidx) do
    assertEquals( cm:tr(), cm:getdiag():sum() )
  end
end

-- inner, cross, mixed, outer -------------------------------------------------o

function TestCMatrixErr:testInner()
  local msg = {
    "invalid argument #2 (matrix expected)",
    "incompatible matrix sizes"            ,
  }
  assertErrorMsgContains( msg[1], mth, 'inner', errCMat, nil              )
  assertErrorMsgContains( msg[1], mth, 'inner', errCMat, ''               )
  assertErrorMsgContains( msg[1], mth, 'inner', errCMat, 1                )
  assertErrorMsgContains( msg[1], mth, 'inner', errCMat, 1..2             )
  assertErrorMsgContains( msg[1], mth, 'inner', errCMat, {}               )
  assertErrorMsgContains( msg[2], mth, 'inner', errCMat, errCMat, errCMat )
end

function TestCMatrixLinAlg:testInner()
  -- inner prod:  u'.v = |u|.|v| cos(u^v)
  for _,cm in ipairs(G.cmatidx) do
    local mres, mref
    local cmc = cm:copy()
    mres =  cm:inner(cmc)
    mref = (cm:t() * cmc):getdiag():t()
    if mref:size() == 1 then assertEquals( mres, mref:geti(1) )
    else                     assertEquals( mres, mref         ) end
    mres =  cm:inner(cmc,'tr')
    mref = (cm:t() * cmc):tr()
    assertEquals( mres, mref )
  end
end

function TestCMatrixErr:testOuter()
  local cm = cmatrix(2,1)
  local msg = {
    "invalid argument #2 (matrix expected)",
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'outer', cm          , nil          )
  assertErrorMsgContains( msg[1], mth, 'outer', cm          , ''           )
  assertErrorMsgContains( msg[1], mth, 'outer', cm          , {}           )
  assertErrorMsgContains( msg[1], mth, 'outer', cm          , 1            )
  assertErrorMsgContains( msg[1], mth, 'outer', cm          , 1..2         )
  assertErrorMsgContains( msg[2], mth, 'outer', cmatrix(1,2), cmatrix(2,2) )
end

function TestCMatrixLinAlg:testOuter()
  -- x * y:t() without temporary
  for nr=1,5 do
    local cm1 = cvector(nr):fill(1..2*nr..2):map(toC)
    local cm2 = cvector(nr):fill(1..  nr)   :map(toC)
    assertEquals( cm1:outer(cm2), cm1*cm2:t() )
  end
end

function TestCMatrixErr:testCross()
  local cm = cmatrix(3)
  local msg = {
    "invalid argument #2 (matrix expected)",
    "invalid matrix sizes"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'cross', cm     , nil  )
  assertErrorMsgContains( msg[1], mth, 'cross', cm     , ''   )
  assertErrorMsgContains( msg[1], mth, 'cross', cm     , 1    )
  assertErrorMsgContains( msg[1], mth, 'cross', cm     , 1..2 )
  assertErrorMsgContains( msg[1], mth, 'cross', cm     , {}   )
  assertErrorMsgContains( msg[2], mth, 'cross', errCMat, cm   )
end

function TestCMatrixLinAlg:testCross()
  -- cross prod:  uxv = |u|.|v| sin(u^v) \vec{n}
  local cm1 = cmatrix(3):fill(0..8):map(toC)   -- skew-symmetric matrix
  local cm2 = cvector {2,-4,2}:map(toC)
  local cm3 = cm2:copy()
  assertEquals( cm2:cross(cm3), cm1*cm3 )
  for nc=1,5 do
    cm1 = cmatrix(3,nc):fill(1   ..3*nc    ):map(toC)
    cm2 = cm1:copy()   :fill(3*nc..1   ..-1):map(toC)
    cm3 = cm2:copy()
    assertEquals(    cm1 :cross(cm2)    ,-cm2  :cross( cm1)                )
    assertEquals(    cm1 :cross(cm2+cm3), cm1  :cross( cm2)+cm1:cross(cm3) )
    assertEquals( (2*cm1):cross(cm2)    , cm1  :cross( cm2*2)              )
    assertEquals( (2*cm1):cross(cm2)    , 2*cm1:cross( cm2)                )
    assertEquals( (2*cm1):cross(cm2)    , 2*cm1:cross( cm2)                )
    if nc == 3 then
      assertEquals( cm1:cross( cm2:cross(cm3) ), cm2*(cm1*cm3)-cm3*(cm1*cm2)  )
    end
  end
end

function TestCMatrixErr:testMixed()
  local msg = {
    "invalid argument #2 (matrix expected)",
    "invalid argument #3 (matrix expected)",
    "invalid matrix sizes"                 ,
    "incompatible matrix sizes"            ,
  }
  local cm1 = cmatrix(3,1)
  assertErrorMsgContains( msg[1], mth, 'mixed', cm1         , nil                        )
  assertErrorMsgContains( msg[1], mth, 'mixed', cm1         , ''                         )
  assertErrorMsgContains( msg[1], mth, 'mixed', cm1         , 1                          )
  assertErrorMsgContains( msg[1], mth, 'mixed', cm1         , 1..2                       )
  assertErrorMsgContains( msg[1], mth, 'mixed', cm1         , {}                         )
  assertErrorMsgContains( msg[2], mth, 'mixed', cm1         , cm1         , nil          )
  assertErrorMsgContains( msg[2], mth, 'mixed', cm1         , cm1         , ''           )
  assertErrorMsgContains( msg[2], mth, 'mixed', cm1         , cm1         , 1            )
  assertErrorMsgContains( msg[2], mth, 'mixed', cm1         , cm1         , 1..2         )
  assertErrorMsgContains( msg[2], mth, 'mixed', cm1         , cm1         , {}           )
  assertErrorMsgContains( msg[3], mth, 'mixed', cmatrix(2,1), cm1         , cm1          )
  assertErrorMsgContains( msg[4], mth, 'mixed', cmatrix(3,2), cm1         , cm1          )
  assertErrorMsgContains( msg[4], mth, 'mixed', cm1         , cmatrix(2,1), cm1          )
  assertErrorMsgContains( msg[4], mth, 'mixed', cm1         , cmatrix(3,2), cm1          )
  assertErrorMsgContains( msg[4], mth, 'mixed', cm1         , cm1         , cmatrix(2,1) )
  assertErrorMsgContains( msg[4], mth, 'mixed', cm1         , cm1         , cmatrix(3,2) )
end

function TestCMatrixLinAlg:testMixed()
  -- x:cross(y):inner(z) without temporary
  for nc=1,5 do
    local cm1 = cmatrix(3,nc):fill(1   ..3*nc  ):map(toC)
    local cm2 = cm1:same()   :fill(3*nc..1.. -1):map(toC)
    local cm3 = cm1:same()   :fill(1)           :map(toC)
    assertEquals( cm1:mixed(cm2,cm3), cm1:cross(cm2):inner(cm3) )
  end
end

-- norm, unit, center, angle (in place) ---------------------------------------o

function TestCMatrixLinAlg:testNorm() --|u| = sqrt(u'.u), forbidius norm
  for _,cm in ipairs(G.cmatidx) do
    assertEquals( cm:norm(), sqrt(cm:map(\x x^2):sumabs()) )
  end
end

function TestCMatrixErr:testDistance()
  local msg = {
    "invalid argument #2 (cmatrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'distance', errCMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'distance', errCMat, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'distance', errCMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'distance', errCMat, {}   )
end

function TestCMatrixLinAlg:testDistance()
  --sqrt( trace((A-B) * (A-B)') )
  for _,cm in ipairs(G.cmatidx) do
    local mn  = cm:size()
    local cmc = cm:copy()
    local cm2 = cm:same():fill(mn..1..-1):map(toC)
    assertEquals( cm:distance(cmc), sqrt( ( (cm-cmc)*(cm-cmc):t() ):tr()):real() )
    assertEquals( cm:distance(cm2), sqrt( ( (cm-cm2)*(cm-cm2):t() ):tr()):real() )
  end
end

function TestCMatrixErr:testUnit()
  local msg = {
    "null matrix norm",
  }
  assertErrorMsgContains( msg[1], mth, 'unit', cmatrix(2) )
end

function TestCMatrixLinAlg:testUnit()  --  unit :  u / |u|
  for _,cm in ipairs(G.cmatidx) do
    assertEquals( cm:unit(), cm / cm:norm() )
  end
end

function TestCMatrixLinAlg:testCenter()
  for _,cm in ipairs(G.cmatidx) do
    local mid = cm:sum() / cm:size()
    assertEquals( cm:center(),  cm:map(\x x-mid) )
  end
end

function TestCMatrixErr:testAngle()
  local msg = {
    "null vector norm",
  }
  assertErrorMsgContains( msg[1], mth, 'angle', cvector{1,1,1}, cvector{0,0,0} )
  assertErrorMsgContains( msg[1], mth, 'angle', cvector{0,0,0}, cvector{1,1,1} )
end

function TestCMatrixLinAlg:testAngle()
  -- angle:  u^v = acos(u'.v / |u|.|v|)  in [0,pi] (or [-pi,pi] if n)
  local rad = \i,n -> pi*(i-1)/n
  local function unitVectors(n1, n2, r)
    local v = {}
    if is_nil(r) then r=1 end
    for i = 1, n1 do
      local a = rad(i, n1)
      v[i]={}
      for j = 1, n2 do
        local b = rad(j,n2)
        local x = r * cos(a) * sin(b)
        local y = r * sin(a) * sin(b)
        local z = r * cos(b)
        v[i][j] = cvector{x,y,z}
      end
    end
    return v
  end

  local n, m = 16, 16
  for i,t in ipairs( unitVectors( m, n ) ) do
  for j,v in ipairs( t ) do
    assertAlmostEquals( cvector{0,0,1}:angle( v ):real() - rad(j, n), 0, 3*eps )
    assertEquals      ( cvector{0,0,1}:angle( v ):imag(), 0 )
  end
  end
  assertAlmostEquals( cvector{1,0,0}:angle(cvector{ 1, 1, 0}):real(), pi/4  , eps )
  assertAlmostEquals( cvector{1,0,1}:angle(cvector{ 1, 1, 0}):real(), pi/3  , eps )
  assertEquals      ( cvector{1,0,0}:angle(cvector{ 1, 0, 0}), 0      + 0i        )
  assertEquals      ( cvector{1,0,0}:angle(cvector{ 0, 1, 0}), pi/2   + 0i        )
  assertEquals      ( cvector{1,0,0}:angle(cvector{-1,-1, 0}), 3*pi/4 + 0i        )
  assertEquals      ( cvector{1,0,0}:angle(cvector{-1, 0, 0}), pi     + 0i        )
  assertEquals      ( cvector{0,0,1}:angle(cvector{ 0, 0, 1}), 0      + 0i        )
  assertEquals      ( cvector{0,0,1}:angle(cvector{ 0, 0,-1}), pi     + 0i        )
end

-- operators ------------------------------------------------------------------o

function TestCMatrixOps:testUnm()
  for _,cm in ipairs(G.cmatidx) do
    local mn = cm:size()
    local cmref = cm:same():fill(-1..-mn..-1):map(\x x+x*1i)
    assertEquals( -cm      , cmref )
    assertEquals(  cm:unm(), cmref )
  end
end

function TestCMatrixOps:testMod()
  for _,cm in ipairs(G.cmatidx) do
    local m = matrix(cm:sizes()):fill(3)
    assertEquals( cm%cm:copy()                             , cm:same()            )
    assertEquals( cm:same():fill(4   )%cm:same():fill(3   ), cm:same():fill(1   ) )
    assertEquals( cm:same():fill(4+4i)%cm:same():fill(3+3i), cm:same():fill(1+1i) )
    assertEquals( cm:same():fill(3+4i)%cm:same():fill(3+3i), cm:same():fill(  1i) )
    assertEquals( cm:same():fill(4+4i)%m                   , cm:same():fill(1+1i) )
  end
end

function TestCMatrixOps:testPow() --TODO after pow() modifications
  for i,cm in ipairs(G.cmatidx) do
    local cmref = cm:copy():map(\x x*x)
    assertEquals( cm^2, cmref )
  end
end

function TestCMatrixErr:testEq()
  local errCMat = matrix(2):fill(1..4)
  local msg = {
  "invalid arguments (unsupported matrix operation)",
  "invalid argument #3 (callable expected)"         ,
  }
  assertErrorMsgContains( msg[1], mth, 'eq', errCMat, {}             )
  assertErrorMsgContains( msg[1], mth, 'eq', errCMat, ''             )
  assertErrorMsgContains( msg[1], mth, 'eq', errCMat, 1..4           )
  assertErrorMsgContains( msg[2], mth, 'eq', errCMat, cmatrix(1), '' )
  assertErrorMsgContains( msg[2], mth, 'eq', errCMat, cmatrix(1), {} )
end

function TestCMatrixOps:testEq()
  for _,cm in ipairs(G.cmatidx) do
    local m = matrix(cm:sizes())
    assertTrue ( m         == cm:same() ) -- mat  == cmat
    assertTrue ( cm:same() == m:copy()  ) -- cmat == mat
    -- f defined
    assertTrue ( cm       :eq( cm:map(\x x+eps*1i    )         ,   eps) )
    assertTrue ( cm       :eq( cm:map(\x x+eps*(1+1i))         , 2*eps) )
    assertTrue ( cm:imag():eq( cm:map(\x x+eps*1i    ):imag()  ,   eps) )
    assertTrue ( cm:real():eq( cm:map(\x x+eps*1i    ):real()  ,   eps) )
  end
  -- f as function
  local  m =  matrix(2)
  local cm = cmatrix(2)
  assertTrue (  0        == cm:same()         ) -- num  == cmat
  assertFalse(  0        == cm:same():fill(1) )
  assertTrue (  0+0i     ==  m:same()         ) -- cpx  == mat
  assertFalse(  1+0i     ==  m:same()         )
  assertTrue (  0+0i     == cm:same()         ) -- cpx  == cmat
  assertFalse(  0+1i     == cm:same()         )
  assertTrue ( cm:same() == 0                 ) -- cmat == num
  assertTrue ( cm:same() == 0+0i              ) -- cmat == cpx
end

function TestCMatrixErr:testAdd()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
    "incompatible matrix sizes"                       ,
  }
  assertErrorMsgContains( msg[1], mth, 'add', errCMat, ''               )
  assertErrorMsgContains( msg[1], mth, 'add', errCMat, nil              )
  assertErrorMsgContains( msg[1], mth, 'add', errCMat, 1..4             )
  assertErrorMsgContains( msg[2], mth, 'add', errCMat, cmatrix(1)       )
  assertErrorMsgContains( msg[2], mth, 'add', errCMat, cmatrix(3)       )
  assertErrorMsgContains( msg[2], mth, 'add', errCMat, cmatrix(2), {}   )
  assertErrorMsgContains( msg[2], mth, 'add', errCMat, cmatrix(2), 1..4 )
end

function TestCMatrixOps:testAdd()
  for _,cm in ipairs(G.cmatidx) do
    local mn  = cm:size()
    local cmc = cm:copy()
    local m   = matrix(cm:sizes()):fill(1..mn)
    assertEquals( 2  + cm        , cmc:map(\x x+2       ) ) -- num  + cmat => num  + cvec
    assertEquals( cm + 2         , cmc:map(\x x+2       ) ) -- cmat + num  => cvec + num
    assertEquals( cm + cmc       , cmc:map(\x x*2       ) ) -- cmat + cmat => cvec + cvec
    assertEquals( cm + cmc:imag(), cmc:map(\x x+x:imag()) )
    assertEquals( cm + 2i        , cmc:map(\x x+2i      ) ) -- cmat + cpx  => cvec + cpx
    assertEquals( cm + m         , cmc:map(\x x+x:real()) ) -- cmat + mat  => cvec + vec
  end
end

function TestCMatrixOps:testAddCpx()
  for _,cm in ipairs(G.cmatidx) do
    local cmres = 2i + cm
    assertEquals( cmres, cm:copy():map(\x x+2i) ) -- cpx + cmat => cpx + cvec
  end
end

function TestCMatrixErr:testSub()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
    "incompatible matrix sizes"                       ,
  }
  assertErrorMsgContains( msg[1], mth, 'sub', errCMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'sub', errCMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'sub', errCMat, 1..4      )
  assertErrorMsgContains( msg[2], mth, 'sub', errCMat, matrix(1) )
  assertErrorMsgContains( msg[2], mth, 'sub', errCMat, matrix(3) )
end

function TestCMatrixOps:testSub()
  for _,cm in ipairs(G.cmatidx) do
    local mn  = cm:size()
    local cmc = cm:copy()
    local m   = matrix(cm:sizes()):fill(1..mn)
    assertEquals( cm - cmc          , cm :same()              ) -- cmat - cmat => cvec - cvec
    assertEquals( cm - cmc:imag()*1i, cmc:real()              )
    assertEquals( 2  - cm           , cmc:map(\x 2-x        ) ) -- num  - cmat => num  - cvec
    assertEquals( cm - 2            , cmc:map(\x x-2        ) ) -- cmat - num  => cvec + -num
    assertEquals( cm - 2i           , cmc:map(\x x-2i       ) ) -- cmat - cpx  => cvec + -cpx
    assertEquals( cm - m            , cmc:map(\x x:imag()*1i) ) -- cmat - mat  => cvec -  vec
  end
end

function TestCMatrixOps:testSubCpx()
  for _,cm in ipairs(G.cmatidx) do
    local cmres = 2i - cm
    assertEquals( cmres, cm:copy():map(\x 2i-x) ) -- cpx - cmat => cpx - cvec
  end
end

function TestCMatrixErr:testMul()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
    "incompatible matrix sizes"                       ,
  }
  assertErrorMsgContains( msg[1], mth, 'mul', errCMat    , ''          )
  assertErrorMsgContains( msg[1], mth, 'mul', errCMat    , nil         )
  assertErrorMsgContains( msg[1], mth, 'mul', errCMat    , 1..4        )
  assertErrorMsgContains( msg[2], mth, 'mul', matrix(2,1), matrix(2,1) )
  assertErrorMsgContains( msg[2], mth, 'mul', matrix(1,2), matrix(1,1) )
  assertErrorMsgContains( msg[2], mth, 'mul', matrix(1,2), matrix(3,1) )
end

local function refMul(m1, m2, i, j )
  local mref = cmatrix(m1:nrow(), m2:ncol())
  for i=1,m1:nrow() do
  for j=1,m2:ncol() do
    local x = 0
    for ii=1,m1:ncol()
      do x = x + m1:get(i,ii) * m2:get(ii,j)
    end
    mref:set(i,j,x)
  end end
  return mref
end

function TestCMatrixOps:testMul()
  for _,cm in ipairs(G.cmatidx) do
    local mn, nr, nc, _ = cm:size(), cm:sizes()
    for j=1,5 do
      local cm2 = cm:same(_ ,nc,j):fill(1..nc*j):map(toC)
      local m   = matrix(nc,j)    :fill(1..nc*j)
      assertEquals( j  * cm  , cm:same():fill(j..mn*j..j):map(toC) ) -- num  * cmat => num  * cvec
      assertEquals( cm * j   , cm:same():fill(j..mn*j..j):map(toC) ) -- cmat * num  => cvec * num
      assertEquals( cm * j*1i, cm:copy():map(\x x*j*1i  )          ) -- cmat * cpx  => cvec * cpx
      assertEquals( cm * cm2 , refMul(cm,cm2)                      ) -- cmat * cmat
      assertEquals( cm * m   , refMul(cm,m  )                      ) -- cmat * mat
    end
  end
end

function TestCMatrixOps:testMulCpx()
  for _,cm in ipairs(G.cmatidx) do
    local mref = 2i * cm
    assertEquals( mref, cm:copy():map(\x x*2i) )
  end
end

function TestCMatrixErr:testTmul()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
    "incompatible matrix sizes"                       ,
  }
  assertErrorMsgContains( msg[1], mth, 'tmul', errCMat     , ''           )
  assertErrorMsgContains( msg[1], mth, 'tmul', errCMat     , nil          )
  assertErrorMsgContains( msg[1], mth, 'tmul', errCMat     , 1..4         )
  assertErrorMsgContains( msg[2], mth, 'tmul', cmatrix(2,1), cmatrix(1,2) )
  assertErrorMsgContains( msg[2], mth, 'tmul', cmatrix(1,2), cmatrix(3,1) )
end

function TestCMatrixOps:testTmul()
  for _,cm in ipairs(G.cmatidx) do
    local nr, _ = cm:nrow()
    for i=1,5 do
      local m   =  matrix(nr,i   ):fill(1..nr*i)
      local cm2 = cm:same(0i,nr,i):fill(1..nr*i):map(toC)
      assertEquals( cm:tmul(m  ), refMul(cm:t(),m  ) ) -- cmat' * mat
      assertEquals( cm:tmul(cm2), refMul(cm:t(),cm2) ) -- cmat' * cmat
    end
  end
end

function TestCMatrixErr:testMult()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
    "incompatible matrix sizes"                       ,
  }
  assertErrorMsgContains( msg[1], mth, 'mult', errCMat     , ''           )
  assertErrorMsgContains( msg[1], mth, 'mult', errCMat     , nil          )
  assertErrorMsgContains( msg[1], mth, 'mult', errCMat     , 1..4         )
  assertErrorMsgContains( msg[2], mth, 'mult', cmatrix(2,1), cmatrix(1,2) )
  assertErrorMsgContains( msg[2], mth, 'mult', cmatrix(1,2), cmatrix(3,1) )
end

function TestCMatrixOps:testMult()
  for _,cm in ipairs(G.cmatidx) do
    local nr, _ = cm:ncol()
    for i=1,5 do
      local m   =  matrix(i ,nr   ):fill(1..nr*i)
      local cm2 = cm:same(0i,i ,nr):fill(1..nr*i)
      assertEquals( cm:mult(m  ), refMul(cm, m  :t()) ) -- cmat * mat'
      assertEquals( cm:mult(cm2), refMul(cm, cm2:t()) ) -- cmat * cmat'
    end
  end
end

function TestCMatrixErr:testDiv()
  local msg = {
    "invalid arguments (unsupported matrix operation)",
    "incompatible matrix sizes"                       ,
  }
  assertErrorMsgContains( msg[1], mth, 'div', errCMat     , ''           )
  assertErrorMsgContains( msg[1], mth, 'div', errCMat     , nil          )
  assertErrorMsgContains( msg[1], mth, 'div', errCMat     , 1..4         )
  assertErrorMsgContains( msg[2], mth, 'div', cmatrix(2,1), cmatrix(1,2) )
  assertErrorMsgContains( msg[2], mth, 'div', cmatrix(1,2), cmatrix(3,1) )
end

--[[
function TestCMatrixOps:testDiv() -- TODO
--  local m = matrix(3,2):fill(2)
--  print(1/m)
  for _,cm in ipairs(G.cmatidx) do
    local mn, nr, nc = cm:size(), cm:sizes()
    local cmc = cm:copy():random(randomseed(2))
    local m   = matrix(nr,nc):fill(1..mn)
    if nr == nc then
      --assertTrue( (cmc * (1/cmc)):eq( cmc:copy():eye(), 5*eps) )  -- num / cmat
    else--TODO
      --print( 1/mc,"\n" )
      --print( mc,"\n" )
      --print( mc:t() * (1/mc),"\n" )  -- num / mat
    end
    --assertEquals(  cm / 2 , cm:copy():map(\x  x/2   )         ) -- cmat / num
    --assertEquals(  cm / 2i, cm:copy():map(\x -x/2*1i)         ) -- cmat / cpx
    --assertTrue  ( (cm / cm ):eq(m:copy()*1/cm        ,   eps) ) -- cmat / cmat
    --assertTrue  ( (cm / m ):eq(m:copy()*1/m       , 2*eps) )    -- cmat / mat
  end
end
]]

function TestCMatrixOps:testDivCpx()
  for _,cm in ipairs(G.cmatidx) do
    local mref = 2i / cm
    assertTrue( mref:eq( 2i*1/cm, 2*eps) )
    assertTrue( is_cmatrix(mref) )
  end
end

function TestCMatrixErr:testEmul()
  local msg = {
    "invalid argument #2 (matrix expected)",
    "incompatible matrix sizes"            ,
  }
  assertErrorMsgContains( msg[1], mth, 'emul', errCMat, ''         )
  assertErrorMsgContains( msg[1], mth, 'emul', errCMat, nil        )
  assertErrorMsgContains( msg[1], mth, 'emul', errCMat, 1..4       )
  assertErrorMsgContains( msg[2], mth, 'emul', errCMat, cmatrix(1) )
  assertErrorMsgContains( msg[2], mth, 'emul', errCMat, cmatrix(3) )
end

function TestCMatrixOps:testEmul()
  for _,cm in ipairs(G.cmatidx) do
    local mn  = cm:size()
    local cmc = cm:copy()
    local m   = matrix(cm:sizes()):fill(1..mn)
    assertEquals( cm:emul(cmc), cm:map2(cmc, '*') )
    assertEquals( cm:emul(m  ), cm:map2(m  , '*') )
  end
end

function TestCMatrixErr:testEdiv()
  local msg = {
    "invalid argument #2 (matrix expected)",
    "incompatible matrix sizes"            ,
  }
  assertErrorMsgContains( msg[1], mth, 'ediv', errCMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'ediv', errCMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'ediv', errCMat, 1..4      )
  assertErrorMsgContains( msg[2], mth, 'ediv', errCMat, matrix(1) )
  assertErrorMsgContains( msg[2], mth, 'ediv', errCMat, matrix(3) )
end

function TestCMatrixOps:testEdiv()
  for _,cm in ipairs(G.cmatidx) do
    local mn  = cm:size()
    local cmc = cm:copy()
    local m   = matrix(cm:sizes()):fill(1..mn)
    assertEquals( cm:ediv(cmc), cm:map2(cmc, '/') )
    assertEquals( cm:ediv(m  ), cm:map2(m  , '/') )
   end
end

-- linear algebra -------------------------------------------------------------o

function TestCMatrixLapack:testSolve()
  for i,m1 in ipairs(dat.solveIn1) do
    local mc = m1:copy()      :map(toC)
    local m2 = dat.solveIn2[i]:map(toC)
    local m3 = dat.solveOut[i]:map(\x x+0i)
    assertTrue( (mc):solve(m2):eq(m3, 2*eps) )
  end
end

--[[
function TestCMatrixErr:testSvd() --TODO
  local msg = {
    "invalid input argument" ,
    "SVD failed to converged",
  }
end
]]

function TestCMatrixLapack:testSvd()
  for i,cm in ipairs(datC.svdIn) do
    local refU = datC.svdU[i]
    local refS = datC.svdS[i]:getdiag()
    local refV = datC.svdV[i]
    local ru, rs, rv, info = cm:svd()
    local cm1 = ru * cm:same():setdiag(rs) * rv:t() -- M = U*S*V'
    assertTrue( ru :eq(refU,   6*eps) )
    assertTrue( rs :eq(refS, 112*eps) )
    assertTrue( rv :eq(refV,   3*eps) )
    assertTrue( cm1:eq(cm  ,  32*eps) )
  end
end

function TestCMatrixErr:testDet()
  local msg = {
    "matrix must be square",
  }
  assertErrorMsgContains( msg[1], mth, 'det', cmatrix(2,1) )
end

function TestCMatrixLapack:testDet()
  local CM = {}
  for i=1,5 do CM[i] = cmatrix(i):random() end
  assertEquals( cmatrix(2):symp():det(), 1+0i )
  assertEquals( cmatrix(2):eye() :det(), 1+0i )
  for i,cm in ipairs(CM) do
    local cm1 = cm:same():random()
    assertAlmostEquals( ((cm*cm1)    :det() - cm:det()*cm1:det()):real(), 0,32*eps )
    assertAlmostEquals( ((cm*cm1)    :det() - cm:det()*cm1:det()):imag(), 0,32*eps )
    assertAlmostEquals( ((2*cm)      :det() - cm:det()*(2^i)    ):real(), 0,   eps )
    assertAlmostEquals( ((2*cm)      :det() - cm:det()*(2^i)    ):imag(), 0,   eps )
    assertAlmostEquals( ( cm:t(false):det() - cm:det()          ):real(), 0,16*eps )
    assertAlmostEquals( ( cm:t(false):det() - cm:det()          ):imag(), 0,16*eps )
  end
end

function TestCMatrixErr:testEigen()
  local msg = {
    "matrix must be square"                  ,
    "invalid input argument"                 ,
    "eigen failed to compute all eigenvalues",
  }
  assertErrorMsgContains( msg[1], mth, 'eigen', cmatrix(2,1) )
  assertErrorMsgContains( msg[1], mth, 'eigen', cmatrix(1,3) )
end

function TestCMatrixLapack:testEigen()
  for i=1,5,1 do
    local cm = cmatrix(i)
    local w, vl, vr, info = cm:eigen()
    assertEquals( w   , cvector(i)       )
    assertEquals( vl  , cmatrix(i):eye() )
    assertEquals( vr  , cmatrix(i):eye() )
    assertEquals( info, 0                )
  end
  for i,cm in ipairs(datC.eigenIn) do
    local w, vl, vr, info = cm:eigen()
    local refD  = datC.eigenD[i]:getdiag()
    local refW  = datC.eigenW[i]
    local refV  = datC.eigenV[i]
    local diagW = cm:same():setdiag(w)
    assertTrue( w          :eq( refD                      , 64*eps) )
    assertTrue( vr         :eq( refV                      ,  4*eps) )
    assertTrue( vl         :eq( refW                      ,  4*eps) )
    assertTrue( (cm * vr)  :eq( vr    * diagW             , 64*eps) ) -- A * V - V * D
    assertTrue( (vl:t()*cm):eq( diagW * vl:t()            , 64*eps) ) -- W'* A - D * W'
    assertAlmostEquals( w:sum():real() - cm:tr():real(), 0, 64*eps  )
    assertAlmostEquals( w:sum():imag() - cm:tr():imag(), 0, 64*eps  )
  end
end

-- FFT, convolution, correlation, covrariance ---------------------------------o
  --vector sizes: 1,2,3,4,5,7,11,13,17,19,25
  --matrix sizes: (of 2,5,7 combinations)

function TestCMatrixFFT:testFFT()
  for i,s in ipairs(datC.sv) do -- 1D
    local ref = datC.fftVOut[i]
    local res = datC.fftVIn:getsub(1..s, 1):fft()
    local ms = matrix(res:sizes())
    local mf = matrix(res:sizes())
    assertTrue( res:real():eq( ref:real(), 16*eps ) )
    assertTrue( res:imag():eq( ref:imag(), 16*eps ) ) -- linux err: 16eps
  end
  for i ,s1 in ipairs(datC.sm) do -- 2D
  for ii,s2 in ipairs(datC.sm) do
    local ref = datC.fftMOut[idx(i,ii,3)]
    local res = datC.fftMIn:getsub(1..s1, 1..s2):fft()
    assertTrue( res:real():eq( ref:real(), 32*eps ) )
    assertTrue( res:imag():eq( ref:imag(), 16*eps ) )
  end end
end

function TestCMatrixFFT:testIFFT()
  -- FFT on cmatrix input
  for i,s in ipairs(datC.sv) do -- 1D
    local ref = datC.fftVIn:getsub(1..s, 1)
    local res = ref:fft():ifft()
    assertTrue( res:real():eq( ref:real(), 4*eps ) )
    assertTrue( res:imag():eq( ref:imag(), 2*eps ) )
  end
  for i ,s1 in ipairs(datC.sm) do -- 2D
  for ii,s2 in ipairs(datC.sm) do
    local ref = dat.fftMIn:getsub(1..s1, 1..s2)
    local res = ref:fft():ifft()
    assertTrue( res:real():eq( ref:real(), 2*eps ) )
    assertTrue( res:imag():eq( ref:imag(), 2*eps ) )
  end end
  -- FFT on  matrix input
    for i,s in ipairs(dat.sv) do -- 1D
    local ref = dat.fftVIn:getsub(1..s, 1)
    local res = ref:fft():ifft()
    assertTrue( res:real():eq( ref:real(), 4*eps ) )
    assertTrue( res:imag():eq( ref:imag(),   eps ) )
  end
  for i ,s1 in ipairs(dat.sm) do -- 2D
  for ii,s2 in ipairs(dat.sm) do
    local ref = dat.fftMIn:getsub(1..s1, 1..s2)
    local res = ref:fft():ifft()
    assertTrue( res:real():eq( ref:real(), 2*eps ) )
    assertTrue( res:imag():eq( ref:imag(),   eps ) )
  end end
end

function TestCMatrixFFT:testRFFT()
  local msg = {
    "invalid argument #1 (matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'rfft', cmatrix(1) )
end

function TestCMatrixFFT:testIRFFT()
  local msg = {
    "invalid argument #2 (matrix expected)" ,
    "incompatible matrix sizes"             ,
  }
  assertErrorMsgContains( msg[1], mth, 'irfft', cvector(3), nil       )
  assertErrorMsgContains( msg[2], mth, 'irfft', cvector(3), matrix(1) )
end

function TestMatrixFFT:testIRFFT()
  for i,s in ipairs(dat.sv) do   -- 1D
    local ref = dat.fftVIn:getsub(1..s, 1)
    local res = ref:rfft():irfft(ref:same())
    assertTrue( res:eq( ref, 2*eps ) )
  end
  for i ,s1 in ipairs(dat.sm) do -- 2D
  for ii,s2 in ipairs(dat.sm) do
    local ref = dat.fftMIn:getsub(1..s1, 1..s2)
    local res = ref:rfft():irfft(ref:same())
    assertTrue( res:eq( ref, 2*eps ) )
  end end

  local ref = {
    matrix{{1,1,0},{1,1,0},{1,1,0}},
    matrix{{1,1,1},{1,1,1},{0,0,0}},
    matrix{{1,1,1},{0,0,0},{1,1,1}},
    matrix(3):eye()                ,
  }
  for _,ref in ipairs(ref) do
    local res = ref:rfft():irfft(matrix(3))
    assertTrue( res:eq( ref, 2*eps ) )
  end
end

--function TestCMatrixFFT:testNFFT() end
--function TestCMatrixFFT:testINFFT() end

function TestCMatrixErr:testConv()
  local msg = {
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'conv',  cvector(1), cvector(2) )
  assertErrorMsgContains( msg[1], mth, 'conv',  cmatrix(1), cmatrix(2) )
end

-- pascal triangle helpers
local pasVal = \x => local y=1 for i=1,x do y=y*i end return y end
local function pasVec(x)
  local v = vector(x)
  for z=1,x do v:seti(z, pasVal(x-1)/( pasVal(z-1)*pasVal(x-z) )) end
  return v
end

 -- convolution theorem
function TestCMatrixFFT:testConv()
  -- HELP - to get full conv: nr, nc = xr+yr-1, xc+yc-1
  for i=3,8 do
    local outs = (i-1)+(i-2) - 1
    local v1  = pasVec(i-1):resize(outs,1):map(toC)
    local v2  = pasVec(i-2):resize(outs,1):map(toC)
    local res = v1:conv(v2)
    assertTrue( res:eq(pasVec(outs):map(\x 2i*x), 600*eps ) )
    assertTrue( res:eq(v2:conv(v1)) )
  end
  for i=3,5 do
  for j=0,2 do
    local outs = i+2
    local cm = dat.fftMIn:getsub(1+j..i+j, 1+j..i+j):resize(outs):map(toC)
    local k  = matrix{{0,0,0},{0,1,0},{0,0,0}}      :resize(outs):map(toC)
    local mres = cm:conv(k):shift(-1,-1)
    assertTrue( mres:getsub(1..i     ,1..i     ):eq( cm:getsub(1..i, 1..i  ):map(\x ((x:real()+x:imag())*1i) ), 3*eps) )
    assertTrue( mres:getsub(i+1..outs,1..i     ):eq( cmatrix(outs-i, i     )                                  , 2*eps) )
    assertTrue( mres:getsub(1..i     ,i+1..outs):eq( cmatrix(i     , outs-i)                                  , 2*eps) )
  end end
end

 -- correlation theorem
function TestCMatrixFFT:testCorr()
  for i=3,6 do
    local outs = (i-1)+(i-2) - 1
    local v1  = pasVec(i-1):resize(outs,1):map(toC)
    local v2  = pasVec(i-2):resize(outs,1):map(toC)
    local res = v1:corr(v2)
    assertTrue( res:eq( pasVec(outs):shift(outs/2+1,0):map(\x 2*x+0i), 32*eps ) )
    assertTrue( res:eq( v2:corr(v1) :shift(1       ,0)               , 32*eps ) )
  end
  for i=3,5 do
  for j=0,2 do
    local outs = i+2
    local m = dat.fftMIn:getsub(1+j..i+j, 1+j..i+j):resize(outs):map(toC)
    local k = matrix{{0,0,0},{0,1,0},{0,0,0}}      :resize(outs):map(toC)
    local mref = m:conv(k):shift(-1,-1):map(\x complex(x:imag(), x:real()) )
    local mres = m:corr(k):shift( 1 ,1)
    assertTrue( mref:eq( mres, 4*eps ) )
  end end
end

function TestCMatrixFFT:testCovar()
for i=3,6 do
    local outs = (i-1)+(i-2) - 1
    local v1 = pasVec(i-1):resize(outs,1):map(toC)
    local v2 = pasVec(i-2):resize(outs,1):map(toC)
    local res = v1:covar(v2)
    local ref = v1:corr (v2):center()
    assertTrue( res:eq( ref, 32*eps ) )
  end
  for i=3,5 do
    local outs = i+2
    local m = dat.fftMIn:getsub(1..i, 1..i)  :resize(outs):map(toC)
    local k = matrix{{0,0,0},{0,1,0},{0,0,0}}:resize(outs):map(toC)
    local mref = m:corr (k):shift(1,1):center()
    local mres = m:covar(k):shift(1,1)
    assertTrue( mref:eq( mres, 4*eps ) )
  end
end

-- concatenation, conversion --------------------------------------------------o

function TestCMatrixErr:testConcat()
  local msg = {
    "invalid argument #1 (matrix expected)"                     ,
    "invalid argument #2 (matrix expected)"                     ,
    "incompatible matrix sizes"                                 ,
    "invalid argument #3 (string 'vec', row' or 'col' expected)",
    "incompatible matrix sizes"                                 ,
  }
  assertErrorMsgContains( msg[2], mth, 'concat', errCMat     , ''                              )
  assertErrorMsgContains( msg[2], mth, 'concat', errCMat     , nil                             )
  assertErrorMsgContains( msg[2], mth, 'concat', errCMat     , 1..4                            )
  assertErrorMsgContains( msg[3], mth, 'concat', errCMat     , cmatrix(1)                      )
  assertErrorMsgContains( msg[3], mth, 'concat', cmatrix(3)  , errCMat                         )
  assertErrorMsgContains( msg[4], mth, 'concat', errCMat     , errCMat     , ''                )
  assertErrorMsgContains( msg[4], mth, 'concat', errCMat     , errCMat     , 1                 )
  assertErrorMsgContains( msg[5], mth, 'concat', cmatrix(1,2), cmatrix(3,2), 'row'             )
  assertErrorMsgContains( msg[5], mth, 'concat', cmatrix(2,3), cmatrix(2,2), 'col'             )
  assertErrorMsgContains( msg[5], mth, 'concat', errCMat     , errCMat     , 'col', cmatrix(3) )
end

function TestCMatrix:testConcat()
  for _,cm in ipairs(G.cmatidx) do
    local mn, nr, nc, _ = cm:size(), cm:sizes()
    local cmref1 = cm:same(_,2*nr,  nc):setsub(1..nr, 1..nc, 1..mn):setsub(1+nr..2*nr, 1   ..  nc, 1..mn):map(\x x+x*1i)
    local cmref2 = cm:same(_,  nr,2*nc):setsub(1..nr, 1..nc, 1..mn):setsub(1   ..  nr, 1+nc..2*nc, 1..mn):map(\x x+x*1i)
    local cmref3 = cm:same(_,2*mn,  1 ):setsub(1..mn, 1    , 1..mn):setsub(1+mn..2*mn, 1         , 1..mn):map(\x x+x*1i)
    assertEquals( cm:concat( cm       ), cmref1 )
    assertEquals( cm:concat( cm, 'col'), cmref1 )
    assertEquals( cm:concat( cm, 'row'), cmref2 )
    assertEquals( cm:concat( cm, 'vec'), cmref3 )
  end
end

function TestCMatrixConv:testTosting()
  local cm = cmatrix(2)
  assertTrue( is_string(tostring(cm      )) )
  assertTrue( is_string(tostring(cm, ''  )) )
  assertTrue( is_string(tostring(cm, "\n")) )
  for i,cm in ipairs(G.cmatidx) do
    local c, nr, nc = {}, cm:sizes()
    local ref1 = {} for i=1,nr do for j=1,nc do c[j]=tostring(idxC(i,j,nc)) end ref1[i]=table.concat(c, ' ' ) end
    local ref2 = {} for i=1,nr do for j=1,nc do c[j]=tostring(idxC(i,j,nc)) end ref2[i]=table.concat(c      ) end
    local ref3 = {} for i=1,nr do for j=1,nc do c[j]=tostring(idxC(i,j,nc)) end ref3[i]=table.concat(c, "\n") end
    assertEquals( tostring(cm      ), table.concat(ref1, '\n') )
    assertEquals( tostring(cm, ''  ), table.concat(ref2, '\n') )
    assertEquals( tostring(cm, '\n'), table.concat(ref3, '\n') )
  end
end

function TestCMatrixErr:testTotable()
  local msg = {
    "invalid argument #2 (table expected)"          ,
    "invalid argument #2 (table of tables expected)",
  }
  assertErrorMsgContains( msg[1], totable, errCMat, ''      )
  assertErrorMsgContains( msg[1], totable, errCMat, 1       )
  assertErrorMsgContains( msg[1], totable, errCMat, true    )
  assertErrorMsgContains( msg[1], totable, errCMat, 1..2    )
  assertErrorMsgContains( msg[1], totable, errCMat, errCMat )
  assertErrorMsgContains( msg[2], totable, errCMat, {{},5}  )
end

function TestCMatrixConv:testTotable()
  for i,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    local tref   = totable(cm)
    if nc ~=1 then for i=1,nr do for j=1,nc do assertEquals( tref[i][j], idxC(i,j,nc) ) end end
              else for i=1,nr do               assertEquals( tref[i]   , idxC(i,1,nc) )     end end
    assertTrue  ( is_table(totable(cm))     )
    assertEquals( cmatrix  (totable(cm)), cm )
  end
end

TestCMatrixZ = {}

function TestCMatrixZ:testGMatixCheck()
  for i,cm in ipairs(G.cmatidx) do
    local mn = cm:size()
    assertEquals( G.size[i], {cm:sizes()}                          )
    assertEquals( cm       ,  cm:same():fill(1..mn):map(\x x+x*1i) )
  end
  for i,cm in ipairs(G.cmattmp) do
    assertEquals( G.size[i], {cm:sizes()} )
    assertEquals( cm       ,  cm:same()   )
  end
end

-- performance test suite -----------------------------------------------------o

--[[
Test_Matrix = {}
]]

-- end ------------------------------------------------------------------------o
