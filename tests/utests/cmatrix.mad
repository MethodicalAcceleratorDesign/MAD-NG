--[=[
 o-----------------------------------------------------------------------------o
 |
 | Matrix module regression tests -  complex matrices
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the matrix module.

 o-----------------------------------------------------------------------------o
]=]

local complex, range, nrange, nlogrange, vector, cvector, matrix,
      cmatrix, linspace, logspace, totable, tostring, concat     in MAD
local assertEquals, assertAlmostEquals, assertInf, assertFalse,
      assertNotEquals, assertErrorMsgContains, assertNaN,
      assertIsString, assertTrue, assertAllAlmostEquals          in MAD.utest
local is_vector, is_matrix, is_cvector, is_cmatrix, isa_vector,
      is_nil, isa_matrix, is_table, is_cdata, is_string          in MAD.typeid
local sqrt, abs, log, exp, floor, round,
      sin, cos, tan, sinh, cosh, tanh, asin, acos, atan, asinh,
      acosh, atanh, atan2, hypot, erfc, erf, hypot3, acot, acoth,
      asinc, asinhc, acot, cot, coth, log10, sinc, sinhc         in MAD.gmath
local chain, duplicate                                           in MAD.fun
local rep                                                        in MAD.utility
local eps, tiny, huge, inf, nan, pi                              in MAD.constant
local min, random, randomseed                                    in math

local infi = complex(0,inf)

local dat  = assert(loadfile('data/matrix.dat'))()
local datC = assert(loadfile('data/cmatrix.dat'))()

-- locals ---------------------------------------------------------------------o

local mth  = \f,s,... s[f](s,...)
local idx  = \i,j,nc ( (i-1)*nc+j )
local toC  = \x complex(x,x)
local idxC = \i,j,nc toC(idx(i,j,nc))
local sym_func = \v, i,j -> i*j
local function sympTransferMatrix(a, b, nr) --Create a known symplectic matrix 
  local sinm = sin(0.5)
  local cosm = cos(0.5)
  local c = (1+a^2)/b 
  local twoByTwo = cmatrix({{cosm + a*sinm, b*sinm}, {-c*sinm, cosm - a*sinm}})
  local transfer_mat = cmatrix(nr*2, nr*2)
  for i = 0, nr-1 do
    transfer_mat:setsub((i * 2 + 1)..(i * 2 + 2), (i * 2 + 1)..(i * 2 + 2), twoByTwo)
  end
  transfer_mat:mul(sqrt(2)/2 + sqrt(2)/2 * 1i) --(wikipedia)
  return transfer_mat
end

local errCMat = cmatrix(2)

local G   = {}
G.cmatidx = {}
G.cmattmp = {}
G.cmatsym = {}
G.cmatsymp= {}
G.matidx  = {}
G.size    = {}
G.vi      = {}
G.vj      = {}

for nr=1,5 do
  G.vi[nr] = vector(nr):fill(1..nr)
  G.vj[nr] = vector(nr):fill(1..nr)
  G.cmatsym[#G.cmatsym+1] = cmatrix(nr,nr):fill(sym_func):fill(toC)
  for nc=1,5 do
    G.cmatidx [#G.cmatidx+1 ] = cmatrix(nr,nc):fill(1..nr*nc):map( toC )
    G.cmatsymp[#G.cmatsymp+1] = sympTransferMatrix(nr, nc, nr)
    G.cmattmp [#G.cmattmp+1 ] = cmatrix(nr,nc)
    G.matidx  [#G.matidx+1  ] =  matrix(nr,nc):fill(1..nr*nc)
    G.size    [#G.size+1    ] = {nr,nc}
  end
end

math.randomseed( os.clock() )

-- regression test suites -----------------------------------------------------o

TestCMatrix    = {}
TestCMatrixErr = {}

TestCMatrixGet = {}
TestCMatrixSet = {}

TestCMatrixInPlace   = {}
TestCMatrixInPlaceII = {}
TestCMatrixFun       = {}
TestCMatrixFunctions = {}

TestCMatrixSMaps  = {}
TestCMatrixSFolds = {}
TestCMatrixSScans = {}

TestCMatrixSympl  = {}
TestCMatrixLinAlg = {}
TestCMatrixOps    = {}
TestCMatrixLapack = {}
TestCMatrixFFT    = {}
TestCMatrixConv   = {}

function TestCMatrixErr:testCtor()
  local msg = {
  "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
   "cmatrix is too large",
  }
  assertErrorMsgContains( msg[1], cmatrix, ''     )
  assertErrorMsgContains( msg[1], cmatrix, nil    )
  assertErrorMsgContains( msg[1], cmatrix, 0      )
  assertErrorMsgContains( msg[1], cmatrix, tiny   )
  assertErrorMsgContains( msg[1], cmatrix, eps    )
  assertErrorMsgContains( msg[1], cmatrix, 1..2   )
  assertErrorMsgContains( msg[1], cmatrix, infi   )
  assertErrorMsgContains( msg[1], cmatrix, nan    )
  assertErrorMsgContains( msg[1], cmatrix,-1      )
  assertErrorMsgContains( msg[1], cmatrix,-eps    )
  assertErrorMsgContains( msg[2], cmatrix, inf    )
  assertErrorMsgContains( msg[2], cmatrix, huge   )
  assertErrorMsgContains( msg[2], cmatrix, 2^15   )
  assertErrorMsgContains( msg[2], cvector, 2^29+1 )
end

function TestCMatrix:testCtor()
  for ii,cm in ipairs(G.cmatidx) do --ipairs only implicitly tested
    local nr, nc = cm:sizes()
    for j=1,#cm do
      assertEquals( cm._dat[j-1], j+j*1i )
    end
    assertTrue( is_cmatrix(cm) )
    if nc==1 then
      assertTrue  ( is_cvector(cm) )
      assertEquals( nc, 1 )
    else
      if nr ~= 1 then assertFalse(is_vector(cm)) end
      assertEquals( nr, G.size[ii][1] )
      assertEquals( nr, cm.nrow )
      assertEquals( nc, G.size[ii][2] )
      assertEquals( nc, cm.ncol )
    end
  end
end

function TestCMatrixErr:testCtorFromtable()
  local msg = {
  "invalid argument #1 (non-empty table expected)",
  "cannot convert 'string' to 'complex'"          ,
  }
  assertErrorMsgContains( msg[1], cmatrix, {nil} )
  assertErrorMsgContains( msg[2], cmatrix, {''}  )
end

function TestCMatrix:testCtorFromtable() 
  local cv = cvector{1,2 + 1i,3 + 2i,4 + 3i,5 + 4i,6 + 5i}
  local cm = cmatrix{{1 + 2i,2 + 3i,3 + 4i},{4 + 5i,5 + 6i,6 + 7i}}
  for j=1,#cv do assertEquals( cv._dat[j-1], j+(j-1)*1i ) end
  for j=1,#cm do assertEquals( cm._dat[j-1], j+(j+1)*1i ) end
  assertTrue  ( is_cmatrix( cmatrix{2}            ) )
  assertTrue  ( is_cvector( cmatrix{2}            ) )
  assertTrue  ( is_cmatrix( cmatrix{complex(0,0)} ) )
  assertEquals( cmatrix{complex(0,0)}, cmatrix(1)   )
end

function TestCMatrix:testCdataType()
  local cm, cv = cmatrix(2), cvector(2)
  assertFalse( is_matrix ( cm ) )
  assertFalse( is_matrix ( cv ) )
  assertFalse( is_vector ( cm ) )
  assertFalse( is_vector ( cv ) )
  assertTrue ( is_cmatrix( cm ) )
  assertTrue ( is_cmatrix( cv ) )
  assertFalse( is_cvector( cm ) )
  assertTrue ( is_cvector( cv ) )
  assertFalse( isa_vector( cm ) )
  assertTrue ( isa_vector( cv ) )
  assertTrue ( isa_matrix( cm ) )
  assertTrue ( isa_matrix( cv ) )
end

function TestMatrix:testIpairs()
  for _, m in ipairs(G.cmatidx) do 
    for i, v in ipairs(m) do 
      assertEquals(i, v) 
    end
  end
end

-- special constructors -------------------------------------------------------o

function TestMatrix:testVec()
  for _,cmat in ipairs(G.cmatidx) do 
    local vec_res = cmat:vec()
    assertEquals(vec_res, cmat:transpose():reshape(#cmat, 1))
    for i = 1, cmat.nrow do 
      for j = 1, cmat.ncol do
        assertEquals(cmat:get(i, j), vec_res[i + (j-1)*cmat.nrow])
      end
    end
   end
  for _,cmat in ipairs(G.cmattmp) do 
    assertEquals(cmat:vec(), cmat:transpose():reshape(#cmat, 1)) 
  end
end

function TestCMatrix:testVech()
  for _, cmat in ipairs(G.cmatsym) do 
    local vec_res = cmat:vech()
    local vec_idx = 1
    for i = 1, cmat.nrow do 
      for j = i, cmat.ncol do 
        assertEquals(cmat:get(i, j), vec_res[vec_idx])
        vec_idx = vec_idx + 1
      end
    end
  end
end

function TestCMatrix:testDiag()
  for _, vec_set in ipairs({G.vi, G.vj}) do 
    for _, vec in ipairs(vec_set) do 
      local diag_mat = vec:diag()
      for i = 1, #vec do 
        assertEquals(vec[i], diag_mat:get(i, i))
      end
      assertEquals(vec:sum(), diag_mat:sum())
      assertTrue(diag_mat:is_diag())
    end
  end
  for _, vec in ipairs(G.vi) do
    for k = 0, 5 do
      local diag_mat = vec:diag(k)
      for i = 1, #vec do 
        if k >= 0 then assertEquals(vec[i], diag_mat:get(i, i + k)) 
        else           assertEquals(vec[i], diag_mat:get(i + k, i)) 
        end
      end
    end
  end
  for _, cm in ipairs(G.cmatidx) do 
    if cm.nrow > 1 and cm.ncol > 1 then
      assertEquals(cm:diag(), cm:getdiag())
    end
  end
end

-- get, set, same -------------------------------------------------------------o

function TestCMatrixSet:setUp()
  for _,cm in ipairs(G.cmattmp) do cm:zeros() end
  for _,m  in ipairs(G.matidx)  do m :fill(1..#m)  end
  for _,cm in ipairs(G.cmatidx) do cm:fill(1..#cm):map( toC, 'in') end
end

function TestCMatrixSet:tearDown()
  for _,cm in ipairs(G.cmattmp) do cm:zeros() end
  for _,m  in ipairs(G.matidx)  do m :fill(1..#m)  end
  for _,cm in ipairs(G.cmatidx) do cm:fill(1..#cm):map( toC, 'in') end
end

function TestCMatrixErr:testGeti()
  local msg = {
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], errCMat.geti, errCMat, nil )
end

function TestCMatrixGet:testGeti()
  for _,cm in ipairs(G.cmatidx) do
    for j=1,#cm do assertEquals( cm:geti(j), j+j*1i ) end
  end
end

function TestCMatrixErr:testGet()
  local msg = {
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], errCMat.get0, errCMat, 1  , nil )
  assertErrorMsgContains( msg[1], errCMat.get0, errCMat, nil, 1   )
end

function TestCMatrixGet:testGet()
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    for i=1,nr do
    for j=1,nc do
      assertEquals( cm:get(i,j), idxC(i,j,nc) )
    end end
  end
end

function TestCMatrixGet:testGetidx() 
  for _, cm in ipairs(G.cmatidx) do 
    local res, ir, jc = cm:getidx() --Check default works
    assertEquals(1..cm.nrow, ir )
    assertEquals(1..cm.ncol, jc)
    assertEquals(#cm, #res)
    assertEquals(totable(cm:real()), totable(res))
    for i = 1, cm.nrow do 
      for j = 1, cm.ncol do 
        local res = cm:getidx(i, j) --Check numbers work
        assertTrue(MAD.typeid.is_number(res))
        assertEquals(res, cm:real():get(i, j))
        local res = cm:getidx(1..i, 1..j, {}) --Check ranges work (and casting to table)
        assertEquals(i*j, #res)
        assertTrue(is_table(res))
        local index = 1
        for ii = 1, i do 
          for jj = 1, j do 
            assertEquals(cm:real():get(ii, jj), res[index])
            index = index + 1
          end
        end
      end
    end
  end
end

function TestCMatrixGet:testGetij() --Relies on test above
  for _, cm in ipairs(G.cmatidx) do 
    local ij = cm:getidx() --Check inverse works
    local ir, jc = cm:getij(ij)
    for idx = 1, #ij do 
        assertEquals(cm:get(ir[idx], jc[idx]), cm:geti(ij[idx]))
    end 
    local ir, jc = cm:getij() --check default works
    for idx = 1, #cm do 
        assertEquals(cm:get(ir[idx], jc[idx]), cm:geti(idx))
    end 
    for i = 1, cm.nrow do 
      for j = 1, cm.ncol do 
        local ir, jc = cm:getij(cm:getidx(i, j)) --Check numbers work
        assertEquals(i, ir)
        assertEquals(j, jc)
        local ij = cm:getidx(1..i, 1..j)
        local ir, jc = cm:getij(ij, {}, {}) --Check ranges work (and casting to table)
        assertTrue(is_table(ir))
        assertTrue(is_table(jc))
        for idx = 1, #ij do 
            assertEquals(cm:get(ir[idx], jc[idx]), cm[ij[idx]])
        end
      end
    end
  end
end

function TestCMatrixGet:testGetdidx()
  for _, cmat in ipairs(G.matidx) do 
    for k = -cmat.nrow, cmat.ncol do 
      local idxs = cmat:getdidx(k)
      for i = 1, #idxs do 
        if k >= 0 then assertEquals(idxs[i], idx(i, i + k, cmat.ncol))
        else           assertEquals(idxs[i], idx(i - k, i, cmat.ncol)) -- -k means left diag
        end
      end
    end
  end
end


function TestCMatrixErr:testSeti()
  local msg = {
    "index out of bounds"               ,
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], errCMat.seti, errCMat, nan  , 1i )
  assertErrorMsgContains( msg[1], errCMat.seti, errCMat, 0    , 1i )
  assertErrorMsgContains( msg[1], errCMat.seti, errCMat, 1-eps, 1i )
  assertErrorMsgContains( msg[1], errCMat.seti, errCMat, 5    , 1i )
  assertErrorMsgContains( msg[2], errCMat.seti, errCMat, nil  , 1i )
end

function TestCMatrixSet:testSeti()
  for _,cm in ipairs(G.cmattmp) do
    for i=1,#cm do
      cm:seti((i), complex(i,i))
      assertEquals( cm:geti(i), complex(i,i) )
    end
  end
end

function TestCMatrixErr:testSet()
  local msg = {
    "index out of bounds"               ,
    "attempt to compare nil with number",
  }
  assertErrorMsgContains( msg[1], errCMat.set, errCMat, nan  , 1    , 1i )
  assertErrorMsgContains( msg[1], errCMat.set, errCMat, 0    , 1    , 1i )
  assertErrorMsgContains( msg[1], errCMat.set, errCMat, 1    , 0    , 1i )
  assertErrorMsgContains( msg[1], errCMat.set, errCMat, 1-eps, 1    , 1i )
  assertErrorMsgContains( msg[1], errCMat.set, errCMat, 1    , 1-eps, 1i )
  assertErrorMsgContains( msg[2], errCMat.set, errCMat, nil  , 1    , 1i )
end

function TestCMatrixSet:testSet()
  for _,cm in ipairs(G.cmattmp) do
    local nr, nc = cm:sizes()
    for i=1,nr do
    for j=1,nc do
      cm:set( i, j, idxC(i,j,nc) )
      assertEquals( cm:get(i,j), idxC(i,j,nc) )
    end end
  end
end

function TestCMatrixErr:testSame()
  local msg = {
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
    "invalid argument #1 (non-empty table expected)"                           ,
  }
  assertErrorMsgContains( msg[1], errCMat.same, errCMat, 1   , ''      )
  assertErrorMsgContains( msg[1], errCMat.same, errCMat, 1   , 1..2    )
  assertErrorMsgContains( msg[1], errCMat.same, errCMat, 1   , nan     )
  assertErrorMsgContains( msg[2], errCMat.same, errCMat, 1   , {}      )
end

function TestCMatrixSet:testSame()
  local cm, _ = cmatrix(2)
  assertEquals( cm:same( nan), cmatrix(cm:sizes()) )
  assertEquals( cm:same( inf), cmatrix(cm:sizes()) )
  assertEquals( cm:same( 0  ), cmatrix(cm:sizes()) )
  for i,cm in ipairs(G.cmatidx) do
     --                   e ,nr,nc
    assertEquals( cm:same(        ), cmatrix(cm:sizes())           ) -- 1) x:same(               )
    assertEquals( cm:same(1       ), cmatrix(cm:sizes())           ) -- 5) x:same(   e           )
    -- two arg: nr, nc
    assertEquals( cm:same(2 , 2   ), cmatrix(2)                    ) -- 4')x:same( nr , nc       )
    assertEquals( cm:same(6 , 5   ), cmatrix(6,5)                  )
    assertEquals( cm:same( 2 ,2, _), cmatrix(2)                    ) -- 4) x:same( nr , nc, nil  )
    -- three arg: e_, nr, nc
    assertEquals( cm:same(2, 2, 0i), cmatrix(2)                    ) -- 8) x:same(  nr , nc, e   )
    assertEquals( cm:same(2, 2,  1), cmatrix(2)                    )
    -- one sizse define
    assertEquals( cm:same(1, cm.ncol  ), cmatrix(1        , cm.ncol) ) -- 2) x:same( nil, nr       )
    assertEquals( cm:same( nil, 1), cmatrix(cm.nrow, 1        ) ) -- 3) x:same( nil, nil, nc  )
    assertEquals( cm:same( nil, 1, 0i), cmatrix(cm.nrow, 1        ) ) -- 7) x:same(  nil, nc , e )
  end
end

-- getx, setx -----------------------------------------------------------------o

function TestCMatrixErr:testGetsub()
  local C = complex(1,1)
  local msg = {
    "invalid argument #2 (iterable expected)"                                  ,
    "invalid argument #3 (iterable expected)"                                  ,
    "invalid argument #4 (iterable expected)"                                  ,
    "invalid range member '1'"                                                 ,
    "cannot convert 'nil' to 'complex'"                                        ,
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
  }
  assertErrorMsgContains( msg[1], errCMat.getsub, errCMat, nil              )
  assertErrorMsgContains( msg[1], errCMat.getsub, errCMat, ''               )
  assertErrorMsgContains( msg[1], errCMat.getsub, errCMat, \x x             )
  assertErrorMsgContains( msg[1], errCMat.getsub, errCMat, C                )
  assertErrorMsgContains( msg[2], errCMat.getsub, errCMat, 1   , nil        )
  assertErrorMsgContains( msg[2], errCMat.getsub, errCMat, 1   , ''         )
  assertErrorMsgContains( msg[2], errCMat.getsub, errCMat, 1   , \x x       )
  assertErrorMsgContains( msg[3], errCMat.getsub, errCMat, 0   , 0   , 1    )
  assertErrorMsgContains( msg[3], errCMat.getsub, errCMat, 1   , 1   , \x x )
  assertErrorMsgContains( msg[4], errCMat.getsub, errCMat, 1   , 1   , 1..4 )
  assertErrorMsgContains( msg[5], errCMat.getsub, errCMat, 0   , 0          )
  assertErrorMsgContains( msg[5], errCMat.getsub, errCMat, 0   , 1          )
  assertErrorMsgContains( msg[5], errCMat.getsub, errCMat, 1   , 0          )
  assertErrorMsgContains( msg[5], errCMat.getsub, errCMat, 3   , 1          )
  assertErrorMsgContains( msg[5], errCMat.getsub, errCMat, 1   , 3          )
  assertErrorMsgContains( msg[5], errCMat.getsub, errCMat, {0}       , 1    )
  assertErrorMsgContains( msg[5], errCMat.getsub, errCMat, vector(1) , 1    )
  assertErrorMsgContains( msg[6], errCMat.getsub, errCMat, 2..1      , 1    )
end

function TestCMatrixGet:testGetsub()
  local cm, r = G.cmatidx[25]
  assertEquals( cm:getsub(2,2          ):geti(1)  , cm:get(2,2) )
  assertEquals( cm:getsub(2,2,{}       )[1]       , cm:get(2,2) )
  assertEquals( cm:getsub(2,2,cvector(2)):get(1,1), cm:get(2,2) )
  assertEquals( cm:getsub(2,2,cvector(2)):get(2,1), 0+0i        )
  assertEquals( cm:getsub(2,2, vector(2)):get(2,1), 0           )
  r = cm:getsub( 1..2, 1..3) for i=1,2 do for j=1,3 do assertEquals( r:get(i,j), idxC(i,j,5) ) end end
  r = cm:getsub({1}  ,{1,2}) for i=1,1 do for j=1,2 do assertEquals( r:get(i,j), idxC(i,j,5) ) end end

  for _,cm in ipairs(G.cmatidx) do  -- 25  (all shapes over 5x5)
    local nr, nc = cm:sizes()
    for li=1,nr do                  -- 625 (all sub-shapes over 5x5)
    for lj=1,nc do
      local vi, vj = G.vi[li], G.vj[lj]
      vi:shuffle(); vj:shuffle()
      local r = cm:getsub(vi, vj)
      for i=1,li do
      for j=1,lj do
        assertEquals( r:get(i,j), cm:get(vi[i], vj[j]) )
      end end
    end end
  end
end

function TestCMatrixErr:testSetsub()
  local C = complex(1,1)
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (iterable expected)"          ,
    "invalid argument #4 (scalar or iterable expected)",
    "index out of bounds"                              ,
    "cannot convert 'nil' to 'double'"                 ,
  }
  assertErrorMsgContains( msg[1], errCMat.setsub, errCMat, nil , 1  , 1i  )
  assertErrorMsgContains( msg[1], errCMat.setsub, errCMat, ''  , 1  , 1i  )
  assertErrorMsgContains( msg[1], errCMat.setsub, errCMat, \x x, 1  , 1i  )
  assertErrorMsgContains( msg[2], errCMat.setsub, errCMat, 1              )
  assertErrorMsgContains( msg[2], errCMat.setsub, errCMat, 1   , nil, 1i  )
  assertErrorMsgContains( msg[2], errCMat.setsub, errCMat, 1   , '' , 1i  )
  assertErrorMsgContains( msg[3], errCMat.setsub, errCMat, 1   , 1  , nil )
  assertErrorMsgContains( msg[3], errCMat.setsub, errCMat, 1   , 1  , ''  )
  assertErrorMsgContains( msg[4], errCMat.setsub, errCMat, nan , 1  , 1i  )
  assertErrorMsgContains( msg[4], errCMat.setsub, errCMat, 1   , nan, 1i  )
  assertErrorMsgContains( msg[4], errCMat.setsub, errCMat, 0   , 1  , 1i  )
  assertErrorMsgContains( msg[4], errCMat.setsub, errCMat, 1   , 0  , 1i  )
  assertErrorMsgContains( msg[1], errCMat.setsub, errCMat, C   , 1  , 1i  )
  assertErrorMsgContains( msg[2], errCMat.setsub, errCMat, 1   , C  , 1i  )
end

function TestCMatrixSet:testSetsub()
  local cm = G.cmattmp[25]
  cm:setsub( 1..5, 1, {1,1,1,1,1}) assertEquals( cm:getsub( 1..5, 1   ), cm:same(5,1):fill(1)    )
                                   assertEquals( cm:getsub( 1..5, 2..5), cm:same(5,4)            )
  cm:setsub( 1..5, 1, 1..5       ) assertEquals( cm:getsub( 1..5, 1   ), cm:same(5,1):fill(1..5) )
                                   assertEquals( cm:getsub( 1..5, 2..5), cm:same(5,4)            )
  cm:setsub( 1..5, 1..5, 1       ) assertEquals( cm:getsub( 1..5, 1..5), cm:same(5,5):fill(1)    )
  cm:zeros()
-- recycling
  cm:setsub( 1..5, 1   , {1i} ) assertEquals( cm:getsub( 1..5, 1   ), cm:same(5,1):fill(1):map\x x*1i )
                                assertEquals( cm:getsub( 1..5, 2..5), cm:same(5,4)            )
  cm:setsub( 1..5, 1   , 1..3 ) assertEquals( cm:getsub( 1..3, 1   ), cm:same(3,1):fill(1..3) )
                                assertEquals( cm:getsub( 4..5, 1   ), cm:same(2,1):fill(1..2) )
                                assertEquals( cm:getsub( 1..5, 2..5), cm:same(5,4)            )
  local f = \p, s => return s + p, 0 + 0i end
  cm:setsub(1..cm.nrow, 1..cm.ncol, f, 1, 1)
  assertEquals(cm, cm:same():fill(0+0i))
  f = \p, s => return s + p, s end
  cm:setsub(1..cm.nrow, 1..cm.ncol, f, 2+2i, 2+2i)
  assertEquals(cm, cm:same():seq()*2 + cm:same():seq()*2i)
  cm:fill(0)
  cm:setsub(1..2, 2..3, f, 3, 2) assertEquals( cm:getsub(1..2, 2..3 ), cm:same(2 ,2):fill(2..12..3) )
                                assertEquals( cm:getsub(3..5, 4..5), cm:same(3 ,2):fill(0)        )
  cm:setsub( 1..5, 1..5, 1..5 )
  for i =1,5 do assertEquals( cm:getsub( i, 1..5), cm:same(1,5):fill(1..5) ) end

  for i,cm in ipairs(G.cmattmp) do
    local nr, nc = cm:sizes()
    for li=1,nr do
    for lj=1,nc do
      local vi, vj = G.vi[li], G.vj[lj]
      cm:zeros()
      vi:shuffle(); vj:shuffle()
      cm:setsub(vi,vj,duplicate(2i))
      assertEquals( cm:getsub(vi,vj), cmatrix(#vi,#vj):fill(2i) )
      local cmtemp = cm:same(#vi,#vj):fill(1..#vi*#vj):map(toC)
      cm:setsub(vi,vj,cmtemp)
      if     #vi ~= nr and #vj ~= nc then  assertEquals( cm:getsub(1    ..nr, #vj+1..nc), cm:same(nr    , nc-#vj) )
                                           assertEquals( cm:getsub(#vi+1..nr, 1    ..nc), cm:same(nr-#vi, nc    ) )
      elseif #vi == nr and #vj ~= nc then  assertEquals( cm:getsub(1    ..nr, #vj+1..nc), cm:same(nr    , nc-#vj) )
      elseif #vi ~= nr and #vj == nc then  assertEquals( cm:getsub(#vi+1..nr, 1    ..nc), cm:same(nr-#vi, nc    ) ) end

      local rset  = cm:getsub(vi, vj)
      for i=1,li do
      for j=1,lj do
        assertEquals( rset:get(i,j), idxC(i,j,lj) )
      end end
    end end
  end
end

function TestCMatrixErr:testGetvec()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'complex"       ,
    "invalid range member '1'"               ,
  }
  assertErrorMsgContains( msg[1], errCMat.getvec, errCMat, nil             )
  assertErrorMsgContains( msg[1], errCMat.getvec, errCMat, ''              )
  assertErrorMsgContains( msg[2], errCMat.getvec, errCMat, 1        , ''   )
  assertErrorMsgContains( msg[2], errCMat.getvec, errCMat, 1        , 1    )
  assertErrorMsgContains( msg[2], errCMat.getvec, errCMat, 1        , \x x )
  assertErrorMsgContains( msg[3], errCMat.getvec, errCMat, nan             )
  assertErrorMsgContains( msg[3], errCMat.getvec, errCMat, 0               )
  assertErrorMsgContains( msg[4], errCMat.getvec, errCMat, 1        , 1..2 )
  assertErrorMsgContains( msg[3], errCMat.getvec, errCMat, matrix(2)       )
end

function TestCMatrixGet:testGetvec()
  local cm = cmatrix(4):fill(1..16)
  assertEquals( cm:getvec(1   , {}       ), {1+0i}                )
  assertEquals( cm:getvec(1   , vector(2)), cvector{1+0i,0+0i}    )
  assertEquals( cm:getvec(1..2           ), cvector(2):fill(1..2):map\x x+0i )
  assertEquals( cm:getvec({1,2}          ), cvector(2):fill(1..2):map\x x+0i )

  for _,cm in ipairs(G.cmatidx) do
    local cmn, nr, nc = #cm, cm:sizes()
    for j=1,cmn do assertEquals( cm:getvec(j), cvector{j}:map(toC) ) end
    for li=1,nr do
      local vi = G.vi[li]:copy()
      vi:random(nil,1,cmn):shuffle()
      assertEquals( cm:getvec(vi), vi:map(toC) )
    end
  end
  cm:getvec(1..5) assertEquals( cm, cmatrix(4):fill(1..16) ) -- same output - to documentation
end

function TestCMatrixSet:testRemvec()
  local cm = cmatrix(6):fill(1..36) + 1i
  for n = 1, 25 do --Check single element by element removal
    assertEquals( cm:remvec(1), matrix(36-n, 1):fill((n+1)..36) + 1i) --Now reshaped as column vector
  end
  local cm = cmatrix(6):fill(1..36) + 1i
  for n = 1, 25 do --Check multi-element removal
    assertEquals( cm:copy():remvec(1..n), matrix(36-n, 1):fill((n+1)..36) + 1i) --Always outputs 1D
    assertEquals( #cm:copy():remvec(1..n), #cm - #(1..n) )
  end
end

function TestCMatrixErr:testSetvec()
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
    "index out of bounds"                              ,
  }
  assertErrorMsgContains( msg[1], errCMat.setvec, errCMat, nil , 0    )
  assertErrorMsgContains( msg[1], errCMat.setvec, errCMat, ''  , 0    )
  assertErrorMsgContains( msg[1], errCMat.setvec, errCMat, \x x, 0    )
  assertErrorMsgContains( msg[2], errCMat.setvec, errCMat, 1   , ''   )
  assertErrorMsgContains( msg[2], errCMat.setvec, errCMat, 1   , nil  )
  assertErrorMsgContains( msg[2], errCMat.setvec, errCMat, 1   , \x x )
  assertErrorMsgContains( msg[3], errCMat.setvec, errCMat, nan , 0    )
end

function TestCMatrixSet:testSetvec()
  local cm = G.cmattmp[25]
  cm:setvec(1..5, 1          ) assertEquals( cm:getvec(1..5 ), cm:same(5 ,1):fill(1   ) )
                               assertEquals( cm:getvec(6..25), cm:same(20,1)            )
  cm:setvec(1..5, 1..5       ) assertEquals( cm:getvec(1..5 ), cm:same(5 ,1):fill(1..5) )
                               assertEquals( cm:getvec(6..25), cm:same(20,1)            )
  cm:setvec(1..5, {0,0,0,0,0}) assertEquals( cm            , cm:same(5   )            )
-- recycling
  cm:setvec(1..6, 1..3       ) assertEquals( cm:getvec(1..3 ), cm:same(3 ,1):fill(1..3) )
                               assertEquals( cm:getvec(4..6 ), cm:same(3 ,1):fill(1..3) )
  cm:setvec(1..6, 1..7       ) assertEquals( cm:getvec(1..6 ), cm:same(6 ,1):fill(1..6) )
                               assertEquals( cm:getvec(7    ), cm:same(1 ,1)            )
  local f = \p, s => return s + p, 1i end
  cm:setvec(1..#cm, f, 1, 1)    assertEquals(cm, cm:same():fill(1i))
  f = \p, s => return s + p, s end
  cm:setvec(1..#cm, f, 2i, 2i)    assertEquals(cm, cm:same():seq()*2i)
  cm:fill(0)
  cm:setvec(4..15, f, 3, 2)    assertEquals( cm:getvec(4..15 ), cm:same(12 ,1):fill(2..35..3) )
                              assertEquals( cm:getvec(16..25), cm:same(10 ,1):fill(0)        )
  cm:zeros()

  for _,c in ipairs(G.cmattmp) do
    local nr, nc = cm:sizes()
    for j=1,#cm do
      cm:setvec(j,j)
      assertEquals( cm:getvec(j), cvector{j} )
    end
    for li=1,nr do
      local vi = G.vi[li]
      vi:shuffle()
      local cmt = cm:getvec(vi)
      cm:setvec(vi, 1..li)
      assertEquals( cm:getvec(vi), vi:same(li):fill(1..li) )
      cm:setvec(vi, duplicate(li*1i) )
      assertEquals( cm:getvec(vi), vi:same(li):fill(li):map(\x x*1i) )
      cm:setvec(vi, cmt   )
    end
  end
end

function TestCMatrixErr:testGetdiag()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid range member '1'"               ,
  }
  assertErrorMsgContains( msg[1], errCMat.getdiag, errCMat, ''   )
  assertErrorMsgContains( msg[1], errCMat.getdiag, errCMat, \x x )
  assertErrorMsgContains( msg[1], errCMat.getdiag, errCMat, 1    )
  assertErrorMsgContains( msg[2], errCMat.getdiag, errCMat, 1..2 )
end

function TestCMatrixGet:testGetdiag()
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    local n , d  = min(nr,nc), cm:getdiag()
    assertEquals( {d:sizes()}, {n,1} )
    for i=1,n do assertEquals( d[i], cm:get(i,i) ) end
  end
end

function TestCMatrixErr:testSetdiag()
  local msg = {
    "invalid argument #2 (scalar or iterable expected)",
  }
  assertErrorMsgContains( msg[1], errCMat.setdiag, errCMat, nil  )
  assertErrorMsgContains( msg[1], errCMat.setdiag, errCMat, ''   )
  assertErrorMsgContains( msg[1], errCMat.setdiag, errCMat, \x x )
end

function TestCMatrixSet:testSetdiag()
  for _,cm in ipairs(G.cmattmp) do
    local nr, nc = cm:sizes()
    local n = min(nr,nc)
    for i=1,n do
      local ra = cm:same(i,1):fill(1..i):map(toC)
      cm:setdiag(ra)
      local d = cm:getdiag()
      assertEquals( {cm:getdiag():sizes()}, {n,1} )
      for i=1,n do assertEquals( d[i], cm:get(i,i) ) end
      cm:setdiag(2)
      assertEquals( cm:getdiag(), cvector(n):fill(2) )
     end
  end
  local cm = G.cmattmp[25]
  cm:setdiag(1..3) assertEquals( cm:getdiag(), cvector{1,2,3,1,2} )
  cm:setdiag(1..6) assertEquals( cm:getdiag(), cvector{1,2,3,4,5} )
  local f = \p, s => return s + p, 2i end
  cm:setdiag(f, 0, 1, 1)    assertEquals(cm, cm:same():setdiag(2i)) --k required!
  f = \p, s => return s + p, s end
  cm:zeros():setdiag(f, 1, 2i, 2i)    assertEquals(cm, cm:same():setdiag(vector(5):seq()*2i, 1))
end

function TestCMatrixErr:testGetrow()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'complex'"       ,
    "invalid range member '1'"               ,
    "index out of bounds"                    ,
  }
  assertErrorMsgContains( msg[1], mth, 'getrow', errCMat, ''               )
  assertErrorMsgContains( msg[1], mth, 'getrow', errCMat, nil              )
  assertErrorMsgContains( msg[1], mth, 'getrow', errCMat, \x x             )
  assertErrorMsgContains( msg[2], mth, 'getrow', errCMat, 1   , ''         )
  assertErrorMsgContains( msg[2], mth, 'getrow', errCMat, 1   , 1          )
  assertErrorMsgContains( msg[3], mth, 'getrow', errCMat, nan              )
  assertErrorMsgContains( msg[3], mth, 'getrow', errCMat, 0                )
  assertErrorMsgContains( msg[3], mth, 'getrow', errCMat, 5                )
  assertErrorMsgContains( msg[4], mth, 'getrow', errCMat, 1   , 1..2       )
  assertErrorMsgContains( msg[5], mth, 'getrow', errCMat, 1   , cvector(1) )
end

function TestCMatrixGet:testGetrow()
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    for i=1,nr do
    for a=1,i  do
      for li=1,i-a+1 do
        local ra = a..i..li
        assertEquals( cm:getrow(ra), cm:getsub(ra, 1..nc) )
      end
    end end
  end
end

function TestCMatrixErr:testSetrow()
  local m = matrix(3)
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
    "index out of bounds"                              ,
    "cannot convert 'nil' to 'complex'"                ,
  }
  assertErrorMsgContains( msg[1], mth, 'setrow', errCMat, ''         )
  assertErrorMsgContains( msg[1], mth, 'setrow', errCMat, nil        )
  assertErrorMsgContains( msg[1], mth, 'setrow', errCMat, \x x       )
  assertErrorMsgContains( msg[2], mth, 'setrow', errCMat, nan        )
  assertErrorMsgContains( msg[2], mth, 'setrow', errCMat, 1   , nil  )
  assertErrorMsgContains( msg[2], mth, 'setrow', errCMat, 1   , ''   )
  assertErrorMsgContains( msg[3], mth, 'setrow', errCMat, 0   , 1    )
  assertErrorMsgContains( msg[3], mth, 'setrow', errCMat, 3   , 1    )
end

function TestCMatrixSet:testSetrow()
  local cm = G.cmattmp[25]
  cm:setrow(1, 1)           assertEquals( cm:getrow(1   ), cm:same(1,5):fill(1)    )
                            assertEquals( cm:getrow(2..5), cm:same(4,5)            )
  cm:setrow(1, 1..5)        assertEquals( cm:getrow(1   ), cm:same(1,5):fill(1..5) )
                            assertEquals( cm:getrow(2..5), cm:same(4,5)            )
  cm:setrow(1, {0,0,0,0,0}) assertEquals( cm:getrow(1..5), cm:same(5,5)            )
-- recycling
  cm:setrow(1, 1..3)        assertEquals( cm:getrow(1   ), cm:same(1,5):fill({1,2,3,1,2}) )
                            assertEquals( cm:getrow(2..5), cm:same(4,5)                   )
  cm:setrow(1, {0} )        assertEquals( cm:getrow(1..5), cm:same(5,5)                   )

  for _,cm in ipairs(G.cmattmp) do
    local nr, nc = cm:sizes()
    for i=1,nr do
    for a=1,i  do
      for li=1,i-a+1 do
        local ra = a..i..li
        local r = 1..nc*#ra
        cm:setrow(ra,r)
        for ii=1,#ra do
        for jj=1,nc  do
          assertEquals( cm:getrow(ra):get(ii,jj), idx(ii,jj,nc)+0i )
        end end
        cm:setrow(ra,duplicate(2i))
        for ii=1,#ra do
          assertEquals( cm:getrow(ra[ii]), cvector(nc):fill(2):map(\x x*1i):t(false) )
        end
        cm:setrow(ra,0)
      end
    end end
  end
end

function TestCMatrixErr:testGetcol()
  local msg = {
    "invalid argument #2 (iterable expected)",
    "invalid argument #3 (iterable expected)",
    "cannot convert 'nil' to 'complex'"      ,
    "invalid range member '1'"               ,
    "index out of bounds"                    ,
  }
  assertErrorMsgContains( msg[1], mth, 'getcol', errCMat, ''               )
  assertErrorMsgContains( msg[1], mth, 'getcol', errCMat, nil              )
  assertErrorMsgContains( msg[1], mth, 'getcol', errCMat, \x x             )
  assertErrorMsgContains( msg[2], mth, 'getcol', errCMat, 1   , ''         )
  assertErrorMsgContains( msg[2], mth, 'getcol', errCMat, 1   , 1          )
  assertErrorMsgContains( msg[3], mth, 'getcol', errCMat, nan              )
  assertErrorMsgContains( msg[3], mth, 'getcol', errCMat, 0                )
  assertErrorMsgContains( msg[3], mth, 'getcol', errCMat, 3                )
  assertErrorMsgContains( msg[4], mth, 'getcol', errCMat, 1   , 1..2       )
  assertErrorMsgContains( msg[5], mth, 'getcol', errCMat, 1   , cvector(1) )
end

function TestCMatrixGet:testGetcol()
  local cm = G.cmatidx[25]
  assertEquals( cm:getcol({1,2}          ), cm:getsub(1..5,{1,2}    ) )
  assertEquals( cm:getcol(vector{1,2}    ), cm:getsub(1..5,{1,2}    ) )
  assertEquals( cm:getcol(vector{1}  , {}), cm:getsub(1..5,{1}  , {}) )

  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    for j=1,nc do
    for b=1,j  do
      for lj = 1,j-b+1 do
        local rb = b..j..lj
        assertEquals( cm:getcol(rb) , cm:getsub(nil  ,rb) )
        assertEquals( cm:getcol(rb) , cm:getsub(1..nr,rb) )
      end
    end end
  end
  local cm = cmatrix(4):fill(1..16):fill(toC):transpose(false) --Get columns of 1-4, 5-8, 9-12, 13-16
  for i = 1,4 do 
    assertEquals(cm:getcol({i}), cvector(4):fill(4*(i-1)+1..4*i):fill(toC) )
  end
  for i = 1,3 do 
    local expected = cmatrix(4, 2)
    expected:setvec({1, 3, 5, 7}, cvector(4):fill(4*(i-1)+1..4*i):fill(toC))
    expected:setvec({2, 4, 6, 8}, cvector(4):fill(4*i+1..4*(i+1)):fill(toC))
    assertEquals(cm:getcol({i, i+1}), expected )
  end
end

function TestCMatrixErr:testSetcol()
  local msg = {
    "invalid argument #2 (iterable expected)"          ,
    "invalid argument #3 (scalar or iterable expected)",
    "index out of bounds"                              ,
    "cannot convert 'nil' to 'double'"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'setcol', errCMat, ''         )
  assertErrorMsgContains( msg[1], mth, 'setcol', errCMat, nil        )
  assertErrorMsgContains( msg[1], mth, 'setcol', errCMat, \x x       )
  assertErrorMsgContains( msg[2], mth, 'setcol', errCMat, nan        )
  assertErrorMsgContains( msg[2], mth, 'setcol', errCMat, 1   ,  ''  )
  assertErrorMsgContains( msg[2], mth, 'setcol', errCMat, 1   ,  nil )
  assertErrorMsgContains( msg[3], mth, 'setcol', errCMat, 0   ,  1   )
  assertErrorMsgContains( msg[3], mth, 'setcol', errCMat, 3   ,  1   )
end

function TestCMatrixSet:testSetcol()
  local cm = G.cmattmp[25]
  cm:setcol(1, 1)           assertEquals( cm:getcol(1   ), cm:same(5,1):fill(1   )        )
                            assertEquals( cm:getcol(2..5), cm:same(5,4)                   )
  cm:setcol(1, 1..5)        assertEquals( cm:getcol(1   ), cm:same(5,1):fill(1..5)        )
                            assertEquals( cm:getcol(2..5), cm:same(5,4)                   )
  cm:setcol(1, {0,0,0,0,0}) assertEquals( cm:getcol(1..5), cm:same(5,5)                   )
-- recycling
  cm:setcol(1, 1..3)        assertEquals( cm:getcol(1   ), cm:same(5,1):fill({1,2,3,1,2}) )
                            assertEquals( cm:getcol(2..5), cm:same(5,4)                   )
  cm:setcol(1, {0} )        assertEquals( cm:getcol(1..5), cm:same(5,5)                   )
  local f = \a,s => return s+1, a*s end
  for i = 1, 5 do  --Check setsub identity
    assertEquals(cm:copy():setcol(1..i, 2..i*2..2) , cm:copy():setsub(nil, 1..i, 2..i*2..2) )
    assertEquals(cm:copy():setcol(1..i, f, 12.2, 4), cm:copy():setsub(nil, 1..i, f, 12.2, 4))
  end
  for _,cm in ipairs(G.cmattmp) do
    local nr, nc = cm:sizes()
    for j=1,nc do
    for b=1,j  do
      for lj = 1,j-b+1 do
        local rb = b..j..lj
        local r = 1..nr*#rb
        cm:setcol(rb,r)
        for ii=1,nr  do
        for jj=1,#rb do
          assertEquals( cm:getcol(rb):get(ii,jj), idx(jj,ii,nr)+0i )
        end end
        cm:setcol(rb,duplicate(2i))
        for ii=1,#rb do
          assertEquals( cm:getcol(rb[ii]), vector(nr):fill(2):map(\x x*1i) )
        end
        cm:setcol(rb,0)
      end
    end end
  end
end

function TestCMatrixInPlaceII:testInsvec()
  local cm = cmatrix(6):fill(1)
  for n = 1, 36 do --Check single element by element addition
    local expected = cmatrix(6,6):fill(1)
    for i = n, 1, -1 do
      expected[i] = n-i+1
    end
    assertEquals( cm:insvec(1, n), expected)
  end
  local cm = cmatrix(6):fill(1)
  for n = 1, 25 do --Check multi-element insertion
    local expected = cmatrix(6,6):fill(1)
    for i = n, 1, -1 do
      expected[i] = i
    end
    assertEquals( cm:copy():insvec(1..n, 1..n), expected)
  end
end

function TestCMatrixInPlaceII:testInssub()
  for _,cm in ipairs(G.cmatidx) do
    local nrow, ncol = cm:sizes()
    for startSub = 1, nrow - 1 do 
      for i = startSub, nrow - 1 do 
        for j = startSub, ncol - 1 do
          local adjMat = cm:copy():inssub(startSub..i, startSub..j, 1..((i - startSub + 1)*(j - startSub + 1)))
          local shiftedVal = 1
          for row = 1, adjMat.nrow do
            for col = 1, adjMat.ncol do 
              if row >= startSub and col >= startSub and row <= i and col <= j then --Bit that has been inserted
                assertEquals(adjMat:real():get(row, col), cmatrix(i-startSub + 1, j-startSub + 1):getidx(row-startSub + 1, col-startSub + 1, j)) --cmatrix(..) bit finds which index that was input
              else --shifted values
                assertEquals(adjMat:real():get(row, col), shiftedVal)
                shiftedVal = shiftedVal + 1 --Shifts rows across first, so sort of unpredictable based on index
              end
            end
          end
        end
      end
    end
  end
end

function TestCMatrixInPlaceII:testInsrow()
  for _,cm in ipairs(G.cmatidx) do
    for i = 1, cm.nrow do 
      assertEquals(cm:copy():insrow(1..i, i), cm:copy():inssub(1..i, nil, i))
      assertEquals(cm:copy():insrow(1..i, 1..i*cm.ncol):getrow(1..i), cmatrix(i, cm.ncol):fill(1..i*cm.ncol)) --check for rowwise fill
      assertEquals(cm:zeros():insrow(1..i, 1..i*cm.ncol), cm:zeros():inssub(1..i, nil, 1..i*cm.ncol))
    end
  end
end

function TestCMatrixInPlaceII:testInscol() --Fails, when inserting 4 elements to a 2x2 cmatrix (insvec cannot handle ij of [1 3 2 4])
  for _,cm in ipairs(G.cmatidx) do
    for i = 1, cm.ncol do 
      assertEquals(cm:copy():inscol(1..i, i), cm:copy():inssub(nil, 1..i, i))
      assertEquals(cm:copy():inscol(1..i, 1..i*cm.nrow):getcol(1..i), cmatrix(i, cm.nrow):fill(1..i*cm.nrow):t()) --check for columnwise fill
      assertEquals(cm:copy():zeros():inscol(1..i, 1..i*cm.nrow), cm:copy():zeros():inssub(nil, 1..i, 1..i*cm.nrow))
    end
  end
end

function TestCMatrixInPlaceII:testSwpvec() 
  for _,cm in ipairs(G.cmatidx) do
    for i = 1, math.floor(#cm/2) do
      local swpedM = cm:copy():swpvec(1..i, i+1..2*i)
      assertEquals(totable(swpedM:copy():swpvec(i+1..2*i, 1..i)), totable(cm)) --Check for identity
      for idx = 1, #cm do
        if idx > 2*i then assertEquals(cm:geti(idx), swpedM:geti(idx))
        elseif idx <= i then assertEquals(cm:geti(idx), swpedM:geti(idx + i))
        elseif idx >  i then assertEquals(cm:geti(idx), swpedM:geti(idx - i))
        end
      end
    end
  end
end

function TestCMatrixInPlaceII:testSwpsub() --Double check
  for _,cm in ipairs(G.cmatidx) do
    for i = 1, math.floor(cm.nrow/2) do
      for j = 1, math.floor(cm.ncol/2) do
        local swpedM = cm:copy():swpsub(1..i, 1..j, i+1..2*i, j+1..2*j)
        assertEquals(totable(swpedM:copy():swpsub(1..i, 1..j, i+1..2*i, j+1..2*j)), totable(cm)) --Check for identity
        local newRow, newCol
        for row = 1, cm.ncol do
          for col = 1, cm.nrow do
            if row > 2*i or col > 2*j or (row > i and col < j + 1) or (row < i + 1 and col > j) then newRow = row; newCol = col--The element has not been moved
            else
              if row <= i then newRow = row + i --Moved forwards
              else             newRow = row - i -- Moved backwards
              end
              if col <= j then newCol = col + j --Moved forwards
              else             newCol = col - j -- Moved backwards
              end
            end
            assertEquals(cm:get(row, col), swpedM:get(newRow, newCol))
          end
        end
      end
    end
  end
end
--Below may be excessive, written before swpsub tested
function TestCMatrixInPlaceII:testSwpcol() 
  for _,cm in ipairs(G.cmatidx) do
    local nrow, ncol = cm:sizes()
    local columns = linspace(1, ncol, ncol)
    if ncol > 1 then--and ncol < 3 then
      local swpMat = cm:copy()
      for col1 = 1, ncol - 1 do 
        for col2 = 2, ncol do
          local swpedM = cm:copy():swpcol(col1, col2)
          local swpedM2= cm:copy():swpcol(col2, col1)
          local doubleSwp = cm:copy():swpcol(col1, col2):swpcol(col1, col2)
          assertEquals(swpedM, swpedM2)
          assertEquals(doubleSwp, cm)
          for i = 1, nrow do
            for j = 1, ncol do 
              if j == col1  then
                assertEquals(cm:get(i, col2), swpedM:get(i, j))
              elseif j == col2 then 
                assertEquals(cm:get(i, col1), swpedM:get(i, j))
              else
                assertEquals(cm:get(i, j), swpedM:get(i, j))
              end
            end
          end
        end
      end
    end
  end
end

function TestCMatrixInPlaceII:testSwprow() 
  for _,cm in ipairs(G.cmatidx) do
    local nrow, ncol = cm:sizes()
    local rows = linspace(1, nrow, nrow)
    if nrow > 1 then--and ncol < 3 then
      local swpMat = cm:copy()
      for row1 = 1, nrow - 1 do 
        for row2 = 2, nrow do
          local swpedM = cm:copy():swprow(row1, row2)
          local swpedM2= cm:copy():swprow(row2, row1)
          local doubleSwp = cm:copy():swprow(row1, row2):swprow(row1, row2)
          assertEquals(swpedM, swpedM2)
          assertEquals(doubleSwp, cm)
          for i = 1, nrow do
            for j = 1, ncol do 
              if i == row1  then
                assertEquals(cm:get(row2, j), swpedM:get(i, j))
              elseif i == row2 then 
                assertEquals(cm:get(row1, j), swpedM:get(i, j))
              else
                assertEquals(cm:get(i, j), swpedM:get(i, j))
              end
            end
          end
        end
      end
    end
  end
end
-- size -----------------------------------------------------------------------o

function TestCMatrix:testNrow()
  for i,cm in ipairs(G.cmatidx) do
    assertEquals( cm.nrow, G.size[i][1] )
  end
end

function TestCMatrix:testNcol()
  for i,cm in ipairs(G.cmatidx) do
    assertEquals( cm.ncol, G.size[i][2] )
  end
end

function TestCMatrix:testSize()
  for i,cm in ipairs(G.cmatidx) do
    assertEquals( #cm, G.size[i][1]*G.size[i][2] )
    assertEquals( cm:size(), G.size[i][1]*G.size[i][2] )
  end
end

function TestCMatrix:testBytesize()
  local sizeof = require("ffi").sizeof --cache
  for i,cm in ipairs(G.cmatidx) do
    assertEquals( cm:bytesize(), #cm*sizeof('cnum_t') )
  end
  assertEquals(sizeof('cnum_t'), 16) --An assert to check if double size is 64 bit (necessary?)
end

function TestCMatrix:testSizes()
  for i = 1, 20 do 
    for j = 1, 20 do 
      assertEquals({cmatrix(i, j):sizes()}, {i, j})
    end 
  end
  for i,cm in ipairs(G.cmatidx) do
    assertEquals( {cm:sizes()}, G.size[i] )
  end
end

function TestCMatrix:testTsizes()
  for i = 1, 20 do 
    for j = 1, 20 do 
      assertEquals({cmatrix(i, j):tsizes()}, {j, i})
    end 
  end
  for i,cm in ipairs(G.cmatidx) do
    assertEquals( {cm:tsizes()}, {G.size[i][2], G.size[i][1]} )
    assertEquals( {cm:tsizes()}, {MAD.gfunc.swap(cm:sizes())}           )
  end
end

-- Properties -----------------------------------------------------------------o
function TestCMatrix:testIs_Const()
  for i,cm in ipairs(G.cmatidx) do
    local rNum = random(-1,1)
    local cmat = cm:copy()
    cmat:fill(i + i*1i)      assertTrue(cmat:is_const())
    cmat:fill(rNum)   assertTrue(cmat:is_const())
    cmat:zeros()      assertTrue(cmat:is_const())
    if #cmat > 1 then
      cmat[1] = eps     assertFalse(cmat:is_const())
      assertTrue(cmat:is_const(eps))
    end
  end
end

function TestCMatrix:testIs_Real() 
  for i,cm in ipairs(G.cmatidx) do
    local cmat = cm:real():copy()
    assertTrue(cmat:is_real())
    if #cmat > 1 then
      local cm = cmatrix(cmat:sizes())
      assertTrue(cm:is_real())
      cm[1] = cm[1] + eps*1i
      assertFalse(cm:is_real())
      assertTrue (cm:is_real(eps))
    end
  end
end

function TestCMatrix:testIs_Imag() 
  for i,cm in ipairs(G.cmatidx) do
    local cmat = cm:real():copy() * 1i
    assertTrue(cmat:is_imag())
    if #cmat > 1 then
      local cm = cmatrix(cmat:sizes())
      assertTrue(cm:is_imag())
      cm[1] = cm[1] + eps
      assertFalse(cm:is_imag(   ))
      assertTrue (cm:is_imag(eps))
    end
  end
end

function TestCMatrix:testIs_Diag()
  for i,cm in ipairs(G.cmatidx) do
    local cmat = cm:copy()
    local diag_mat = cmat:zeros() + i * cmat:eye()
    assertTrue(diag_mat:is_diag())
    cmat:zeros()      assertTrue(cmat:is_diag())
    if cmat.ncol > 1 then
      diag_mat[2] = diag_mat[2] + eps
      assertFalse(diag_mat:is_diag())
      assertTrue (diag_mat:is_diag(eps))
    end
  end
end

function TestCMatrix:testIs_Symm()
  for _, cm in ipairs(G.cmatsym) do 
    assertTrue(cm:is_symm(false))   --Not hermitian
    assertTrue(cm:real():is_symm()) --Real matrix is hermitian
    assertFalse(cm:is_symm())       --complex matrix is not hermitian
    local cmat = cm:copy()
    if cmat.nrow > 1 and cmat.ncol > 1 then
      cmat[2] = cmat[2] + 0.000001
      assertFalse(cmat:is_symm())
      assertTrue (cmat:is_symm(0.000001+eps, nil, false))
    end
  end
  for _, cm in ipairs(G.cmatidx) do
    if #cm > 1 and cm.nrow == cm.ncol then 
      local antiSymmMat = cm - cm:copy():t()
      assertTrue(antiSymmMat:is_symm(true))
      assertTrue(antiSymmMat:is_symm(true, true)) --skew hermitian
      assertTrue(antiSymmMat:real():is_symm(true, false))--real part is skew symmetric
      assertFalse(antiSymmMat:is_symm())          --skew not symmetric
      assertFalse(antiSymmMat:is_symm(true, false))  --Skew hermitian is not skew symmetric
    end
  end
end

function TestCMatrix:testIs_Symp()
  for _, cm in ipairs(G.cmatsymp) do 
    assertTrue(cm:same():symp():is_symp())
    assertTrue(cm:is_symp(100*eps))
  end
end

-- in place -------------------------------------------------------------------o

function TestCMatrixInPlace:setUp()
  for _,cm in ipairs(G.cmatidx) do cm:fill(1..#cm):map( toC, 'in') end
end

function TestCMatrixInPlace:tearDown()
  for _,cm in ipairs(G.cmatidx) do cm:fill(1..#cm):map( toC, 'in') end
end

function TestCMatrixErr:testRandom()
  local msg, s = {
    "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)",
    "invalid argument #1 (non-empty table expected)"                           ,
  }
  assertErrorMsgContains( msg[1], mth, 'same', errCMat, 1, ''   )
  assertErrorMsgContains( msg[1], mth, 'same', errCMat, 1, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'same', errCMat, 1, nan  )
  assertErrorMsgContains( msg[2], mth, 'same', errCMat, 1, {}   )
end

function TestCMatrixInPlace:testRandom()
  local oldVal, val = {}, {}
  for _,cm in ipairs(G.cmatidx) do
    local mn = #cm
    local oldVal, val = table.new(mn,0), table.new(mn,0)
    cm:random()
    oldVal[0] = complex(1,1)
    for i = 1,mn do
      val[i] = cm:geti(i)
      assertTrue ( val[i]:imag() <  1                  )
      assertTrue ( val[i]:real() <  1                  )
      assertTrue ( val[i]:imag() >= 0                  )
      assertTrue ( val[i]:real() >= 0                  )
      assertTrue ( val[i]:imag() ~= val[i]:real()      )
      assertFalse( val[i]:imag() == oldVal[i-1]:imag() )
      assertFalse( val[i]:real() == oldVal[i-1]:real() )
      oldVal[i] = val[i]
    end
    cm:random(nil,1,mn)
    for i = 1,mn do
      assertTrue ( cm:geti(i):imag() <= mn )
      assertTrue ( cm:geti(i):real() <= mn )
      assertTrue ( cm:geti(i):imag() >= 1  )
      assertTrue ( cm:geti(i):real() >= 1  )
    end
  end
end

function TestCMatrixInPlaceII:testShuffle()
  local oldCV = {}
  local cv = cvector(25):fill(1..25):map(toC)
  oldCV[0] = 0
  for i=1,10 do
    cv = cv:shuffle()
    for is=1,#cv do
      assertTrue( cv:geti(is):imag() <= 25 )
      assertTrue( cv:geti(is):real() <= 25 )
      assertTrue( cv:geti(is):imag() >= 1  )
      assertTrue( cv:geti(is):real() >= 1  )
    end
    assertFalse( cv == oldCV[i-1] )
    oldCV[i] = cv:copy()
  end
end

function TestCMatrixErr:testFill()
  local msg = {
    "invalid argument #2 (scalar, callable or iterable expected)",
    "incompatible container size"                                ,
    "invalid container (iterable expected)"                      ,
  }
  assertErrorMsgContains( msg[1], mth,'fill', errCMat, nil  )
  assertErrorMsgContains( msg[1], mth,'fill', errCMat, true )
  assertErrorMsgContains( msg[1], mth,'fill', errCMat, ''   )
  assertErrorMsgContains( msg[2], mth,'fill', errCMat, {}   )
end

function TestCMatrixInPlace:testFill()
  for _,cm in ipairs(G.cmatidx) do
    local mn = #cm
    --scalar
    cm:fill(nan   )                  for j=1,mn do assertNaN   ( cm:geti(j):real()      )
                                                   assertEquals( cm:geti(j):imag(), 0   ) end
    cm:fill(nan*1i)                  for j=1,mn do assertNaN   ( cm:geti(j):real()      )
                                                   assertNaN   ( cm:geti(j):imag()      ) end
    cm:fill(inf)                     for j=1,mn do assertEquals( cm:geti(j), inf + 0i   ) end
    cm:fill(1  )                     for j=1,mn do assertEquals( cm:geti(j), 1   + 0i   ) end
    cm:fill(2i )                     for j=1,mn do assertEquals( cm:geti(j), 0   + 2i   ) end
    cm:fill(complex(1,1))            for j=1,mn do assertEquals( cm:geti(j), 1   + 1i   ) end
    --generator
    cm:fill(1..mn)                   for j=1,mn do assertEquals( cm:geti(j), j   + 0i   ) end
    cm:fill(1..mn):fill\x  x*1i      for j=1,mn do assertEquals( cm:geti(j), 0   + 1i*j ) end
    cm:fill(1..mn):fill\x (x^2)      for j=1,mn do assertEquals( cm:geti(j), j^2 + 0i   ) end
    cm:fill(1..mn):fill\x ((x*1i)^2) for j=1,mn do assertEquals( cm:geti(j),-j^2 + 0i   ) end
    --2D container
    cm:fill( cm:same() )             for j=1,mn do assertEquals( cm:geti(j), 0   + 0i   ) end
    --1D container
    local t={} for i=1,mn do t[i]=i end
    cm:fill(t)                       for j=1,mn do assertEquals( cm:geti(j), j   + 0i   ) end
    cm:fill(vector(mn))              for j=1,mn do assertEquals( cm:geti(j), 0   + 0i   ) end
    cm:fill(duplicate(2i))           for j=1,mn do assertEquals( cm:geti(j),       2i   ) end
  end
  local m, t = cmatrix(5), {}
  for i=1,5 do t[i] = {}      for j=1,5 do t[i][j]=(i-1)*5+j+1.25i end end
  m:fill(t)                  for i=1,#m do assertEquals( m:geti(i), i + 1.25i ) end
end

function TestCMatrixErr:testCopy()
  local msg = {
    "invalid argument #2 (cmatrix expected)",
  }
  assertErrorMsgContains( msg[1], mth,'copy', errCMat, 1         )
  assertErrorMsgContains( msg[1], mth,'copy', errCMat, matrix(2) )
end

function TestCMatrixInPlaceII:testCopy()
  for i,cm in ipairs(G.cmatidx) do
    local cmcopy = cmatrix( cm:sizes() )
    cm:copy(cmcopy)
    assertEquals( cm       , cmcopy )
    assertEquals( cm:copy(), cm     )
    local copiedM = cm:copy()
    copiedM = copiedM + 1
    assertNotEquals(cm, copiedM) --Check actually a copy, not a reference
  end
end

function TestCMatrixInPlaceII:testRemsub() --Need to test for ir or jc = nil
  for _,cm in ipairs(G.cmatidx) do
    local nrow, ncol = cm:sizes()
    for startRem = 1, nrow - 1 do 
      for i = startRem, nrow - 1 do 
      for j = startRem, ncol - 1 do
        local smallMat = cm:copy():remsub(startRem..i, startRem..j)
          assertEquals(nrow - (i - startRem + 1), smallMat.nrow)
          assertEquals(ncol - (j - startRem + 1), smallMat.ncol)
          for row = 1, smallMat.nrow do
            for col = 1, smallMat.ncol do 
              local rowIncrease, colIncrease = 0, 0
              if row >= startRem and col >= startRem then 
                rowIncrease, colIncrease = i - startRem + 1, j - startRem + 1
              elseif row >= startRem then 
                rowIncrease = i - startRem + 1
              elseif col >= startRem then 
                colIncrease = j - startRem + 1
              end
              assertEquals(cm:get(row + rowIncrease, col + colIncrease ), smallMat:get(row, col))
            end
          end
        end
      end
    end
  end
end

function TestCMatrixInPlaceII:testRemcol()
  for _,cm in ipairs(G.cmatidx) do
    local nrow, ncol = cm:sizes()
    if ncol > 1 then
      local smallMat = cm:copy():remcol(1)
      assertEquals(ncol, smallMat.ncol + 1)
      local smallMat2 = cm:copy():remcol(ncol)
      for i = 1, nrow do
        for j = 1, ncol - 1 do 
          assertEquals(cm:get(i, j+1), smallMat:get(i, j)) 
          assertEquals(cm:get(i, j  ), smallMat2:get(i, j))
        end
      end
    end
  end
end

function TestCMatrixInPlaceII:testRemrow()
  for _,cm in ipairs(G.cmatidx) do
    local nrow, ncol = cm:sizes()
    if nrow > 1 then
      local smallMat = cm:copy():remrow(1)
      assertEquals(nrow, smallMat.nrow + 1)
      local smallMat2 = cm:copy():remrow(nrow)
      for i = 1, nrow - 1 do
        for j = 1, ncol do 
          assertEquals(cm:get(i+1,j), smallMat:get(i, j))
          assertEquals(cm:get(i  ,j), smallMat2:get(i, j))
        end
      end
    end
  end
end

function TestCMatrixInPlace:testZeros()
  for _,cm in ipairs(G.cmatidx) do
    cm:zeros()
    assertEquals( cm, cm:same() )
  end
end

function TestCMatrixInPlace:testOnes()
  for _,cm in ipairs(G.cmatidx) do
    cm:ones(    ) assertEquals( cm, cm:same():fill(1   ) )
    cm:ones(2   ) assertEquals( cm, cm:same():fill(2   ) )
    cm:ones(  1i) assertEquals( cm, cm:same():fill(  1i) )
    cm:ones(1+1i) assertEquals( cm, cm:same():fill(1+1i) )
  end
end

function TestCMatrixInPlace:testSeq()
  for i,cm in pairs(G.cmatidx) do --Assumes G.matidx is a sequence
    assertEquals(cm:same():seq(0) + cm:same():seq() * 1i, cm)      --cm starts from 1, seq starts from 0 --?
    assertEquals(cm:same():seq("col"), matrix(cm.ncol, cm.nrow):seq():t()) --check for columnwise fill
    assertEquals(cm:same():seq(1) + cm:same():seq() * 1i, cm + 1)  --cm starts from 1, seq starts from 1 --?
    assertEquals(cm:same():seq(2) + cm:same():seq() * 1i, cm + 2)  --cm starts from 1, seq starts from 2 --?
    assertEquals(cm:same():seq(3) + cm:same():seq() * 1i, cm + 3)  --cm starts from 1, seq starts from 3 --?
    assertEquals(cm:same():seq(3, "col"), matrix(cm.ncol, cm.nrow):seq():t() + 3) --check for columnwise fill
    local testCase = cm:same():seq()
    for i, e in ipairs(testCase) do --Checks all elements are 1 greater than previous
      if i > 1 then assertEquals(testCase[i] - testCase[i-1], 1 + 0i) end
    end

  end
end

function TestCMatrixInPlace:testEye()
  for i,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    local min = min(nr,nc)
    cm:eye()
    assertEquals( cm:getdiag(), cm:same(min,1):fill(1) )
    for i=1,nr do
    for j=1,nc do
      if i~=j then assertEquals( cm:get(i,j), 0+0i ) end
    end end
    cm:eye(2 ) assertEquals( cm:getdiag(), cm:same(min,1):fill(2 ) )
    cm:eye(1i) assertEquals( cm:getdiag(), cm:same(min,1):fill(1i) )
  end
end

function TestCMatrixErr:testSymp()
  local msg = {
    "invalid argument #1 (2n matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth,'symp',  cmatrix(3)   )
  assertErrorMsgContains( msg[1], mth,'symp',  cvector(2)   )
  assertErrorMsgContains( msg[1], mth,'symp',  cmatrix(4,3) )
end

function TestCMatrixInPlaceII:testSymp()
  for i=2,6,2 do
    local cm = cmatrix(i):symp()
    assertTrue( cm:t() == -cm )
    for ii=1,cm.ncol do
    for jj=1,cm.nrow do
      if     ii==2 and jj==1 then assertEquals( cm:get(ii,jj),-1 + 0i )
      elseif ii==4 and jj==3 then assertEquals( cm:get(ii,jj),-1 + 0i )
      elseif ii==6 and jj==5 then assertEquals( cm:get(ii,jj),-1 + 0i )
      elseif ii==1 and jj==2 then assertEquals( cm:get(ii,jj), 1 + 0i )
      elseif ii==3 and jj==4 then assertEquals( cm:get(ii,jj), 1 + 0i )
      elseif ii==5 and jj==6 then assertEquals( cm:get(ii,jj), 1 + 0i )
      else                        assertEquals( cm:get(ii,jj), 0 + 0i ) end
    end end
  end
end

function TestCMatrixErr:testCirc()
  local msg = {
    "invalid argument #2 (iterable expected)",
  }
  assertErrorMsgContains( msg[1], mth,'circ', errCMat, nil  )
  assertErrorMsgContains( msg[1], mth,'circ', errCMat, 1    )
  assertErrorMsgContains( msg[1], mth,'circ', errCMat, \x x )
end

function TestCMatrixInPlaceII:testCirc()
  for ii=1,5 do
    local cm = cmatrix(ii)
    local t = {} for j=1,ii do t[j]=j+j*1i end
    --'row'
    cm:circ(t)
    for j=1,ii   do assertEquals( cm:get(j  ,j  ), 1    +       1i ) end
    for j=1,ii-1 do assertEquals( cm:get(j+1,j  ), 2    +       2i )
                    assertEquals( cm:get(j  ,j+1), ii   + ii   *1i ) end
    for j=1,ii-2 do assertEquals( cm:get(j+2,j  ), 3    +       3i )
                    assertEquals( cm:get(j  ,j+2), ii-1 +(ii-1)*1i ) end
    for j=1,ii-3 do assertEquals( cm:get(j+3,j  ), 4    +       4i )
                    assertEquals( cm:get(j  ,j+3), ii-2 +(ii-2)*1i ) end
    cm:fill(0):circ(cvector(ii):fill(1..ii))
    for j=1,ii   do assertEquals( cm:get(j  ,j  ), 1    +       0i ) end
    for j=1,ii-1 do assertEquals( cm:get(j+1,j  ), 2    +       0i )
                    assertEquals( cm:get(j  ,j+1), ii   +       0i ) end
    for j=1,ii-2 do assertEquals( cm:get(j+2,j  ), 3    +       0i )
                    assertEquals( cm:get(j  ,j+2), ii-1 +       0i ) end
    for j=1,ii-3 do assertEquals( cm:get(j+3,j  ), 4    +       0i )
                    assertEquals( cm:get(j  ,j+3), ii-2 +       0i ) end
    --'col'
    cm:fill(0):circ(cmatrix(1,ii):fill(1..ii):map(toC))
    for j=1,ii   do assertEquals( cm:get(j  ,j  ), 1    +       1i ) end
    for j=1,ii-1 do assertEquals( cm:get(j+1,j  ), ii   + ii   *1i )
                    assertEquals( cm:get(j  ,j+1), 2    +       2i ) end
    for j=1,ii-2 do assertEquals( cm:get(j+2,j  ), ii-1 +(ii-1)*1i )
                    assertEquals( cm:get(j  ,j+2), 3    +       3i ) end
    for j=1,ii-3 do assertEquals( cm:get(j+3,j  ), ii-2 +(ii-2)*1i )
                    assertEquals( cm:get(j  ,j+3), 4    +       4i ) end
  end
end

function TestCMatrixInPlaceII:testMovev()
  for _, cm in ipairs(G.cmatidx) do 
    for i = 1, #cm do 
      for j = i, #cm do
        for k = 1, #cm - j + 1 do
          local moved_mat = cm:copy():movev(i, j, k)
          assertEquals(moved_mat:getvec(k..k+j-i), cm:getvec(i..j)) --Does what it says on the tin
          assertEquals(cm:movev(i, j, k, cmatrix(cm:sizes())):getvec(k..k+j-i), cm:getvec(i..j)) --Does what it says on the tin (with r)
          if k > 1 then assertEquals(moved_mat:getvec(1..k-1), cm:getvec(1..k-1)) end --Other values are unaffected
          if k + j - 1 < #cm then assertEquals(moved_mat:getvec(k+j-i+1..#cm), cm:getvec(k+j-i+1..#cm)) end ---Other values are unaffected
          if not (i == k and j == k+j-i) then --Not identity
            assertNotEquals(moved_mat, cm) --The matrix isn't the same
          end
        end
      end
    end
  end
end

function TestCMatrixErr:testShiftv()
  local msg = {
    "index out of bound",
  }
  local v = cvector(4)

  assertErrorMsgContains( msg[1], mth, 'shiftv', v,  0, 0 )
  assertErrorMsgContains( msg[1], mth, 'shiftv', v, -1, 0 )
  assertErrorMsgContains( msg[1], mth, 'shiftv', v,  5, 0 )
end

function TestCMatrixInPlaceII:testShiftv()
  for n=1,6 do
    for i=1,n do
      for j=0,n-i do
        -- left shift
        local v = cvector(n):fill(1..n)/2i
        local w = cvector(n):fill(1..n)/2i
        v:shiftv(i,-j)
        w:setvec(i..n-j, w:getvec(i+j..n) )
        assertAllAlmostEquals(totable(v:real()), totable(w:real()))
        assertAllAlmostEquals(totable(v:imag()), totable(w:imag()))
        -- right shift
        local v = cvector(n):fill(1..n)/2i
        local w = cvector(n):fill(1..n)/2i
        v:shiftv(i,+j)
        w:setvec(i+j..n, w:getvec(i..n-j) )
        assertAllAlmostEquals(totable(v:real()), totable(w:real()))
        assertAllAlmostEquals(totable(v:imag()), totable(w:imag()))
      end
    end
  end
end

function TestCMatrixInPlaceII:testRoll()
  local cm = cvector(4):fill(1..4)
  assertEquals( cm:roll( 0  , 0  ), cm )
  assertEquals( cm:roll( 4  , 0  ), cm )
  assertEquals( cm:roll( 0  , 1  ), cm )
  assertEquals( cm:roll( 0  , 2  ), cm )
  assertEquals( cm:roll( nil, 0  ), cm )
  assertEquals( cm:roll( 0  , nil), cm )
  assertEquals( cm:roll( nil, nil), cm )

  cm = cmatrix(2):fill(1..4)
  assertEquals( cm:roll( 0  , 0  ), cm )
  assertEquals( cm:roll( 3  , 0  ), cm )
  assertEquals( cm:roll(-3  , 0  ), cm )

  for nr=1,5 do
  for nc=1,5 do
    cm = cmatrix(nr,nc):fill(1..nr*nc):map(toC)
    for inc=0,nc do
    for inr=0,nr do
      cm:roll(inr,inc)
      for jnr=1,nr do
      for jnc=1,nc do
        if     jnc<=inc and jnr<=inr then assertEquals( cm:get(jnr,jnc), idxC(jnr+(nr-inr),jnc+(nc-inc),nc) )
        elseif jnc<=inc and jnr> inr then assertEquals( cm:get(jnr,jnc), idxC(jnr-inr     ,jnc+(nc-inc),nc) )
        elseif jnc> inc and jnr<=inr then assertEquals( cm:get(jnr,jnc), idxC(jnr+(nr-inr),jnc- inc    ,nc) )
        else                              assertEquals( cm:get(jnr,jnc), idxC(jnr-inr     ,jnc- inc    ,nc) ) end
      end end
      cm:roll(-inr,-inc)
    end end
  end end
end

function TestCMatrixErr:testReshape()
  local msg = {
    "invalid cmatrix new sizes",
  }
  assertErrorMsgContains( msg[1], mth,'reshape', errCMat, nil, 2 )
  assertErrorMsgContains( msg[1], mth,'reshape', errCMat, 0  , 1 )
  assertErrorMsgContains( msg[1], mth,'reshape', errCMat, 1  , 0 )
  assertErrorMsgContains( msg[1], mth,'reshape', errCMat, 3  , 2 )
  assertErrorMsgContains( msg[1], mth,'reshape', errCMat, 1  , 5 )
end

function TestCMatrixInPlaceII:testReshape()
  local cm
  cm = matrix(2,2) assertEquals( {cm:reshape() :sizes()}, {4,1} )
  cm = matrix(2,2) assertEquals( {cm:reshape(1):sizes()}, {1,1} )
  for nr=1,5 do
  for nc=1,5 do
    for i=1,nr do
    for j=1,nc do
      cm = matrix(nr,nc):fill(1..nr*nc)
      cm:reshape(i,j)
      assertEquals( {cm:sizes()}, {i,j}                     )
      assertEquals( cm          , cmatrix(i,j):fill(1..i*j) )
    end end
  end end
end

-- foreach, filter, map, fold, scan -------------------------------------------o

function TestCMatrixFun:setUp()
  for _,cm in ipairs(G.cmatidx) do cm:fill(1..#cm):map(\x x+x*1i,'in') end
end

function TestCMatrixFun:tearDown()
  for _,cm in ipairs(G.cmatidx) do cm:fill(1..#cm):map(\x x+x*1i,'in') end
end

function TestCMatrixErr:testForeach()
  local msg = {
    "invalid argument #2 (callable expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'foreach', errCMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'foreach', errCMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'foreach', errCMat, 1         )
  assertErrorMsgContains( msg[1], mth, 'foreach', errCMat, 1..2      )
  assertErrorMsgContains( msg[1], mth, 'foreach', errCMat, matrix(1) )
  assertErrorMsgContains( msg[1], mth, 'foreach', errCMat, { }       )
end

function TestCMatrixFun:testForeach() 
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    local t = {}
    local f = \x, ij => t[ij] = x  end
    cm:foreach(f)
    assertEquals(t, cm:totable())                          --Check function call

    cm:foreach("+", t)
    assertEquals(t, cm:add(cm:same():seq()):totable())                   --Check function call w/ r and f is opstring
    
    f = \x, ij -> x + 2*ij
    t = cmatrix(math.ceil(#cm/2), 1)
    cm:foreach(1..math.ceil(#cm/2), f, t)   
    assertEquals(#t, math.ceil(#cm/2))
    assertEquals(t, cm:add(cm:same():seq()*2):getvec(1..math.ceil(#cm/2)))  --Check function call w/ ij and r as mat

    f = \x, ij -> x * x
    cm:foreach(f, "in")                                    
    assertEquals(cm:copy():foreach(f, "in"), cm:epow(2))    --Check function call w/ r = "in"

    cm:foreach(1..#cm, "*", "in")                                    
    assertEquals(cm:copy():foreach(f, "in"), cm:epow(2))    --Check function call w/ r = "in" and ij and f is opstring
  end
end

function TestCMatrixErr:testMap()
  local msg = {
    "invalid argument #2 (callable expected)",
    "invalid argument #2 (scalar function expected)",
    "invalid argument #3 (iterable expected)",
    "invalid 'cpx + ?' operation",
    "invalid range member '1'",
    "attempt to compare 'complex' with 'number'",
    "attempt to compare 'complex' with 'complex'",
  }
  assertErrorMsgContains( msg[1], mth, 'map', errCMat, ''              )
  assertErrorMsgContains( msg[1], mth, 'map', errCMat, 1..2            )
  assertErrorMsgContains( msg[1], mth, 'map', errCMat, 1               )
  assertErrorMsgContains( msg[1], mth, 'map', errCMat, matrix(1)       )
  assertErrorMsgContains( msg[1], mth, 'map', errCMat, {}              )
  assertErrorMsgContains( msg[2], mth, 'map', errCMat, '!'             )
  assertErrorMsgContains( msg[4], mth, 'map', errCMat, '+'             )
  assertErrorMsgContains( msg[3], mth, 'map', errCMat, \x x+1   , ''   )
  assertErrorMsgContains( msg[3], mth, 'map', errCMat, \x x+1   , 1    )
  assertErrorMsgContains( msg[5], mth, 'map', errCMat, \x x+1   , 1..2 )
  assertErrorMsgContains( msg[6], mth, 'map', errCMat, \x x<2          )
  assertErrorMsgContains( msg[7], mth, 'map', errCMat, \x x<2+2i       )
end

function TestCMatrixFun:testMap()
  for i,cm in ipairs(G.cmatidx) do
    local mn, nr, nc = #cm, cm:sizes()
    assertEquals( cm:map('~'      ), cm:same():fill(-1..-mn..-1):fill(toC) )
    assertEquals( cm:map(\x x-x   ), cm:same()                             )
    --totable test
    assertEquals( cm:map(\x x-x,{}), rep(0+0i , mn) )
    assertEquals( cm:map('!'   ,{}), rep(false, mn) )
    --'in' place test
    cm:map('~'   , 'in') assertEquals( cm, cm:same():fill(-1..-mn..-1):fill(toC) )
    cm:map(\x x-x, 'in') assertEquals( cm, cm:same()                             )
    --ij test
    for j = 1, mn do 
      local r = {}
      cm:seq():add(cm:same():seq()*1i):map(j..mn, "+", r)
      cm:map(j..mn, '~' )        
      for ij = 1, mn do
        if ij < j then 
          assertEquals(cm[ij],  ij + 0i) 
          assertEquals(r [ij],  nil) 
        else 
          assertEquals(cm[ij], -ij + 0i) 
          assertEquals(r [ij], 2*ij + ij*1i) 
        end
      end
    end
  end
end

function TestCMatrixErr:testMap2()
  local cm = cmatrix(1)
  local msg = {
    "invalid argument #2 (scalar or iterable expected)",
    "invalid argument #3 (callable expected)",
    "invalid argument #3 (scalar function expected)",
    "invalid argument #4 (iterable expected)",
    "invalid range member '1'",
    "invalid 'cpx + ?' operation",
    "attempt to compare 'complex' with 'complex'",
  }
  assertErrorMsgContains( msg[1], mth, 'map2', errCMat, nil               )
  assertErrorMsgContains( msg[1], mth, 'map2', errCMat, ''                )
  assertErrorMsgContains( msg[1], mth, 'map2', errCMat, \x x              )
  assertErrorMsgContains( msg[2], mth, 'map2', errCMat, nan               )
  assertErrorMsgContains( msg[2], mth, 'map2', errCMat, cm   , nil        )
  assertErrorMsgContains( msg[2], mth, 'map2', errCMat, cm   , ''         )
  assertErrorMsgContains( msg[2], mth, 'map2', errCMat, cm   , 1..2       )
  assertErrorMsgContains( msg[2], mth, 'map2', errCMat, cm   , 1          )
  assertErrorMsgContains( msg[3], mth, 'map2', errCMat, cm   , '!'        )
  assertErrorMsgContains( msg[4], mth, 'map2', errCMat, cm   , \x x, 1    )
  assertErrorMsgContains( msg[5], mth, 'map2', errCMat, cm   , \x x, 1..2 )
  assertErrorMsgContains( msg[6], mth, 'map2', errCMat, cm   , \x,y  x+y  )
  assertErrorMsgContains( msg[7], mth, 'map2', errCMat, cm   , '<'        )
end

function TestCMatrixFun:testMap2()
  for _,cm in ipairs(G.cmatidx) do
    local mn, nr, nc = #cm, cm:sizes()
    local m = matrix(nr,nc):fill(1..mn)
    assertEquals( cm:map2(1 , '+'         ), cm:same():fill(1..mn):map(\x ((x+1)+x*1i)) )
    assertEquals( cm:map2(1 , \x,y x-y    ), cm:same():fill(1..mn):map(\x ((x-1)+x*1i)) )
    assertEquals( cm:map2(cm, '~'         ), cm:same():fill(1..mn):map(\x  -x-x*1i    ) )
    assertEquals( cm:map2(cm, '+'         ), cm:copy()            :map(\x  2*x        ) )
    assertEquals( cm:map2(cm, \x,y x-y    ), cm:same()                                  )
    assertEquals( cm:map2(cm, '-'     , {}), cm:same()            :map(\x  x      , {}) )  --totable test
    assertEquals( cm:map2(cm, '!'     , {}), rep(false, mn)                             )  --totable test

    local ir = { m, 1..mn, totable(1..mn) }
    for d=1,#ir do
      assertEquals( cm:map2(ir[d], '+'         ), cm:same():fill(1..mn):map(\x (x*2+x   *1i)    ) )
      assertEquals( cm:map2(ir[d], \x,y x-y    ), cm:copy()            :map(\x  x:imag()*1i     ) )
      assertEquals( cm:map2(ir[d], '-'     , {}), cm:same():fill(1..mn):map(\x  x       *1i, {} ) ) --totable test
    end
    --'in' place test
    for d=1,#ir do
      cm:map2(ir[d], '~'     , 'in') for j=1,mn do assertEquals( cm:geti(j), j*((-1)^d)*(1+1i) ) end
    end
      cm:map2(cm   , \x,y x-y, 'in') assertEquals( cm, cm:same() )
    for j = 1, mn do 
      local r = {}
      cm:seq():add(cm:same():seq()*1i):map2(4, j..mn, "+", r)
      cm:map2(j, j..mn, \x, y x-y*2 )        
      for ij = 1, mn do
        if ij < j then 
          assertEquals(cm[ij],  ij + 0i) 
          assertEquals(r [ij],  nil) 
        else 
          assertEquals(cm[ij], ij-j*2 + 0i ) 
          assertEquals(r [ij], ij+4 + ij*1i) 
        end
      end
    end
  end
end

function TestCMatrixErr:testMap3()
  local cm = cmatrix(1)
  local msg = {
    "invalid argument #2 (scalar or iterable expected)",
    "invalid argument #3 (scalar or iterable expected)",
    "invalid argument #4 (callable expected)",
    "invalid argument #4 (scalar function expected)",
    "invalid argument #5 (iterable expected)",
    "invalid range member '1'",
    "invalid 'cpx + ?' operation",
    "attempt to compare 'complex' with 'complex'",
  }
  assertErrorMsgContains( msg[1], mth, 'map3', errCMat, nil                            )
  assertErrorMsgContains( msg[1], mth, 'map3', errCMat, ''                             )
  assertErrorMsgContains( msg[1], mth, 'map3', errCMat, \x x                           )
  assertErrorMsgContains( msg[2], mth, 'map3', errCMat, nan                            )
  assertErrorMsgContains( msg[2], mth, 'map3', errCMat, errCMat, nil                   )
  assertErrorMsgContains( msg[2], mth, 'map3', errCMat, errCMat, ''                    )
  assertErrorMsgContains( msg[2], mth, 'map3', errCMat, errCMat, \x x                  )
  assertErrorMsgContains( msg[3], mth, 'map3', errCMat, errCMat, nan                   )
  assertErrorMsgContains( msg[3], mth, 'map3', errCMat, errCMat, errCMat, nil          )
  assertErrorMsgContains( msg[3], mth, 'map3', errCMat, errCMat, errCMat, 1..2         )
  assertErrorMsgContains( msg[3], mth, 'map3', errCMat, errCMat, errCMat, 1            )
  assertErrorMsgContains( msg[4], mth, 'map3', errCMat, cm     , cm     , '!'          )
  assertErrorMsgContains( msg[5], mth, 'map3', errCMat, errCMat, errCMat, \x x, 1      )
  assertErrorMsgContains( msg[6], mth, 'map3', errCMat, errCMat, errCMat, \x x, 1..2   )
  assertErrorMsgContains( msg[7], mth, 'map3', errCMat, cm     , errCMat, \x,y,z x+y+z )
  assertErrorMsgContains( msg[7], mth, 'map3', errCMat, cm     , cm     , \x,y,z x+y+z )
  assertErrorMsgContains( msg[7], mth, 'map3', errCMat, errCMat, cm     , \x,y,z x+y+z )
  assertErrorMsgContains( msg[8], mth, 'map3', errCMat, cm     , cm     ,  '<'         )
end

function TestCMatrixFun:testMap3()
  for _,cm1 in ipairs(G.cmatidx) do
    local mn, nr, nc = #cm1, cm1:sizes()
    local m = matrix(nr,nc):fill(1..mn)
    assertEquals( cm1:map3(cm1, cm1, \x,y,z -x       ), cm1:same():fill(-1.. -mn..-1):map(toC       ) )
    assertEquals( cm1:map3(cm1, cm1, \x,y,z x+y      ), cm1:same():fill( 2..2*mn.. 2):map(toC       ) )
    assertEquals( cm1:map3(cm1, cm1, \x,y,z x+y+z    ), cm1:copy()                   :map(\x 3*x    ) )
    assertEquals( cm1:map3(cm1, cm1, \x,y,z x+y+z, {}), cm1:copy()                   :map(\x 3*x, {}) ) -- totable test

    local cm2 = { m, 1..mn, totable(1..mn) }
    local cm3 = { m, 1..mn, totable(1..mn) }
    for i=1,#cm2 do
    for j=1,#cm3 do
      assertEquals( cm1:map3(cm2[i], cm3[j], \x,y,z x+y+z    ), cm1:same():fill(1..mn):map(\x x*3+x*1i)     )
      assertEquals( cm1:map3(cm2[i], cm3[j], \x,y,z x+y+z, {}), cm1:same():fill(1..mn):map(\x x*3+x*1i, {}) ) -- totable test
    end end
    --'in' place test
    cm1:map3(cm1, cm1, \x,y,z -x   , 'in') assertEquals( cm1, cm1:copy():fill(-1..  -mn..-1):map(toC) )
    cm1:map3(cm1, cm1, \x,y,z x+y+z, 'in') assertEquals( cm1, cm1:same():fill(-3..-3*mn..-3):map(toC) )
    --ij test
    for j = 1, mn do 
      local r = {}
      cm1:seq():add(cm1:same():seq()*1i):map3(4,-2, j..mn, \x,y,z x+y+z, r)
      cm1:map3(j, 3, j..mn, \x,y,z x-y*z )        
      for ij = 1, mn do
        if ij < j then 
          assertEquals(cm1[ij],  ij + 0i) 
          assertEquals(r  [ij],  nil) 
        else 
          assertEquals(cm1[ij], ij-j*3 + 0i) 
          assertEquals(r  [ij], ij+2 + ij * 1i) 
        end
      end
    end
  end
end

function TestCMatrixErr:testFoldl()
  local msg = {
    "invalid argument #2 (callable expected)",
    "invalid argument #5 (iterable expected)",
    "invalid argument #4 (string 'vec', 'diag', 'row' or 'col' expected)",
    "invalid range member '1'",
    "invalid 'cpx + ?' operation",
  }
  local m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'foldl', errCMat, nil                   )
  assertErrorMsgContains( msg[1], mth, 'foldl', errCMat, nan                   )
  assertErrorMsgContains( msg[1], mth, 'foldl', errCMat, ''                    )
  assertErrorMsgContains( msg[1], mth, 'foldl', errCMat, {}                    )
  assertErrorMsgContains( msg[1], mth, 'foldl', errCMat, 1                     )
  assertErrorMsgContains( msg[1], mth, 'foldl', errCMat, 1..2                  )
  assertErrorMsgContains( msg[1], mth, 'foldl', errCMat, m                     )
  assertErrorMsgContains( msg[1], mth, 'foldl', errCMat, cm                    )
  assertErrorMsgContains( msg[3], mth, 'foldl', errCMat, \x x, ''              )
  assertErrorMsgContains( msg[3], mth, 'foldl', errCMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', errCMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldl', errCMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'foldl', errCMat, \x x, 1 , 'vec', ''   )
  assertErrorMsgContains( msg[2], mth, 'foldl', errCMat, \x x, 1 , 'vec', 1    )
  assertErrorMsgContains( msg[2], mth, 'foldl', errCMat, \x x, 1 , 'vec', \x x )
  assertErrorMsgContains( msg[5], mth, 'foldl', errCMat, '+' , {}              )
end

--[[
parameters:
  f: callable, x0: initial value, d: ['vec', 'row', 'col'], r: iterable
  r:{}, cmatrix(2), matrix(2), 1..2

fold cases:
  1) x:fold( f )
  2) x:fold( f, nil, d )      and 2') x:fold( f, d   )
  3) x:fold( f, nil, nil, r ) and 3') x:fold( f, r   ) and  3") x:fold( f, nil, r)
  4) x:fold( f, nil, d, r )   and 4') x:fold( f, d, r) and  4") x:fold( f, d, nil, r )
  5) x:fold( f, x0 )
  6) x:fold( f, x0 , d )
  7) x:fold( f, x0, nil, r ) and 7') x:fold( f, x0, r )
  8) x:fold( f, x0 , d, r )
]]
local sum = \r =>local x = 0    for i=1,#r do x = x + r[i] end return x end
local sub = \r =>local x = r[1] for i=2,#r do x = x - r[i] end return x end

function TestCMatrixFun:testFoldl()
  local _ = nil
  for i,cm in ipairs(G.cmatidx) do
    local mn, nr, nc = #cm, cm:sizes()
    local s = sum(1..mn)
    --                      f  , x0 , d    , r
    assertEquals( cm:foldl(\r r                ) , 1+1i         ) -- 1)
    assertEquals( cm:foldl('+' , 2  , nil  , {}) , s+s*1i + 2   ) -- 7)
    assertEquals( cm:foldl('+'                 ) , s+s*1i       ) -- 1)
    assertEquals( cm:foldl('+'      , 'vec'    ) , s+s*1i       ) -- 2)
    assertEquals( cm:foldl('+' , nil, 'vec'    ) , s+s*1i       ) -- 2)
    assertEquals( cm:foldl('+'      , 'vec', {}) , s+s*1i       ) -- 4)
    assertEquals( cm:foldl('+' , 2             ) , s+s*1i + 2   ) -- 5)
    assertEquals( cm:foldl('+' , 2         , {}) , s+s*1i + 2   ) -- 5)
    assertEquals( cm:foldl('+' , 2  , 'vec'    ) , s+s*1i + 2   ) -- 6)
    assertEquals( cm:foldl('+' , nil       , {}) , s+s*1i       ) -- 3)
    assertEquals( cm:foldl('+' , nil, nil  , {}) , s+s*1i       ) -- 3)
    assertEquals( cm:foldl('+' , 2  , 'diag'   ) , cm:trace()+2 )
    assertEquals( cm:foldl('+'      , 'diag'   ) , cm:trace()   )
    assertEquals( cm:foldl('+' , 0  , 'diag',{}) , cm:trace()   )

    local t ={} for i=1,nc do local x=sum(idx(1,i,nc)..idx(nr,i,nc)..nc); t [i]=toC(x) end
    local tr={} for i=1,nr do local x=sum(idx(i,1,nc)..idx(i,nc,nc)..1 ); tr[i]=toC(x) end
    assertAllAlmostEquals( cm:foldl('+', 0, 'col', {}) , t                    ) -- 8)
    assertAllAlmostEquals( cm:foldl('+', 0, 'row', {}) , tr                   ) -- 8)
    assertEquals         ( cm:foldl('+'   , 'col'    ) , cmatrix(t ):t(false) ) -- 2)
    assertEquals         ( cm:foldl('+'   , 'row'    ) , cmatrix(tr)          ) -- 2)
    assertEquals         ( cm:foldl('+', 0, 'col'    ) , cmatrix(t ):t(false) ) -- 6)
    assertEquals         ( cm:foldl('+', 0, 'row'    ) , cmatrix(tr)          ) -- 6)

  -- non-commutative operations
  local cmrefC = cm:same(1, cm.ncol  ):map(\x,j sub(idx(1,j,nc)..idx(nr,j,nc)..nc)):map(toC)
  local cmrefR = cm:same(_,1):map(\x,i sub(idx(i,1,nc)..idx(i,nc,nc)..1)):map(toC)
    if mn%2 == 0 then assertEquals( cm:foldl '~',-1-1i )
                 else assertEquals( cm:foldl '~', 1+1i ) end
    assertEquals( cm:foldl('-'       ) , sub(1..mn)+sub(1..mn)*1i  )
    assertEquals( cm:foldl('-', 'col') , cmrefC                    )
    assertEquals( cm:foldl('-', 'row') , cmrefR                    )
  end
  assertAlmostEquals( cvector(4):fill(4..1..-1):foldl('^'):real() - (4^3)^2, 0, 2e4*eps )
  assertEquals      ( cvector(4):fill(4..1..-1):foldl('^'):imag()          , 0          )
end

function TestCMatrixErr:testFoldr()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'diag', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  local m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'foldr', errCMat, nil                   )
  assertErrorMsgContains( msg[1], mth, 'foldr', errCMat, nan                   )
  assertErrorMsgContains( msg[1], mth, 'foldr', errCMat, ''                    )
  assertErrorMsgContains( msg[1], mth, 'foldr', errCMat, {}                    )
  assertErrorMsgContains( msg[1], mth, 'foldr', errCMat, 1                     )
  assertErrorMsgContains( msg[1], mth, 'foldr', errCMat, 1..2                  )
  assertErrorMsgContains( msg[1], mth, 'foldr', errCMat, m                     )
  assertErrorMsgContains( msg[1], mth, 'foldr', errCMat, cm                    )
  assertErrorMsgContains( msg[3], mth, 'foldr', errCMat, \x x, ''              )
  assertErrorMsgContains( msg[3], mth, 'foldr', errCMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', errCMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'foldr', errCMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'foldr', errCMat, \x x, 1 , "vec", ''   )
  assertErrorMsgContains( msg[2], mth, 'foldr', errCMat, \x x, 1 , "vec", 1    )
  assertErrorMsgContains( msg[2], mth, 'foldr', errCMat, \x x, 1 , "vec", \x x )
end

function TestCMatrixFun:testFoldr()
  for _,cm in ipairs(G.cmatidx) do
    local mn, nr, nc = #cm, cm:sizes()
    local s = sum(1..mn)
    --                     f   , x0 , d   , r
    assertEquals( cm:foldr(\r r               ) , 1+1i          ) -- 1)
    assertEquals( cm:foldr('+' , 2 , nil  , {}) , s+s*1i+2      ) -- 7)
    assertEquals( cm:foldr('+'                ) , s+s*1i        ) -- 1)
    assertEquals( cm:foldr('+'     , 'vec'    ) , s+s*1i        ) -- 2)
    assertEquals( cm:foldr('+', nil, 'vec'    ) , s+s*1i        ) -- 2)
    assertEquals( cm:foldr('+'     , 'vec', {}) , s+s*1i        ) -- 4)
    assertEquals( cm:foldr('+', 2             ) , s+s*1i+2      ) -- 5)
    assertEquals( cm:foldr('+', 2         , {}) , s+s*1i+2      ) -- 5)
    assertEquals( cm:foldr('+', 2  , 'vec'    ) , s+s*1i+2      ) -- 6)
    assertEquals( cm:foldr('+', nil       , {}) , s+s*1i        ) -- 3)
    assertEquals( cm:foldr('+', nil, nil  , {}) , s+s*1i        ) -- 3)
    assertEquals( cm:foldr('+' , 2  , 'diag'   ) , cm:trace()+2 )
    assertEquals( cm:foldr('+'      , 'diag'   ) , cm:trace()   )
    assertEquals( cm:foldr('+' , 0  , 'diag',{}) , cm:trace()   )

    local t ={} for i=1,nc do local x=sum(idx(1,i,nc)..idx(nr,i,nc)..nc); t [i]=toC(x) end
    local tr={} for i=1,nr do local x=sum(idx(i,1,nc)..idx(i,nc,nc)..1 ); tr[i]=toC(x) end
    assertEquals         ( cm:foldr('+'   , 'col'    ) , cmatrix(t ):t(false) ) -- 2)
    assertEquals         ( cm:foldr('+'   , 'row'    ) , cmatrix(tr)          ) -- 2)
    assertEquals         ( cm:foldr('+', 0, 'col'    ) , cmatrix(t ):t(false) ) -- 6)
    assertEquals         ( cm:foldr('+', 0, 'row'    ) , cmatrix(tr)          ) -- 6)
    assertAllAlmostEquals( cm:foldr('+', 0, 'col', {}) , t                    ) -- 8)
    assertAllAlmostEquals( cm:foldr('+', 0, 'row', {}) , tr                   ) -- 8)

  -- non-commutative operations
  local cmrefC = cm:same(1 ,nc):map(\x,j sum(idx(1,j,nc)..idx(nr,j,nc)..2*nc) - sum(idx(2,j,nc)..idx(nr,j,nc)..2*nc)):map(toC)
  local cmrefR = cm:same(nr,1 ):map(\x,i sum(idx(i,1,nc)..idx(i,nc,nc)..2   ) - sum(idx(i,2,nc)..idx(i,nc,nc)..2   )):map(toC)
  local cv = cvector( #cm ):fill(1..#cm):map(\x => if x%2==0 then x=-x end return x end)
    if mn == 1 then assertEquals( cm:foldr '~', 1+1i )
               else assertEquals( cm:foldr '~',-1-1i ) end
    assertEquals( cm:foldr '-'        , cv:map(toC):foldr('+') )
    assertEquals( cm:foldr('-', 'col'), cmrefC                       )
    assertEquals( cm:foldr('-', 'row'), cmrefR                       )
  end
  assertAlmostEquals( cvector(4):fill(4..1..-1):foldr('^'):real()- 4^(3^2), 0, 2e6*eps )
  assertEquals      ( cvector(4):fill(4..1..-1):foldr('^'):imag()         , 0          )
end

--[[ scan cases:
1) x:scan( f )
2) x:scan( f, nil, d )      and 2') x:scan( f, d )
3) x:scan( f, nil, nil, r ) and 3') x:scan( f, r ) and  3") x:scan( f, nil, r)
4) x:scan( f, nil, d, r )   and 4') x:scan( f, d, r) and  4")x:scan( f, d, nil, r )
5) x:scan( f, x0 )
6) x:scan( f, x0 , d )
7) x:scan( f, x0 , nil, r ) and 7') x:scan( f, x0, r )
8) x:scan( f, x0 , d, r )              ]]
function TestCMatrixErr:testScanl()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'diag', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  local m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'scanl', errCMat, nil                   )
  assertErrorMsgContains( msg[1], mth, 'scanl', errCMat, nan                   )
  assertErrorMsgContains( msg[1], mth, 'scanl', errCMat, ''                    )
  assertErrorMsgContains( msg[1], mth, 'scanl', errCMat, {}                    )
  assertErrorMsgContains( msg[1], mth, 'scanl', errCMat, 1                     )
  assertErrorMsgContains( msg[1], mth, 'scanl', errCMat, 1..2                  )
  assertErrorMsgContains( msg[1], mth, 'scanl', errCMat, m                     )
  assertErrorMsgContains( msg[1], mth, 'scanl', errCMat, cm                    )
  assertErrorMsgContains( msg[3], mth, 'scanl', errCMat, \x x, ''              )
  assertErrorMsgContains( msg[3], mth, 'scanl', errCMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', errCMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanl', errCMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'scanl', errCMat, \x x, 1 , 'vec', ''   )
  assertErrorMsgContains( msg[2], mth, 'scanl', errCMat, \x x, 1 , 'vec', 1    )
  assertErrorMsgContains( msg[2], mth, 'scanl', errCMat, \x x, 1 , 'vec', \x x )
end

function TestCMatrixFun:testScanl()
  for _,cm in ipairs(G.cmatidx) do
    local mn, nr, nc = #cm, cm:sizes()
    local t={} for i=1,mn do local x=sum(1..i); t[i]=toC(x) end
    local cmref  = cm:same():fill(1..mn):map(\x sum(1..x:real())):map(toC)
    local cmref2 = cmref:copy():map(\x x+2)
    local t2 = {cm[1]}
    for ij = 2, min(nr, nc) do t2[ij] = t2[ij - 1] + cm:get(ij, ij) end
    local mref3 = cmatrix(t2)
    assertEquals         ( cm:scanl(\x x               ), cm:same():fill(1):map(toC) ) -- 1)
    assertEquals         ( cm:scanl('+'                ), cmref                      ) -- 1)
    assertEquals         ( cm:scanl('+','vec'          ), cmref                      ) -- 2)
    assertEquals         ( cm:scanl('+', 2             ), cmref2                     ) -- 5)
    assertEquals         ( cm:scanl('+', 2   ,'vec'    ), cmref2                     ) -- 6)
    assertAllAlmostEquals( cm:scanl('+','vec', {}      ), t                          ) -- 4)
    assertAllAlmostEquals( cm:scanl('+', 0   ,'vec', {}), t                          ) -- 8)
    assertAllAlmostEquals( cm:scanl('+', nil       , {}), t                          ) -- 3)
    assertAllAlmostEquals( cm:scanl('+', nil , nil , {}), t                          ) -- 3)
    assertAllAlmostEquals( cm:scanl('+', 0   , nil , {}), t                          ) -- 7)
    assertEquals         ( cm:scanl('+' , 2  ,'diag'   ), mref3 + 2                  )
    assertEquals         ( cm:scanl('+'      ,'diag'   ), mref3                      )
    assertEquals         ( cm:scanl('+' , 0  ,'diag',{}), t2                         )

    cmref = cm:copy() cmref2 = cm:copy()
    for i = 1, nr do
      for j = 1, nc do 
        if i ~= 1 then cmref [cmref :getidx(i, j)] = cmref [cmref :getidx(i-1, j)] + cmref [cmref :getidx(i, j)] end
        if j ~= 1 then cmref2[cmref2:getidx(i, j)] = cmref2[cmref2:getidx(i, j-1)] + cmref2[cmref2:getidx(i, j)] end
      end
    end
    assertEquals( cm:scanl('+', 'col'), cmref  ) -- 2)
    assertEquals( cm:scanl('+', 'row'), cmref2 ) -- 2)
  -- non-commutative operations
    cmref = cm:copy() cmref2 = cm:copy()
    for i = 1, nr do
      for j = 1, nc do 
        if i ~= 1 then cmref [cmref :getidx(i, j)] = cmref [cmref :getidx(i-1, j)] - cmref [cmref :getidx(i, j)] end 
        if j ~= 1 then cmref2[cmref2:getidx(i, j)] = cmref2[cmref2:getidx(i, j-1)] - cmref2[cmref2:getidx(i, j)] end
      end
    end
    assertEquals( cm:scanl('-', 'col'), cmref  )
    assertEquals( cm:scanl('-', 'row'), cmref2 )
  end
end

function TestCMatrixErr:testScanr()
  local msg = {
    "invalid argument #2 (callable expected)"                    ,
    "invalid argument #5 (iterable expected)"                    ,
    "invalid argument #4 (string 'vec', 'diag', 'row' or 'col' expected)",
    "invalid range member '1'"                                   ,
  }
  local m, cm = matrix(2), cmatrix(2)
  assertErrorMsgContains( msg[1], mth, 'scanr', errCMat, nil                   )
  assertErrorMsgContains( msg[1], mth, 'scanr', errCMat, nan                   )
  assertErrorMsgContains( msg[1], mth, 'scanr', errCMat, ''                    )
  assertErrorMsgContains( msg[1], mth, 'scanr', errCMat, {}                    )
  assertErrorMsgContains( msg[1], mth, 'scanr', errCMat, 1                     )
  assertErrorMsgContains( msg[1], mth, 'scanr', errCMat, 1..2                  )
  assertErrorMsgContains( msg[1], mth, 'scanr', errCMat, m                     )
  assertErrorMsgContains( msg[1], mth, 'scanr', errCMat, cm                    )
  assertErrorMsgContains( msg[3], mth, 'scanr', errCMat, \x x, ''              )
  assertErrorMsgContains( msg[3], mth, 'scanr', errCMat, \x x, 1 , {}   , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', errCMat, \x x, 1 , 1..2 , {}   )
  assertErrorMsgContains( msg[3], mth, 'scanr', errCMat, \x x, 1 , ''   , {}   )
  assertErrorMsgContains( msg[2], mth, 'scanr', errCMat, \x x, 1 , 'vec', ''   )
  assertErrorMsgContains( msg[2], mth, 'scanr', errCMat, \x x, 1 , 'vec', 1    )
  assertErrorMsgContains( msg[2], mth, 'scanr', errCMat, \x x, 1 , 'vec', \x x )
end

function TestCMatrixFun:testScanr()
  local function subR(r)
    local s = #r
    local x = table.new(s,1)
    x[s] = toC(r[s])
    for i=#r-1,1,-1 do
      if i%2 == 0 then x[i]= -(x[i+1] - toC(r[i]))
                  else x[i]= - x[i+1] + toC(r[i] ) end
    end
    return x
  end
  for _,cm in ipairs(G.cmatidx) do
    local mn, nr, nc = #cm, cm:sizes()
    local cmref  = cm:same():fill(1..mn):map(\x sum(x:real()..mn)):map(toC)
    local cmref2 = cmref:copy():map(\x x+2)
    local t={} for i=1,mn do local x=sum(i..mn); t[i]=toC(x) end
    local cmref3 = cvector(min(nr, nc)):fill(cm:get(min(nr, nc), min(nr, nc)))
    for ij = min(nr, nc)-1, 1, -1 do cmref3[ij] = cmref3[ij + 1] + cm:get(ij, ij) end
    assertEquals         ( cm:scanr(\x x               ) , cm:same():fill(1..mn):map(toC) ) -- 1)
    assertEquals         ( cm:scanr('+'                ) , cmref                          ) -- 1)
    assertEquals         ( cm:scanr('+','vec'          ) , cmref                          ) -- 2)
    assertEquals         ( cm:scanr('+', 2             ) , cmref2                         ) -- 5)
    assertEquals         ( cm:scanr('+', 2   ,'vec'    ) , cmref2                         ) -- 6)
    assertAllAlmostEquals( cm:scanr('+','vec', {}      ) , t                              ) -- 4)
    assertAllAlmostEquals( cm:scanr('+', 0   ,'vec', {}) , t                              ) -- 8)
    assertAllAlmostEquals( cm:scanr('+', nil       , {}) , t                              ) -- 3)
    assertAllAlmostEquals( cm:scanr('+', nil , nil , {}) , t                              ) -- 3)
    assertAllAlmostEquals( cm:scanr('+', 0   , nil , {}) , t                              ) -- 7)
    assertEquals         ( cm:scanr('+' , 2  ,'diag'   ) , cmref3 + 2                     )
    assertEquals         ( cm:scanr('+'      ,'diag'   ) , cmref3                         )
    assertEquals         ( cm:scanr('+' , 0  ,'diag',{}) , cmref3:totable()               )

    cmref = cm:copy() cmref2 = cm:copy()
    for i = nr, 1, -1 do
      for j = nc, 1, -1 do 
        if i ~= nr then cmref [cmref :getidx(i, j)] = cmref [cmref :getidx(i, j)] + cmref [cmref :getidx(i+1, j)] end
        if j ~= nc then cmref2[cmref2:getidx(i, j)] = cmref2[cmref2:getidx(i, j)] + cmref2[cmref2:getidx(i, j+1)] end
      end
    end
    assertEquals( cm:scanr('+', 'col'), cmref  )
    assertEquals( cm:scanr('+', 'row'), cmref2 )
    -- non-commutative operations
    cmref = cm:copy() cmref2 = cm:copy()
    for i = nr, 1, -1 do
      for j = nc, 1, -1 do 
        if i ~= nr then cmref [cmref :getidx(i, j)] = cmref [cmref :getidx(i, j)] - cmref [cmref :getidx(i+1, j)] end
        if j ~= nc then cmref2[cmref2:getidx(i, j)] = cmref2[cmref2:getidx(i, j)] - cmref2[cmref2:getidx(i, j+1)] end
      end
    end
    assertEquals         ( cm:scanr('-'          ) , cm:same():fill(subR(1..mn)):map(toC) )
    assertAllAlmostEquals( cm:scanr('-', nil , {}) , subR(1..mn)  )
    assertEquals         ( cm:scanr('-','col'    ) , cmref        )
    assertEquals         ( cm:scanr('-','row'    ) , cmref2       )
  end
end

function TestCMatrixErr:testFilter()
  local msg = {
    "invalid argument #2 (callable expected)"    ,
    "invalid argument #3 (iterable expected)"    ,
    "invalid matrix new sizes"                   ,
    "attempt to compare 'number' with 'complex'" ,
    "attempt to compare 'complex' with 'complex'",
  }
  assertErrorMsgContains( msg[1], mth, 'filter', errCMat   , nil              )
  assertErrorMsgContains( msg[1], mth, 'filter', errCMat   , ''               )
  assertErrorMsgContains( msg[1], mth, 'filter', errCMat   , 1..2             )
  assertErrorMsgContains( msg[1], mth, 'filter', errCMat   , 1                )
  assertErrorMsgContains( msg[1], mth, 'filter', errCMat   , cmatrix(1)       )
  assertErrorMsgContains( msg[1], mth, 'filter', errCMat   , { }              )
  assertErrorMsgContains( msg[2], mth, 'filter', errCMat   , \x x      , ''   )
  assertErrorMsgContains( msg[2], mth, 'filter', errCMat   , \x x      , 1    )
  assertErrorMsgContains( msg[2], mth, 'filter', errCMat   , \x x      , \x x )
  assertErrorMsgContains( msg[3], mth, 'filter', matrix{1}, \x x~=1           )
  assertErrorMsgContains( msg[4], mth, 'filter', errCMat   , \x x>1           )
  assertErrorMsgContains( msg[5], mth, 'filter', errCMat   , \x x>1+1i        )
end

function TestCMatrixFun:testFilter()
 for _,cm in ipairs(G.cmatidx) do
    local mn = #cm
    assertEquals( cm:filter(\x x==1+1i             ), cvector(1) :fill(1+1i)           )
    assertEquals( cm:filter(\x x~=0+0i             ), cvector(mn):fill(1..mn):map(toC) )
    assertEquals( cm:filter(\x x==1+1i, {}         ), {1+1i}                           )
    assertEquals( cm:filter(\x x==1+1i, cvector(25)), cvector(1):seti(1,1+1i)          )
    assertEquals( cm:filter(2..#cm, \x x == 1 + 1i, {}), {}                     )
    if #cm >= 3 then 
      assertEquals( cm:filter(3..#cm, \x x ~= 1 + 1i, {}), cvector(#cm - 2):seq(2):map(toC):totable()         )
    else
      assertEquals( cm:filter(3..#cm, \x x ~= 1 + 1i, {}), {}         )
    end
    local cmc = cm:copy()
    cmc:filter(\x x==1+1i, 'in' ) assertEquals( cmc , cvector(1) :fill(1+1i)           )
    cmc = cm:copy()
    if #cmc > 4 then
      cmc:filter(\x x:real()>4, 'in' ) assertEquals( cmc  , cvector(#cmc):seq(4) + cvector(#cmc):seq(4)*1i)
    end
  end
end

function TestCMatrixErr:testFilter_out()
  local msg = {
    "invalid argument #2 (callable expected)"    ,
    "attempt to compare 'number' with 'complex'" ,
    "attempt to compare 'complex' with 'complex'",
  }
  assertErrorMsgContains( msg[1], mth, 'filter_out', errCMat, nil        )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errCMat, ''         )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errCMat, 1..2       )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errCMat, 1          )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errCMat, cmatrix(1) )
  assertErrorMsgContains( msg[1], mth, 'filter_out', errCMat, {}         )
  assertErrorMsgContains( msg[2], mth, 'filter_out', errCMat, \x x>1     )
  assertErrorMsgContains( msg[3], mth, 'filter_out', errCMat, \x x>1+1i  )
end

function TestCMatrixFun:testFilter_out()
  for _,cm in ipairs(G.cmatidx) do
    local mn = #cm
    assertEquals( cm:filter_out(\x x~=1+1i    ), cm:filter(\x x==1+1i    ) )
    assertEquals( cm:filter_out(\x x==0+0i    ), cm:filter(\x x~=0+0i    ) )
    assertEquals( cm:filter_out(\x x~=1+1i, {}), cm:filter(\x x==1+1i, {}) )
    assertEquals( cm:filter_out(2..#cm, \x x ~= 1, {}), {}                     )
    if #cm >= 3 then 
      assertEquals( cm:filter_out(3..#cm, \x x == 1 + 1i, {}), cvector(#cm - 2):seq(2):map(toC):totable()         )
    else
      assertEquals( cm:filter_out(3..#cm, \x x == 1 + 1i, {}), {}         )
    end
  end
end

-- special maps ---------------------------------------------------------------o

function TestCMatrixSMaps:setUp()
  for _,cm in ipairs(G.cmattmp) do cm:zeros()           :map( toC, 'in') end
  for _,cm in ipairs(G.cmatidx) do cm:fill(1..#cm):map( toC, 'in') end
end

function TestCMatrixSMaps:tearDown()
  for _,cm in ipairs(G.cmattmp) do cm:zeros()           :map( toC, 'in') end
  for _,cm in ipairs(G.cmatidx) do cm:fill(1..#cm):map( toC, 'in') end
end

function TestCMatrixSMaps:testCeil ()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(0.01, 1, #cm)
    cm:fill(r):map(toC,'in'):ceil('in')
    assertEquals( cm, cm:same():fill(1):map(toC) )
  end
end

function TestCMatrixSMaps:testFloor()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(0, 1-0.01, #cm)
    cm:fill(r):map(toC,'in'):floor('in')
    assertEquals( cm, cm:same():map(toC) )
  end
end

function TestCMatrixSMaps:testFrac()
  for _,cm in ipairs(G.cmattmp) do
    local mn = #cm
    local r  = range(0.1,(mn)/10,0.1)
    cm:fill(r):map(toC,'in'):frac('in')
    for i=1,mn do
      if     r[i] < 1 then assertAlmostEquals( cm:geti(i):real() -  i/10   , 0,   eps )
                           assertAlmostEquals( cm:geti(i):imag() -  i/10   , 0,   eps )
      elseif r[i] < 2 then assertAlmostEquals( cm:geti(i):real() - (i/10-1), 0,   eps )
                           assertAlmostEquals( cm:geti(i):real() - (i/10-1), 0,   eps )
                      else assertAlmostEquals( cm:geti(i):real() - (i/10-2), 0, 2*eps )
                           assertAlmostEquals( cm:geti(i):real() - (i/10-2), 0, 2*eps ) end
    end
  end
end

function TestCMatrixSMaps:testTrunc()
  for _,cm in ipairs(G.cmattmp) do
    local mn = #cm
    local r = nrange(0, 3-0.01, mn)
    cm:fill(r):map(toC,'in'):trunc('in')
    for i=1,mn do
      if     r[i] < 1 then assertEquals( cm:geti(i), 0+0i )
      elseif r[i] < 2 then assertEquals( cm:geti(i), 1+1i )
                      else assertEquals( cm:geti(i), 2+2i ) end
    end
  end
end

function TestCMatrixSMaps:testRound()
  for _,cm in ipairs(G.cmattmp) do
    local mn = #cm
    local r = nrange(0, 1, mn)
    cm:fill(r):map(toC,'in'):round('in')
    for i=1,mn do
    if r[i] < 0.5 then assertEquals( cm:geti(i), 0+0i )
                  else assertEquals( cm:geti(i), 1+1i ) end
    end
  end
end

function TestCMatrixSMaps:testAbs()
  for _,cm in ipairs(G.cmattmp) do
    local mn, res = #cm
    local r = nrange(-3, 3, mn)
    cm:fill(r):map(toC,'in'):abs('in')
    res = cm:map(\x x:real()>=0, {})  assertEquals( res, rep(true, mn) )
    res = cm:map(\x x:imag()>=0, {})  assertEquals( res, rep(true, mn) )
  end
end

function TestCMatrixSMaps:testSqrt()
  for _,cm in ipairs(G.cmatidx) do
    local mn = #cm
    cm:map(\x x*x):map(toC,'in'):sqrt('in')
    assertEquals( cm, cm:same():fill(1..mn):map(toC) )
  end
end

function TestCMatrixSMaps:testSqr()
  for _,cm in ipairs(G.cmatidx) do
    assertEquals( cm:sqr(), cm:copy():map(\x x*x) )
  end
end

function TestCMatrixSMaps:testExp()
  for _,cm in ipairs(G.cmatidx) do
    local mn = #cm
    local cref = cm:copy()
    cm:exp('in')
    assertEquals( cm, cref:map(\x exp(x:real()) * complex(cos(x:imag()), sin(x:imag()))) )
  end
end

function TestCMatrixSMaps:testLog()
  for _,cm in ipairs(G.cmatidx) do
    local mn = #cm
    cm:map(toC,'in'):log('in')
    local res = cm:map(\x exp(x), 'in' )
    assertTrue( res:eq( cm:same():fill(1..mn):map(toC,'in'), 58*eps ) )
  end
end

function TestCMatrixSMaps:testLog10()
  for _,cm in ipairs(G.cmatidx) do
    local mres = cm:copy():map(\x log(x)/log(10) )
    cm:map(toC,'in'):log10('in')
    assertTrue( cm:eq( mres, eps) )
  end
end

function TestCMatrixSMaps:testSin()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1, pi/2, #cm)
    cm:fill(r):map(toC,'in')
    assertEquals( cm:sin(), cm:copy():map(\x -sin(-x)) )
  end
end

function TestCMatrixSMaps:testCos()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1, pi/2, #cm)
    cm:fill(r):map(toC,'in')
    assertEquals( cm:cos(),    cm:copy():map(\x cos(-x    ))          )
    assertTrue  ( cm:cos():eq( cm:copy():map(\x sin(pi/2-x)), 3*eps ) )
  end
end

function TestCMatrixSMaps:testTan()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,#cm)
    cm:fill(r):map(toC,'in')
    assertTrue( cm:tan():eq( cm:copy():map(\x sin(x)/cos(x)), 32*eps ) )
  end
end

function TestCMatrixSMaps:testCot()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,#cm)
    cm:fill(r):map(toC)
    assertTrue( cm:cot():eq( cm:copy():map(\x cos(x)/sin(x)), eps ) )
  end
end

function TestCMatrixSMaps:testSinc()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,#cm)
    cm:fill(r):map(toC)
    assertEquals( cm:sinc(), cm:copy():map(\x MAD.gmath.sinc(x)) )
  end
end

function TestCMatrixSMaps:testSinh()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,#cm)
    cm:fill(r):map(toC,'in')
    assertTrue( cm:sinh():eq( cm:copy():map(\x 2*sinh(x/2)*cosh(x/2)), 5*eps ) )
  end
end

function TestCMatrixSMaps:testCosh()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,#cm)
    cm:fill(r):map(toC,'in')
    assertTrue( cm:cosh():eq( cm:copy():map(\x 2*sinh(x/2)^2 + 1), 5*eps ) )
  end
end

function TestCMatrixSMaps:testTanh()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,#cm)
    cm:fill(r):map(toC,'in')
    assertTrue( cm:tanh():eq( cm:copy():map(\x sinh(x)/cosh(x)), 3*eps) )
  end
end

function TestCMatrixSMaps:testCoth()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,#cm)
    cm:fill(r):map(toC)
    assertTrue( cm:coth():eq( cm:copy():map(\x cosh(x)/sinh(x)), 3*eps) )
  end
end

function TestCMatrixSMaps:testSinhc()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,#cm)
    cm:fill(r):map(toC)
    assertEquals( cm:sinhc(), cm:copy():map(\x MAD.gmath.sinhc(x)) )
  end
end

function TestCMatrixSMaps:testAsin()
  for _,cm in ipairs(G.cmatidx) do
    local r = nrange(1,pi/2,#cm)
    cm:fill(r):map(toC,'in')
    local cref = cm:copy()
    assertTrue( cm:sin():asin('in'):eq( cref, 8*eps) ) -- linux err: 6*eps
  end
end

function TestCMatrixSMaps:testAcos()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,#cm)
    cm:fill(r):map(toC,'in')
    local cref = cm:copy()
    assertTrue( cm:cos():acos('in'):eq( cref, 2*eps ) )
  end
end

function TestCMatrixSMaps:testAtan()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,#cm)
    cm:fill(r):map(toC,'in')
    local cref = cm:copy()
    assertTrue( cm:tan():atan('in'):eq( cref, 9*eps ) )
  end
end

function TestCMatrixSMaps:testAcot()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,#cm)
    cm:fill(r)
    assertTrue( cm:cot():acot('in'):eq( cm:same():fill(r), eps ) )
  end
end

function TestCMatrixSMaps:testAsinh()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,#cm)
    cm:fill(r):map(toC,'in')
    local cref = cm:copy()
    assertTrue( cm:asinh():sinh('in'):eq( cref, 3*eps ) )
  end
end

function TestCMatrixSMaps:testAcosh()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,#cm)
    cm:fill(r):map(toC,'in')
    local cref = cm:copy()
    assertTrue( cm:acosh():cosh('in'):eq( cref, 4*eps ) )
  end
end

function TestCMatrixSMaps:testAtanh()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,#cm)
    cm:fill(r):map(toC,'in')
    local cref = cm:copy()
    assertTrue( cm:tanh():atanh('in'):eq( cref, 9*eps ) )
  end
end

function TestCMatrixSMaps:testAcoth()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,#cm)
    cm:fill(r)
    assertTrue( cm:coth():acoth('in'):eq( cm:copy(), 7*eps ) )
  end
end

function TestCMatrixSMaps:testAsinc()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,#cm)
    cm:fill(r)
    local res = (cm:copy():map(\x MAD.gmath.asinc(x)))
    assertEquals( cm:asinc(), res )
  end
end

function TestCMatrixSMaps:testAsinhc()
  for _,cm in ipairs(G.cmattmp) do
    local r = nrange(1,pi/2,#cm)
    cm:fill(r)
    local res = (cm:copy():map(\x MAD.gmath.asinhc(x)))
    assertEquals( cm:asinhc(), res )
  end
end

function TestCMatrixSMaps:testErf() --Is this suitable? Literally just tests the map and the fact erf is odd
  for _,cm in ipairs(G.cmatidx) do
    local erfM = cm:copy():erf()
    local res = (cm:copy():map(\x erf(x)))
    assertEquals( res, erfM)
    assertEquals( cm:erf(), -1*((-1*cm):erf()))
  end
end

function TestCMatrixSMaps:testErfc()
  for _,cm in ipairs(G.cmatidx) do
    local res = cm:copy():map(\x 1 - erf(x))
    assertTrue( res:eq(cm:erfc(), eps) ) 
  end
end

function TestCMatrixSMaps:testWf()
  for _,cm in ipairs(G.cmatidx) do
    cm = cm:map(\x complex(x, 0)) --purely real input returns im(w(z))
    local res = (cm:copy():map(\x exp(-(x^2))*erfc(-1i * x)))
    assertTrue( res:real():eq(cm:wf():real(), eps) ) 
    assertTrue( res:imag():eq(cm:wf():imag(), eps) ) 
  end
end

function TestCMatrixSMaps:testErfi()
  for _,cm in ipairs(G.cmatidx) do
    local res = cm:copy():map(\x -1i*erf(1i*x))
    local res2 = cm:copy():map(\x -1i+ 1i*erfc(1i*x))
    assertEquals( res:real(), cm:erfi():real()) 
    assertEquals( res:imag(), cm:erfi():imag())
    assertEquals( res2:real(), cm:erfi():real()) 
    assertTrue( res2:imag():eq(cm:erfi():imag(), 2*eps) ) 
  end
end

function TestCMatrixSMaps:testErfcx()
  for _,cm in ipairs(G.cmatidx) do
    local res = cm:copy():map(\x exp(x^2)*erfc(x))
    assertTrue( res:eq(cm:erfcx(), eps) ) 
  end
end

function TestCMatrixSMaps:testCarg()
  for _,cm in ipairs(G.cmatidx) do
    local r = nrange(1,pi/2,#cm)
    local cref = cm:fill(r):map(toC,'in'):copy()
    assertEquals( cm:carg(), cref:copy():map(\x atan2(x:imag(),x:real())) )
  end
end

function TestCMatrixSMaps:testReal()
  for _,cm in ipairs(G.cmatidx) do
    local m = matrix(cm:sizes())
    assertEquals( cm:real(), m:same():fill(1..#cm) )
  end
end

function TestCMatrixSMaps:testImag()
  for _,cm in ipairs(G.cmatidx) do
    local m = matrix(cm:sizes())
    assertEquals( cm:imag(), m:same():fill(1..#cm) )
  end
end

function TestCMatrixSMaps:testConj()
  for _,cm in ipairs(G.cmatidx) do
    assertEquals( cm:conj(), cm:same():fill(1..#cm):map(\x x-x*1i) )
  end
end

function TestCMatrixSMaps:testProj()
  for _,cm in ipairs(G.cmatidx) do
    local mn = #cm
    assertEquals( cm:proj(), cm:same():fill(1..#cm):map(toC) )
  end
end

function TestCMatrixSMaps:testRect()
  for _,cm in ipairs(G.cmatidx) do
    local cref = cm:copy():map(\x x:real()*cos(x:imag())+ x:real()*sin(x:imag())*1i )
    assertEquals( cm:rect(), cref )
  end
end

function TestCMatrixSMaps:testPolar()
  for _,cm in ipairs(G.cmatidx) do
    local cref = cm:copy():map(\x hypot(x:real(),x:imag()) + atan2( x:real(),x:imag())*1i )
    assertEquals( cm:polar(), cref )
  end
end

function TestCMatrixSMaps:testCabs()
  for _,cm in ipairs(G.cmatidx) do
    local cref = cm:copy():map(\x hypot(x:real(),x:imag()))
    assertEquals( cm:cabs(), cref )
  end
end

function TestCMatrixSMaps:testHypot()
  for _,cm in ipairs(G.matidx) do
    local y = 1..#cm
    assertEquals( cm:hypot(y), cm:copy():map(\x, ij hypot(x, y[ij])) )
  end
end

function TestCMatrixSMaps:testHypot3()
  for _,cm in ipairs(G.matidx) do
    local y = 1..#cm
    local z = #cm..1..-1
    assertEquals( cm:hypot3(y, z), cm:copy():map(\x, ij hypot3(x, y[ij], z[ij])) )
  end
end

function TestCMatrixSMaps:testFabs()
  for _,cm in ipairs(G.matidx) do
    local cm2 = cm:map(\x x*x) - 10*cm --Acheives +/-
    assertEquals( cm2:fabs(), cm2:real():abs() + cm2:imag():abs()*1i ) --No cplx
  end
end

function TestCMatrixErr:testReim()
  local msg = {
    "invalid argument #2 (matrix expected)"    ,
    "invalid argument #3 (matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'reim', errCMat, ''                )
  assertErrorMsgContains( msg[1], mth, 'reim', errCMat, 1..2              )
  assertErrorMsgContains( msg[1], mth, 'reim', errCMat, 1                 )
  assertErrorMsgContains( msg[1], mth, 'reim', errCMat, errCMat           )
  assertErrorMsgContains( msg[1], mth, 'reim', errCMat, { }               )
  assertErrorMsgContains( msg[2], mth, 'reim', errCMat, errCMat:real(), ''  )
  assertErrorMsgContains( msg[2], mth, 'reim', errCMat, errCMat:real(), 1..2)
  assertErrorMsgContains( msg[2], mth, 'reim', errCMat, errCMat:real(), 1 )
  assertErrorMsgContains( msg[2], mth, 'reim', errCMat, errCMat:real(), errCMat )
  assertErrorMsgContains( msg[2], mth, 'reim', errCMat, errCMat:real(), { } )

end

function TestCMatrixSMaps:testReim()
  for _,cm in ipairs(G.cmatidx) do
    local re, im = cm:copy():reim()
    assertEquals(re, cm:real())
    assertEquals(im, cm:imag())
    assertEquals(re + 1i * im, cm) --Test we get real and imag out
    local zerosM = matrix(cm:sizes()):zeros() --Is there a function to convet cmat to mat?
    re, im = cm:reim(nil, zerosM) 
    assertEquals(re, cm:real())
    assertEquals(im, zerosM) --Test we can set imag
    local onesM = matrix(cm:sizes()):ones()
    re, im = cm:reim(onesM, nil)
    assertEquals(re, onesM)
    assertEquals(im, cm:imag()) --Test we can set real
    re, im = cm:reim(zerosM, onesM)
    assertEquals(re, zerosM)
    assertEquals(im, onesM) --Test we can set both
  end
end

-- special folds --------------------------------------------------------------o
function TestCMatrixSFolds:testMinabs() --Good enough?
  for _,cm in ipairs(G.cmatidx) do
    local r = nrange(-3, 3, #cm)
    local cm2 = cm:copy():fill(r):map(toC)
    local nr,nc,_ = cm2:sizes()
    assertEquals( cm2:minabs()     , cm2:abs():min()) --identity
    assertEquals( cm :minabs('col'), cm:same(1 ,nc):fill(1..nc):map(toC):abs()               )
    assertEquals( cm :minabs('row'), cm:same(nr,1 ):fill(1..idx(nr,1,nc)..nc):map(toC):abs() )
    local m2 = cm:copy():seq():map(\x x*x) - 10*cm
    local minval = inf
    for ij = 1, min(nr, nc) do minval = minval > abs(m2:get(ij, ij)) and abs(m2:get(ij, ij)) or minval end
    assertEquals( m2:minabs('diag'), minval)
  end
end

function TestCMatrixSFolds:testMaxabs() --Good enough?
  for _,cm in ipairs(G.cmatidx) do
    local r = nrange(-3, 3, #cm)
    local cm2 = cm:copy():fill(r):map(toC)
    local nr,nc = cm2:sizes()
    assertEquals( cm2:maxabs()     , cm2:abs():max()) --identity
    assertEquals( cm :maxabs('col'), cm:same(1 ,nc):fill(idx(nr,1,nc)..idx(nr,nc,nc)..1 ):map(toC):abs() )
    assertEquals( cm :maxabs('row'), cm:same(nr,1 ):fill(idx(1,nc,nc)..idx(nr,nc,nc)..nc):map(toC):abs() )
    local m2 = cm:copy():seq():map(\x x*x) - 10*cm
    local minval = inf
    for ij = 1, min(nr, nc) do minval = minval > abs(m2:get(ij, ij)) and abs(m2:get(ij, ij)) or minval end
    assertEquals( m2:minabs('diag'), minval)
  end
end

function TestCMatrixSFolds:testSum()
  for _,cm in ipairs(G.cmatidx) do
    local mn, _, nr, nc = #cm, nil, cm:sizes()
    assertEquals( cm:sum()     , sum(1..mn) + sum(1..mn)*1i )
    assertEquals( cm:sum('col'), cm:same(1 ,nc):map(\x,j sum(idx(1,j,nc)..idx(nr,j,nc)..nc)):map(toC) )
    assertEquals( cm:sum('row'), cm:same(nr,1 ):map(\x,i sum(idx(i,1,nc)..idx(i,nc,nc)..1 )):map(toC) )
  end
end

function TestCMatrixSFolds:testSumabs()
  local sumabs = \r =>local x = 0 for i=1,#r do x = x + abs(r[i] + r[i]*1i) end return x end
  for _,cm in ipairs(G.cmatidx) do
    local mn, _, nr, nc = #cm, nil, cm:sizes()
    local cm1 = cm:copy():map(\x -x)
    assertEquals( cm1:sumabs()     , sumabs(1..mn) )
    assertEquals( cm1:sumabs('col'), cm:same(1 ,nc):map(\x,j sumabs(idx(1,j,nc)..idx(nr,j,nc)..nc)) )
    assertEquals( cm1:sumabs('row'), cm:same(nr,1 ):map(\x,i sumabs(idx(i,1,nc)..idx(i,nc,nc)..1 )) )
  end
end

function TestCMatrixSFolds:testSumsqr()
  local sumsqr = \r =>local x = 0 for i=1,#r do x = x + (r[i]+r[i]*1i)^2 end return x end
  for _,cm in ipairs(G.cmatidx) do
    local nr,nc,_ = cm:sizes()
    assertEquals( cm:sumsqr()     , sumsqr(1..#cm) )
    assertEquals( cm:sumsqr('col'), cm:same(1 ,nc):map\x,j sumsqr(idx(1,j,nc)..idx(nr,j,nc)..nc) )
    assertEquals( cm:sumsqr('row'), cm:same(nr,1 ):map\x,i sumsqr(idx(i,1,nc)..idx(i,nc,nc)..1 ) )
  end
end

function TestCMatrixSFolds:testProd()
  local prod = \r =>local x = 1 for i=1,#r do x = x * (r[i]+r[i]*1i) end return x end
  for _,cm in ipairs(G.cmatidx) do
    local nr,nc,_ = cm:sizes()
    assertEquals( cm:prod()     , prod(1..#cm) )
    assertEquals( cm:prod('col'), cm:same(1 ,nc):map\x,j prod(idx(1,j,nc)..idx(nr,j,nc)..nc) )
    assertEquals( cm:prod('row'), cm:same(nr,1 ):map\x,i prod(idx(i,1,nc)..idx(i,nc,nc)..1 ) )
  end
end

-- minmax ---------------------------------------------------------------------o
function TestCMatrixSScans:testMinmax()
  for _,cm in ipairs(G.cmatidx) do
    local min, max = cm:minmax()
    assertEquals( min, 1 + 1i                    )
    assertEquals( max, #cm + #cm * 1i)
    cm:fill(nrange(-3, 3.5, #cm))--3.5 means not symmetric
    cm = cm + cm * 1i
    min, max = cm:minmax()
    local absCm = cm:copy():abs()
    assertEquals( abs(min), absCm:min()) --m:abs():min() not necessarily m:min():abs()
    assertEquals( abs(max), absCm:max())
    local minIndex, maxIndex = 1, 1
    for i, val in ipairs(absCm) do
      minIndex = (val < absCm[minIndex]) and i or minIndex 
      maxIndex = (val > absCm[maxIndex]) and i or maxIndex 
    end
    assertEquals(min, cm[minIndex])
    assertEquals(max, cm[maxIndex])
  end
end

function TestCMatrixSScans:testIminmax()
  for _,cm in ipairs(G.cmatidx) do
    cm:fill(nrange(-3, 3.5, #cm)) --3.5 means not symmetric
    cm = cm + cm * 1i
    local min, max = cm:iminmax()
    local absCm = cm:copy():abs()
    assertEquals( abs(cm[min]), absCm:min()) --m:abs():min() not necessarily m:min():abs()
    assertEquals( abs(cm[max]), absCm:max())
    local minIndex, maxIndex = 1, 1
    for i, val in ipairs(absCm) do
      minIndex = (val < absCm[minIndex]) and i or minIndex 
      maxIndex = (val > absCm[maxIndex]) and i or maxIndex 
    end
    assertEquals(min, minIndex)
    assertEquals(max, maxIndex)
  end
end

function TestCMatrixErr:testAll()
  local msg = {
    "invalid argument #2 (callable expected)"    ,
    "attempt to compare 'complex' with 'number'" ,
    "attempt to compare 'complex' with 'complex'",
    "cannot convert 'bool' to 'complex'"         ,
  }
  assertErrorMsgContains( msg[1], mth, 'all', errCMat, nil               )
  assertErrorMsgContains( msg[1], mth, 'all', errCMat, ''                )
  assertErrorMsgContains( msg[1], mth, 'all', errCMat, 1..2              )
  assertErrorMsgContains( msg[1], mth, 'all', errCMat, 1                 )
  assertErrorMsgContains( msg[1], mth, 'all', errCMat, errCMat           )
  assertErrorMsgContains( msg[1], mth, 'all', errCMat, { }               )
  assertErrorMsgContains( msg[2], mth, 'all', errCMat, \x x< 2           )
  assertErrorMsgContains( msg[3], mth, 'all', errCMat, \x x< 2+2i        )
  assertErrorMsgContains( msg[4], mth, 'all', errCMat, \x x==2+2i, 'col' )
  assertErrorMsgContains( msg[4], mth, 'all', errCMat, \x x==2   , 'row' )
end

function TestCMatrixSFolds:testAll()
  for _,cm in ipairs(G.cmatidx) do
    local mn, t, nr, nc = #cm, nil, cm:sizes()
    assertFalse ( cm:all \x x==#cm           )
    assertTrue  ( cm:all \x x~=#cm+1         )
    assertTrue  ( cm:all(\x x~=#cm+1, 'vec') )
    assertEquals( cm:all(\x x==16), cm:all( \x x==16, 'vec')  )

    t = table.new(nc,1); for i=2,nc do t[i]=true end; t[1]=false
    assertEquals( cm:all(\x x~=1+1i, 'col', {}), t )
    t = table.new(nr,1); for i=2,nr do t[i]=true end; t[1]=false
    assertEquals( cm:all(\x x~=1+1i, 'row', {}), t )
  end
end

function TestCMatrixErr:testAny()
  local msg = {
    "invalid argument #2 (callable expected)"    ,
    "attempt to compare 'complex' with 'number'" ,
    "attempt to compare 'complex' with 'complex'",
    "cannot convert 'bool' to 'complex'"         ,
  }
  assertErrorMsgContains( msg[1], mth, 'any', errCMat, nil               )
  assertErrorMsgContains( msg[1], mth, 'any', errCMat, ''                )
  assertErrorMsgContains( msg[1], mth, 'any', errCMat, 1..2              )
  assertErrorMsgContains( msg[1], mth, 'any', errCMat, 1                 )
  assertErrorMsgContains( msg[1], mth, 'any', errCMat, errCMat           )
  assertErrorMsgContains( msg[1], mth, 'any', errCMat, { }               )
  assertErrorMsgContains( msg[2], mth, 'any', errCMat, \x x< 2           )
  assertErrorMsgContains( msg[3], mth, 'any', errCMat, \x x< 2+2i        )
  assertErrorMsgContains( msg[4], mth, 'any', errCMat, \x x==2+2i, 'col' )
  assertErrorMsgContains( msg[4], mth, 'any', errCMat, \x x==2   , 'row' )
end

function TestCMatrixSFolds:testAny()
  for _,cm in ipairs(G.cmatidx) do
    local mn, t, nr, nc = #cm, nil, cm:sizes()
    assertTrue  ( cm:any \x x~=#cm+1         )
    assertFalse ( cm:any \x x==1                   )
    assertTrue  ( cm:any(\x x~=#cm+1, 'vec') )
    assertEquals( cm:any(\x x==16), cm:any( \x x==16, 'vec')  )

    t = table.new(nc,1); for i=2,nc do t[i]=true end; t[1]=false
    assertEquals( cm:all(\x x~=1+1i, 'col', {}), t )
    t = table.new(nr,1); for i=2,nr do t[i]=true end; t[1]=false
    assertEquals( cm:all(\x x~=1+1i, 'row', {}), t )
  end
end

-- special scans --------------------------------------------------------------o

function TestCMatrixSScans:setUp()
  for _,cm in ipairs(G.cmatidx) do cm:fill(1..#cm):map( toC, 'in') end
end

function TestCMatrixSScans:tearDown()
  for _,cm in ipairs(G.cmatidx) do cm:fill(1..#cm):map( toC, 'in') end
end

-- left accumulation
function TestCMatrixSScans:testAccminabs() --Good enough?
  for _,cm in ipairs(G.cmatidx) do
    local r = nrange(-3, 3, #cm)
    local m2 = cm:copy():fill(r)
    local nr,nc,_ = m2:sizes()
    --Just tests identity, fails if accmin or abs fail
    assertEquals( m2:accminabs()     , m2:abs():accmin())
    assertEquals( m2:accminabs("row")     , m2:abs():accmin("row"))
    assertEquals( m2:accminabs("col")     , m2:abs():accmin("col"))
    assertEquals( m2:accminabs("diag")    , m2:abs():accmin("diag"))
  end
end

function TestCMatrixSScans:testAccmaxabs() --Good enough?
  for _,cm in ipairs(G.cmatidx) do
    local r = nrange(-3, 3, #cm)
    local m2 = cm:copy():fill(r)
    local nr,nc,_ = m2:sizes()
    assertEquals( m2:accmaxabs()          , m2:abs():accmax())
    assertEquals( m2:accmaxabs("row")     , m2:abs():accmax("row"))
    assertEquals( m2:accmaxabs("col")     , m2:abs():accmax("col"))
    assertEquals( m2:accmaxabs("diag")    , m2:abs():accmax("diag"))
  end
end

function TestCMatrixSScans:testAccsum()
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    assertEquals( cm:accsum()     , cm:copy():map\x sum(vector(x:real()):seq():map(toC)) )
    local cmref, cmref2, cmref3 = cm:copy(), cm:copy(), cm:getdiag()
    for i = 1, nr do
      for j = 1, nc do 
        if i ~= 1 then cmref [cmref :getidx(i, j)] = cmref [cmref :getidx(i-1, j)] + cmref [cmref :getidx(i, j)] end
        if j ~= 1 then cmref2[cmref2:getidx(i, j)] = cmref2[cmref2:getidx(i, j-1)] + cmref2[cmref2:getidx(i, j)] end
        if i == j and i ~= 1 then cmref3[i] = cmref3[i-1] + cmref3[i] end
      end
    end
    assertEquals( cm:accsum('col') , cmref  )
    assertEquals( cm:accsum('row') , cmref2 )
    assertEquals( cm:accsum('diag'), cmref3 )
    assertEquals( cm:accsum()     , cm:accumulate()     )
    assertEquals( cm:accsum('col'), cm:accumulate('col'))
    assertEquals( cm:accsum('row'), cm:accumulate('row'))
    assertEquals( cm:accsum('diag'), cm:accumulate('diag'))
  end
end

function TestCMatrixSScans:testAccsumabs()
for _,cm0 in ipairs(G.cmatidx) do
    local nr, nc = cm0:sizes()
    local cm = cm0:copy():map(\x -x)
    local cmref, cmref2, cmref3, cmref4 = cm:copy():abs(), cm:copy():abs(), cm:getdiag():abs(), cm0:copy():abs()
    for i = 1, nr do
      for j = 1, nc do 
        if i ~= 1 then cmref [cmref :getidx(i, j)] = cmref [cmref :getidx(i-1, j)] + cmref [cmref :getidx(i, j)] end
        if j ~= 1 then cmref2[cmref2:getidx(i, j)] = cmref2[cmref2:getidx(i, j-1)] + cmref2[cmref2:getidx(i, j)] end
        if i == j and i ~= 1 then cmref3[i] = cmref3[i-1] + cmref3[i] end
        if idx(i, j, nc) ~= 1 then cmref4[idx(i, j, nc)] = cmref4[idx(i, j-1, nc)] + cmref4[idx(i, j, nc)] end
      end
    end
    assertEquals( cm:accsumabs('col' ) , cmref  )
    assertEquals( cm:accsumabs('row' ) , cmref2 )
    assertEquals( cm:accsumabs('diag'), cmref3 )
    assertEquals( cm:accsumabs(      ) , cmref4 )
    assertEquals( cm:accsumabs("vec" ) , cmref4 )
  end
end

function TestCMatrixSScans:testAccsumsqr()
  local sumsqr = \r =>local x = 0 for i=1,#r do x = x + r[i]^2 end return x end
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    assertEquals( cm:accsumsqr()     , cm:copy():map\x sumsqr(vector(x:real()):seq():map(toC)) )
    local cmref, cmref2, cmref3 = cm:copy():map(\x x*x), cm:copy():map(\x x*x), cm:getdiag():map(\x x*x)
    for i = 1, nr do
      for j = 1, nc do 
        if i ~= 1 then cmref [cmref :getidx(i, j)] = cmref [cmref :getidx(i-1, j)] + cmref [cmref :getidx(i, j)] end
        if j ~= 1 then cmref2[cmref2:getidx(i, j)] = cmref2[cmref2:getidx(i, j-1)] + cmref2[cmref2:getidx(i, j)] end
        if i == j and i ~= 1 then cmref3[i] = cmref3[i-1] + cmref3[i] end
      end
    end
    assertEquals( cm:accsumsqr('col') , cmref  )
    assertEquals( cm:accsumsqr('row') , cmref2 )
    assertEquals( cm:accsumsqr('diag'), cmref3 )
  end
end

function TestCMatrixSScans:testAccprod()
  local prod = \r =>local x = 1 for i=1,#r do x = x * r[i] end return x end
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    assertEquals( cm:accprod()     , cm:copy():map(\x prod(vector(x:real()):seq():map(toC))) )
    local cmref, cmref2, cmref3 = cm:copy(), cm:copy(), cm:getdiag()
    for i = 1, nr do
      for j = 1, nc do 
        if i ~= 1 then cmref [cmref :getidx(i, j)] = cmref [cmref :getidx(i-1, j)] * cmref [cmref :getidx(i, j)] end
        if j ~= 1 then cmref2[cmref2:getidx(i, j)] = cmref2[cmref2:getidx(i, j-1)] * cmref2[cmref2:getidx(i, j)] end
        if i == j and i ~= 1 then cmref3[i] = cmref3[i-1] * cmref3[i] end
      end
    end
    assertEquals( cm:accprod('col') , cmref  )
    assertEquals( cm:accprod('row') , cmref2 )
    assertEquals( cm:accprod('diag'), cmref3 )
  end
end

-- right accumulation
function TestCMatrixSScans:testRaccminabs() --Good enough?
  for _,cm in ipairs(G.cmatidx) do
    local r = nrange(-3, 3, #cm)
    local m2 = cm:copy():fill(r)
    local nr,nc,_ = m2:sizes()
    assertEquals( m2:raccminabs()          , m2:abs():raccmin())
    assertEquals( m2:raccminabs("row")     , m2:abs():raccmin("row"))
    assertEquals( m2:raccminabs("col")     , m2:abs():raccmin("col"))
    assertEquals( m2:raccminabs("diag")    , m2:abs():raccmin("diag"))
  end
end

function TestCMatrixSScans:testRaccmaxabs() --Good enough?
  for _,cm in ipairs(G.cmatidx) do
    local r = nrange(-3, 3, #cm)
    local m2 = cm:copy():fill(r)
    local nr,nc,_ = m2:sizes()
    assertEquals( m2:raccmaxabs()      , m2:abs():raccmax())
    assertEquals( m2:raccmaxabs("row") , m2:abs():raccmax("row"))
    assertEquals( m2:raccmaxabs("col") , m2:abs():raccmax("col"))
    assertEquals( m2:raccmaxabs("diag"), m2:abs():raccmax("diag"))
  end
end

function TestCMatrixSScans:testRaccsum()
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    assertEquals( cm:raccsum()     , cm:copy():map\x sum(vector((x:real()..nr*nc):totable()):map(toC)) )
    local cmref, cmref2, cmref3 = cm:copy(), cm:copy(), cm:getdiag()
    for i = nr, 1, -1 do
      for j = nc, 1, -1 do 
        if i ~= nr then cmref [cmref :getidx(i, j)] = cmref [cmref :getidx(i, j)] + cmref [cmref :getidx(i+1, j)] end
        if j ~= nc then cmref2[cmref2:getidx(i, j)] = cmref2[cmref2:getidx(i, j)] + cmref2[cmref2:getidx(i, j+1)] end
        if i == j and i ~= min(nr, nc) then cmref3[i] = cmref3[i] + cmref3[i+1] end
      end
    end
    assertEquals( cm:raccsum('col') , cmref  )
    assertEquals( cm:raccsum('row') , cmref2 )
    assertEquals( cm:raccsum('diag'), cmref3 )
  end
end

function TestCMatrixSScans:testRaccsumabs()
  for _,cm0 in ipairs(G.cmatidx) do
    local nr, nc = cm0:sizes()
    local cm = cm0:copy():map(\x -x)
    local cmref, cmref2, cmref3, cmref4 = cm0:copy():abs(), cm0:copy():abs(), cm0:getdiag():abs(), cm0:copy():abs()
    for i = nr, 1, -1 do
      for j = nc, 1, -1 do 
        if i ~= nr then cmref [cmref :getidx(i, j)] = cmref [cmref :getidx(i, j)] + cmref [cmref :getidx(i+1, j)] end
        if j ~= nc then cmref2[cmref2:getidx(i, j)] = cmref2[cmref2:getidx(i, j)] + cmref2[cmref2:getidx(i, j+1)] end
        if i == j and i ~= min(nr, nc) then cmref3[i] = cmref3[i] + cmref3[i+1] end
        if idx(i, j, nc) ~= #cm0 then cmref4[idx(i, j, nc)] = cmref4[idx(i, j, nc)] + cmref4[idx(i, j+1, nc)] end
      end
    end
    assertEquals( cm:raccsumabs('col' ) , cmref  )
    assertEquals( cm:raccsumabs('row' ) , cmref2 )
    assertEquals( cm:raccsumabs('diag') , cmref3 )
    assertEquals( cm:raccsumabs(      ) , cmref4 )
    assertEquals( cm:raccsumabs("vec" ) , cmref4 )
  end
end

function TestCMatrixSScans:testRaccsumsqr()
  local sumsqr = \r =>local x = 0 for i=1,#r do x = x + r[i]^2 end return x end
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    assertEquals( cm:raccsumsqr()     , cm:copy():map\x sumsqr(vector((x:real()..nr*nc):totable()):map(toC)) )
    local cmref, cmref2, cmref3 = cm:copy():map(\x x*x), cm:copy():map(\x x*x), cm:getdiag():map(\x x*x)
    for i = nr, 1, -1 do
      for j = nc, 1, -1 do 
        if i ~= nr then cmref [cmref :getidx(i, j)] = cmref [cmref :getidx(i, j)] + cmref [cmref :getidx(i+1, j)] end
        if j ~= nc then cmref2[cmref2:getidx(i, j)] = cmref2[cmref2:getidx(i, j)] + cmref2[cmref2:getidx(i, j+1)] end
        if i == j and i ~= min(nr, nc) then cmref3[i] = cmref3[i] + cmref3[i+1] end
      end
    end
    assertEquals( cm:raccsumsqr('col') , cmref  )
    assertEquals( cm:raccsumsqr('row') , cmref2 )
    assertEquals( cm:raccsumsqr('diag'), cmref3 )
  end
end

function TestCMatrixSScans:testRaccprod()
  local prod = \r =>local x = 1 for i=1,#r do x = x * r[i] end return x end
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    if nr*nc < 25 then
      assertTrue( cm:raccprod()   :eq( cm:copy():map\x prod(vector((x:real()..nr*nc):totable()):map(toC)) ) )
    end
    local cmref, cmref2, cmref3 = cm:copy(), cm:copy(), cm:getdiag()
    for i = nr, 1, -1 do
      for j = nc, 1, -1 do 
        if i ~= nr then cmref [cmref :getidx(i, j)] = cmref [cmref :getidx(i, j)] * cmref [cmref :getidx(i+1, j)] end
        if j ~= nc then cmref2[cmref2:getidx(i, j)] = cmref2[cmref2:getidx(i, j)] * cmref2[cmref2:getidx(i, j+1)] end
        if i == j and i ~= min(nr, nc) then cmref3[i] = cmref3[i] * cmref3[i+1] end
      end
    end
    assertEquals( cm:raccprod('col') , cmref  )
    assertEquals( cm:raccprod('row') , cmref2 )
    assertEquals( cm:raccprod('diag'), cmref3 )
  end
end

function TestCMatrixFunctions:testMfun() --To be further tested (when reached)
  local f = \x x*x
  local g = \x x/x
  local h = \x x+3
  for _, cm in ipairs(G.cmatidx) do 
    if cm.nrow == cm.ncol then --Square diagonlisable matrix
      local res = cm:mfun(f) - cm*cm
      assertTrue(res:ediv(cm*cm):eq(cm:same(), 23*eps)) --relative error
      assertTrue(cm:mfun(g):eq(cm:copy():eye(), eps))
      res = cm:mfun(h) - (cm+cm:copy():eye(3))
      assertTrue(res:ediv(cm*cm):eq(cm:same(), eps)) --relative error
    end
  end
end

function TestCMatrixFunctions:testEquivalence()
  local cmat = cmatrix(5):seq():map(toC)
  assertEquals(cmat:macos  (), cmat:mfun(acos  ))
  assertEquals(cmat:macosh (), cmat:mfun(acosh )) 
  assertEquals(cmat:macot  (), cmat:mfun(acot  )) 
  assertEquals(cmat:macoth (), cmat:mfun(acoth )) 
  assertEquals(cmat:masin  (), cmat:mfun(asin  ))
  assertEquals(cmat:masinh (), cmat:mfun(asinh ))
  assertEquals(cmat:masinc (), cmat:mfun(asinc ))
  assertEquals(cmat:masinhc(), cmat:mfun(asinhc))
  assertEquals(cmat:matan  (), cmat:mfun(atan  ))
  assertEquals(cmat:matanh (), cmat:mfun(atanh ))
  assertEquals(cmat:mcos   (), cmat:mfun(cos   ))
  assertEquals(cmat:mcosh  (), cmat:mfun(cosh  ))
  assertEquals(cmat:mcot   (), cmat:mfun(cot   ))
  assertEquals(cmat:mcoth  (), cmat:mfun(coth  ))
  assertEquals(cmat:mexp   (), cmat:mfun(exp   ))
  assertEquals(cmat:mlog   (), cmat:mfun(log   ))
  assertEquals(cmat:mlog10 (), cmat:mfun(log10 ))
  assertEquals(cmat:msin   (), cmat:mfun(sin   ))
  assertEquals(cmat:msinc  (), cmat:mfun(sinc  ))
  assertEquals(cmat:msinh  (), cmat:mfun(sinh  ))
  assertEquals(cmat:msinhc (), cmat:mfun(sinhc ))
  assertEquals(cmat:msqrt  (), cmat:mfun(sqrt  ))
  assertEquals(cmat:mtan   (), cmat:mfun(tan   ))
  assertEquals(cmat:mtanh  (), cmat:mfun(tanh  ))
end

function TestCMatrixFunctions:testDiagonalMapping()
  local cmat1 = cvector(5):seq(1.1):diag():map(toC)
  local cmat2 = cvector(5):fill(linspace(-pi/4, pi/4, 5)):diag():map(toC)
  assertTrue(cmat2:macos  ():eq(cmat2:copy():map(cmat2:getdidx(), acos  ), eps   ))
  assertTrue(cmat1:macosh ():eq(cmat1:copy():map(cmat1:getdidx(), acosh )        ))
  assertTrue(cmat1:macot  ():eq(cmat1:copy():map(cmat1:getdidx(), acot  ), eps   ))
  assertTrue(cmat1:macoth ():eq(cmat1:copy():map(cmat1:getdidx(), acoth ), eps   ))
  assertTrue(cmat2:masin  ():eq(cmat2:copy():map(cmat2:getdidx(), asin  )        ))
  assertTrue(cmat2:masinh ():eq(cmat2:copy():map(cmat2:getdidx(), asinh ), eps   ))
  assertTrue(cmat2:masinc ():eq(cmat2:copy():map(cmat2:getdidx(), asinc )        ))
  assertTrue(cmat2:masinhc():eq(cmat2:copy():map(cmat2:getdidx(), asinhc), eps   ))
  assertTrue(cmat2:matan  ():eq(cmat2:copy():map(cmat2:getdidx(), atan  )        ))
  assertTrue(cmat2:matanh ():eq(cmat2:copy():map(cmat2:getdidx(), atanh ), eps   ))
  assertTrue(cmat2:mcos   ():eq(cmat2:copy():map(cmat2:getdidx(), cos   )        ))
  assertTrue(cmat2:mcosh  ():eq(cmat2:copy():map(cmat2:getdidx(), cosh  )        ))
  assertTrue(cmat1:mcot   ():eq(cmat1:copy():map(cmat1:getdidx(), cot   ), 16*eps))
  assertTrue(cmat1:mcoth  ():eq(cmat1:copy():map(cmat1:getdidx(), coth  ), eps   ))
  assertTrue(cmat2:mexp   ():eq(cmat2:copy():map(cmat2:getdidx(), exp   )        )) 
  assertTrue(cmat1:mlog   ():eq(cmat1:copy():map(cmat1:getdidx(), log   )        )) 
  assertTrue(cmat1:mlog10 ():eq(cmat1:copy():map(cmat1:getdidx(), log10 ), eps   )) 
  assertTrue(cmat2:msin   ():eq(cmat2:copy():map(cmat2:getdidx(), sin   )        ))
  assertTrue(cmat2:msinc  ():eq(cmat2:copy():map(cmat2:getdidx(), sinc  )        ))
  assertTrue(cmat2:msinh  ():eq(cmat2:copy():map(cmat2:getdidx(), sinh  )        ))
  assertTrue(cmat2:msinhc ():eq(cmat2:copy():map(cmat2:getdidx(), sinhc )        ))
  assertTrue(cmat1:msqrt  ():eq(cmat1:copy():map(cmat1:getdidx(), sqrt  )        ))
  assertTrue(cmat2:mtan   ():eq(cmat2:copy():map(cmat2:getdidx(), tan   ), eps   ))
  assertTrue(cmat2:mtanh  ():eq(cmat2:copy():map(cmat2:getdidx(), tanh  ), eps   ))
end

-- symplectic matrix ----------------------------------------------------------o

function TestCMatrixErr:testSympconj()
  local msg = {
   "invalid argument #1 (2n matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth,'sympconj', cmatrix(3)   )
  assertErrorMsgContains( msg[1], mth,'sympconj', cmatrix(4,3) )
  assertErrorMsgContains( msg[1], mth,'bar', cmatrix(3)   )
  assertErrorMsgContains( msg[1], mth,'bar', cmatrix(4,3) )
end

function TestCMatrixSympl:testSympconj()
  local mat = {
    cmatrix{{1,1},{0,1}}:map\x x+x/2i,
    cmatrix{{1,0},{0,1}}:map\x x+x/2i,
    cmatrix{{1,0},{1,1}}:map\x x+x/2i,
    cmatrix{{0,1},{1,0}}:map\x x+x/2i,
    cmatrix{{0,1},{1,1}}:map\x x+x/2i,
    cmatrix{{1,1},{1,0}}:map\x x+x/2i,
  }
  for _,M in ipairs(mat) do
    local J = M:same():symp()
    local R = -J*M:t()*J
    assertEquals( M:sympconj(), R )
    assertEquals( M:bar     (), R )
    local Rcpy = R:same()
    M:bar(Rcpy) --Test r_
    assertEquals( Rcpy, R )
    M:bar("in") --Test in
    assertEquals( M, R )
  end

  for i=2,10,2 do
    local J =  matrix(i):symp()
    local M = cmatrix(i):fill(1..i*i):map\x x+x/2i
    local R = -J*M:t()*J
    local Mcpy = M:copy()
    assertEquals( M:sympconj( ), R )
    assertEquals( M:sympconj(M), R ) -- in place
    assertEquals( Mcpy:bar  ( ), R )
    assertEquals( Mcpy:bar  (M), R ) -- in place
  end
end

function TestCMatrixErr:testSymperr()
  local msg = {
    "invalid argument #1 (2n matrix expected)"       ,
    "invalid argument #2 (different matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth,'symperr', cmatrix(3)   )
  assertErrorMsgContains( msg[1], mth,'symperr', cmatrix(4,3) )
end

function TestCMatrixSympl:testSymperr()
  for i=2,10,2 do
    local J =  matrix(i):symp()
    local M = cmatrix(i):fill(1..i*i):map\x x+x/2i
    local R = M:t()*J*M - J
    assertEquals( M:symperr(), R:norm() ) -- M' J M - J
  end
  local smat = { cmatrix{{1,0},{0,1}},
                 cmatrix{{1,0},{1,1}},
                 cmatrix{{1,1},{0,1}}, }
  for _,M in ipairs(smat) do
    assertEquals( M:symperr(), 0 )
  end
end

function TestCMatrixErr:testSymplectify() end
function TestCMatrixSympl:testSymplectify() end

-- mean, variance, horners method --------------------------------------------o
function TestCMatrix:testMean()
  for _,cm in ipairs(G.cmatidx) do
    assertEquals( cm:mean(), cm:sum()/#cm )
  end
end

function TestMatrix:testVariance()
  for _,cm in ipairs(G.cmatidx) do
    local mean = cm:mean()
    local sum = 0
    for _, val in ipairs(cm) do 
      sum = sum + (val - mean)^2
    end
    local sz = #cm > 1 and #cm - 1 or #cm
    assertEquals( cm:variance(), sum / sz) 
    assertEquals( cm:variance(), (cm - cm:mean()):sumsqr()/ sz )
  end
end

function TestCMatrix:testKsum() 
  for _,cm in ipairs(G.cmatidx) do
    local cmpi = cm:copy() * 10000
    cmpi[1] = pi
    local sum = 0
    local c = 0 -- error 
    for _, val in ipairs(cmpi) do 
      local t = sum + val
      c = c - ((t - sum) - val)
      sum = t
    end
    local res = cmpi:ksum()
    if sum + c ~= sum then --Check that sum is small enough to have the effect from c
      assertNotEquals(res, sum)   --Check that ksum is not just the sum
      if abs(res - sum) > abs(c) then assertTrue(abs(res - sum) < 2*abs(c)) --from C, if c is greater than the min float of sum, then it will become 2* the min float
      else                       assertTrue(abs(res - sum) <=  abs(c)) --In this case, the c in C is the min float of sum 
      end
    end
  end
  local cm = matrix({1, 10^100, 1, -10^100})
  assertEquals(cm:ksum(), 2)
  assertNotEquals(cm:sum(), 2) --checking sum is better than ksum
end

function TestCMatrix:testKdot() --using dot for final test also works?
  for _,cm in ipairs(G.cmatidx) do
    local cmpi = cm:copy() * 10000
    cmpi[1] = pi
    assertEquals(cmpi:emul(cmpi):ksum(), cmpi:kdot(cmpi))
  end
  local cm1 = cmatrix({1, 10^50, 1, -10^50}):map(toC)
  local cm2 = cmatrix({1, 10^50, 1,  10^50}):map(toC)
  assertEquals(cm1:kdot(cm2), 4i) --(1+1i)^2 = 2i
end

function TestCMatrix:testEval() --Algorthm adapted from www.geeksforgeeks.org/horners-method-algorithm/
  for _,cm in ipairs(G.cmatidx) do
    for _, x0 in ipairs({1 + 1i,2 + 2i,3 + 3i,4 + 4i,5 + 5i}) do
      local result = cm[#cm]
      for i = #cm-1, 1, -1 do
        result = result *x0 + cm[i]
      end
      assertEquals(cm:eval(x0), result)
    end
  end
end


-- conjugate, transpose -------------------------------------------------------o

function TestCMatrixLinAlg:testConjugate()
  for _,cm in ipairs(G.cmatidx) do
    assertEquals( cm:conj(), cm:copy():map(\x x:real()-x:imag()*1i) )
  end
  for _,cm in ipairs(G.cmattmp) do
    assertEquals( cm:conj(), cm:copy():map(\x x:real()-x:imag()*1i) )
  end
end

function TestCMatrixLinAlg:testTranspose()
  for _,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    local cmc = cm:copy()
    assertEquals( {cm:t():sizes()}, {nc,nr}          )
    assertEquals(  cm:t()   :t()  , cm               )
    assertEquals( (cm + cmc):t()  , cm:t() + cmc:t() )
    assertEquals( (2  * cm ):t()  , 2 * cm:t()       )
    if nr == nc then
      assertEquals( (cm*cmc):t(), cm:t()*cmc:t() )
      cmc:t('in')     for i=1,nr do for j=1,nc do assertEquals( cmc:get(i,j), cm:conj():get(j,i) ) end end
    end
    cmc = cm:t()      for i=1,nr do for j=1,nc do assertEquals( cmc:get(i,j), cm:conj():get(j,i) ) end end
    cmc = cm:t(false) for i=1,nr do for j=1,nc do assertEquals( cmc:get(i,j), cm       :get(j,i) ) end end
  end
end

function TestCMatrixLinAlg:testTrace()
  for _,cm in ipairs(G.cmatidx) do
    assertEquals( cm:tr(), cm:getdiag():sum() )
  end
end

-- inner, cross, mixed, outer -------------------------------------------------o

function TestCMatrixErr:testInner()
  local msg = {
    "invalid argument #2 (matrix expected)",
    "incompatible matrix sizes"            ,
  }
  assertErrorMsgContains( msg[1], mth, 'inner', errCMat, nil              )
  assertErrorMsgContains( msg[1], mth, 'inner', errCMat, ''               )
  assertErrorMsgContains( msg[1], mth, 'inner', errCMat, 1                )
  assertErrorMsgContains( msg[1], mth, 'inner', errCMat, 1..2             )
  assertErrorMsgContains( msg[1], mth, 'inner', errCMat, {}               )
  assertErrorMsgContains( msg[2], mth, 'inner', errCMat, errCMat, errCMat )
end

function TestCMatrixLinAlg:testInner()
  -- inner prod:  u'.v = |u|.|v| cos(u^v)
  for _,cm in ipairs(G.cmatidx) do
    local mres, mref
    local cmc = cm:copy()
    mres =  cm:inner(cmc)
    mref = (cm:t() * cmc):getdiag():t():sum()
    assertEquals( mres, mref)
    mres =  cm:inner(cmc,'tr')
    mref = (cm:t() * cmc):tr()
    assertEquals( mres, mref )
  end
end

function TestCMatrixErr:testOuter()
  local cm = cmatrix(2,1)
  local msg = {
    "invalid argument #2 (matrix expected)",
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'outer', cm          , nil          )
  assertErrorMsgContains( msg[1], mth, 'outer', cm          , ''           )
  assertErrorMsgContains( msg[1], mth, 'outer', cm          , {}           )
  assertErrorMsgContains( msg[1], mth, 'outer', cm          , 1            )
  assertErrorMsgContains( msg[1], mth, 'outer', cm          , 1..2         )
  assertErrorMsgContains( msg[2], mth, 'outer', cmatrix(1,2), cmatrix(2,2) )
end

function TestCMatrixLinAlg:testOuter()
  -- x * y:t() without temporary
  for nr=1,5 do
    local cm1 = cvector(nr):fill(1..2*nr..2):map(toC)
    local cm2 = cvector(nr):fill(1..  nr)   :map(toC)
    assertEquals( cm1:outer(cm2), cm1*cm2:t() )
  end
end

function TestCMatrixErr:testCross()
  local cm = cmatrix(3)
  local msg = {
    "invalid argument #2 (matrix expected)",
    "invalid matrix sizes"                 ,
  }
  assertErrorMsgContains( msg[1], mth, 'cross', cm     , nil  )
  assertErrorMsgContains( msg[1], mth, 'cross', cm     , ''   )
  assertErrorMsgContains( msg[1], mth, 'cross', cm     , 1    )
  assertErrorMsgContains( msg[1], mth, 'cross', cm     , 1..2 )
  assertErrorMsgContains( msg[1], mth, 'cross', cm     , {}   )
  assertErrorMsgContains( msg[2], mth, 'cross', errCMat, cm   )
end

function TestCMatrixLinAlg:testCross()
  -- cross prod:  uxv = |u|.|v| sin(u^v) \vec{n}
  local cm1 = cmatrix(3):fill(0..8):map(toC)   -- skew-symmetric matrix
  local cm2 = cvector {2,-4,2}:map(toC)
  local cm3 = cm2:copy()
  assertEquals( cm2:cross(cm3), cm1*cm3 )
  for nc=1,5 do
    cm1 = cmatrix(3,nc):fill(1   ..3*nc    ):map(toC)
    cm2 = cm1:copy()   :fill(3*nc..1   ..-1):map(toC)
    cm3 = cm2:copy()
    assertEquals(    cm1 :cross(cm2)    ,-cm2  :cross( cm1)                )
    assertEquals(    cm1 :cross(cm2+cm3), cm1  :cross( cm2)+cm1:cross(cm3) )
    assertEquals( (2*cm1):cross(cm2)    , cm1  :cross( cm2*2)              )
    assertEquals( (2*cm1):cross(cm2)    , 2*cm1:cross( cm2)                )
    assertEquals( (2*cm1):cross(cm2)    , 2*cm1:cross( cm2)                )
    if nc == 3 then
      assertEquals( cm1:cross( cm2:cross(cm3) ), cm2*(cm1*cm3)-cm3*(cm1*cm2)  )
    end
  end
end

function TestCMatrixErr:testMixed()
  local msg = {
    "invalid argument #2 (matrix expected)",
    "invalid argument #3 (matrix expected)",
    "invalid matrix sizes"                 ,
    "incompatible matrix sizes"            ,
  }
  local cm1 = cmatrix(3,1)
  assertErrorMsgContains( msg[1], mth, 'mixed', cm1         , nil                        )
  assertErrorMsgContains( msg[1], mth, 'mixed', cm1         , ''                         )
  assertErrorMsgContains( msg[1], mth, 'mixed', cm1         , 1                          )
  assertErrorMsgContains( msg[1], mth, 'mixed', cm1         , 1..2                       )
  assertErrorMsgContains( msg[1], mth, 'mixed', cm1         , {}                         )
  assertErrorMsgContains( msg[2], mth, 'mixed', cm1         , cm1         , nil          )
  assertErrorMsgContains( msg[2], mth, 'mixed', cm1         , cm1         , ''           )
  assertErrorMsgContains( msg[2], mth, 'mixed', cm1         , cm1         , 1            )
  assertErrorMsgContains( msg[2], mth, 'mixed', cm1         , cm1         , 1..2         )
  assertErrorMsgContains( msg[2], mth, 'mixed', cm1         , cm1         , {}           )
  assertErrorMsgContains( msg[3], mth, 'mixed', cmatrix(2,1), cm1         , cm1          )
  assertErrorMsgContains( msg[4], mth, 'mixed', cmatrix(3,2), cm1         , cm1          )
  assertErrorMsgContains( msg[4], mth, 'mixed', cm1         , cmatrix(2,1), cm1          )
  assertErrorMsgContains( msg[4], mth, 'mixed', cm1         , cmatrix(3,2), cm1          )
  assertErrorMsgContains( msg[4], mth, 'mixed', cm1         , cm1         , cmatrix(2,1) )
  assertErrorMsgContains( msg[4], mth, 'mixed', cm1         , cm1         , cmatrix(3,2) )
end

function TestCMatrixLinAlg:testMixed()
  -- x:cross(y):inner(z) without temporary
  for nc=1,5 do
    local cm1 = cmatrix(3,nc):fill(1   ..3*nc  ):map(toC)
    local cm2 = cm1:same()   :fill(3*nc..1.. -1):map(toC)
    local cm3 = cm1:same()   :fill(1)           :map(toC)
    assertEquals( cm1:mixed(cm2,cm3), cm1:cross(cm2):inner(cm3) )
  end
end

-- norm, unit, center, angle (in place) ---------------------------------------o

function TestCMatrixLinAlg:testNorm() --|u| = sqrt(u'.u), forbidius norm
  for _,cm in ipairs(G.cmatidx) do
    assertEquals( cm:norm(), sqrt(cm:map(\x x^2):sumabs()) )
  end
end

function TestCMatrixErr:testDistance()
  local msg = {
    "invalid argument #2 (cmatrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'dist', errCMat, nil  )
  assertErrorMsgContains( msg[1], mth, 'dist', errCMat, 1..2 )
  assertErrorMsgContains( msg[1], mth, 'dist', errCMat, ''   )
  assertErrorMsgContains( msg[1], mth, 'dist', errCMat, {}   )
end

function TestCMatrixLinAlg:testDist()
  --sqrt( trace((A-B) * (A-B)') )
  for _,cm in ipairs(G.cmatidx) do
    local mn  = #cm
    local cmc = cm:copy()
    local cm2 = cm:same():fill(mn..1..-1):map(toC)
    assertEquals( cm:dist(cmc), sqrt( ( (cm-cmc)*(cm-cmc):t() ):tr()):real() )
    assertEquals( cm:dist(cm2), sqrt( ( (cm-cm2)*(cm-cm2):t() ):tr()):real() )
  end
end

function TestCMatrixErr:testUnit()
  local msg = {
    "null matrix norm",
  }
  assertErrorMsgContains( msg[1], mth, 'unit', cmatrix(2) )
end

function TestCMatrixLinAlg:testUnit()  --  unit :  u / |u|
  for _,cm in ipairs(G.cmatidx) do
    assertEquals( cm:copy():unit(), cm / cm:norm() )
  end
end

function TestCMatrixLinAlg:testCenter()
  for _,cm in ipairs(G.cmatidx) do
    local mid = cm:sum() / #cm
    assertEquals( cm:center(),  cm:map(\x x-mid) )
    local centeredrow, centeredcol, cmc = cm:copy(), cm:copy(), cm:same()
    for i = 1, cm.nrow do 
      local row = centeredrow:getsub(i)
      centeredrow:setsub(i, nil, row - row:mean())
    end
    for i = 1, cm.ncol do 
      local col = centeredcol:getsub(nil, i)
      centeredcol:setsub(nil, i, col - col:mean())
    end
    assertEquals( cm:center("row"), centeredrow)
    assertEquals( cm:center("col"), centeredcol)
    cm:center(cmc)
    assertEquals( cm:center("vec"), cmc) --check r_
  end
end

function TestCMatrixErr:testAngle()
  local msg = {
    "null vector norm",
  }
  assertErrorMsgContains( msg[1], mth, 'angle', cvector{1,1,1}, cvector{0,0,0} )
  assertErrorMsgContains( msg[1], mth, 'angle', cvector{0,0,0}, cvector{1,1,1} )
end

function TestCMatrixLinAlg:testAngle()
  -- angle:  u^v = acos(u'.v / |u|.|v|)  in [0,pi] (or [-pi,pi] if n)
  local rad = \i,n -> pi*(i-1)/n
  local function unitVectors(n1, n2, r)
    local v = {}
    if is_nil(r) then r=1 end
    for i = 1, n1 do
      local a = rad(i, n1)
      v[i]={}
      for j = 1, n2 do
        local b = rad(j,n2)
        local x = r * cos(a) * sin(b)
        local y = r * sin(a) * sin(b)
        local z = r * cos(b)
        v[i][j] = cvector{x,y,z}
      end
    end
    return v
  end

  local n, m = 16, 16
  for i,t in ipairs( unitVectors( m, n ) ) do
  for j,v in ipairs( t ) do
    assertAlmostEquals( cvector{0,0,1}:angle( v ):real() - rad(j, n), 0, 3*eps )
    assertEquals      ( cvector{0,0,1}:angle( v ):imag(), 0 )
  end
  end
  assertAlmostEquals( cvector{1,0,0}:angle(cvector{ 1, 1, 0}):real(), pi/4  , eps )
  assertAlmostEquals( cvector{1,0,1}:angle(cvector{ 1, 1, 0}):real(), pi/3  , eps )
  assertEquals      ( cvector{1,0,0}:angle(cvector{ 1, 0, 0}), 0      + 0i        )
  assertEquals      ( cvector{1,0,0}:angle(cvector{ 0, 1, 0}), pi/2   + 0i        )
  assertEquals      ( cvector{1,0,0}:angle(cvector{-1,-1, 0}), 3*pi/4 + 0i        )
  assertEquals      ( cvector{1,0,0}:angle(cvector{-1, 0, 0}), pi     + 0i        )
  assertEquals      ( cvector{0,0,1}:angle(cvector{ 0, 0, 1}), 0      + 0i        )
  assertEquals      ( cvector{0,0,1}:angle(cvector{ 0, 0,-1}), pi     + 0i        )
end

-- operators ------------------------------------------------------------------o

function TestCMatrixOps:testUnm()
  for _,cm in ipairs(G.cmatidx) do
    local mn = #cm
    local cmref = cm:same():fill(-1..-mn..-1):map(\x x+x*1i)
    assertEquals( -cm      , cmref )
    assertEquals(  cm:unm(), cmref )
  end
end

function TestCMatrixOps:testInv() --This uses the result from matlab (although, for singular matrices we get different results)
  for i, cm in ipairs(G.cmatidx) do
    if datC.invRes[i] then
      assertTrue(cm:inv():eq(datC.invRes[i], 8*eps))
    end
  end
end

function TestCMatrixOps:testPow()
  for i, cmat in ipairs(G.cmatidx) do
      if cmat.ncol == cmat.nrow then
        --identity check
        local identity = cmatrix(cmat.nrow, cmat.ncol):eye()
        assertEquals(cmat^0,identity)
        assertEquals(cmat^-0, identity)
        --Positive power check
        local cmatExp = cmat:copy()
        for n = 1,9 do 
          assertEquals(cmat^n, cmatExp)
          cmatExp = cmatExp * cmat 
        end
        --Negative power check
        local invMat = datC.invRes[i]
        if invMat then 
          cmatExp = invMat:copy()
          for n = 1,10 do
            assertTrue(cmatExp:eq(cmat^-n, 23*eps*cmatExp:maxabs())) --Rel error
            cmatExp = cmatExp * invMat 
          end
        end
      end
  end
end

function TestCMatrixErr:testEq()
  local errCMat = matrix(2):fill(1..4)
  local msg = {
    "invalid argument #3 (number expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'eq', errCMat, cmatrix(1), '' )
  assertErrorMsgContains( msg[1], mth, 'eq', errCMat, cmatrix(1), {} )
end

function TestCMatrixOps:testEq()
  for _,cm in ipairs(G.cmatidx) do
    local m = matrix(cm:sizes())
    assertTrue ( m         == cm:same() ) -- mat  == cmat
    assertTrue ( cm:same() == m:copy()  ) -- cmat == mat
    -- f defined
    assertTrue ( cm       :eq( cm:map(\x x+eps*1i    )         ,   eps) )
    assertTrue ( cm       :eq( cm:map(\x x+eps*(1+1i))         , 2*eps) )
    assertTrue ( cm:imag():eq( cm:map(\x x+eps*1i    ):imag()  ,   eps) )
    assertTrue ( cm:real():eq( cm:map(\x x+eps*1i    ):real()  ,   eps) )
  end
  -- f as function
  local  m =  matrix(2)
  local cm = cmatrix(2)
  assertTrue (  0        == cm:same()         ) -- num  == cmat
  assertFalse(  0        == cm:same():fill(1) )
  assertTrue (  0+0i     ==  m:same()         ) -- cpx  == mat
  assertFalse(  1+0i     ==  m:same()         )
  assertTrue (  0+0i     == cm:same()         ) -- cpx  == cmat
  assertFalse(  0+1i     == cm:same()         )
  assertTrue ( cm:same() == 0                 ) -- cmat == num
  assertTrue ( cm:same() == 0+0i              ) -- cmat == cpx
end

function TestCMatrixErr:testAdd()
  local msg = {
    "invalid 'cmat + ?' operation",
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'add', errCMat, ''               )
  assertErrorMsgContains( msg[1], mth, 'add', errCMat, nil              )
  assertErrorMsgContains( msg[1], mth, 'add', errCMat, 1..4             )
  assertErrorMsgContains( msg[2], mth, 'add', errCMat, cmatrix(1)       )
  assertErrorMsgContains( msg[2], mth, 'add', errCMat, cmatrix(3)       )
  assertErrorMsgContains( msg[2], mth, 'add', errCMat, cmatrix(2), {}   )
  assertErrorMsgContains( msg[2], mth, 'add', errCMat, cmatrix(2), 1..4 )
end

function TestCMatrixOps:testAdd()
  for _,cm in ipairs(G.cmatidx) do
    local mn  = #cm
    local cmc = cm:copy()
    local m   = matrix(cm:sizes()):fill(1..mn)
    assertEquals( 2  + cm        , cmc:map(\x x+2       ) ) -- num  + cmat => num  + cvec
    assertEquals( cm + 2         , cmc:map(\x x+2       ) ) -- cmat + num  => cvec + num
    assertEquals( cm + cmc       , cmc:map(\x x*2       ) ) -- cmat + cmat => cvec + cvec
    assertEquals( cm + cmc:imag(), cmc:map(\x x+x:imag()) )
    assertEquals( cm + 2i        , cmc:map(\x x+2i      ) ) -- cmat + cpx  => cvec + cpx
    assertEquals( cm + m         , cmc:map(\x x+x:real()) ) -- cmat + mat  => cvec + vec
  end
end

function TestCMatrixOps:testAddCpx()
  for _,cm in ipairs(G.cmatidx) do
    local cmres = 2i + cm
    assertEquals( cmres, cm:copy():map(\x x+2i) ) -- cpx + cmat => cpx + cvec
  end
end

function TestCMatrixErr:testSub()
  local msg = {
    "invalid 'cmat - ?' operation",
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'sub', errCMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'sub', errCMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'sub', errCMat, 1..4      )
  assertErrorMsgContains( msg[2], mth, 'sub', errCMat, matrix(1) )
  assertErrorMsgContains( msg[2], mth, 'sub', errCMat, matrix(3) )
end

function TestCMatrixOps:testSub()
  for _,cm in ipairs(G.cmatidx) do
    local mn  = #cm
    local cmc = cm:copy()
    local m   = matrix(cm:sizes()):fill(1..mn)
    assertEquals( cm - cmc          , cm :same()              ) -- cmat - cmat => cvec - cvec
    assertEquals( cm - cmc:imag()*1i, cmc:real()              )
    assertEquals( 2  - cm           , cmc:map(\x 2-x        ) ) -- num  - cmat => num  - cvec
    assertEquals( cm - 2            , cmc:map(\x x-2        ) ) -- cmat - num  => cvec + -num
    assertEquals( cm - 2i           , cmc:map(\x x-2i       ) ) -- cmat - cpx  => cvec + -cpx
    assertEquals( cm - m            , cmc:map(\x x:imag()*1i) ) -- cmat - mat  => cvec -  vec
  end
end

function TestCMatrixOps:testSubCpx()
  for _,cm in ipairs(G.cmatidx) do
    local cmres = 2i - cm
    assertEquals( cmres, cm:copy():map(\x 2i-x) ) -- cpx - cmat => cpx - cvec
  end
end

function TestCMatrixErr:testMul()
  local msg = {
    "invalid 'cmat * ?' operation",
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'mul', errCMat    , ''          )
  assertErrorMsgContains( msg[1], mth, 'mul', errCMat    , nil         )
  assertErrorMsgContains( msg[1], mth, 'mul', errCMat    , 1..4        )
  assertErrorMsgContains( msg[2], mth, 'mul', matrix(2,1), matrix(2,1) )
  assertErrorMsgContains( msg[2], mth, 'mul', matrix(1,2), matrix(1,1) )
  assertErrorMsgContains( msg[2], mth, 'mul', matrix(1,2), matrix(3,1) )
end

local function refMul(m1, m2, i, j )
  local mref = cmatrix(m1.nrow, m2.ncol)
  for i=1,m1.nrow do
  for j=1,m2.ncol do
    local x = 0
    for ii=1,m1.ncol
      do x = x + m1:get(i,ii) * m2:get(ii,j)
    end
    mref:set(i,j,x)
  end end
  return mref
end

function TestCMatrixOps:testMul()
  for _,cm in ipairs(G.cmatidx) do
    local mn, nr, nc, _ = #cm, cm:sizes()
    for j=1,5 do
      local cm2 = cm:same(nc,j):fill(1..nc*j):map(toC)
      local m   = matrix(nc,j)    :fill(1..nc*j)
      assertEquals( j  * cm  , cm:same():fill(j..mn*j..j):map(toC) ) -- num  * cmat => num  * cvec
      assertEquals( cm * j   , cm:same():fill(j..mn*j..j):map(toC) ) -- cmat * num  => cvec * num
      assertEquals( cm * j*1i, cm:copy():map(\x x*j*1i  )          ) -- cmat * cpx  => cvec * cpx
      assertEquals( cm * cm2 , refMul(cm,cm2)                      ) -- cmat * cmat
      assertEquals( cm * m   , refMul(cm,m  )                      ) -- cmat * mat
    end
  end
end

function TestCMatrixOps:testMulCpx()
  for _,cm in ipairs(G.cmatidx) do
    local mref = 2i * cm
    assertEquals( mref, cm:copy():map(\x x*2i) )
  end
end

function TestCMatrixErr:testTmul()
  local msg = {
    "invalid 'cmat^t * ?' operation",
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'tmul', errCMat     , ''           )
  assertErrorMsgContains( msg[1], mth, 'tmul', errCMat     , nil          )
  assertErrorMsgContains( msg[1], mth, 'tmul', errCMat     , 1..4         )
  assertErrorMsgContains( msg[2], mth, 'tmul', cmatrix(2,1), cmatrix(1,2) )
  assertErrorMsgContains( msg[2], mth, 'tmul', cmatrix(1,2), cmatrix(3,1) )
end

function TestCMatrixOps:testTmul()
  for _,cm in ipairs(G.cmatidx) do
    local nr, _ = cm.nrow
    for i=1,5 do
      local m   =  matrix(nr,i   ):fill(1..nr*i)
      local cm2 = cm:same(nr,i, 0i):fill(1..nr*i):map(toC)
      assertEquals( cm:tmul(m  ), refMul(cm:t(),m  ) ) -- cmat' * mat
      assertEquals( cm:tmul(cm2), refMul(cm:t(),cm2) ) -- cmat' * cmat
    end
  end
end

function TestCMatrixErr:testMult()
  local msg = {
    "invalid 'cmat * ?^t' operation",
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'mult', errCMat     , ''           )
  assertErrorMsgContains( msg[1], mth, 'mult', errCMat     , nil          )
  assertErrorMsgContains( msg[1], mth, 'mult', errCMat     , 1..4         )
  assertErrorMsgContains( msg[2], mth, 'mult', cmatrix(2,1), cmatrix(1,2) )
  assertErrorMsgContains( msg[2], mth, 'mult', cmatrix(1,2), cmatrix(3,1) )
end

function TestCMatrixOps:testMult()
  for _,cm in ipairs(G.cmatidx) do
    local nr, _ = cm.ncol
    for i=1,5 do
      local m   =  matrix(i ,nr   ):fill(1..nr*i)
      local cm2 = cm:same(i ,nr,0i):fill(1..nr*i)
      assertEquals( cm:mult(m  ), refMul(cm, m  :t()) ) -- cmat * mat'
      assertEquals( cm:mult(cm2), refMul(cm, cm2:t()) ) -- cmat * cmat'
    end
  end
end

function TestCMatrixErr:testDiv()
  local msg = {
    "invalid 'cmat / ?' operation",
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'div', errCMat     , ''           )
  assertErrorMsgContains( msg[1], mth, 'div', errCMat     , nil          )
  assertErrorMsgContains( msg[1], mth, 'div', errCMat     , 1..4         )
  assertErrorMsgContains( msg[2], mth, 'div', cmatrix(2,1), cmatrix(1,2) )
  assertErrorMsgContains( msg[2], mth, 'div', cmatrix(1,2), cmatrix(3,1) )
end

function TestCMatrixOps:testDiv()
  for _,cm in ipairs(G.cmatidx) do
    local mn, nr, nc = #cm, cm:sizes()
    local cmc = cm:copy():random(randomseed(2))
    local m   = matrix(nr,nc):fill(1..mn)
    if nr == nc then
      assertTrue( (cmc * (1/cmc)):eq( cmc:copy():eye(), 8*eps) )  -- num / cmat
    else
      local rs, ru, rv, info = cmc:svd()
      rs = cmc:same():setdiag( rs:map(\x 1/x) ):t(false)
      local ref = rv * rs * ru:t() -- M = V*S: reciprocal():t()*U'
      local res = 1/cmc
      for i=1,#res do
        assertAlmostEquals( (res:geti(i) - ref:geti(i)).re, 0, 32*eps )
        assertAlmostEquals( (res:geti(i) - ref:geti(i)).im, 0, 32*eps )
      end
    end
    assertEquals(  cm / 2 , cm:copy():map(\x  x/2   )       ) -- cmat / num
    assertEquals(  cm / 2i, cm:copy():map(\x -x/2*1i)       ) -- cmat / cpx
    assertTrue  ( (cm / cm):eq(cm:copy()*1/cm        , eps) ) -- cmat / cmat
    assertTrue  ( (cm / m ):eq(cm:copy()*1/m         , eps) ) -- cmat / mat
  end
end

function TestCMatrixOps:testDivCpx()
  for _,cm in ipairs(G.cmatidx) do
    local mref = 2i / cm
    assertTrue( mref:eq( 2i*1/cm, 2*eps) )
    assertTrue( is_cmatrix(mref) )
  end
end

function TestCMatrixErr:testKadd()
  local msg = {
    "incompatible number of coefficients",
    "incompatible matrix size"           ,
    "incompatible matrix type"           ,
    "too many matrices"                  ,
    "invalid argument #1 (iterable expected)",
    "invalid argument #2 (iterable expected)",
  }
  local t = {} for i=1,21 do t[i]=cmatrix(2) end
  assertErrorMsgContains( msg[1], mth, 'kadd', cmatrix(2), vector(2), {cmatrix(2)            } )
  assertErrorMsgContains( msg[2], mth, 'kadd', cmatrix(2), vector(2), {cmatrix(2),cmatrix(3) } )
  assertErrorMsgContains( msg[3], mth, 'kadd', cmatrix(2), vector(2), { matrix(2), matrix(3) } )
  assertErrorMsgContains( msg[4], mth, 'kadd', cmatrix(2), vector(2), t                        )
  assertErrorMsgContains( msg[5], mth, 'kadd', cmatrix(2),        3 , vector(2)                )
  assertErrorMsgContains( msg[1], mth, 'kadd', cmatrix(2),       {3}, vector(2)                )
end

function TestCMatrixOps:testKadd()
  local l = {1,3,5,7,11,13,17,19}
  for _,cm in ipairs(G.cmatidx) do
    local cm1  = cm:copy()
    local x, a = {}, {}
    for j=1,#l do
      local sum = cvector(l[j]):fill(1..l[j]):map(\x x*1i):sum()
      for i=1,l[j] do x[i], a[i] = cm:copy(), i*1i end
      assertEquals( cm1:kadd(a,x), cm1:same():fill(1..#cm):map(\x sum*x*(1+1i)) )
    end
  end
  local cm = cmatrix(2):fill(1..4):map(toC)
  local x  = { cm:copy(), cm:copy() }
  local a  = { 1, 1i }
  assertTrue  ( is_cmatrix(cm:kadd(a,x)) )
  assertEquals( cm:kadd(a,x), cm:copy()  )
end

function TestCMatrixErr:testEmul()
  local msg = {
    "invalid 'cmat .* ?' operation",
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'emul', errCMat, ''         )
  assertErrorMsgContains( msg[1], mth, 'emul', errCMat, nil        )
  assertErrorMsgContains( msg[1], mth, 'emul', errCMat, 1..4       )
  assertErrorMsgContains( msg[2], mth, 'emul', errCMat, cmatrix(1) )
  assertErrorMsgContains( msg[2], mth, 'emul', errCMat, cmatrix(3) )
end

function TestCMatrixOps:testEmul()
  for _,cm in ipairs(G.cmatidx) do
    local mn  = #cm
    local cmc = cm:copy()
    local m   = matrix(cm:sizes()):fill(1..mn)
    assertEquals( cm:emul(cmc), cm:map2(cmc, '*') )
    assertEquals( cm:emul(m  ), cm:map2(m  , '*') )
  end
end

function TestCMatrixErr:testEdiv()
  local msg = {
    "invalid 'cmat ./ ?' operation",
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'ediv', errCMat, ''        )
  assertErrorMsgContains( msg[1], mth, 'ediv', errCMat, nil       )
  assertErrorMsgContains( msg[1], mth, 'ediv', errCMat, 1..4      )
  assertErrorMsgContains( msg[2], mth, 'ediv', errCMat, matrix(1) )
  assertErrorMsgContains( msg[2], mth, 'ediv', errCMat, matrix(3) )
end

function TestCMatrixOps:testEdiv()
  for _,cm in ipairs(G.cmatidx) do
    local mn  = #cm
    local cmc = cm:copy()
    local m   = matrix(cm:sizes()):fill(1..mn)
    assertEquals( cm:ediv(cmc), cm:map2(cmc, '/') )
    assertEquals( cm:ediv(m  ), cm:map2(m  , '/') )
   end
end

function TestCMatrixOps:testEmod()
  for _,cm in ipairs(G.cmatidx) do
    local mn = #cm
    local cmc = cm:copy()
    local cm2 = cm:same(0i):fill(1..mn):map(\x x+x*1i)
    assertEquals( cm:emod(cmc), cm:map2(cmc, '%') )
    assertEquals( cm:emod(cm2), cm:map2(cm2, '%') )
    assertTrue  ( is_cmatrix(cm:ediv(cm2)) )
   end
end

function TestCMatrixOps:testEpow()
  for _,cm in ipairs(G.cmatidx) do
    local mn = #cm
    local cmc = cm:copy()
    local cm2 = cm:same(0i):fill(1..mn):map(\x x+x*1i)
    assertEquals( cm:epow(cmc), cm:map2(cmc, '^') )
    assertEquals( cm:epow(cm2), cm:map2(cm2, '^') )
    assertTrue  ( is_cmatrix(cm:ediv(cm2)) )
   end
end
-- linear algebra -------------------------------------------------------------o

function TestCMatrixErr:testSolve() -- TODO
  local msg = {
    "invalid input argument",
    "unexpect lapack error",
  }
end

function TestCMatrixLapack:testSolve()
  for i,m1 in ipairs(datC.solveIn1) do
    local m2 = datC.solveIn2[i]
    local m3 = datC.solveOut[i]
    local er = datC.solveTol[i]
    local rk = datC.solveRnk[i]
    local x, r = m1:solve(m2, er)
    assertTrue( r == rk )
    assertTrue( x:eq(m3, 6*eps) )
  end
end

function TestCMatrixErr:testSSolve() --TODO
  local msg = {
    "invalid input argument",
    "SSolve failed to converge",
  }
end

function TestCMatrixLapack:testSSolve()
  for i,m1 in ipairs(datC.ssolveIn1) do
    local m2 = datC.ssolveIn2 [i]
    local m3 = datC.ssolveOut1[i]
    local m4 = datC.ssolveOut2[i]
    local er = datC.ssolveTol [i]
    local rk = datC.ssolveRnk [i]
    local x, r, s = m1:ssolve(m2, er)
    assertTrue( r == rk )
    assertTrue( x:eq(m3, 12*eps) ) --Only 3 eps away for i = 1
    assertTrue( s:eq(m4, 32*eps) ) --Singular values for i = 1 have eps = 12 to 32 and i = 2 eps = 1 to 12
  end
end

function TestCMatrixErr:testGSolve() -- TODO
  local msg = {
    "invalid system sizes",
    "invalid input argument",
    "[B A] is singular, no solution found",
  }
end

function TestCMatrixLapack:testGSolve()
  for i,m1 in ipairs(datC.gsolveIn1) do
    local m2 = datC.gsolveIn2[i]
    local m3 = datC.gsolveIn3[i]
    local m4 = datC.gsolveIn4[i]
    local m5 = datC.gsolveOut[i]
    local er = datC.gsolveRes[i]
    local x, e = m1:gsolve(m2, m3, m4)
    assertAlmostEquals( e, er, eps )
    assertTrue( x:eq(m5, 10*eps) )
  end
end

function TestCMatrixErr:testGMSolve() -- TODO
  local msg = {
    "invalid system sizes",
    "invalid input argument",
    "[A B] is singular, no solution found",
  }
end

function TestCMatrixLapack:testGMSolve()
  for i,m1 in ipairs(datC.gmsolveIn1) do
    local m2 = datC.gmsolveIn2 [i]
    local m3 = datC.gmsolveIn3 [i]
    local m4 = datC.gmsolveOut1[i]
    local m5 = datC.gmsolveOut2[i]
    local er = datC.gmsolveRes [i]
    local x, y = m1:gmsolve(m2, m3)
    local e = y:norm() -- residues
    assertAlmostEquals( e, er, eps )
    assertTrue( x:eq(m4, 2*eps) )
    assertTrue( y:eq(m5, 2*eps) )
  end
end

function TestCMatrixErr:testSvd() --TODO
  local msg = {
    "invalid input argument",
    "SVD failed to converge",
  }
end

function TestCMatrixLapack:testSvd()
  for i,cm in ipairs(datC.svdIn) do
    local refU = datC.svdU[i]
    local refS = datC.svdS[i]:getdiag()
    local refV = datC.svdV[i]
    local rs, ru, rv, info = cm:svd()
    local cm1 = ru * cm:same():setdiag(rs) * rv:t() -- M = U*S*V'
    assertTrue( ru :eq(refU,   6*eps) )
    assertTrue( rs :eq(refS, 112*eps) )
    assertTrue( rv :eq(refV,   3*eps) )
    assertTrue( cm1:eq(cm  ,  32*eps) )
    local sortedTable = totable(rs)
    table.sort( sortedTable, \x,y x>y)
    assertEquals(totable(rs), sortedTable) --Check svd values are sorted (maybe unnecessary)
    assertEquals( info, 0)                 --Check that info = 0 for valid svd 
  end
end

function TestCMatrixErr:testDet()
  local msg = {
    "matrix must be square",
  }
  assertErrorMsgContains( msg[1], mth, 'det', cmatrix(2,1) )
end

function TestCMatrixLapack:testDet()
  local CM = {}
  for i=1,5 do CM[i] = cmatrix(i):random() end
  assertEquals( cmatrix(2):symp():det(), 1+0i )
  assertEquals( cmatrix(2):eye() :det(), 1+0i )
  for i,cm in ipairs(CM) do
    local cm1 = cm:same():random()
    assertAlmostEquals( ((cm*cm1)    :det() - cm:det()*cm1:det()):real(), 0,32*eps )
    assertAlmostEquals( ((cm*cm1)    :det() - cm:det()*cm1:det()):imag(), 0,32*eps )
    assertAlmostEquals( ((2*cm)      :det() - cm:det()*(2^i)    ):real(), 0,   eps )
    assertAlmostEquals( ((2*cm)      :det() - cm:det()*(2^i)    ):imag(), 0,   eps )
    assertAlmostEquals( ( cm:t(false):det() - cm:det()          ):real(), 0,16*eps )
    assertAlmostEquals( ( cm:t(false):det() - cm:det()          ):imag(), 0,16*eps )
    local det, info = cm:det()
    assertEquals(info, 0)
  end
end

function TestCMatrixErr:testEigen()
  local msg = {
    "matrix must be square"                  ,
    "invalid input argument"                 ,
    "eigen failed to compute all eigenvalues",
  }
  assertErrorMsgContains( msg[1], mth, 'eigen', cmatrix(2,1) )
  assertErrorMsgContains( msg[1], mth, 'eigen', cmatrix(1,3) )
end

function TestCMatrixLapack:testEigen()
  for i=1,5,1 do
    local cm = cmatrix(i)
    local w, info, vr, vl = cm:eigen(cm:same(), cm:same())
    assertEquals( w   , cvector(i)       )
    assertEquals( vl  , cmatrix(i):eye() )
    assertEquals( vr  , cmatrix(i):eye() )
    assertEquals( info, 0                )
  end
  for i,cm in ipairs(datC.eigenIn) do
    local w, info, vr, vl = cm:eigen(cm:same(), cm:same())
    local refD  = datC.eigenD[i]:getdiag()
    local refW  = datC.eigenW[i]:t(false) --The function returns W'
    local refV  = datC.eigenV[i]
    local diagW = cm:same():setdiag(w)
    assertTrue( w          :eq( refD                      , 64*eps) )
    assertTrue( vr         :eq( refV                      ,  4*eps) )
    assertTrue( vl         :eq( refW                      ,  4*eps) )
    assertTrue( (cm * vr)  :eq( vr    * diagW             , 64*eps) ) -- A * V - V * D
    assertTrue( (vl * cm)  :eq( diagW * vl                , 64*eps) ) -- W'* A - D * W'  <- Changed to match this formula (from matlab)
    assertAlmostEquals( w:sum():real() - cm:tr():real(), 0, 64*eps  )
    assertAlmostEquals( w:sum():imag() - cm:tr():imag(), 0, 64*eps  )
  end
end

-- FFT, convolution, correlation, covrariance ---------------------------------o
  --vector sizes: 1,2,3,4,5,7,11,13,17,19,25
  --matrix sizes: (of 2,5,7 combinations)

function TestCMatrixFFT:testFFT()
  for i,s in ipairs(datC.sv) do -- 1D
    local ref = datC.fftVOut[i]
    local res = datC.fftVIn:getsub(1..s, 1):fft()
    assertTrue( res:real():eq( ref:real(), 16*eps ) )
    assertTrue( res:imag():eq( ref:imag(), 16*eps ) ) -- linux err: 16eps
  end
  for i ,s1 in ipairs(datC.sm) do -- 2D
  for ii,s2 in ipairs(datC.sm) do
    local ref = datC.fftMOut[idx(i,ii,3)]
    local res = datC.fftMIn:getsub(1..s1, 1..s2):fft()
    assertTrue( res:real():eq( ref:real(), 16*eps ) )
    assertTrue( res:imag():eq( ref:imag(), 16*eps ) )
  end end
  local cm = dat.fftMIn:copy():map(toC)
  assertTrue(datC.fftMOutVec:reshape(cm:sizes()):eq(cm:fft("vec"), 10*eps))
  assertTrue(datC.fftMOutRow:eq(cm:fft("row"), 4*eps)        )
  local res = cmatrix(cm:sizes())
  cm:fft("col", res) --test d_ and r_
  assertTrue(datC.fftMOutCol:eq(res, 4*eps))
end

function TestCMatrixFFT:testIFFT()
  -- FFT on cmatrix input
  for i,s in ipairs(datC.sv) do -- 1D
    local ref = datC.fftVIn:getsub(1..s, 1)
    local res = ref:fft():ifft()
    assertTrue( res:real():eq( ref:real(), 4*eps ) )
    assertTrue( res:imag():eq( ref:imag(), 2*eps ) )
  end
  for i ,s1 in ipairs(datC.sm) do -- 2D
  for ii,s2 in ipairs(datC.sm) do
    local ref = dat.fftMIn:getsub(1..s1, 1..s2)
    local res = ref:fft():ifft()
    assertTrue( res:real():eq( ref:real(), 2*eps ) )
    assertTrue( res:imag():eq( ref:imag(), 2*eps ) )
  end end
  -- FFT on  matrix input
    for i,s in ipairs(dat.sv) do -- 1D
    local ref = dat.fftVIn:getsub(1..s, 1)
    local res = ref:fft():ifft()
    assertTrue( res:real():eq( ref:real(), 4*eps ) )
    assertTrue( res:imag():eq( ref:imag(),   eps ) )
  end
  for i ,s1 in ipairs(dat.sm) do -- 2D
  for ii,s2 in ipairs(dat.sm) do
    local ref = dat.fftMIn:getsub(1..s1, 1..s2)
    local res = ref:fft():ifft()
    assertTrue( res:real():eq( ref:real(), 2*eps ) )
    assertTrue( res:imag():eq( ref:imag(),   eps ) )
  end end
  local cm = datC.fftMIn:copy()
  assertTrue(cm:reshape(1, #cm):eq(cm:fft("vec"):reshape(cm:sizes()):ifft("vec"), 2*eps))
  assertTrue(cm               :eq(cm:fft("row")                   :ifft("row"), 2*eps))
  local res = cmatrix(cm:sizes())
  cm:fft("col"):ifft("col", res) --test d_ and r_
  assertTrue(cm:eq(res, 2*eps))
end

function TestCMatrixErr:testRFFT()
  local msg = {
    "invalid argument #1 (matrix expected)",
  }
  assertErrorMsgContains( msg[1], mth, 'rfft', cmatrix(1) )
end

function TestCMatrixErr:testIRFFT()
  local msg = {
    "invalid argument #2 (matrix expected)" ,
    "incompatible matrix sizes"             ,
  }
  assertErrorMsgContains( msg[1], mth, 'irfft', cvector(3), nil       )
  assertErrorMsgContains( msg[2], mth, 'irfft', cvector(3), matrix(1) )
end

function TestCMatrixFFT:testIRFFT()
  for i,s in ipairs(dat.sv) do   -- 1D
    local ref = dat.fftVIn:getsub(1..s, 1)
    local res = ref:rfft():irfft(ref:same())
    assertTrue( res:eq( ref, 2*eps ) )
  end
  for i ,s1 in ipairs(dat.sm) do -- 2D
  for ii,s2 in ipairs(dat.sm) do
    local ref = dat.fftMIn:getsub(1..s1, 1..s2)
    local res = ref:rfft():irfft(ref:same())
    assertTrue( res:eq( ref, 2*eps ) )
  end end

  local ref = {
    matrix{{1,1,0},{1,1,0},{1,1,0}},
    matrix{{1,1,1},{1,1,1},{0,0,0}},
    matrix{{1,1,1},{0,0,0},{1,1,1}},
    matrix(3):eye()                ,
  }
  for _,ref in ipairs(ref) do
    local res = ref:rfft():irfft(matrix(3))
    assertTrue( res:eq( ref, 2*eps ) )
  end
end

--function TestCMatrixFFT:testNFFT() end
-- function TestCMatrixFFT:testINFFT() --Lost some of the data - needs to be redone
--   for i,s in ipairs(dat.nfftsv) do   -- 1D
--     local ref = dat.fftVIn:getsub(1..s, 1)
--     local pos = dat.nfftVPosIn:getsub(1..s, 1) / s
--     local res = ref:nfft(pos):infft(pos)
--     assertTrue( res:eq( ref, 38*eps ) )
--   end

--   --Need to do 2D
-- end

function TestCMatrixErr:testConv()
  local msg = {
    "incompatible matrix sizes",
  }
  assertErrorMsgContains( msg[1], mth, 'conv',  cvector(1), cvector(2) )
  assertErrorMsgContains( msg[1], mth, 'conv',  cmatrix(1), cmatrix(2) )
end

-- pascal triangle helpers
local pasVal = \x => local y=1 for i=1,x do y=y*i end return y end
local function pasVec(x)
  local v = vector(x)
  for z=1,x do v:seti(z, pasVal(x-1)/( pasVal(z-1)*pasVal(x-z) )) end
  return v
end

local function resize (x, nr, nc)
	local y = x:same(nr,nc)
  local nr, nc = y:sizes()
	for i=1,nr do
    for j = 1, nc do
      local val = x:get(i, j) or 0 
      y:set(i, j, val)
    end
	end
	return y
end

 -- convolution theorem
function TestCMatrixFFT:testConv()
  -- HELP - to get full conv: nr, nc = xr+yr-1, xc+yc-1
  for i=3,8 do
    local outs = (i-1)+(i-2) - 1
    local v1  = resize(pasVec(i-1), outs,1):map(toC)
    local v2  = resize(pasVec(i-2), outs,1):map(toC)
    local res = v1:conv(v2)
    assertTrue( res:eq(pasVec(outs):map(\x 2i*x), 600*eps ) )
    assertTrue( res:eq(v2:conv(v1), 74*eps) )
  end
  for i=3,5 do
  for j=0,2 do
    local outs = i+2
    local cm = resize(dat.fftMIn:getsub(1+j..i+j, 1+j..i+j), outs, outs):map(toC)
    local k  = resize(matrix{{0,0,0},{0,1,0},{0,0,0}}      , outs, outs):map(toC)
    local mres = cm:conv(k):roll(-1,-1)
    assertTrue( mres:getsub(1..i     ,1..i     ):eq( cm:getsub(1..i, 1..i  ):map(\x ((x:real()+x:imag())*1i) ), 3*eps) )
    assertTrue( mres:getsub(i+1..outs,1..i     ):eq( cmatrix(outs-i, i     )                                  , 2*eps) )
    assertTrue( mres:getsub(1..i     ,i+1..outs):eq( cmatrix(i     , outs-i)                                  , 2*eps) )
  end end
  local cm1 = dat.fftMIn:getsub(1..3, 1..3):map(toC)
  local cm2 = dat.fftMIn:getsub(5..7, 5..7):map(toC)
  assertTrue(datC.convRow:eq(cm1:conv(cm2, "row"), 2*eps))
  assertTrue(datC.convCol:eq(cm1:conv(cm2, "col"), 2*eps))
  assertTrue(datC.convVec:reshape(3, 3):eq(cm1:conv(cm2, "vec"), 4*eps))
end

 -- correlation theorem
function TestCMatrixFFT:testCorr()
  for i=3,6 do
    local outs = (i-1)+(i-2) - 1
    local v1  = resize(pasVec(i-1), outs,1):map(toC)
    local v2  = resize(pasVec(i-2), outs,1):map(toC)
    local res = v1:corr(v2)
    assertTrue( res:eq( pasVec(outs):roll(outs/2+1,0):map(\x 2*x+0i), 32*eps ) )
    assertTrue( res:eq( v2:corr(v1) :roll(1       ,0)               , 32*eps ) )
  end
  for i=3,5 do
  for j=0,2 do
    local outs = i+2
    local m = resize(dat.fftMIn:getsub(1+j..i+j, 1+j..i+j), outs, outs):map(toC)
    local k = resize(matrix{{0,0,0},{0,1,0},{0,0,0}}, outs, outs):map(toC)
    local mref = m:conv(k):roll(-1,-1):map(\x complex(x:imag(), x:real()) )
    local mres = m:corr(k):roll( 1 ,1)
    assertTrue( mref:eq( mres, 4*eps ) )
  end end
  local cm1 = dat.fftMIn:getsub(1..3, 1..3):map(toC)
  local cm2 = dat.fftMIn:getsub(5..7, 5..7):map(toC)
  assertTrue(datC.corrRow:eq(cm1:corr(cm2, "row"), 2*eps))
  assertTrue(datC.corrCol:eq(cm1:corr(cm2, "col"), 2*eps))
  assertTrue(datC.corrVec:reshape(3, 3):eq(cm1:corr(cm2, "vec"), 4*eps)) 
end

function TestCMatrixFFT:testCovar()
for i=3,6 do
    local outs = (i-1)+(i-2) - 1
    local v1 = resize(pasVec(i-1), outs,1):map(toC)
    local v2 = resize(pasVec(i-2), outs,1):map(toC)
    local res = v1:covar(v2)
    local ref = v1:corr (v2):center()
    assertTrue( res:eq( ref, 32*eps ) )
  end
  for i=3,5 do
    local outs = i+2
    local m = resize(dat.fftMIn:getsub(1..i, 1..i)  ,outs, outs):map(toC)
    local k = resize(matrix{{0,0,0},{0,1,0},{0,0,0}},outs, outs):map(toC)
    local mref = m:corr (k):roll(1,1):center()
    local mres = m:covar(k):roll(1,1)
    assertTrue( mref:eq( mres, 5*eps ) )
  end
  local cm1 = dat.fftMIn:getsub(1..3, 1..3):map(toC)
  local cm2 = dat.fftMIn:getsub(5..7, 5..7):map(toC)
  assertTrue(cm1:corr(cm2, "vec"):center("vec"):eq(cm1:covar(cm2, "vec"), 8*eps))
  assertTrue(cm1:corr(cm2, "row"):center("row"):eq(cm1:covar(cm2, "row"), 4*eps))
  assertTrue(cm1:corr(cm2, "col"):center("col"):eq(cm1:covar(cm2, "col"), 2*eps))
end

-- concatenation, conversion --------------------------------------------------o

function TestCMatrixErr:testConcat()
  local msg = {
    "invalid argument #1 (matrix expected)"                     ,
    "invalid argument #2 (matrix expected)"                     ,
    "incompatible matrix sizes"                                 ,
    "invalid argument #3 (string 'vec', row' or 'col' expected)",
    "incompatible matrix sizes"                                 ,
  }
  assertErrorMsgContains( msg[2], errCMat     .concat, errCMat     , ''                              )
  assertErrorMsgContains( msg[2], errCMat     .concat, errCMat     , nil                             )
  assertErrorMsgContains( msg[2], errCMat     .concat, errCMat     , 1..4                            )
  assertErrorMsgContains( msg[3], errCMat     .concat, errCMat     , cmatrix(1)                      )
  assertErrorMsgContains( msg[3], cmatrix(3)  .concat, cmatrix(3)  , errCMat                         )
  assertErrorMsgContains( msg[4], errCMat     .concat, errCMat     , errCMat     , ''                )
  assertErrorMsgContains( msg[4], errCMat     .concat, errCMat     , errCMat     , 1                 )
  assertErrorMsgContains( msg[5], cmatrix(1,2).concat, cmatrix(1,2), cmatrix(3,2), 'row'             )
  assertErrorMsgContains( msg[5], cmatrix(2,3).concat, cmatrix(2,3), cmatrix(2,2), 'col'             )
  assertErrorMsgContains( msg[5], errCMat     .concat, errCMat     , errCMat     , 'col', cmatrix(3) )
end

function TestCMatrix:testConcat()
  for _,cm in ipairs(G.cmatidx) do
    local mn, nr, nc, _ = #cm, cm:sizes()
    local cmref1 = cm:same(2*nr,  nc):setsub(1..nr, 1..nc, 1..mn):setsub(1+nr..2*nr, 1   ..  nc, 1..mn):map(\x x+x*1i)
    local cmref2 = cm:same(  nr,2*nc):setsub(1..nr, 1..nc, 1..mn):setsub(1   ..  nr, 1+nc..2*nc, 1..mn):map(\x x+x*1i)
    local cmref3 = cm:same(2*mn,  1 ):setsub(1..mn, 1    , 1..mn):setsub(1+mn..2*mn, 1         , 1..mn):map(\x x+x*1i)
    assertEquals( cm:concat( cm       ), cmref2 ) -- default now row
    assertEquals( cm:concat( cm, 'col'), cmref1 )
    assertEquals( cm:concat( cm, 'row'), cmref2 )
    assertEquals( cm:concat( cm, 'vec'), cmref3 )
  end
end

function TestCMatrixConv:testTostring()
  local cm = cmatrix(2)
  assertTrue( is_string(cm:tostring(    )) )
  assertTrue( is_string(cm:tostring(''  )) )
  assertTrue( is_string(cm:tostring("\n")) )
  for i,cm in ipairs(G.cmatidx) do
    local c, nr, nc = {}, cm:sizes()
    local ref1 = {} for i=1,nr do for j=1,nc do c[j]=tostring(idxC(i,j,nc)) end ref1[i]=table.concat(c, ' ' ) end
    local ref2 = {} for i=1,nr do for j=1,nc do c[j]=tostring(idxC(i,j,nc)) end ref2[i]=table.concat(c      ) end
    local ref3 = {} for i=1,nr do for j=1,nc do c[j]=tostring(idxC(i,j,nc)) end ref3[i]=table.concat(c, "\n") end
    assertEquals( cm:tostring(    ), table.concat(ref1, '\n') )
    assertEquals( cm:tostring(''  ), table.concat(ref2, '\n') )
    assertEquals( cm:tostring('\n'), table.concat(ref3, '\n') )
  end
end

function TestCMatrixErr:testTotable()
  local msg = {
    "invalid argument #2 (boolean expected)"        ,
    "invalid argument #3 (table expected)"          ,
    "invalid argument #3 (table of tables expected)",
  }
  assertErrorMsgContains( msg[1], errCMat.totable, errCMat, ''      )
  assertErrorMsgContains( msg[1], errCMat.totable, errCMat, 1       )
  assertErrorMsgContains( msg[1], errCMat.totable, errCMat, 1..2    )
  assertErrorMsgContains( msg[1], errCMat.totable, errCMat, errCMat )
  assertErrorMsgContains( msg[2], errCMat.totable, errCMat, true, '')
  assertErrorMsgContains( msg[3], errCMat.totable, errCMat, {{},5}  )
end

function TestCMatrixConv:testTotable()
  for i,cm in ipairs(G.cmatidx) do
    local nr, nc = cm:sizes()
    local tref   = cm:totable("row")
    if nc ~=1 then for i=1,nr do for j=1,nc do assertEquals( tref[i][j], idxC(i,j,nc) ) end end
              else for i=1,nr do               assertEquals( tref[i]   , idxC(i,1,nc) ) end end
    local tref   = cm:totable("col")
    if nc ~=1 then for i=1,nr do for j=1,nc do assertEquals( tref[i][j], idxC(i,j,nc) ) end end
              else for i=1,nr do               assertEquals( tref[i]   , idxC(i,1,nc) ) end end
    cm:totable("vec", tref)
    if nc ~=1 then for i=1,nr do for j=1,nc do assertEquals( tref[idx(i,j,nc)], idxC(i,j,nc) ) end end
              else for i=1,nr do               assertEquals( tref[i]   , idxC(i,1,nc) ) end end
    assertEquals(cm:totable(), tref)
    assertTrue  ( is_table(cm:totable())    )
    assertEquals( cmatrix (cm:totable("row")), cm )
    assertEquals( cmatrix (cm:totable("col")), cm )
    assertEquals( cmatrix (cm:totable("vec")), cm:reshape(#cm, 1) )
    assertEquals( cmatrix (cm:totable(     )), cm:reshape(#cm, 1) )
  end
end

TestCMatrixZ = {}

function TestCMatrixZ:testGMatrixCheck()
  for i,cm in ipairs(G.cmatidx) do
    local mn = #cm
    assertEquals( G.size[i], {cm:sizes()}                          )
    assertEquals( cm       ,  cm:same():fill(1..mn):map(\x x+x*1i) )
  end
  for i,cm in ipairs(G.cmattmp) do
    assertEquals( G.size[i], {cm:sizes()} )
    assertEquals( cm       ,  cm:same()   )
  end
end

-- performance test suite -----------------------------------------------------o

--[[
Test_Matrix = {}
]]

-- end ------------------------------------------------------------------------o
