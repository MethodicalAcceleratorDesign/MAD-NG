--[=[
 o-----------------------------------------------------------------------------o
 |
 | Plot module regression tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A. Bloch, aurelien.bloch at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the plot module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local drift, marker, sbend, quadrupole, sequence, bline,
      instrument, translate, srotation, sextupole,
      octupole, decapole, solenoid, kicker, vkicker, rbend,
      tkicker, hkicker, elseparator, rfcavity, twcavity,
      collimator, crabcavity, combined                           in MAD.element
local tkicker                                                    in MADX
local assertNotNil, assertNotEquals, assertEquals,
      assertErrorMsgContains, assertTrue, assertFalse,
      assertAlmostEquals                                         in MAD.utest
local object, plot, gplot, mtable, vector, filesys, atexit       in MAD
local flags, sequence, marker                                    in MAD.element
local observe                                                    in flags
local tblcpy, fileexists, pause, strsplitall                     in MAD.utility
local min, abs                                                   in MAD.gmath
local pi, eps                                                    in MAD.constant
local is_number                                                  in MAD.typeid


--[[
  Generate:
  ---------
  The generate local variable helps with the debugging/maintenance of the
  tests of the plot module. Changing its value will change the behavior of the
  tests. Bellow is an explanation of the accepted values.
    false : run the test normally failing if tests doesn't pass (default).
    true  : run all test without assertion, generating the scripts (used to
            regenerate reference files).
    "pdf" : change the default plot command used in the tests to generate a
            single pdf (plot_run/tests.pdf) containing all plot (used for
            visual verification of the plot generated by the tests).
    "wxt" : change the default plot command used in the tests to use a new wxt
            interactive windows for each plot (used for visual and interactive
            verification of the plot generated by the test).
]]

local toolbox  = require "toolbox"
local generate = false                           -- false | true | "pdf" | "wxt"
local refdir   = \s -> "plot_ref/"..(s or '')
local rundir   = \s -> "plot_run/"..(s or '')
local id       = 0
local plotTest, reset                            -- Parametrized plot command

-- helpers --------------------------------------------------------------------o

-- unique id generator
local function newSID ()
  id = id % 25 + 1
  return id
end

-- customize the plot command use in the tests
-- w.r.t. the generate local variable (see above).
local function setPlotTest ()
  if plotTest then return end
  if generate == "pdf" then
    plotTest = plot "plotTest" { output = rundir("tests.pdf"), exec = false }
    reset    = \ gplot:write("reset")
    atexit(io.read)
  elseif generate == "wxt" then
    plotTest = plot "plotTest" { sid = newSID, exec = false }
    reset    = \ ()
    atexit(io.read)
  else
    reset    = \ ()
    plotTest = plot "plotTest" { output = false, exec = false }
  end
end

local function loadLHC ()
  local lhcb1, lhcb2 = toolbox.loadLHC()
  MADX:load("../share/LHC/opt_inj.mad")
  lhcb1:select(observe)
  lhcb2:select(observe)
  return lhcb1, lhcb2
end

-- create a small mtbl
local function getSTbl ()
  local smtbl = mtable { {"name"}, "x1", "x2", "y1", "y2", "y3", "y4" }
  for i=1,25 do
    smtbl = smtbl + { "A" .. i, i, i+10, i, i+10, i+20, i+30 }
  end
  return smtbl
end

-- create a big mtbl
local function getBtbl ()
  local bmtbl = mtable { {"name"}, "x", "y", "z" }
  for i=1,25000 do
    bmtbl = bmtbl + { "A" .. i, i, i, 2*i+100 }
  end
  return bmtbl
end

-- create a sequence with all tested shapes.
local function getSeq ()
  return sequence "seq" {
    refer = "entry",
    marker      "start"       { at = 1,                            },
    srotation   "srotation"   { at = 5,                            },
    translate   "translate"   { at = 10,                           },
    quadrupole  "quadrupole"  { at = 15,  l = 3, k1    =-1,        },
    quadrupole  "quadrupole"  { at = 20,  l = 3, k1    = 1,        },
    sextupole   "sextupole"   { at = 25,  l = 3, k2    =-1,        },
    sextupole   "sextupole"   { at = 30,  l = 3, k2    = 1,        },
    octupole    "octupole"    { at = 35,  l = 3, k3    =-1,        },
    octupole    "octupole"    { at = 40,  l = 3, k3    = 1,        },
    decapole    "decapole"    { at = 45,  l = 3, k4    =-1,        },
    decapole    "decapole"    { at = 50,  l = 3, k4    = 1,        },
    solenoid    "solenoid"    { at = 55,  l = 3, ks    =-1,        },
    solenoid    "solenoid"    { at = 60,  l = 3, ks    = 1,        },
    sbend       "sbend"       { at = 65,  l = 3, angle =-1,        },
    sbend       "sbend"       { at = 70,  l = 3, angle = 1,        },
    combined    "combined"    { at = 75,  l = 3, angle = 1, k1 =-1 },
    combined    "combined"    { at = 80,  l = 3, angle = 1, k1 = 1 },
    combined    "combined"    { at = 85,  l = 3, angle =-1, k1 =-1 },
    combined    "combined"    { at = 90,  l = 3, angle =-1, k1 = 1 },
    rbend       "rbend"       { at = 95,  l = 3,                   },
    kicker      "kicker"      { at = 100, l = 3,                   },
    tkicker     "tkicker"     { at = 105, l = 3, kind="tkicker"    },
    hkicker     "hkicker"     { at = 110, l = 3,                   },
    vkicker     "vkicker"     { at = 115, l = 3,                   },
    elseparator "elseparator" { at = 120, l = 3,                   },
    instrument  "instrument"  { at = 125, l = 3,                   },
    rfcavity    "rfcavity"    { at = 130, l = 3,                   },
    twcavity    "twcavity"    { at = 135, l = 3,                   },
    collimator  "collimator"  { at = 140, l = 3,                   },
    crabcavity  "crabcavity"  { at = 145,                          },
    drift       "drift"       { at = 150,                          },
    marker      "end"         { at = 155,                          },
  }
end

-- very simple and fast function to compare test files that can contains numbers
-- Should be replace by a more refined version in the future
-- (i.e. line number, test name, idea of the issue)
local function assertFiles (name)
  if generate then return end
  local ref  = assert(io.open(refdir(name), "r"))
  local run  = assert(io.open(rundir(name), "r"))
  local reftbl, sref = strsplitall(ref:read("*all"), " \n,:;[]")
  local runtbl, srun = strsplitall(run:read("*all"), " \n,:;[]")
  ref:close(); run:close()
  assertEquals(sref, srun)
  for i=1,sref do
    reftbl[i] = tonumber(reftbl[i]) or reftbl[i]
    runtbl[i] = tonumber(runtbl[i]) or runtbl[i]
    if is_number(reftbl[i]) then
      local approx = abs(runtbl[i]-reftbl[i])
      if 14*eps < approx then
        local div = min(runtbl[i], reftbl[i])
        if div == 0 then
          assertAlmostEquals(approx, 0, 5e-6)
        else
          -- max possible error with 5 decimal digits is 1.00001-1.00000 = 1e-5
          assertAlmostEquals((runtbl[i]-reftbl[i])/div, 0, 5e-6)
        end
      end
    else
      assertEquals(runtbl[i], reftbl[i])
    end
  end
  if not generate then os.remove(rundir(name)) end
end

-- customize the plot command by setting the test name as the plot title and the
-- script dump file name.
local function getEmptyPlot (name)
  return plotTest {
    title   = name,
    scrdump = rundir(name),
    exec    = false,
  }
end

local function wait_fileexists(fname)
  local t0 = os.clock()
  while not fileexists(fname) and os.clock() - t0 < 1 do pause(20) end
end

-- plot regression test suite -------------------------------------------------o

TestPlotScript = {}

function TestPlotScript:setUp ()
  setPlotTest()
  filesys.mkdir(rundir())
  self.id = 1
  reset()
  self.tmpname = gplot.tmpname
  gplot:set_tmpname_("TMP_MAD_TestPlotScript")
end

function TestPlotScript:tearDown ()
  if not generate and self.testPassed then filesys.rmdir(rundir()) end
  gplot:clean_tmpfile()
  gplot:set_tmpname_(self.tmpname)
end

function TestPlotScript:execTest (param)
  local name = self.testName .. self.id
  getEmptyPlot(name)(param)
  assertFiles(name)
  self.id = self.id + 1
end

function TestPlotScript:testEmptyPlot ()
  local print_s = print
  print = \s -> assertEquals(s,
    "MAD Plot Warning : no scrdump nor output provided - Nothing done")
  plotTest { }
  print = print_s
end

function TestPlotScript:testEmptyPlotScript ()
  local param = { }
  self:execTest(param)
end

function TestPlotScript:testPrologEpilog ()
  local param = {
    prolog = "set multi",
    epilog = "unset multi",
  }
  self:execTest(param)
end

function TestPlotScript:testDataSelection ()
  local smtbl = getSTbl()
  local params = {
    { x1 = {"y1", "y2"}, x2 = {"y3", "y4"}},
    { x1 = {"y1", "y2"}, x2 = "y3"},
    { x2 = {"y1", "y2"}, "y3"},
    { x1 = {"y1", "y2"}},
    { x2 = "y1", "y2"},
    { x1 = "y1"},
    {"y1", "y2"},
    "y1",
  }
  for i=1,#params do
    self:execTest{table = smtbl, x1y1 = params[i] }
  end
end

function TestPlotScript:testAxisSelection ()
  local smtbl  = getSTbl()
  local params = {
    { table = smtbl, x1y1 = { x1 = "y1" }, x1y2 = { x1 = "y2" } },
    { table = smtbl, x1y1 = { x1 = "y1" }, x2y1 = { x2 = "y2" } },
    { table = smtbl, x1y2 = { x1 = "y1" }, x2y1 = { x2 = "y2" } },
    { table = smtbl, x1y1 = { x1 = "y1" }, x2y2 = { x2 = "y2" } },
    { table = smtbl, x1y1 = { x1 = "y1" }, x2y2 = { x2 = "y2" },
                     x1y2 = { x1 = "y3" }, x2y1 = { x2 = "y4" } },
  }
  for i=1,#params do self:execTest(params[i]) end
end

function TestPlotScript:testAxisLabel ()
  local smtbl = getSTbl()
  local param = {
    table   = smtbl,
    x1y1    = { x1 = "y1" },
    x2y2    = { x2 = "y2" },
    xlabel  = "label X",
    x2label = "label X2",
    ylabel  = "label Y",
    y2label = "label Y2",
  }
  self:execTest(param)
end

function TestPlotScript:testAxisRange ()
  local smtbl = getSTbl()
  local param = {
    table   = smtbl,
    x1y1    = { x1 = "y1" },
    x2y2    = { x2 = "y2" },
    xrange  = { 7  ,  12  },
    x2range = { 27 ,  32  },
    yrange  = { 8  ,  11  },
    y2range = { 28 ,  31  },
  }
  self:execTest(param)
end

function TestPlotScript:testTableOrData ()
  local smtbl  = getSTbl()
  local x1, y2 = table.new(25,0), vector(25)
  for i=1,25 do
    x1[i] = 11 + i
    y2[i] = 22 + i
  end
  local param = {
    table = smtbl,
    data  = { x1 = x1  , y2 = y2   },
    x1y1  = { x1 = "y1", x2 = "y2" },
  }
  self:execTest(param)
end

function TestPlotScript:testTableRangeAbscisseData ()
  local smtbl  = getSTbl()
  local x1, y1 = table.new(11,0),table.new(11,0)
  for i=1,11 do
    x1[i] = 41 + i
    y1[i] = 41 + i
  end
  local param  = {
    table      = smtbl,
    data       = { x1 = x1   },
    x1y1       = { x1 = "y1" },
    tablerange = { 13, 23    },
  }
  self:execTest(param)
end

function TestPlotScript:testTableRangeOrdinateData ()
  local smtbl  = getSTbl()
  local x1, y1 = table.new(11,0),table.new(11,0)
  for i=1,11 do
    x1[i] = 41 + i
    y1[i] = 41 + i
  end
  local param  = {
    table      = smtbl,
    data       = { y1 = y1   },
    x1y1       = { x1 = "y1" },
    tablerange = { 13, 23    },
  }
  self:execTest(param)
end

function TestPlotScript:testLegendDefault ()
  local smtbl = getSTbl()
  local param = {
    table  = smtbl,
    x1y1   = { x1 = { "y1", "y2" } },
    legend = nil,
  }
  self:execTest(tblcpy(param))
end

function TestPlotScript:testLegendDeactivate ()
  local smtbl = getSTbl()
  local param = {
    table  = smtbl,
    x1y1   = { x1 = { "y1", "y2" } },
    legend = false,
  }
  self:execTest(tblcpy(param))
end

function TestPlotScript:testLegendUserName ()
  local smtbl = getSTbl()
  local param = {
    table  = smtbl,
    x1y1   = { x1 = { "y1", "y2" } },
    legend = { y1 = "legend1"      },
  }
  self:execTest(tblcpy(param))
end

function TestPlotScript:testLegendPartialDeactivate ()
  local smtbl = getSTbl()
  local param = {
    table  = smtbl,
    x1y1   = { x1 = { "y1", "y2" }            },
    legend = { y1 = "legend1"    , y2 = false },
  }
  self:execTest(tblcpy(param))
end

function TestPlotScript:testTitle ()
  local name    = self.testName .. self.id
  local pattern = "set title 'plotTest MAD %d+.%d+.%d+, %d+/%d+/%d+, %d+:%d+:%d+'"
  local smtbl   = getSTbl()
  local line, file

  plotTest { scrdump = rundir(name), table = smtbl, x1y1 = "y1" }

  local t0 = os.clock()
  while not file and os.clock() - t0 < 1 do
    file = io.open(rundir(name), "r")
    pause(20)
  end
  repeat
    line = file:read("*line")
    if line and (string.find(line, pattern)) then
      if not generate then os.remove(rundir(name)) end
        file:close()
      return
    end
  until not line

  file:close()
  error("Default title doesn't contain : version, date, time")
end

function TestPlotScript:testPlotDecoration ()
  local smtbl  = getSTbl()
  local param  = {
    table      = smtbl,
    x1y1       = { x1 = {"y1", "y4" } },
    titlefont  = "Arial Black",
    titlesize  = 21,
    legend = {
      y1 = "legend1 {/Symbol b} + \u{03b2}",
      y4 = "legend2 {/Symbol B} + \u{0392}",
    },
    legendfont = "Aclonica",
    legendsize = 11,
    legendpos  = "bottom right",
    grid       = false,
    border     = 3,
  }
  self:execTest(param)
end

function TestPlotScript:testPlotDataStyleTypeSpec ()
  local smtbl  = getSTbl()
  local param  = {
    table      = smtbl,
    x1y1       = { x1 = {"y1", "y3", "y4" } },
    originx    = 0.3,
    originy    = 0.4,
    psizex     = 0.7,
    psizey     = 0.6,
    styles     = { y1 = "lines"   , y3 = "points", y4 = "linespoints" },
    colors     = { y1 = "red"     , y3 = "blue"  , y4 = "green"       },
    dashtypes  = { y1 = "..   "   ,                y4 = "--  "        },
    linewidths = { y1 = 2.3       ,                y4 = 3.2           },
    pointtypes = {                  y3 = 2       , y4 = 3             },
    pointsizes = {                  y3 = 2.0     , y4 = 4.1           },
    smooths    = { y1 = "csplines", y3 = "bezier",                    },
  }
  self:execTest(param)
end

function TestPlotScript:testPlotDataStyleOrdinateSpec ()
  local smtbl  = getSTbl()
  local param  = {
    table      = smtbl,
    x1y1       = { x1 = {"y1", "y3", "y4" } },
    originx    = 0.3,
    originy    = 0.4,
    psizex     = 0.7,
    psizey     = 0.6,
    datastyles = {
      y1 = {
        style     = "lines",      color      = "red",
        dashtype  = "..   ",      linewidth  = 2.3,
        smooth    = "csplines"
        },
      y3 = {
        style     = "points",      color     = "blue",
        pointtype = 2,             pointsize = 2.0 ,
        smooth    = "bezier"
      },
      y4 = {
        style     = "linespoints", color     = "green",
        dashtype  = "--  ",        linewidth = 3.2,
        pointtype = 3,             pointsize = 4.1
      }
    }
  }
  self:execTest(param)
end

function TestPlotScript:testPlotDataStyleGlobalSpec ()
  local smtbl  = getSTbl()
  local param  = {
    table      = smtbl,
    x1y1       = { x1 = {"y1", "y4" } },
    styles     = "linespoints",
    colors     = "black",
    dashtypes  = ".-.-",
    smooths    = "csplines",
    linewidths = 4,
    pointtypes = 2,
    pointsizes = 3,
  }
  self:execTest(param)
end

function TestPlotScript:testPlotConfigSplot ()
  local data   = {
    c1 = {6, 3, 0, 0, 0, 0}, c2 = {5, 2, 0, 0, 0, 1}, c3 = {4, 2, 0, 0, 1, 2},
    c4 = {3, 0, 0, 0, 2, 3}, c5 = {1, 0, 1, 2, 4, 4}, c6 = {0, 1, 0, 3, 3, 5},
  }
  local param = { -- simple splot example
    data    = data,
    x1y1    = { c1 = {"c2", "c3", "c4", "c5", "c6"} },
    plotcfg = "set pm3d map",
    plotcmd = "splot ${data1} matrix",
  }
  self:execTest(param)
end

function TestPlotScript:testPlotConfigInterpolationAndPlotvar ()
  local smtbl  = getSTbl()
  local param  = { -- test all available interpolation variables + plotvar
    table      = smtbl,
    x1y1       = { x1 = {"y1", "y3", "y4" } },
    styles     = { y1 = "lines", y3 = "points", y4 = "linespoints" },
    colors     = { y1 = "red"  , y3 = "blue"  , y4 = "green"       },
    dashtypes  = { y1 = "..   ",                y4 = "--  "        },
    linewidths = { y1 = 2.3    ,                y4 = 3.2           },
    pointtypes = {               y3 = 2       , y4 = 3             },
    pointsizes = {               y3 = 2.0     , y4 = 4.1           },
    plotvar    = { color3 ="linecolor 'pink' " },
    plotcmd    = "\z
      ${cmd1}${data1}${index1}${using1}with \z
        ${style1}${lines1}${points1}\z
        ${color1}${title1}${axes1},\\\n\z

      ${cmd2}${data2}${index2}${using2}with \z
        ${style2}${lines2}${points2}\z
        ${color2}${title2}${axes2},\\\n\z

      ${cmd3}${data3}${index3}${using3}with \z
        ${style3}${lines3}${points3}\z
        ${color3}${title3}${axes3},\\\n\z
    "
  }
  self:execTest(param)
end

function TestPlotScript:testPlotConfigLambdaT ()
  local smtbl  = getSTbl()
  local T = \s\ctx -> s % ctx
  local param = { -- plotvar + lambda T resolution example
    table   = smtbl,
    x1y1    = {"y1", "y2"},
    plotvar = {
      title2  = T"title '${mytitle}' ",
      mytitle = T"title for command (${cmd1}) on axes (${axes2})",
    },
  }
  self:execTest(param)
end

function TestPlotScript:testObjectShift ()
  local param = {
    sequence = sequence { l = 10, marker "middle" { at = 5 } },
    oshft    = 11,
  }
  self:execTest(param)
end

function TestPlotScript:testAllShapes ()
  local seq   = getSeq()
  local smtbl = getSTbl()
  local param = { sequence = seq, table = smtbl, x1y1 = "y1" }
  self:execTest(param)
end

function TestPlotScript:testLayposNum ()
  local seq   = getSeq()
  local smtbl = getSTbl()
  local param = { sequence = seq, table = smtbl, x1y1 = "y1", laypos = 0.25 }
  self:execTest(param)
end

function TestPlotScript:testLayposMiddle ()
  local seq   = getSeq()
  local smtbl = getSTbl()
  local param = { sequence = seq, table = smtbl, x1y1 = "y1", laypos = "middle"}
  self:execTest(param)
end

function TestPlotScript:testLayposTop ()
  local seq   = getSeq()
  local smtbl = getSTbl()
  local param = { sequence = seq, table = smtbl, x1y1 = "y1", laypos = "top" }
  self:execTest(param)
end

function TestPlotScript:testLayposBottom ()
  local seq   = getSeq()
  local smtbl = getSTbl()
  local param = { sequence = seq, table = smtbl, x1y1 = "y1", laypos = "bottom"}
  self:execTest(param)
end

function TestPlotScript:testLaysizeNum ()
  local seq   = getSeq()
  local smtbl = getSTbl()
  local param = {
    sequence  = seq, table = smtbl, x1y1 = "y1", laysize=0.5, laypos = 0.25
  }
  self:execTest(param)
end

function TestPlotScript:testLaysizeMiddle ()
  local seq   = getSeq()
  local smtbl = getSTbl()
  local param = {
    sequence  = seq, table = smtbl, x1y1 = "y1", laysize=0.5, laypos = "middle"
  }
  self:execTest(param)
end

function TestPlotScript:testLaysizeTop ()
  local seq   = getSeq()
  local smtbl = getSTbl()
  local param = {
    sequence  = seq, table = smtbl, x1y1 = "y1", laysize=0.5, laypos = "top",
  }
  self:execTest(param)
end

function TestPlotScript:testLaysizeBottom ()
  local seq   = getSeq()
  local smtbl = getSTbl()
  local param = {
    sequence  = seq, table = smtbl, x1y1 = "y1", laysize=0.5, laypos = "bottom",
  }
  self:execTest(param)
end

function TestPlotScript:testElemNameActivated ()
  local seq   = getSeq()
  local smtbl = getSTbl()
  local param = {
    sequence  = seq, table = smtbl, x1y1 = "y1", elemname = true,
  }
  self:execTest(param)
end

function TestPlotScript:testElemNameDeactivated ()
  local seq   = getSeq()
  local smtbl = getSTbl()
  local param = {
    sequence  = seq, table = smtbl, x1y1 = "y1", elemname = false,
  }
  self:execTest(param)
end

function TestPlotScript:testKindColorActivated ()
  local seq    = getSeq()
  local smtbl  = getSTbl()
  local param  = {
    sequence   = seq, table = smtbl, x1y1 = "y1", kindcolor = true,
  }
  self:execTest(param)
end

function TestPlotScript:testKindColorDeactivated ()
  local seq    = getSeq()
  local smtbl  = getSTbl()
  local param  = {
    sequence   = seq, table = smtbl, x1y1 = "y1", kindcolor = false,
  }
  self:execTest(param)
end

function TestPlotScript:testKindColorSpec ()
  local seq    = getSeq()
  local smtbl  = getSTbl()
  local param  = {
    sequence   = seq, table = smtbl, x1y1 = "y1",
    kindcolor  = {
      quadrupole = "blue",
      sbend      = { fillcolor = "red"  ,                         },
      rbend      = {                      fillstyle = "pattern 1" },
      instrument = { fillcolor = "green", fillstyle = "pattern 2" },
      srotation  = { linecolor = "gold" , dashtype  = "..  "      },
    },
  }
  self:execTest(param)
end

function TestPlotScript:testSeqOnly ()
  local seq   = getSeq()
  local param = { sequence = seq }
  self:execTest(param)
end

function TestPlotScript:testSeqRangeName()
  local seq   = getSeq()
  local smtbl = getSTbl()
  local param = {
    sequence = seq, table = smtbl, x1y1 = "y1",
    range = { "quadrupole", "elseparator" },
  }
  self:execTest(param)
end

function TestPlotScript:testSeqRangeSpos()
  local seq   = getSeq()
  local smtbl = getSTbl()
  local param = {
    sequence = seq, table = smtbl, x1y1 = "y1",
    range = { 15, 120 },
  }
  self:execTest(param)
end

function TestPlotScript:testSeqDistYNum ()
  local seq   = getSeq()
  local smtbl = getSTbl()
  local param = {
    sequence  = { seq, seq, seq }, table = smtbl, x1y1 = "y1",
    seqdisty  = 0.2,
  }
  self:execTest(param)
end

function TestPlotScript:testSeqDistYTable ()
  local seq   = getSeq()
  local smtbl = getSTbl()
  local param = {
    sequence  = { seq, seq, seq }, table = smtbl, x1y1 = "y1",
    seqdisty  = { 0.2, 0.4 },
  }
  self:execTest(param)
end

function TestPlotScript:testSeqDistXNum ()
  local seq   = getSeq()
  local smtbl = getSTbl()
  local param = {
    sequence  = { seq, seq, seq }, table = smtbl, x1y1 = "y1",
    seqdistx  = 10,
  }
  self:execTest(param)
end

function TestPlotScript:testSeqDistXTable ()
  local seq   = getSeq()
  local smtbl = getSTbl()
  local param = {
    sequence  = { seq, seq, seq }, table = smtbl, x1y1 = "y1",
    seqdistx  = { 5, 10 },
  }
  self:execTest(param)
end

function TestPlotScript:testSeqShift ()
  local seq   = getSeq()
  local smtbl = getSTbl()
  local param = {
    sequence  = { seq, seq, seq }, table = smtbl, x1y1 = "y1",
    seqshift  = 20,
  }
  self:execTest(param)
end

function TestPlotScript:testSeqNturn ()
  local seq   = getSeq()
  local smtbl = getSTbl()
  local param = { sequence = seq, table = smtbl, x1y1 = "y1", nturn = 2 }
  self:execTest(param)
end

function TestPlotScript:testSeqKeep()
  local seq    = getSeq()
  local smtbl  = getSTbl()
  local param1 = { sid = 1, sequence = seq, table = smtbl, x1y1 = "y1" }
  local param2 = { sid = 1, sequence = "keep", table = smtbl, x1y1 = "y2" }
  self:execTest(param1)
  self:execTest(param2)
end

function TestPlotScript:testElemScale ()
  local lhcb1, lhcb2 = loadLHC()
  local smtbl = getSTbl()
  local param = {
    table     = smtbl,
    x1y1      = "y1",
    sequence  = { lhcb1, lhcb2 },
    range     = { {"E.DS.L1.B1", "S.DS.R1.B1"}, {"E.DS.L1.B2", "S.DS.R1.B2"} },
    seqdisty  = lhcb2["E.DS.L1.B2"].mech_sep,
    elemscale = 2,
  }
  self:execTest(param)
end

function TestPlotScript:testElemWidth ()
  local lhcb1, lhcb2 = loadLHC()
  local smtbl = getSTbl()
  local param = {
    table     = smtbl,
    x1y1      = "y1",
    sequence  = { lhcb1, lhcb2 },
    range     = { {"E.DS.L1.B1", "S.DS.R1.B1"}, {"E.DS.L1.B2", "S.DS.R1.B2"} },
    seqdisty  = lhcb2["E.DS.L1.B2"].mech_sep,
    elemwidth = 0.2,
  }
  self:execTest(param)
end

function TestPlotScript:testElemFilterKindselect()
  local lhcb1, lhcb2 = loadLHC()
  local smtbl = getSTbl()
  local param = {
    table      = smtbl,
    x1y1       = "y1",
    sequence   = { lhcb1, lhcb2 },
    range      = { {"E.DS.L1.B1", "S.DS.R1.B1"}, {"E.DS.L1.B2", "S.DS.R1.B2"} },
    seqdisty   = lhcb2["E.DS.L1.B2"].mech_sep,
    kindselect = { "quadrupole", "sbend" },
  }
  self:execTest(param)
end

function TestPlotScript:testElemFilterElemminlen()
  local lhcb1, lhcb2 = loadLHC()
  local smtbl = getSTbl()
  local param = {
    table      = smtbl,
    x1y1       = "y1",
    sequence   = { lhcb1, lhcb2 },
    range      = { {"E.DS.L1.B1", "S.DS.R1.B1"}, {"E.DS.L1.B2", "S.DS.R1.B2"} },
    seqdisty   = lhcb2["E.DS.L1.B2"].mech_sep,
    elemminlen = 1,
  }
  self:execTest(param)
end

function TestPlotScript:testLayangleActivated()
  local lhcb1 = loadLHC()
  local smtbl = getSTbl()
  local param = {
    table    = smtbl,
    x1y1     = "y1",
    sequence = lhcb1,
    range    = {"E.DS.L1.B1", "S.DS.R1.B1"},
    layangle = true,
  }
  self:execTest(param)
end

function TestPlotScript:testLayangleDeactivated()
  local lhcb1 = loadLHC()
  local smtbl = getSTbl()
  local param = {
    table    = smtbl,
    x1y1     = "y1",
    sequence = lhcb1,
    range    = {"E.DS.L1.B1", "S.DS.R1.B1"},
    layangle = false,
  }
  self:execTest(param)
end

function TestPlotScript:testSurveySimple()
  local smtbl = getSTbl()
  local seq   = sequence { refer = "entry", instrument { at = 0, l = 3 } }
  seq:select(observe)
  local param = {
    sequence  = seq,
    table     = smtbl,
    laypos    = "in",
    x1y1      = "y1",
  }
  self:execTest(param)
end

function TestPlotScript:testSurveySimpleA0()
  local smtbl = getSTbl()
  local seq   = sequence { refer = "entry", instrument { at = 0, l = 3 } }
  seq:select(observe)
  local param = {
    sequence  = seq,
    table     = smtbl,
    laypos    = "in",
    x1y1      = "y1",
    A0        = { -pi/2, 0 , 0 }
  }
  self:execTest(param)
end

function TestPlotScript:testSurvey()
  local smtbl  = getSTbl()
  local seq    = sequence { refer = "entry",
    20*sbend { l = 1, angle = pi/10 },
  }
  seq:select(observe)
  local param = {
    sequence  = seq,
    table     = smtbl,
    laypos    = "in",
    x1y1      = "y1",
  }
  self:execTest(param)
end

function TestPlotScript:testSurveyPosDirNegDir()
  local seq_pos  = sequence "seq_pos" { refer = "entry",
    20*sbend { l = 1, angle = pi/10 },
  }
  local seq_neg  = seq_pos "seq_neg" { dir = -1 }
  seq_pos:select(observe)
  seq_neg:select(observe)
  local param = {
    sequence  = { seq_pos, seq_neg },
    laypos    = "in",
    x1y1      = "y1",
  }
  self:execTest(param)
end

function TestPlotScript:testSurveyNturn()
  local smtbl  = getSTbl()
  local seq    = sequence { refer = "entry",
    10*sbend { l = 1, angle = pi/10 },
  }
  seq:select(observe)
  local param = {
    sequence = seq,
    table    = smtbl,
    laypos   = "in",
    x1y1     = "y1",
    nturn    = 2,
  }
  self:execTest(param)
end

function TestPlotScript:testSurveyInput()
  local lhcb1 = loadLHC()
  local smtbl = getSTbl()
  local param = {
    sequence  = lhcb1,
    table     = smtbl,
    laypos    = "in",
    x1y1      = "y1",
    xrange    = { -8510.46, 101.011    },
    yrange    = { -405.75 , 4605.54    },
    range     = { "IP2"   , "IP4"      },
    X0        = { -1231.18, 0, 2970.46 },
    A0        = { -pi/4   , 0, 0       },
  }
  self:execTest(param)
end

function TestPlotScript:testIP1IP5 ()
  local lhcb1, lhcb2 = loadLHC()
  local smtbl = getSTbl()
  local param = {
    table    = smtbl,
    x1y1     = "y1",
    sequence = { lhcb1, lhcb2, lhcb1, lhcb2 },
    range    = {
      {"E.DS.L1.B1", "S.DS.R1.B1"},{"E.DS.L1.B2", "S.DS.R1.B2"},
      {"E.DS.L5.B1", "S.DS.R5.B1"},{"E.DS.L5.B2", "S.DS.R5.B2"},
    },
    seqdisty = {
      lhcb2["E.DS.L1.B2"].mech_sep,
      -0.4,
      -0.4 + lhcb2["E.DS.L5.B2"].mech_sep
    },
  }
  self:execTest(param)
end

function TestPlotScript:testLHC ()
  local lhcb1, lhcb2 = loadLHC()
  local bmtbl        = getBtbl()
  local param        = {
    sequence = { lhcb1, lhcb2 },
    table    = bmtbl,
    x1y1     = { x = "y" },
  }
  self:execTest(param)
end

function TestPlotScript:testSurveyLHC ()
  local lhcb1, lhcb2 = loadLHC()
  local param = {
    sequence = { lhcb1, lhcb2 },
    laypos   = "in",
  }
  self:execTest(param)
end

function TestPlotScript:testSurveyMultipleInit ()
  local seq   = sequence { refer = "entry",
    10*sbend { l = 1, angle = pi/10 },
  }
  local param = {
    sequence = { seq           , seq                 },
    X0       = { {-100, 0, 100}, {-106.3666, 0, 100} },
    A0       = { {   0, 0,   0}, {-pi      , 0,   0} },
    laypos   = "in",
  }
  self:execTest(param)
end

function TestPlotScript:testSurveyNotLayonly ()
  local seq   = sequence { refer = "entry",
    20*sbend { l = 1, angle = pi/10 },
  }
  local param = {
    sequence = seq,
    laypos   = "in",
    layonly  = false,
    xrange   = {-3.2, 0.75},
    yrange   = {-3.4, 3.4 },
  }
  self:execTest(param)
end

function TestPlotScript:testOutput ()
  local sid = gplot.sid
  gplot:set_methods {
    printf = \s,... =>
      local match = string.match(string.format(...), "system '(.+)'")
      if match then os.execute(match) end
    end,
    write  = \ error("call to write in gplot"),
  }
  local param = {
    sid      = 12,
    output   = 2,
    term     = "qt",
    wsizex   = 300,
    wsizey   = 300,
    font     = "Comic Sans MS",
    fontsize = 31,
  }
  assertEquals(gplot.sid, 1)
  self:execTest(tblcpy(param))
  param.output="plot.pdf"
  self:execTest(tblcpy(param))
  assertEquals(gplot.sid, 12)
  gplot:set_sid(sid)

  gplot.printf, gplot.write = nil, nil
end

-- gplot regression test suite -------------------------------------------------o

TestPlotGplot = {}

function TestPlotGplot:setUp ()
  filesys.mkdir(rundir())
  self.sid = gplot.sid
  self.tmpname = gplot.tmpname
  gplot:set_tmpname_("TMP_MAD_TestPlotGplot")
end

function TestPlotGplot:tearDown ()
  if not generate and self.testPassed then filesys.rmdir(rundir()) end
  gplot:clean_tmpfile()
  gplot:set_sid(self.sid)
  gplot:set_tmpname_(self.tmpname)
end

function TestPlotGplot:testSid()
  for i=1, 25 do
    gplot:set_sid(i)
    assertEquals(gplot.sid, i)
  end

  local msg = {
    "invalid argument #1 (number expected)",
    "invalid argument #1 (number should be comprise between 1 and 25)",
  }

  assertErrorMsgContains(msg[1], gplot.set_sid, gplot, ""  )
  assertErrorMsgContains(msg[1], gplot.set_sid, gplot, \ ())
  assertErrorMsgContains(msg[1], gplot.set_sid, gplot, {}  )
  assertErrorMsgContains(msg[2], gplot.set_sid, gplot, 0   )
  assertErrorMsgContains(msg[2], gplot.set_sid, gplot, 26  )
end

function TestPlotGplot:testWritePrintf()
  local fname = rundir("test.gp")

  os.remove(fname)
  gplot:write(string.format("save '%s'", fname))
  wait_fileexists(fname)
  assertTrue(fileexists(fname))
  os.remove(fname)

  assertFalse(fileexists(fname))
  gplot:printf("save '%s'", fname)
  wait_fileexists(fname)
  assertTrue(fileexists(fname))
  os.remove(fname)
end

function TestPlotGplot:testIsBusy()
  plot { prolog = "pause 0.2" }
  assertTrue(gplot:is_busy())

  pause(500)
  for i=1, 25 do
    gplot:set_sid(i)
    assertFalse(gplot:is_busy())
  end
end

function TestPlotGplot:testCleanTmpFile()
  local tmp = gplot.tmpname.."/madplot-"
  filesys.mkdir(gplot.tmpname)

  for i=1,25 do assert(io.open(tmp..i, "w")):close()   end
  gplot:clean_tmpfile()
  for i=1,25 do assertFalse(fileexists(tmp..i))        end

  for i=1,25 do plot { sid = i, prolog = "pause 0.3" } end
  gplot:clean_tmpfile()
  for i=1,25 do assertTrue(fileexists(tmp..i))         end
end

-- end ------------------------------------------------------------------------o
