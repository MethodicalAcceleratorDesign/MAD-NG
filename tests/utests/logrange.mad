--[=[
 o-----------------------------------------------------------------------------o
 |
 | Range module regression tests - logrange
 |
 | Methodical Accelerator Design - Copyright CERN 2015+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the range module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertEquals, assertAlmostEquals, assertTrue, assertFalse,
      assertErrorMsgContains, assertNil, assertNaN, assertIsString, assertInf
      in require 'luaunit'

local range   , nrange   , irange   , is_range,
      logrange, nlogrange, ilogrange, is_logrange, log,
      tiny, eps, huge, inf, nan in MAD
local is_function in MAD
local exp         in math

-- regression test suite ------------------------------------------------------o

TestLogrange = {}

local values = {
  limit = { huge, tiny, inf },
  num   = {2^-64, 2^-63, 2^-53, eps, 2^-52, 2*eps, 2^-32, 2^-31, 1e-9,
          0.1-eps, 0.1, 0.1+eps, 0.5, 0.7-eps, 0.7, 0.7+eps, 1-eps, 1, 1+eps,
          1.1, 1.7, 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53,
          2^63, 2^64 },
  lrng =   {
           { 10^5, 1    , 0.1},
           { 1   , 10^5 , 10 },
           { 1   , 10^-5, 0.1},
           },
  lempty = {
           { 10^5, 1    , 10 },
           { 1   , 10^5 , 0.1},
           { 1   , 10^-5, 10 },
           },
  nlrng =  {
           { 10^5, 1    , 100 },
           { 1   , 10^5 , 100 },
           { 1   , 10^-5, 100 },
           },
}

function TestLogrange:testConstructor()
    local a = 2
  local msg = {
    "invalid argument #1 (positive number expected)",
    "invalid argument #2 (positive number expected)",
    "invalid argument #3 (positive number expected)",
    "cannot convert 'string' to 'const double'"     ,
  }
  assertErrorMsgContains( msg[1],  logrange            )
  assertErrorMsgContains( msg[1],  logrange,-1         )
  assertErrorMsgContains( msg[1],  logrange, nil, 1    )
  assertErrorMsgContains( msg[1],  logrange, 1..10..2  )
  assertErrorMsgContains( msg[1],  logrange, ''        )
  assertErrorMsgContains( msg[2],  logrange, 1, ''     )
  assertErrorMsgContains( msg[3],  logrange, 1, 10, '' )
  assertErrorMsgContains( msg[1],  logrange,-a,-a      )
  assertErrorMsgContains( msg[1],  logrange,-a,-a,-a   )
  assertErrorMsgContains( msg[3],  logrange, 1  , 10  , nan )
  assertErrorMsgContains( msg[2],  logrange, 1  , nan , nan )
  assertErrorMsgContains( msg[1],  logrange, nan, nan , nan )
  assertErrorMsgContains( msg[3],  logrange, 1  , 10  ,-nan )
  assertErrorMsgContains( msg[2],  logrange, 1  , nan ,-nan )
  assertErrorMsgContains( msg[1],  logrange,-nan,-nan ,-nan )
  assertErrorMsgContains( msg[3],  logrange, 1  , 10^5,-10  )
  assertErrorMsgContains( msg[2],  logrange, 1  ,-10^5, 10  )
  assertErrorMsgContains( msg[1],  logrange,-1  , 10^5, 10  )
  assertErrorMsgContains( msg[3],  logrange, 1  , 10^5, 0   )
  assertErrorMsgContains( msg[3], nlogrange, 1  , 10^5,-1   )
  assertErrorMsgContains( msg[3], nlogrange, 1  , 10^5, 0   )
  assertErrorMsgContains( msg[2], nlogrange, 1  , 0   , 1   )
  assertErrorMsgContains( msg[1], nlogrange, 0  , 10^5, 1   )

  assertTrue( is_logrange( logrange(1)       ) )
  assertTrue( is_logrange( logrange(1,10)    ) )
  assertTrue( is_logrange( logrange( a, a)   ) )
  assertTrue( is_logrange( logrange( a, a, a)) )

  for _,v in ipairs(values.lrng) do
    assertTrue( is_logrange( logrange(v[1],v[2],v[3]) ) )
  end
  for _,v in ipairs(values.lempty) do
    assertTrue( is_logrange( logrange(v[1],v[2],v[3]) ) )
  end
  for _,v in ipairs(values.limit) do
    assertTrue( is_logrange(logrange( 1,  10, v)) )
    assertTrue( is_logrange(logrange( 1 , v , v)) )
    assertTrue( is_logrange(logrange( v , v , v)) )
  end
end

function TestLogrange:testFields()
  local lr
  assertEquals( logrange( 1 )    .logstart, log(1)  )
  assertEquals( logrange( 1 )    .logstop , log(1)  )
  assertEquals( logrange( 1 )    .logstep , 1       )
  assertEquals( logrange( 1, 10 ).logstart, log(1)  )
  assertEquals( logrange( 1, 10 ).logstop , log(10) )
  assertEquals( logrange( 1, 10 ).logstep , 1       )

  assertEquals( {logrange( 1 ):range()}, { 1, 1, exp(1)} )
  lr = { logrange( 1, 10 ):range() }
  assertAlmostEquals( lr[1] / 1      - 1, 0,   eps )
  assertAlmostEquals( lr[2] / 10     - 1, 0, 9*eps )
  assertAlmostEquals( lr[3] / exp(1) - 1, 0,   eps )

  for _,v in ipairs(values.lempty) do
    lr = { logrange(v[1],v[2],v[3]):range() }
    assertAlmostEquals( lr[1] / v[1] -1, 0, 2*eps )
    assertAlmostEquals( lr[2] / v[2] -1, 0, 2*eps )
    assertAlmostEquals( lr[3] / v[3] -1, 0,   eps )
  end
  for _,v in ipairs(values.lrng)do
    lr = { logrange(v[1],v[2],v[3]):range() }
    assertAlmostEquals( lr[1] / v[1] -1, 0, 2*eps )
    assertAlmostEquals( lr[2] / v[2] -1, 0, 2*eps )
    assertAlmostEquals( lr[3] / v[3] -1, 0,   eps )
  end

    lr = { logrange( 1, 10, huge ):range() }
    assertAlmostEquals( lr[1] / 1  - 1, 0,   eps )
    assertAlmostEquals( lr[2] / 10 - 1, 0, 9*eps )
    --assertAlmostEquals( lr[3] - huge , 0,   eps )
    --print(log(exp(huge)))
    --print( lr[3], huge , lr[3] - huge )

    lr = { logrange( 1, 10, tiny ):range() }
    assertAlmostEquals( lr[1] - 1 , 0,   eps )
    assertAlmostEquals( lr[2] - 10, 0, 9*eps )
     assertAlmostEquals( lr[3] - tiny , 0,   eps )

    lr = { logrange( 1, 10, inf  ):range() }
    assertAlmostEquals( lr[1] - 1 , 0,   eps )
    assertAlmostEquals( lr[2] - 10, 0, 9*eps )
    assertNaN( lr[3] - inf )
end

function TestLogrange:testReadonly()
    local f1, f2, f3
  local msg = {
    "attempt to write to constant location",
  }
  for _,v in ipairs(values.num) do
    f1=\r,v => r.logstart = v end
    assertErrorMsgContains( msg[1], f1, logrange(1,10,0.1), v )
    assertErrorMsgContains( msg[1], f1, nlogrange(1,10,10), v )
    f2=\r,v => r.logstop  = v end
    assertErrorMsgContains( msg[1], f2, logrange(1,10,0.1), v )
    assertErrorMsgContains( msg[1], f2, nlogrange(1,10,10), v )
    f3=\r,v => r.logstep  = v end
    assertErrorMsgContains( msg[1], f3, logrange(1,10,0.1), v )
    assertErrorMsgContains( msg[1], f3, nlogrange(1,10,10), v )
  end
end

 function TestLogrange:testIsLogrange()
  assertFalse( is_logrange('') )
  assertFalse( is_logrange(2)  )
  assertFalse( is_logrange(range(1)) )
  assertFalse( is_logrange(1..10)    )
  assertFalse( is_logrange(nrange(1,10,1))  )

  assertTrue ( is_logrange( logrange( 10^5, 1    , 0.1)) )
  assertTrue ( is_logrange( logrange( 1   , 10^5 , 10 )) )
  assertTrue ( is_logrange( logrange( 1   , 10^-5, 0.1)) )
  assertTrue ( is_logrange( logrange( 10^5, 1    , 10 )) )
  assertTrue ( is_logrange(nlogrange( 1   , 10   ,10  )) )
 end

function TestLogrange:testRange()
  local r
  r =  logrange(1)
  assertEquals( {r:range()}, {exp(r.logstart), exp(r.logstop), exp(r.logstep)} )
  r =  logrange(1,10,10)
  assertEquals( {r:range()}, {exp(r.logstart), exp(r.logstop), exp(r.logstep)} )
  r = nlogrange(1,10,10)
  assertEquals( {r:range()}, {exp(r.logstart), exp(r.logstop), exp(r.logstep)} )

  for _,v in ipairs(values.lempty) do
    r = logrange(v[1],v[2],v[3])
    assertEquals( {r:range()}, {exp(r.logstart), exp(r.logstop), exp(r.logstep)} )
  end
  for _,v in ipairs(values.lrng) do
    r = logrange(v[1],v[2],v[3])
    assertEquals( {r:range()}, {exp(r.logstart), exp(r.logstop), exp(r.logstep)} )
  end
  for _,v in ipairs(values.num) do
    r = logrange( 1 ,10, v)
    assertEquals( {r:range()}, {exp(r.logstart), exp(r.logstop), exp(r.logstep)} )
  end
end

function TestLogrange:testIsEmpty()
  for _,v in ipairs(values.lempty) do
    assertTrue ( logrange(v[1],v[2],v[3]):is_empty() )
  end
  for _,v in ipairs(values.lrng) do
    assertFalse( logrange(v[1],v[2],v[3]):is_empty() )
  end
  assertFalse( logrange(1)          :is_empty() )
  assertFalse( logrange(1,10)       :is_empty() )
  assertFalse( logrange(1,10,1)     :is_empty() )
  assertTrue ( logrange(1,10,0.1)   :is_empty() )
  assertFalse( nlogrange(2, 10, 0.1):is_empty() )

 for _,v in ipairs(values.num) do
    if v > 1 then
      assertFalse( logrange( 1 , 10, v):is_empty() )
      assertTrue ( logrange( 10, 1 , v):is_empty() )
    elseif v < 1 then
      assertTrue ( logrange( 1 , 10, v):is_empty() )
      assertFalse( logrange( 10, 1 , v):is_empty() )
    else
      assertFalse( logrange( 10, 1 , v):is_empty() )
      assertFalse( logrange( 1 , 10, v):is_empty() )
    end
  end
  for _,v in ipairs(values.num) do
    assertFalse( nlogrange( 1 , 10, v):is_empty() )
    assertFalse( nlogrange( 10, 1 , v):is_empty() )
  end

  assertFalse(  logrange( 1, 10, huge ):is_empty() )
  assertFalse(  logrange( 1, 10, inf  ):is_empty() )
  assertTrue (  logrange( 1, 10, tiny ):is_empty() )
  assertFalse( nlogrange( 1, 10, huge ):is_empty() )
  assertFalse( nlogrange( 1, 10, inf  ):is_empty() )
  assertFalse( nlogrange( 1, 10, tiny ):is_empty() )
end

function TestLogrange:testNConstructor()
  local a = 2
  local msg = {
    "invalid argument #1 or #2 (number expected)",
    "invalid argument #1 (positive number expected)",
    "invalid argument #2 (positive number expected)",
    "invalid argument #3 (positive number expected)",
    "attempt to compare number with string",
  }
  assertErrorMsgContains( msg[1], nlogrange                )
  assertErrorMsgContains( msg[1], nlogrange, 1             )
  assertErrorMsgContains( msg[1], nlogrange, nil, 1        )
  assertErrorMsgContains( msg[1], nlogrange, nil, 1  , 1   )
  assertErrorMsgContains( msg[1], nlogrange, ''            )
  assertErrorMsgContains( msg[1], nlogrange, '' , ''       )
  assertErrorMsgContains( msg[1], nlogrange, '' , 1  , 1   )
  assertErrorMsgContains( msg[1], nlogrange, '' , '' , 1   )
  assertErrorMsgContains( msg[1], nlogrange, (1..10..1)    )
  assertErrorMsgContains( msg[4], nlogrange, 1  , 10 , 0   )
  assertErrorMsgContains( msg[4], nlogrange, 1  , 10 ,-1   )
  assertErrorMsgContains( msg[3], nlogrange, 1  ,-10 , 1   )
  assertErrorMsgContains( msg[2], nlogrange,-1  , 10 , 1   )
  assertErrorMsgContains( msg[4], nlogrange, -a ,-a  ,-a   )
  assertErrorMsgContains( msg[4], nlogrange, 1  , 10 , nan )
  assertErrorMsgContains( msg[4], nlogrange, 1  , nan, nan )
  assertErrorMsgContains( msg[4], nlogrange, nan, nan, nan )
  assertErrorMsgContains( msg[5], nlogrange, 1  , 10 , ''  )

  assertTrue( is_logrange(nlogrange( a, a, a))   )
  assertTrue( is_logrange(nlogrange(1,10 ))      )
  assertTrue( is_logrange(nlogrange(1,10 , 1))   )

  for _,v in ipairs(values.num) do
    assertTrue( is_logrange( nlogrange( 1, 10, v)) )
  end
  for _,v in ipairs(values.limit) do
    assertTrue( is_logrange( nlogrange( 1, 10, v)) )
  end
  for _,v in ipairs(values.nlrng) do
    assertTrue( is_logrange( nlogrange(v[1],v[2],v[3]) ) )
  end
end

function TestLogrange:testNCnstrFields()
  assertTrue( is_logrange(nlogrange(1,10 ))   )
  assertTrue( is_logrange(nlogrange(1,10, 1)) )

  for _,v in ipairs(values.nlrng)do
    lr = { nlogrange(v[1],v[2],v[3]):range() }
    assertAlmostEquals( lr[1] / v[1] - 1, 0,   eps )
    assertAlmostEquals( lr[2] / v[2] - 1, 0, 2*eps )
    --print(lr[3])
    --assertAlmostEquals( lr[3] / v[3] - 1, 0, 9*eps )
    end
 end

function TestLogrange:testValue()
  local lr
  assertEquals( logrange(1)          :value(0), 1 )
  assertNaN   ( logrange(1 ,10, inf) :value(0), 1 )
  assertEquals( logrange(1 ,10, huge):value(0), 1 )
  assertNaN   ( logrange(10,1,1)     :value( inf), inf  )
  assertNaN   ( logrange(10,1,1)     :value(-inf),-inf  )

  lr = logrange( 1 , 10^5, 10) assertAlmostEquals( lr:value(#lr) / 10^6 -1, 0, 6*eps )
  lr = logrange( 10, 10^5, 10) assertAlmostEquals( lr:value(-1)  / 1 -1   , 0,   eps )

  for _,v in ipairs(values.nlrng) do
    assertAlmostEquals( nlogrange(v[1],v[2],v[3]):value(0) / v[1] - 1, 0, eps )
    assertAlmostEquals( nlogrange(v[1],v[2],v[3]):value(0) / v[1] - 1, 0, eps )
  end
  for _,v in ipairs(values.lrng) do
    assertAlmostEquals(  logrange(v[1],v[2],v[3]):value(0) / v[1] - 1, 0, eps )
  end
  for _,v in ipairs(values.lempty) do
    assertAlmostEquals(  logrange(v[1],v[2],v[3]):value(0) / v[1] -1 , 0, eps )
  end

  assertEquals( logrange(1, 10, huge):value(0) , 1 )
  assertEquals( logrange(1, 10, tiny):value(0) , 1 )
  assertNaN   ( logrange(1, 10, inf ):value(0) )
  assertAlmostEquals( (0..1..0.1):value(eps) / exp(eps), 0, eps )
end

function TestLogrange:testGet()
  local lr
  assertEquals( logrange(1):get(0), 1 )
  assertEquals( logrange(1, 10, huge):get(0) , 1 )
  assertNil   ( logrange(1, 10, tiny):get(0) )

  for _,v in ipairs(values.lempty) do
    lr = logrange(v[1],v[2],v[3])
    assertNil( lr:get(0)     )
    assertNil( lr:get(#lr-1) )
  end
  for _,v in ipairs(values.nlrng) do
    lr = nlogrange(v[1],v[2],v[3])
    assertAlmostEquals( lr:get(0)     / v[1] - 1, 0,   eps )
    assertAlmostEquals( lr:get(#lr-1) / v[2] - 1, 0, 8*eps )
  end
  for _,v in ipairs(values.lrng) do
    lr = logrange(v[1],v[2],v[3])
    assertAlmostEquals( lr:get(0)     / v[1] - 1, 0,   eps )
    -- assertAlmostEquals( lr:get(#lr-1) / v[2] - 1, 0, 8*eps )
    -- can not be used for logrange(1, 10^5 , 10 ), last value not loaded
  end

  assertAlmostEquals( logrange(10^5, 1, 0.1):get(0) / 10^5 - 1, 0, eps )

  lr = logrange(1, 10^5 , 10 ) --missing the last element
  --for i=0,6 do print(i, lr:get(i)) end
end

--[[
function TestLogrange:testIndex()
end
]]

function TestLogrange:testSize()
  assertEquals(  logrange(1)                :size(), 1   )
  assertEquals(  logrange(2 ,10, inf)       :size(), 1   )
  assertEquals(  logrange(2 ,10, huge)      :size(), 1   )
  assertEquals( nlogrange(10^5, 1    , 100 ):size(), 100 )
  assertEquals( nlogrange(1   , 10^-5, 100 ):size(), 100 )
  assertEquals( nlogrange(1   , 10^5 , 100 ):size(), 100 )
  assertEquals( nlogrange(1   , 10, 0.1)    :size(), inf )
  assertEquals( nlogrange(10^5, 1 , 1  )    :size(), 0   )

  for _,v in ipairs(values.lrng) do
    assertEquals( logrange(v[1],v[2],v[3]) :size(), 6 )
  end
end

--[[
function TestLogrange:testEqual() -- not precisely equal, change in equal or in testing method
  local r
  for _,v in ipairs(values.lempty) do
    r = logrange(v[1],v[2],v[3]) assertTrue( range(r:range()) == r )
  end
  for _,v in ipairs(values.nlrng) do
    r = nlogrange(v[1],v[2],v[3]) assertTrue( range(r:range()) == r )
  end
  for _,v in ipairs(values.lrng) do
    r = logrange(v[1],v[2],v[3]) assertTrue( range(r:range()) == r )
  end
end
]]

function TestLogrange:testReverse()
  local lr1, lr2
  lr1 = { logrange(10^5, 1, 10 ):reverse():range() }
  lr2 = { logrange(1, 10^5, 0.1):range() }
  assertAlmostEquals( lr1[1]/lr2[1] - 1, 0,   eps )
  assertAlmostEquals( lr1[2]/lr2[2] - 1, 0,   eps )
  assertAlmostEquals( lr1[3]/lr2[3] - 1, 0, 2*eps )
  lr1 = { logrange(10^5, 1, 10 ):range() }
  lr2 = { logrange(1, 10^5, 0.1):reverse():range() }
  assertAlmostEquals( lr2[1]/lr1[1] - 1, 0,   eps )
  assertAlmostEquals( lr2[2]/lr1[2] - 1, 0,   eps )
  assertAlmostEquals( lr2[3]/lr1[3] - 1, 0, 2*eps )

  lr1 = {nlogrange(10^5, 1, 1000):reverse():range()}
  lr2 = {nlogrange(1, 10^5, 1000):range()}
  assertAlmostEquals( lr2[1]/lr1[1] - 1, 0,   eps )
  assertAlmostEquals( lr2[2]/lr1[2] - 1, 0,   eps )
  assertAlmostEquals( lr2[3]/lr1[3] - 1, 0, 2*eps )

  lr1 = { nlogrange(10^5, 1, 1000):range() }
  lr2 = { nlogrange(1, 10^5, 1000):reverse():range() }
  assertAlmostEquals( lr2[1]/lr1[1] - 1, 0,   eps )
  assertAlmostEquals( lr2[2]/lr1[2] - 1, 0,   eps )
  assertAlmostEquals( lr2[3]/lr1[3] - 1, 0, 2*eps )
end

function TestLogrange:testBounds()
local lr
  assertEquals( { logrange( 10^5, 1    , 10  ):bounds()}, {nil,nil} )
  assertEquals( { logrange( 1   , 10^5 , 0.1 ):bounds()}, {nil,nil} )
  assertEquals( { logrange( 1   , 10^-5, 10  ):bounds()}, {nil,nil} )

  lr = { logrange( 10^5, 1, 0.1 ):bounds()}
  assertAlmostEquals( lr[1] / 1    - 1, 0, eps )
  assertAlmostEquals( lr[2] / 10^5 - 1, 0, eps )
  lr = { logrange( 1   , 10^5 , 10  ):bounds()}
  assertAlmostEquals( lr[1] / 1    - 1, 0, eps )
  assertAlmostEquals( lr[2] / 10^5 - 1, 0, eps )
  lr = { logrange( 1   , 10^-5, 0.1 ):bounds()}
  assertAlmostEquals( lr[1] / 10^-5 - 1, 0, 2*eps )
  assertAlmostEquals( lr[2] / 1     - 1, 0,   eps )

  lr = {nlogrange( 10^5, 1    , 100 ):bounds()}
  assertAlmostEquals( lr[1] / 1    - 1, 0, eps )
  assertAlmostEquals( lr[2] / 10^5 - 1, 0, eps )
  lr = {nlogrange( 1   , 10^-5, 100 ):bounds()}
  assertAlmostEquals( lr[1] / 10^-5 -1, 0, 2*eps )
  assertAlmostEquals( lr[2] / 1     -1, 0,   eps )

  lr = { logrange( 1   , 10^-5, 1 ):bounds()}
  assertAlmostEquals( lr[1] / 1 - 1, 0, 2*eps )
  assertAlmostEquals( lr[2] / 1 - 1, 0,   eps )
  lr = {nlogrange( 1   , 10^-5, 1   ):bounds()}
  assertAlmostEquals( lr[1] / 1 - 1, 0, 2*eps )
  assertAlmostEquals( lr[2] / 1 - 1, 0,   eps )

  lr = {nlogrange( 1   , 10^5 , 100 ):bounds()}
  assertAlmostEquals( lr[1] / 1    - 1, 0, eps )
  assertAlmostEquals( lr[2] / 10^5 - 1, 0, eps )
end

function TestLogrange:testOverlap()
  local lr, nr
  assertFalse(  logrange( 10^5, 1    , 10 ):overlap(logrange(1,10^5,10))   )
  assertFalse(  logrange( 1   , 10^5 , 0.1):overlap(logrange(1,10^5,10))   )
  assertFalse(  logrange( 1   , 10^-5, 10 ):overlap(logrange(1,10^5,10))   )
  assertTrue ( nlogrange( 10^5, 1    , 1  ):overlap(logrange(1,10^5,10))   )
  assertFalse( nlogrange( 10^5, 1    , 1  ):overlap(logrange(1,10^-5,0.1)) )

  lr = logrange( 10^5, 1, 0.1 )
  assertTrue( lr:overlap(logrange(1, 10^5 , 10  )) )
  assertTrue( lr:overlap(logrange(1, 10^-5, 0.1 )) )
  lr = logrange( 1, 10^5 , 10)
  assertTrue( lr:overlap(logrange(10^5, 1    , 0.1)) )
  assertTrue( lr:overlap(logrange(1   , 10^-5, 0.1)) )
  lr = logrange( 1, 10^-5, 0.1)
  assertTrue( lr:overlap(logrange(10^5, 1    , 0.1)) )
  assertTrue( lr:overlap(logrange(1   , 10^-5, 0.1)) )

  nr = nlogrange(10^5, 1 , 6)
  assertTrue( nr:overlap( logrange(1   , 10^5 , 10  )) )
  assertTrue( nr:overlap( logrange(1   , 10^-5, 0.1 )) )
  assertTrue( nr:overlap( logrange(10^5, 1    , 0.1 )) )
  assertTrue( nr:overlap(nlogrange(1   , 10^5 , 6   )) )
  assertTrue( nr:overlap(nlogrange(1   , 10^-5, 6   )) )

  nr = nlogrange(1   , 10^5 , 6)
  assertTrue( nr:overlap( logrange(1   , 10^5 , 10  )) )
  assertTrue( nr:overlap( logrange(1   , 10^-5, 0.1 )) )
  assertTrue( nr:overlap( logrange(10^5, 1    , 0.1 )) )
  assertTrue( nr:overlap(nlogrange(10^5, 1    , 6   )) )
  assertTrue( nr:overlap(nlogrange(1   , 10^-5, 6   )) )

  nr = nlogrange(1   , 10^-5, 6)
  assertTrue( nr:overlap( logrange(1   , 10^5 , 10  )) )
  assertTrue( nr:overlap( logrange(1   , 10^-5, 0.1 )) )
  assertTrue( nr:overlap( logrange(10^5, 1    , 0.1 )) )
  assertTrue( nr:overlap(nlogrange(1   , 10^5 , 6   )) )
  assertTrue( nr:overlap(nlogrange(10^5, 1    , 6   )) )
end

function TestLogrange:testIlogrange()
  local msg = {
    "invalid argument #1 (positive number expected)",
    "invalid argument #2 (positive number expected)",
    "invalid argument #3 (positive number expected)",
  }
  assertErrorMsgContains( msg[1], ilogrange              )
  assertErrorMsgContains( msg[1], ilogrange, ''          )
  assertErrorMsgContains( msg[1], ilogrange, nil, 1      )
  assertErrorMsgContains( msg[2], ilogrange, 1  , ''     )
  assertErrorMsgContains( msg[3], ilogrange, 1  , 10, '' )

  local s, r, ir
  ir = {ilogrange(1,10^5,10)}
  assertTrue( is_function(ir[1]) )
  assertTrue( is_logrange(ir[2]) )
  assertTrue( ir[3] == 0         )

  for _,v in ipairs(values.lrng) do
    r = logrange(v[1],v[2],v[3]) for i,v in ilogrange(v[1],v[2],v[3]) do assertEquals(r[i], v) end
  end
  for _,v in ipairs(values.lempty) do
    r,s = logrange(v[1],v[2],v[3]),0 for i,v in ilogrange(v[1],v[2],v[3]) do s=s+1; assertEquals(s, 0) end
  end
end

--[[
-- performance test suite -----------------------------------------------------o

Test_Logrange = {}
function Test_Logrange:testIrange()
end

-- end ------------------------------------------------------------------------o
]]
