--[=[
 o-----------------------------------------------------------------------------o
 |
 | Complex module regression tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the complex module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o
local assertEquals, assertAlmostEquals, assertTrue, assertFalse,
      assertErrorMsgContains, assertNil, assertNaN, assertIsString, assertInf
      in MAD.utest

local complex, _C, linspace, option, tocomplex                   in MAD
local abs, sqrt, cos, sin, tan, cosh, sinh, tanh, asinh, atanh, asin,
      atan, atan2, exp, log, frac, trunc, round, hypot, floor,
      cabs, carg, real, imag, cplx, reim                         in MAD.gmath
local is_complex, is_table                                       in MAD.typeid
local eps, tiny, huge, inf, nan, pi                              in MAD.constant

local infi = complex(0,inf)

-- regression test suite ------------------------------------------------------o

TestComplex = {}

local values = {
  num  = {0, tiny, 2^-64, 2^-63, 2^-53, eps, 2^-52, 2*eps, 2^-32, 2^-31, 1e-9,
          0.1-eps, 0.1, 0.1+eps, 0.5, 0.7-eps, 0.7, 0.7+eps, 1-eps, 1, 1+eps,
          1.1, 1.7, 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53,
          2^63, 2^64, huge},
  rad  = {0, eps, 2*eps, pi/180, pi/90, pi/36, pi/18, pi/12, pi/6, pi/4, pi/3, pi/2,
          pi-pi/3, pi-pi/4, pi-pi/6, pi-pi/12, pi},
  rad2 = {0, eps, 2*eps, pi/180, pi/90, pi/36, pi/18, pi/12, pi/6, pi/4, pi/3, pi/2},
  rad3 = {0, eps, 2*eps, pi/180, pi/90, pi/36, pi/18, pi/12, pi/6, pi/4, pi/3},
}

local function unitCircle (r, n)
  local rad
  local z = {}
  if is_table(n) then
    for i,rad in ipairs(n) do
      z[i] = complex( r*cos( rad ), r*sin( rad ) )
    end
  else
    for i = 0, 2*n do
      rad  = 2*pi*(i-1)/n
      z[i] = complex( r*cos( rad ), r*sin( rad ) )
    end
  end
  return z
end

function TestComplex:testCtorErr()
  local msg, c = {
  "cannot convert 'string' to 'complex'",
  "cannot convert 'nil' to 'complex'"   ,
  "cannot convert 'string' to 'double'" ,
  "cannot convert 'nil' to 'double'"    ,
  }
  assertErrorMsgContains( msg[1], complex, ''       )
  assertErrorMsgContains( msg[2], complex, nil      )
  assertErrorMsgContains( msg[3], complex, '' , ''  )
  assertErrorMsgContains( msg[3], complex, 1  , ''  )
  assertErrorMsgContains( msg[3], complex, '' , 1   )
  assertErrorMsgContains( msg[4], complex, nil, 1   )
  assertErrorMsgContains( msg[4], complex, 1  , nil )
end

function TestComplex:testCtor()
  assertEquals( complex(0, 1)  , 1i            )
  assertEquals( complex(0,-1)  ,-1i            )
  assertEquals( complex(0, 1)^2, complex(-1,0) )
  for _,v in ipairs(values.num) do
    assertTrue( is_complex( complex( 0, v) ) )
    assertTrue( is_complex( complex( 0,-v) ) )
    assertTrue( is_complex( complex(-v, 0) ) )
    assertTrue( is_complex( complex( v, 0) ) )
    assertTrue( is_complex( complex( v, v) ) )
    assertTrue( is_complex( complex(-v,-v) ) )
  end
  assertNaN   ( complex(nan, 1  ).re    )
  assertEquals( complex(nan, 1  ).im, 1 )
  assertEquals( complex(1  , nan).re, 1 )
  assertNaN   ( complex(1  , nan).im    )
  assertNaN   ( complex(nan, nan).re    )
  assertNaN   ( complex(nan, nan).im    )
end
function TestComplex:testCtorFields()
  assertNaN   ( complex(nan).re       )
  assertNaN   ( complex(nan, nan).re  )
  assertEquals( complex(1).re   , 1   )
  assertEquals( complex(1).im   , 0   )
  assertEquals( complex(0,1).re , 0   )
  assertEquals( complex(0,1).im , 1   )
  for _,v in ipairs(values.num) do
    assertEquals( complex( 0, v).re,  0 )
    assertEquals( complex( 0,-v).re,  0 )
    assertEquals( complex(-v, 0).re, -v )
    assertEquals( complex( v, 0).re,  v )
    assertEquals( complex( v, v).re,  v )
    assertEquals( complex(-v,-v).re, -v )
    assertEquals( complex( 0, v).im,  v )
    assertEquals( complex( 0,-v).im, -v )
    assertEquals( complex(-v, 0).im,  0 )
    assertEquals( complex( v, 0).im,  0 )
    assertEquals( complex( v, v).im,  v )
    assertEquals( complex(-v,-v).im, -v )
    if v ~= inf then
      assertEquals( ( 0+ v*1i).re,  0 )
      assertEquals( ( 0+-v*1i).re,  0 )
    end
    assertEquals( (-v+ 0*1i).re, -v )
    assertEquals( ( v+ 0*1i).re,  v )
    assertEquals( ( 0+ v*1i).im,  v )
    assertEquals( ( 0+-v*1i).im, -v )
    assertEquals( (-v+ 0*1i).im,  0 )
    assertEquals( ( v+ 0*1i).im,  0 )
  end
    assertEquals( complex( 0  , inf).re,  0   )
    assertEquals( complex( 0  ,-inf).re,  0   )
    assertEquals( complex(-inf, 0  ).re, -inf )
    assertEquals( complex( inf, 0  ).re,  inf )
    assertEquals( complex( inf, inf).re,  inf )
    assertEquals( complex(-inf,-inf).re, -inf )
    assertEquals( complex( 0  , inf).im,  inf )
    assertEquals( complex( 0  ,-inf).im, -inf )
    assertEquals( complex(-inf, 0  ).im,  0   )
    assertEquals( complex( inf, 0  ).im,  0   )
    assertEquals( complex( inf, inf).im,  inf )
    assertEquals( complex(-inf,-inf).im, -inf )
end

-- generic functions

function TestComplex:testReal()
  assertNaN   (    complex( nan, nan):real()       )
  assertEquals(    complex( inf, inf):real() , inf )
  assertEquals(    complex(-inf,-inf):real() ,-inf )
  assertEquals( 1/(complex( 0  , 0  ):real()), inf )
  assertEquals( 1/(complex(-0  ,-0  ):real()),-inf )
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertEquals( z:real()                   , z.re )
    assertEquals( complex(-z.re, z.im):real(),-z.re )
    assertEquals( complex( z.re,-z.im):real(), z.re )
    assertEquals( complex(-z.re,-z.im):real(),-z.re )
  end
end

function TestComplex:testImag()
  local c
  assertNaN   (    complex( nan, nan):imag()       )
  assertEquals(    complex( inf, inf):imag() , inf )
  assertEquals(    complex(-inf,-inf):imag() ,-inf )
  assertEquals( 1/(complex( 0  , 0  ):imag()), inf )
  assertEquals( 1/(complex(-0  ,-0  ):imag()),-inf )
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertEquals( z:imag()                   , z.im )
    assertEquals( complex(-z.re, z.im):imag(), z.im )
    assertEquals( complex( z.re,-z.im):imag(),-z.im )
    assertEquals( complex(-z.re,-z.im):imag(),-z.im )
    assertEquals( complex(z:real(), z:imag()), z    )
  end

  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      c = complex( x, y)
      assertEquals( c, complex(c:real(), c:imag()) )
    end
  end
  c = complex( inf, inf)
  assertEquals( c, complex(c:real(), c:imag()) )
end

function TestComplex:testCeil()
  for _,x in ipairs(values.rad) do
    for _,y in ipairs(values.rad) do
      local x, y = x/pi, y/pi
      if     x >  0 and y >  0 then assertEquals( ( x + y*1i ):ceil(), 1 + 1i )
      elseif x <= 0 and y >  0 then assertEquals( ( x + y*1i ):ceil(), 0 + 1i )
      elseif x >  0 and y <= 0 then assertEquals( ( x + y*1i ):ceil(), 1 + 0i )
      else                          assertEquals( ( x + y*1i ):ceil(), 0 + 0i ) end
    end
  end
end

function TestComplex:testFloor()
  for _,x in ipairs(values.rad) do
    for _,y in ipairs(values.rad) do
      local x, y = x/pi, y/pi
      if     x <  1 and y <  1 then assertEquals( ( x + y*1i ):floor(), 0 + 0i )
      elseif x >= 1 and y >= 1 then assertEquals( ( x + y*1i ):floor(), 1 + 1i )
      elseif x >= 1 then            assertEquals( ( x + y*1i ):floor(), 1 + 0i )
      else                          assertEquals( ( x + y*1i ):floor(), 0 + 1i ) end
    end
  end
end

function TestComplex:testFrac()
  for _,z in ipairs( unitCircle( 1, values.rad) ) do
    local re, im  = z:real(), z:imag()
    assertEquals( z:frac():real(), frac( re ) )
    assertEquals( z:frac():imag(), frac( im ) )
  end
end

function TestComplex:testTrunc()
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im  = z:real(), z:imag()
    assertEquals( z:trunc():real() - trunc( re ), 0, eps )
    assertEquals( z:trunc():imag() - trunc( im ), 0, eps )
  end
end

function TestComplex:testRound()
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im  = z:real(), z:imag()
    assertEquals( z:round():real() - round( re ), 0, eps )
    assertEquals( z:round():imag() - round( im ), 0, eps )
  end
end

function TestComplex:testAbs()
  for _,x in ipairs(values.rad) do
    for _,y in ipairs(values.rad) do
      local x, y = x/pi, y/pi
      assertAlmostEquals( abs(x + y*1i) - hypot(x,y), 0, eps )
    end
  end
  for _,x in ipairs(values.num) do
    if x ~= huge then assertAlmostEquals( abs(x + x*1i) - hypot(x,x), 0, 2*eps )
    else              assertInf         ( abs(x + x*1i) )                       end
  end
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im  = real(z), imag(z)
    assertAlmostEquals( abs( re + im*1i ) - 1, 0, eps )
    assertAlmostEquals( abs(-re + im*1i ) - 1, 0, eps )
    assertAlmostEquals( abs( re - im*1i ) - 1, 0, eps )
    assertAlmostEquals( abs(-re - im*1i ) - 1, 0, eps )
  end
  for _,z in ipairs(unitCircle( 10, values.rad)) do
    assertAlmostEquals( abs(z) - 10, 0, 8*eps )
  end
end

function TestComplex:testCAbs()
  for _,x in ipairs(values.num) do
    if x ~= huge then assertAlmostEquals( cabs(x + x*1i) - hypot(x,x), 0, 2*eps )
    else              assertInf         ( cabs(x + x*1i) )                       end
  end
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = real(z), imag(z)
    assertAlmostEquals( cabs( re + im*1i ) - 1, 0, eps )
    assertAlmostEquals( cabs(-re + im*1i ) - 1, 0, eps )
    assertAlmostEquals( cabs( re - im*1i ) - 1, 0, eps )
    assertAlmostEquals( cabs(-re - im*1i ) - 1, 0, eps )
  end
  for _,z in ipairs(unitCircle( 10, values.rad)) do
    assertAlmostEquals( cabs(z) - 10, 0, 8*eps )
  end
  for _,x in ipairs(values.rad) do
    for _,y in ipairs(values.rad) do
      local x, y = x/pi, y/pi
      assertAlmostEquals( cabs(x + y*1i) - hypot(x,y), 0, eps )
      -- Check for IEEE:IEC 60559 compliance (next 7 below)
      assertEquals(cabs(x + y*1i), cabs(y + 1i * x))
      assertEquals(cabs(x - 1i*y), cabs(x - 1i*y))
    end
    assertEquals(cabs(x, 0), abs(x))
    assertEquals(cabs(inf, x), inf)
    assertEquals(cabs(-inf, x), inf)
  end
  --Below fails on Ubuntu 22.04.1 LTS, instead NaN is returned, not compliant with ISO/IEC 9899:1999 (keep last so other tests run)
  assertEquals(cabs(inf + 1i * nan), inf)
  assertEquals(cabs(-inf + 1i* nan), inf)
end

function TestComplex:testCArg()
  for _,x in ipairs(values.rad) do
    for _,y in ipairs(values.rad) do
      local x, y = x/pi, y/pi
      assertAlmostEquals( carg(x + y*1i) - atan2(y,x), 0, eps )
    end
  end
  for _,x in ipairs(values.num) do
    assertAlmostEquals( carg(x + x*1i) - atan2(x,x), 0, 2*eps )
  end
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = real(z), imag(z)
    assertAlmostEquals( carg( re + im*1i ) -     atan2(im,re) , 0,   eps )
    assertAlmostEquals( carg(-re + im*1i ) - (pi-atan2(im,re)), 0, 2*eps )
    assertAlmostEquals( carg( re - im*1i ) +     atan2(im,re) , 0,   eps )
    assertAlmostEquals( carg(-re - im*1i ) + (pi-atan2(im,re)), 0, 2*eps )
  end
  for _,z in ipairs(unitCircle( 10, values.rad)) do
    assertAlmostEquals( carg(z) - atan2(z.im,z.re), 0, 8*eps )
  end
end

function TestGmath:testCplx()
  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      local actual = cplx(x,y)
      assertEquals(real(actual), x)
      assertEquals(imag(actual), y)
    end
  end
end

function TestGmath:testReim()
  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      local a, b = reim(cplx(x,y))
      assertEquals(a, x)
      assertEquals(b, y)
    end
  end
end

function TestComplex:testSqrt()
  local r = 1
  for i,z in ipairs(unitCircle( r, values.rad2)) do
    local rad2 = values.rad2[i]
    local c = cos(rad2/2) + sin(rad2/2)*1i
    assertAlmostEquals( z:sqrt():real() - sqrt(r)*c:real(), 0, eps )
    assertAlmostEquals( z:sqrt():imag() - sqrt(r)*c:imag(), 0, eps )
    local re, im  = z:real(), z:imag()
    assertEquals( (re + im*1i):sqrt():real(),  (re - im*1i):sqrt():real() )
    assertEquals( (re + im*1i):sqrt():imag(), -(re - im*1i):sqrt():imag() )
  end
  assertEquals      ( ( 0 + 2i ):sqrt()                                 , 1 + 1i )
  assertEquals      ( ( 1 + 0i ):sqrt()                                 , 1 + 0i )
  assertAlmostEquals( ( 0 + 1i ):sqrt():imag() - sqrt(2)/2*(1+1i):imag(), 0, eps )
  assertEquals      ( ( 0 + 1i ):sqrt():real() - sqrt(2)/2*(1+1i):real(), 0      )
  assertAlmostEquals( (-2 + 0i ):sqrt():imag() - 1.414213562373095      , 0, eps )
  assertEquals      ( (-2 + 0i ):sqrt():real()                          , 0      )

  assertEquals      ( 1/( 0 + 0i):sqrt():real()                         , inf    )
  assertEquals      ( 1/( 0 + 0i):sqrt():imag()                         , inf    )
  assertEquals      ( 1/(-0 - 0i):sqrt():real()                         , inf    )
  assertEquals      ( 1/(-0 - 0i):sqrt():imag()                         ,-inf    )
  assertEquals      ( (-eps + 0i):sqrt():real()                         , 0      )
  assertAlmostEquals( (-eps + 0i):sqrt():imag() - 1.49011611938477e-08  , 0, eps )

  local ref = {
    0 - 1i,
    1.11022302462516e-16 - 1i                  ,
    2.22044604925031e-16 - 1i                  ,
    0.00872653549837393  - 0.99996192306417131i,
    0.0174524064372835   - 0.9998476951563913i ,
    0.0436193873653360   - 0.9990482215818578i ,
    0.0871557427476582   - 0.9961946980917455i ,
    0.130526192220052    - 0.991444861373810i  ,
    0.258819045102521    - 0.965925826289068i  ,
    0.382683432365090    - 0.923879532511287i  ,
    0.500000000000000    - 0.866025403784439i  ,
    0.707106781186547    - 0.707106781186548i  ,
    0 + 1i,
    1.11022302462516e-16 + 1i                  ,
    2.22044604925031e-16 + 1i                  ,
    0.00872653549837393  + 0.99996192306417131i,
    0.0174524064372835   + 0.9998476951563913i ,
    0.0436193873653360   + 0.9990482215818578i ,
    0.0871557427476582   + 0.9961946980917455i ,
    0.130526192220052    + 0.991444861373810i  ,
    0.258819045102521    + 0.965925826289068i  ,
    0.382683432365090    + 0.923879532511287i  ,
    0.500000000000000    + 0.866025403784439i  ,
    0.707106781186547    + 0.707106781186548i  ,
  }
  for i,z in ipairs(unitCircle( r, values.rad2)) do
    local re, im  = z:real(), z:imag()
    local s = #values.rad2
    assertAlmostEquals( (-re - im*1i):sqrt():real() - ref[i]  :real(), 0, 2*eps )
    assertAlmostEquals( (-re - im*1i):sqrt():imag() - ref[i]  :imag(), 0, 2*eps )
    assertAlmostEquals( (-re + im*1i):sqrt():real() - ref[i+s]:real(), 0, 2*eps )
    assertAlmostEquals( (-re + im*1i):sqrt():imag() - ref[i+s]:imag(), 0, 2*eps )
  end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( 0, 0):sqrt(), complex( 0, 0 ) )
  for _,x in ipairs(values.rad) do
    assertNaN   ( complex( x  , nan):sqrt().re      )
    assertNaN   ( complex( x  , nan):sqrt().im      )
    assertNaN   ( complex( nan, x  ):sqrt().re      )
    assertNaN   ( complex( nan, x  ):sqrt().im      )
    assertEquals( complex( x  , inf):sqrt(), complex( inf, inf) )
    assertEquals( complex(-inf, x  ):sqrt(), complex( 0  , inf) )
    assertEquals( complex( inf, x  ):sqrt(), complex( inf, 0  ) )
  end
  assertNaN   ( complex(-inf, nan):sqrt().re      )
  assertEquals( complex(-inf, nan):sqrt().im,-inf )
  assertEquals( complex( inf, nan):sqrt().re, inf )
  assertNaN   ( complex( inf, nan):sqrt().im      )
  assertNaN   ( complex( nan, nan):sqrt().re      )
  assertNaN   ( complex( nan, nan):sqrt().im      )
end

function TestComplex:testExp()
  assertEquals      ( complex( 0, 2*pi):exp():real(), 1        )
  assertAlmostEquals( complex( 0, 2*pi):exp():imag(), 0, 2*eps )
  for _,y in ipairs(values.rad) do
    local z = complex(0,y)
    assertEquals( (sin(y) - (z:exp() - (-z):exp()) / 2i), 0 + 0i )
    assertEquals( (cos(y) - (z:exp() + (-z):exp()) / 2 ), 0 + 0i )
  end
  for _,y in ipairs(values.num) do
    local z = complex(0,y)
    assertEquals( (sin(y) - (z:exp() - (-z):exp()) / 2i), 0 + 0i )
    assertEquals( (cos(y) - (z:exp() + (-z):exp()) / 2 ), 0 + 0i )
  end
  for i,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    assertEquals( z      ,           complex( 0      , values.rad[i]):exp() )
    assertEquals( z:exp(), exp(re) * complex( cos(im),       sin(im))       )
  for i,z1 in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (z + z1):exp():real() - (z:exp()*z1:exp()):real(), 0, 12*eps )
    assertAlmostEquals( (z + z1):exp():imag() - (z:exp()*z1:exp()):imag(), 0,  8*eps )
  end end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( 0, 0):exp(), complex( 1, 0) )
  for _,x in ipairs(values.rad) do
    local x = x/pi
    assertNaN( complex( x, inf):exp():real() )
    assertNaN( complex( x, inf):exp():imag() )
    assertNaN( complex( x, nan):exp():real() )
    assertNaN( complex( x, nan):exp():imag() )
    if x > 0 then
      assertNaN   ( complex( nan, x):exp():real() )
      assertNaN   ( complex( nan, x):exp():imag() )
      assertEquals( complex(-inf, x):exp(), complex( 0  , 0  ) )
      assertEquals( complex( inf, x):exp(), complex( inf, inf) )
    end
  end
  assertEquals( complex( inf, 0  ):exp()       , complex( inf, 0) )
  assertEquals( complex(-inf, inf):exp()       , complex( 0  , 0) )
  assertEquals( complex( inf, inf):exp():real(), inf              )
  assertNaN   ( complex( inf, inf):exp():imag()                   )
  assertEquals( complex(-inf, nan):exp()       , complex( 0  , 0) )
  assertEquals( complex( inf, nan):exp():real(), inf              )
  assertNaN   ( complex( inf, nan):exp():imag()                   )
  assertNaN   ( complex( nan, 0  ):exp():real()                   )
  assertEquals( complex( nan, 0  ):exp():imag(), 0                )
  assertNaN   ( complex( nan, nan):exp():real()                   )
  assertNaN   ( complex( nan, nan):exp():imag()                   )
end

function TestComplex:testLog()
  assertEquals( (  1  + 0i):log(),  0                 + 0i      )
  assertEquals( (- 1  + 0i):log(),  0                 + pi  *1i )
  assertEquals( (  0  + 1i):log(),  0                 + pi/2*1i )
  assertEquals( (  0  - 1i):log(),  0                 - pi/2*1i )
  assertEquals( (- 0  + 1i):log(),  0                 + pi/2*1i )
  assertEquals( (  0  + 1i):log(),  0                 + pi/2*1i )
  assertEquals( (-eps + 0i):log(), -36.04365338911715 + pi  *1i )
  assertEquals( ( eps + 0i):log(), -36.04365338911715 + 0i      )

  assertAlmostEquals( complex( 0,  pi      ):log():real() -  1.1447298858494002, 0, eps )
  assertAlmostEquals( complex( 0,- pi      ):log():real() -  1.1447298858494002, 0, eps )
  assertAlmostEquals( complex( 0,  pi + 1  ):log():real() -  1.4210804127942926, 0, eps )
  assertAlmostEquals( complex( 0,-(pi + 1) ):log():real() -  1.4210804127942926, 0, eps )
  assertAlmostEquals( complex(-0,  pi      ):log():real() -  1.1447298858494002, 0, eps )
  assertAlmostEquals( complex(-0,- pi      ):log():real() -  1.1447298858494002, 0, eps )
  assertAlmostEquals( complex(-0,  pi + 1  ):log():real() -  1.4210804127942926, 0, eps )
  assertAlmostEquals( complex(-0,-(pi + 1) ):log():real() -  1.4210804127942926, 0, eps )

  assertAlmostEquals( complex( 0,  pi      ):log():imag() -  1.5707963267948966, 0, eps )
  assertAlmostEquals( complex( 0,- pi      ):log():imag() - -1.5707963267948966, 0, eps )
  assertAlmostEquals( complex( 0,  pi + 1  ):log():imag() -  1.5707963267948966, 0, eps )
  assertAlmostEquals( complex( 0,-(pi + 1) ):log():imag() - -1.5707963267948966, 0, eps )
  assertAlmostEquals( complex(-0,  pi      ):log():imag() -  1.5707963267948966, 0, eps )
  assertAlmostEquals( complex(-0,- pi      ):log():imag() - -1.5707963267948966, 0, eps )
  assertAlmostEquals( complex(-0,  pi + 1  ):log():imag() -  1.5707963267948966, 0, eps )
  assertAlmostEquals( complex(-0,-(pi + 1) ):log():imag() - -1.5707963267948966, 0, eps )

  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    assertAlmostEquals( (z:exp():log()):real() - re, 0, eps )
    assertAlmostEquals( (z:exp():log()):imag() - im, 0, eps )
    assertAlmostEquals( (z:log():exp()):real() - re, 0, eps )
    assertAlmostEquals( (z:log():exp()):imag() - im, 0, eps )

    assertAlmostEquals( (1/z):log():real() - -(z:log()):real()      , 0,   eps )
    assertAlmostEquals( (1/z):log():imag() - -(z:log()):imag()      , 0,   eps ) --Division introduces error
    assertEquals      ( z    :log():real(),  (-z):log():real()                 )
    assertAlmostEquals( abs(z:log():imag() - (-z):log():imag()) - pi, 0, 2*eps )
  end
  for _,z in ipairs(unitCircle( pi, values.rad)) do
    local re, im = z:real(), z:imag()
    assertAlmostEquals( (z:exp():log()):real() - re, 0, 2*eps )
    assertAlmostEquals( (z:exp():log()):imag() - im, 0,   eps )
    assertAlmostEquals( (z:log():exp()):real() - re, 0, 4*eps )
    assertAlmostEquals( (z:log():exp()):imag() - im, 0, 2*eps )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    local re, im = z:real(), z:imag()
    if x < pi then
      assertAlmostEquals( (z:exp():log()):real() - re, 0,   eps )
      assertAlmostEquals( (z:exp():log()):imag() - im, 0,   eps )
      assertAlmostEquals( (z:log():exp()):real() - re, 0, 2*eps )
      assertAlmostEquals( (z:log():exp()):imag() - im, 0, 2*eps )
    end
  end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( complex(-0, 0):log(), complex(-inf, pi) ) --expected: -inf+pi*1i  jit: -inf (JIT) [BUG]
  assertEquals( complex( 0, 0):log(), complex(-inf, 0 ) )
  for _,x in ipairs(values.rad) do
    assertEquals( complex( x  , inf):log(), complex( inf, pi/2) )
    assertNaN   ( complex( x  , nan):log():real()               )
    assertNaN   ( complex( x  , nan):log():imag()               )
    assertEquals( complex(-inf, x  ):log(), complex( inf, pi  ) )
    assertEquals( complex( inf, x  ):log(), complex( inf, 0   ) )
    assertNaN   ( complex( nan, x  ):log():real()               )
    assertNaN   ( complex( nan, x  ):log():imag()               )
  end
  assertEquals( complex(-inf, inf):log()       , complex( inf, 3*pi/4) )
  assertEquals( complex( inf, inf):log()       , complex( inf,   pi/4) )
  assertEquals( complex( inf, nan):log():real(), inf                   )
  assertNaN   ( complex( inf, nan):log():imag()                        )
  assertEquals( complex( nan, inf):log():real(), inf                   )
  assertNaN   ( complex( nan, inf):log():imag()                        )
  assertNaN   ( complex( nan, nan):log():real()                        )
  assertNaN   ( complex( nan, nan):log():imag()                        )
end

function TestComplex:testLog10()
  assertEquals      ( complex( 1  , 0):log10()       ,   complex( 0, 0)                )
  assertEquals      ( complex(-1  , 0):log10():real(),   0                             )
  assertEquals      ( complex( 0  ,-1):log10():real(),   0                             )
  assertEquals      ( complex( 0  , 1):log10():real(),   0                             )
  assertEquals      ( complex(-0  , 1):log10():real(),   0                             )
  assertAlmostEquals( complex(-eps, 0):log10():real() - -15.65355977452702  , 0, 8*eps )
  assertAlmostEquals( complex( eps, 0):log10():real() - -15.65355977452702  , 0, 8*eps )

  assertAlmostEquals( complex(-1  , 0):log10():imag() -  1.364376353841841  , 0,   eps )
  assertEquals      ( complex( 0  ,-1):log10():imag(),  -0.6821881769209206            )
  assertEquals      ( complex( 0  , 1):log10():imag(),   0.6821881769209206            )
  assertEquals      ( complex(-0  , 1):log10():imag(),   0.6821881769209206            )
  assertAlmostEquals( complex(-eps, 0):log10():imag() -  1.364376353841841  , 0,   eps )
  assertEquals      ( complex( eps, 0):log10():imag(),   0                             )
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (z:log10() - z:log()/log(10)):real(), 0, eps )
    assertAlmostEquals( (z:log10() - z:log()/log(10)):imag(), 0, eps )
  end
end

function TestComplex:testSin()
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    local c = complex( sin(re)*cosh(im), cos(re)*sinh(im) )
    assertAlmostEquals( sin( z):real() - c:real(), 0, eps )
    assertAlmostEquals( sin( z):imag() - c:imag(), 0, eps )

    c = complex( sin(-re)*cosh(-im), cos(-re)*sinh(-im) )
    assertAlmostEquals( sin(-z):real() - c:real(), 0, eps )
    assertAlmostEquals( sin(-z):imag() - c:imag(), 0, eps )
    assertAlmostEquals( sin(z+2*pi):real() - sin(z):real(), 0, 3*eps)
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    local re, im = z:real(), z:imag()
    if x< 10 then
      assertAlmostEquals( (sin( z) - complex( sin( re)*cosh( im), cos( re)*sinh( im))):real(), 0, 2*eps )
      assertAlmostEquals( (sin( z) - complex( sin( re)*cosh( im), cos( re)*sinh( im))):imag(), 0, 2*eps )
      assertAlmostEquals( (sin(-z) - complex( sin(-re)*cosh(-im), cos(-re)*sinh(-im))):real(), 0, 2*eps )
      assertAlmostEquals( (sin(-z) - complex( sin(-re)*cosh(-im), cos(-re)*sinh(-im))):imag(), 0, 2*eps )
    end
  end

  assertEquals( complex( 0   , 0   ):sin(), complex( 0   , 0   ) )
  assertEquals( complex( tiny, tiny):sin(), complex( tiny, tiny) )
  assertEquals( complex( huge, huge):sin(), complex( inf ,-inf ) )
  assertEquals( complex(-huge,-huge):sin(), complex(-inf , inf ) )
  assertNaN   ( complex(-inf ,-inf ):sin():real() )
  assertNaN   ( complex( inf , inf ):sin():real() )
  assertInf   ( complex( inf , inf ):sin():imag() )
  assertNaN   ( complex( nan , nan ):sin():real() )
  assertNaN   ( complex( nan , nan ):sin():imag() )
end

function TestComplex:testCos()
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    local c = complex( cos( re)*cosh( im),-sin( re)*sinh( im) )
    assertAlmostEquals( cos( z)    :real() - c     :real(), 0,   eps )
    assertAlmostEquals( cos( z)    :imag() - c     :imag(), 0,   eps )
    c = complex( cos(-re)*cosh(-im),-sin(-re)*sinh(-im) )
    assertAlmostEquals( cos(-z)    :real() - c     :real(), 0,   eps )
    assertAlmostEquals( cos(-z)    :imag() - c     :imag(), 0,   eps )
    assertAlmostEquals( cos(z+2*pi):real() - cos(z):real(), 0, 3*eps )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    local re, im = z:real(), z:imag()
    if x< 10 then
      assertAlmostEquals( (cos( z) - complex( cos( re)*cosh( im),-sin( re)*sinh( im)) ):real(), 0,   eps )
      assertAlmostEquals( (cos( z) - complex( cos( re)*cosh( im),-sin( re)*sinh( im)) ):imag(), 0, 2*eps )
      assertAlmostEquals( (cos(-z) - complex( cos(-re)*cosh(-im),-sin(-re)*sinh(-im)) ):real(), 0,   eps )
      assertAlmostEquals( (cos(-z) - complex( cos(-re)*cosh(-im),-sin(-re)*sinh(-im)) ):imag(), 0, 2*eps )
    end
  end
  assertEquals( complex( 0   , 0   ):cos(), complex( 1  , 0  ) )
  assertEquals( complex( tiny, tiny):cos(), complex( 1  , 0  ) )
  assertEquals( complex( huge, huge):cos(), complex(-inf,-inf) )
  assertEquals( complex(-huge,-huge):cos(), complex(-inf,-inf) )
  assertNaN   ( complex(-inf ,-inf ):cos():imag() )
  assertNaN   ( complex( inf , inf ):cos():imag() )
  assertInf   ( complex( inf , inf ):cos():real() )
  assertNaN   ( complex( nan , nan ):cos():imag() )
  assertNaN   ( complex( nan , nan ):cos():real() )
end

function TestComplex:testTan()
  for _,x in ipairs(values.rad) do
    for _,y in ipairs(values.rad) do

      local x, y = x/pi, y/pi
      local z = complex(x,y)
      assertAlmostEquals( (z:tan() - z:sin() / z:cos() ):real(), 0, 3*eps )
      assertAlmostEquals( (z:tan() - z:sin() / z:cos() ):imag(), 0, 4*eps )
    end
  end
  for _,z in ipairs(unitCircle( 1, values.rad)) do
      assertAlmostEquals( (z:tan() - z:sin() / z:cos() ):real(), 0,  2*eps) --2 eps does not seem outrageous
      assertAlmostEquals( (z:tan() - z:sin() / z:cos() ):imag(), 0,   eps )
  end
  for _,x in ipairs( values.num ) do
    local z = complex( x, x)
    if x < 10e2 then
      assertAlmostEquals( (z:tan() - z:sin() / z:cos() ):real(), 0,   eps )
      assertAlmostEquals( (z:tan() - z:sin() / z:cos() ):imag(), 0, 2*eps )
    end
  end

  assertEquals( complex( 0   , 0   ):tan(), complex( 0   , 0   ) )
  assertEquals( complex( tiny, tiny):tan(), complex( tiny, tiny) )
  assertEquals( complex( huge, huge):tan(), complex( 0   , 1   ) )
  assertEquals( complex(-huge,-huge):tan(), complex( 0   ,-1   ) )
  assertEquals( complex(-inf ,-inf ):tan(), complex( 0   ,-1   ) )
  assertEquals( complex( inf , inf ):tan(), complex( 0   , 1   ) )
  assertNaN   ( complex( nan , nan ):tan():real() )
  assertNaN   ( complex( nan , nan ):tan():imag() )
end

function TestComplex:testCot()
  for _,x in ipairs(values.rad) do
    for _,y in ipairs(values.rad) do
      if x ~= 0 or y ~= 0 then
        local x, y = x/pi, y/pi
        local z = complex(x,y)
        assertAlmostEquals( (z:cot() - z:cos() / z:sin() ):real(), 0,128*eps )
        assertAlmostEquals( (z:cot() - z:cos() / z:sin() ):imag(), 0,128*eps )
        assertAlmostEquals( (z:cot() - 1 / z:tan()       ):real(), 0, eps )
        assertAlmostEquals( (z:cot() - 1 / z:tan()       ):imag(), 0, eps )
      end
    end
  end
  for _,z in ipairs(unitCircle( 1, values.rad)) do
      assertAlmostEquals( (z:cot() - z:cos() / z:sin() ):real(), 0, eps )
      assertAlmostEquals( (z:cot() - z:cos() / z:sin() ):imag(), 0, eps )
      assertAlmostEquals( (z:cot() - 1 / z:tan()       ):real(), 0, eps )
      assertAlmostEquals( (z:cot() - 1 / z:tan()       ):imag(), 0, eps )
  end
  for _,x in ipairs( values.num ) do
    local z = complex( x, x)
    if x < 10e2 and x ~= 0 then
      assertAlmostEquals( (z:cot() - z:cos() / z:sin() ):real(), 0, 8*eps )
      assertAlmostEquals( (z:cot() - z:cos() / z:sin() ):imag(), 0, 8*eps )
      assertAlmostEquals( (z:cot() - 1 / z:tan()       ):real(), 0, eps )
      assertAlmostEquals( (z:cot() - 1 / z:tan()       ):imag(), 0, eps )
    end
  end
end

function TestComplex:testSinh()
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    local x = complex( sinh( re)*cos( im),cosh( re)*sin( im) )
    assertAlmostEquals( (sinh( z)        - (exp( z)-exp(-z))/2):real(), 0, eps )
    assertAlmostEquals( (sinh(-z)        - (exp(-z)-exp( z))/2):imag(), 0, eps )
    assertAlmostEquals(  sinh( z):real() - x:real()                   , 0, eps )
    assertAlmostEquals(  sinh( z):imag() - x:imag()                   , 0, eps )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    local re, im = z:real(), z:imag()
    if x< 10 then
      assertAlmostEquals( (sinh( z) - (exp( z)-exp(-z))/2)                             :real(), 0, 2*eps )
      assertAlmostEquals( (sinh(-z) - (exp(-z)-exp( z))/2)                             :imag(), 0, 2*eps )
      assertAlmostEquals( (sinh( z) - complex( sinh( re)*cos( im),cosh( re)*sin( im) )):real(), 0,   eps )
      assertAlmostEquals( (sinh( z) - complex( sinh( re)*cos( im),cosh( re)*sin( im) )):imag(), 0, 2*eps )
    end
  end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( 0, 0   ):sinh()       , complex( 0, 0) )
  assertEquals( complex( 0, inf ):sinh():real(), 0              )
  assertNaN   ( complex( 0, inf ):sinh():imag()                 )
  assertEquals( complex( 0, nan ):sinh():real(), 0              )
  assertNaN   ( complex( 0, nan ):sinh():imag()                 )
  for _,x in ipairs(values.rad) do
    local x = x/pi
    if x > 0 then
      assertNaN   ( complex( x  , inf ):sinh():real()              )
      assertNaN   ( complex( x  , inf ):sinh():imag()              )
      assertNaN   ( complex( x  , nan ):sinh():real()              )
      assertNaN   ( complex( x  , nan ):sinh():imag()              )
      assertNaN   ( complex( nan, x   ):sinh():real()              )
      assertNaN   ( complex( nan, x   ):sinh():imag()              )
      assertEquals( complex( inf, x   ):sinh(), complex( inf, inf) )
    end
  end
  assertEquals( complex( inf, 0  ):sinh()       , complex( inf, 0) )
  assertEquals( complex( inf, inf):sinh():real(), inf              )
  assertNaN   ( complex( inf, inf):sinh():imag()                   )
  assertEquals( complex( inf, nan):sinh():real(), inf              )
  assertNaN   ( complex( inf, nan):sinh():imag()                   )
  assertNaN   ( complex( nan, 0  ):sinh():real()                   )
  assertEquals( complex( nan, 0  ):sinh():imag(), 0                )
  assertNaN   ( complex( nan, nan):sinh():real()                   )
  assertNaN   ( complex( nan, nan):sinh():imag()                   )

  for _,x in ipairs(values.rad) do
    local x = x/pi
    assertAlmostEquals( (complex(0,x):sin()  - 1i * sinh(x)):real(), 0, eps )
    assertAlmostEquals( (complex(0,x):sin()  - 1i * sinh(x)):imag(), 0, eps )
    assertAlmostEquals( (complex(0,x):sinh() - 1i * sin (x)):real(), 0, eps )
    assertAlmostEquals( (complex(0,x):sinh() - 1i * sin (x)):imag(), 0, eps )
    for _,y in ipairs(values.rad) do
      local y = y/pi
      assertEquals( complex(x,y):sin(), -1i * (1i * complex(x,y)):sinh() )
    end
  end
end

function TestComplex:testCosh()
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (cosh( z)            - (exp( z)+exp(-z))/2)               :real(), 0,   eps )
    assertAlmostEquals( (cosh(-z)            - (exp(-z)+exp( z))/2)               :imag(), 0,   eps )
  for _,z1 in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (z+z1):cosh():real() - (cosh(z)*cosh(z1)+sinh(z)*sinh(z1)):real(), 0, 6*eps )
    assertAlmostEquals( (z+z1):cosh():imag() - (cosh(z)*cosh(z1)+sinh(z)*sinh(z1)):imag(), 0, 4*eps )
  end end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    if x < 10e2 then
      assertAlmostEquals( (cosh( z) - (exp( z)+exp(-z))/2):real(), 0, 2*eps )
      assertAlmostEquals( (cosh(-z) - (exp(-z)+exp( z))/2):imag(), 0, 2*eps )
    else
      assertNaN( (cosh( z) - (exp( z)+exp(-z))/2):real())
      assertNaN( (cosh(-z) - (exp(-z)+exp( z))/2):imag())
    end
  end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( 0, 0   ):cosh(), complex( 1, 0) )
  assertNaN   ( complex( 0, inf ):cosh():real()    )
  assertEquals( complex( 0, inf ):cosh():imag(), 0 )
  assertNaN   ( complex( 0, nan ):cosh():real()    )
  assertEquals( complex( 0, nan ):cosh():imag(), 0 )

  for _,x in ipairs(values.rad) do
    local x = x/pi
    if x > 0 then
      assertNaN   ( complex( x  , inf ):cosh():real() )
      assertNaN   ( complex( x  , inf ):cosh():imag() )
      assertNaN   ( complex( x  , nan ):cosh():real() )
      assertNaN   ( complex( x  , nan ):cosh():imag() )
      assertNaN   ( complex( nan, x   ):cosh():real() )
      assertNaN   ( complex( nan, x   ):cosh():imag() )
      assertEquals( complex( inf, x   ):cosh(), complex( inf, inf) )
    end
  end
  assertEquals( complex( inf, 0   ):cosh(), complex( inf, 0) )
  assertEquals( complex( inf, inf ):cosh():real(), inf )
  assertNaN   ( complex( inf, inf ):cosh():imag()      )
  assertEquals( complex( inf, nan ):cosh():real(), inf )
  assertNaN   ( complex( inf, nan ):cosh():imag()      )
  assertNaN   ( complex( nan, 0   ):cosh():real()      )
  assertEquals( complex( nan, 0   ):cosh():imag(), 0   )
  assertNaN   ( complex( nan, nan ):cosh():real()      )
  assertNaN   ( complex( nan, nan ):cosh():imag()      )

  for _,x in ipairs(values.rad) do
    local x = x/pi
    assertAlmostEquals( (complex(0,x):cos()  - cosh(x)):real(), 0, eps  )
    assertAlmostEquals( (complex(0,x):cos()  - cosh(x)):imag(), 0, eps  )
    assertEquals      ( (complex(0,x):cosh() - cos (x))       , complex(0,0) )
    for _,y in ipairs(values.rad) do
      local y = y/pi
      assertEquals( complex(x,y):cos(), (1i * complex(x,y)):cosh() )
    end
  end
end

function TestComplex:testTanh()
  for _,x in ipairs(values.rad2) do
    for _,y in ipairs(values.rad3) do
      local x = x/pi, y/pi
      local z = complex(x,y)
      assertAlmostEquals( (z:tanh() - z:sinh() / z:cosh() ):real(), 0, 4*eps ) -- mac err: 7.62939453125e-06  [TOCHECK]
      assertAlmostEquals( (z:tanh() - z:sinh() / z:cosh() ):imag(), 0, 4*eps ) -- expected: 0, mac: -2        [TOCHECK]
    end
  end
  for _,z in ipairs(unitCircle( 1, values.rad)) do
      assertAlmostEquals( (z:tanh() - z:sinh() / z:cosh() ):real(), 0, 2*eps )
      assertAlmostEquals( (z:tanh() - z:sinh() / z:cosh() ):imag(), 0,   eps )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    if x < 10e2 then
      assertAlmostEquals( (z:tanh() - z:sinh() / z:cosh() ):real(), 0, 2*eps )
      assertAlmostEquals( (z:tanh() - z:sinh() / z:cosh() ):imag(), 0, 4*eps )
    else
      assertNaN( (z:tanh() - z:sinh() / z:cosh() ):real() )
      assertNaN( (z:tanh() - z:sinh() / z:cosh() ):imag() )
    end
  end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( 0, 0  ):tanh(), complex( 0, 0) )
  for _,x in ipairs(values.rad) do
    if x ~= 0 then
      assertNaN( complex( x, inf ):tanh():real() ) --Similar problem as acosh; for z = 0 + inf i, atan(z) = 0 + i nan; failing IEEE:IEC 60559 compliance (works for x ~= 0)  May be machine dependent
      assertNaN( complex( x, inf ):tanh():imag() )
      assertNaN( complex( x, nan ):tanh():real() ) --Same problem as acosh; for z = 0 + nan i, atan(z) = 0 + i nan; failing IEEE:IEC 60559 compliance (works for x ~= 0)   May be machine dependent
      assertNaN( complex( x, nan ):tanh():imag() )
    end
    if x > 0 then
      assertNaN   ( complex( nan, x ):tanh():real() )
      assertNaN   ( complex( nan, x ):tanh():imag() )
      assertEquals( complex( inf, x ):tanh(), complex( 1, 0) )
    end
  end
  assertEquals( complex( inf, inf):tanh(), complex( 1, 0) )
  assertEquals( complex( inf, nan):tanh(), complex( 1, 0) )
  assertNaN   ( complex( nan, 0  ):tanh():real()      )
  assertEquals( complex( nan, 0  ):tanh():imag(), 0   )
  assertNaN   ( complex( nan, nan):tanh():real()      )
  assertNaN   ( complex( nan, nan):tanh():imag()      )

  for _,x in ipairs(values.rad) do
    local x = x/pi
    assertAlmostEquals( (complex(0,x):tan()  - 1i * tanh(x)):real(), 0,   eps )
    assertAlmostEquals( (complex(0,x):tan()  - 1i * tanh(x)):imag(), 0, 2*eps )
    assertAlmostEquals( (complex(0,x):tanh() - 1i * tan (x)):real(), 0,   eps )
    assertAlmostEquals( (complex(0,x):tanh() - 1i * tan (x)):imag(), 0, 2*eps )
    for _,y in ipairs(values.rad) do
      local y = y/pi
      assertEquals( complex(x,y):tan(), -1i * (1i * complex(x,y)):tanh() )
    end
  end
  --Below fails on Ubuntu 22.04.1 LTS, instead 0 + i nan is returned, not compliant with ISO/IEC 9899:1999 (keep last so other tests run)
  assertNaN( complex( 0, inf ):tanh():real() )
  assertNaN( complex( 0, inf ):tanh():imag() )
  assertNaN( complex( 0, nan ):tanh():real() ) 
  assertNaN( complex( 0, nan ):tanh():imag() )
end

function TestComplex:testCoth()
  for _,x in ipairs(values.rad2) do
    for _,y in ipairs(values.rad3) do
      if x ~= 0 and y ~= 0 then
        local x = x/pi, y/pi
        local z = complex(x,y)
        assertAlmostEquals( (z:coth() - z:cosh() / z:sinh() ):real(), 0, 32*eps )
        assertAlmostEquals( (z:coth() - z:cosh() / z:sinh() ):imag(), 0, 32*eps )
        assertAlmostEquals( (z:coth() -    1     / z:tanh() ):real(), 0, 1*eps )
        assertAlmostEquals( (z:coth() -    1     / z:tanh() ):imag(), 0, 1*eps )
      end
    end
  end
  for _,z in ipairs(unitCircle( 1, values.rad)) do
      assertAlmostEquals( (z:coth() - z:cosh() / z:sinh() ):real(), 0, 2*eps )
      assertAlmostEquals( (z:coth() - z:cosh() / z:sinh() ):imag(), 0, 2*eps )
      assertAlmostEquals( (z:coth() -    1     / z:tanh() ):real(), 0, 1*eps )
      assertAlmostEquals( (z:coth() -    1     / z:tanh() ):imag(), 0, 1*eps )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    if x~=0 then
      assertAlmostEquals( (z:coth() -    1     / z:tanh() ):real(), 0, 1*eps )
      assertAlmostEquals( (z:coth() -    1     / z:tanh() ):imag(), 0, 1*eps )
    else
      assertNaN( (z:coth() -    1     / z:tanh() ):real())
      assertNaN( (z:coth() -    1     / z:tanh() ):imag())
    end
  end
end

function TestComplex:testAsin()
  assertNaN   ( complex( nan, nan ):asin():real()             )
  assertNaN   ( complex( nan, nan ):asin():imag()             )
  assertEquals( complex( 0  , 0   ):asin(), complex( 0   , 0) )
  assertEquals( complex( 1  , 0   ):asin(), complex( pi/2, 0) )
  assertEquals( complex(-1  , 0   ):asin(), complex(-pi/2, 0) )
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (z:asin():sin() - z):real(), 0, eps )
    assertAlmostEquals( (z:asin():sin() - z):imag(), 0, eps )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    if x < pi/2 then
      assertAlmostEquals( (z:asin():sin() - z):real(), 0,     eps )
      assertAlmostEquals( (z:asin():sin() - z):imag(), 0,   2*eps )
    elseif x < 10 then
      assertAlmostEquals( (z:asin():sin() - z):real(), 0,   2*eps )
      assertAlmostEquals( (z:asin():sin() - z):imag(), 0,   2*eps )
    elseif x == 10  then
      assertAlmostEquals( (z:asin():sin() - z):real(), 0,  16*eps )
      assertAlmostEquals( (z:asin():sin() - z):imag(), 0,  16*eps )
    elseif x == 100 then
      assertAlmostEquals( (z:asin():sin() - z):real(), 0, 128*eps )
      assertAlmostEquals( (z:asin():sin() - z):imag(), 0, 128*eps )
    end
  end

  assertAlmostEquals( complex(  1        , 0):asin():real() -  1.5707963267948966  , 0, eps )
  assertAlmostEquals( complex(  1        , 0):asin():imag() -  0                   , 0, eps )
  assertAlmostEquals( complex(- 1        , 0):asin():real() - -1.5707963267948966  , 0, eps )
  assertAlmostEquals( complex(- 1        , 0):asin():imag() -  0                   , 0, eps )
  assertAlmostEquals( complex(  1+eps    , 0):asin():real() -  1.5707963267948966  , 0, eps )
  assertAlmostEquals( complex(  1+eps    , 0):asin():imag() -  2.10734242278576e-08, 0, eps )
  assertAlmostEquals( complex(-(1+eps)   , 0):asin():real() - -1.5707963267948966  , 0, eps )
  assertAlmostEquals( complex(-(1+eps)   , 0):asin():imag() -  2.10734242278576e-08, 0, eps )

  assertAlmostEquals( complex(  pi/2     , 0):asin():real() -  1.5707963267948966, 0,   eps )
  assertAlmostEquals( complex(- pi/2     , 0):asin():real() - -1.5707963267948966, 0,   eps )
  assertAlmostEquals( complex(  pi/2+eps , 0):asin():real() -  1.5707963267948966, 0,   eps )
  assertAlmostEquals( complex(-(pi/2+eps), 0):asin():real() - -1.5707963267948966, 0,   eps )
  assertAlmostEquals( complex(  pi/2     , 0):asin():imag() -  1.02322747854755  , 0, 3*eps )
  assertAlmostEquals( complex(- pi/2     , 0):asin():imag() -  1.02322747854755  , 0, 3*eps )
  assertAlmostEquals( complex(  pi/2+eps , 0):asin():imag() -  1.02322747854755  , 0, 3*eps )
  assertAlmostEquals( complex(-(pi/2+eps), 0):asin():imag() -  1.02322747854755  , 0, 3*eps )
end

function TestComplex:testAcos()
  assertEquals( ( 1 + 0i ):acos(), 0  + 0i )
  assertEquals( (-1 + 0i ):acos(), pi + 0i )
  for _,z in ipairs(unitCircle( 1, values.rad)) do
      assertAlmostEquals( (z:acos():cos() - z):real(), 0, 2*eps )
      assertAlmostEquals( (z:acos():cos() - z):imag(), 0,   eps )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    if x < 10 then
      assertAlmostEquals( (z:acos():cos() - z):real(), 0, 2*eps )
      assertAlmostEquals( (z:acos():cos() - z):imag(), 0, 2*eps )
    end
  end
  assertEquals      ( (  1      + 0i ):acos():real() ,  0                            )
  assertEquals      ( (  1      + 0i ):acos():imag() ,  0                            )
  assertEquals      ( (- 1      + 0i ):acos():real() ,  pi                           )
  assertEquals      ( (- 1      + 0i ):acos():imag() ,  0                            )
  assertEquals      ( (  1+eps  + 0i ):acos():real() ,  0                            )
  assertAlmostEquals( (  1+eps  + 0i ):acos():imag() - -2.10734243388799e-08, 0, eps )
  assertAlmostEquals( (-(1+eps) + 0i ):acos():real() -  pi                  , 0, eps )
  assertAlmostEquals( (-(1+eps) + 0i ):acos():imag() - -2.10734243388799e-08, 0, eps )
  assertAlmostEquals( (-(0+eps) + 0i ):acos():real() -  1.5707963267948966  , 0, eps )
  assertAlmostEquals( (-(0+eps) + 0i ):acos():imag() - -2.46519032881566e-32, 0, eps )
  assertEquals      ( (  pi     + 0i ):acos():real() ,  0                            )
  assertEquals      ( (  pi+eps + 0i ):acos():real() ,  0                            )
  assertAlmostEquals( (- 0      + 0i ):acos():real() -  1.5707963267948966  , 0, eps )
  assertAlmostEquals( (  0      + 0i ):acos():real() -  1.5707963267948966  , 0, eps )
  assertAlmostEquals( (  pi     + 0i ):acos():imag() - -1.8115262724608531  , 0, eps )
  assertAlmostEquals( (  pi+eps + 0i ):acos():imag() - -1.8115262724608531  , 0, eps )
  assertEquals      ( (- 0      + 0i ):acos():imag() ,  0                            )
  assertEquals      ( (  0      + 0i ):acos():imag() ,  0                            )

-- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( 0  , 0   ):acos()       , complex( pi/2, 0  ) )
  assertEquals( complex(-0  , 0   ):acos()       , complex( pi/2, 0  ) )
  assertEquals( complex( 0  ,-0   ):acos()       , complex( pi/2, 0  ) )
  assertEquals( complex(-0  ,-0   ):acos()       , complex( pi/2, 0  ) )
  assertEquals( complex( 0  , nan ):acos():real(), pi/2                )
  assertNaN   ( complex( 0  , nan ):acos():imag()                      )
  assertEquals( complex(-0  , nan ):acos():real(), pi/2                )
  assertNaN   ( complex(-0  , nan ):acos():imag()                      )
  assertEquals( complex( inf, inf ):acos()       , complex( pi/4,-inf) )
  for _,x in ipairs(values.rad) do
      assertEquals( complex( x, inf  ):acos(), complex( pi/2,-inf) )
    if x > 0 then
      assertNaN   ( complex( x  , nan):acos():imag()               )
      assertNaN   ( complex( x  , nan):acos():real()               )
      assertNaN   ( complex( nan, x  ):acos():imag()               )
      assertNaN   ( complex( nan, x  ):acos():real()               )
      assertEquals( complex(-inf, x  ):acos(), complex( pi  ,-inf) )
      assertEquals( complex( inf, x  ):acos(), complex( 0   ,-inf) )
    end
  end
  assertEquals( complex(-inf, inf):acos()       , complex( 3*pi/4,-inf) )
  assertEquals( complex( inf, inf):acos()       , complex(   pi/4,-inf) )
  assertNaN   ( complex( inf, nan):acos():real()                        )
  assertEquals( complex( inf, nan):acos():imag(), inf                   )
  assertNaN   ( complex(-inf, nan):acos():real()                        )
  assertEquals( complex(-inf, nan):acos():imag(), inf                   )
  assertNaN   ( complex( nan, inf):acos():real()                        )
  assertEquals( complex( nan, inf):acos():imag(),-inf                   )
  assertNaN   ( complex( nan, nan):acos():real()                        )
  assertNaN   ( complex( nan, nan):acos():imag()                        )
end

function TestComplex:testAtan()
  assertNaN   ( complex( nan, nan):atan():real()             )
  assertNaN   ( complex( nan, nan):atan():imag()             )
  assertEquals( complex( 0  , 0  ):atan(), complex( 0   , 0) )
  assertEquals( complex(-inf, 0  ):atan(), complex(-pi/2, 0) )
  assertEquals( complex( inf, 0  ):atan(), complex( pi/2, 0) )

  for _,z in ipairs(unitCircle( pi/2, values.rad)) do
    local res = 1/2*1i*((1-1i*z):log()-(1+1i*z):log())
    assertAlmostEquals( (z:atan():tan() - z           ):real(), 0, 2*eps )
    assertAlmostEquals( (z:atan():tan() - z           ):imag(), 0, 2*eps )
    assertAlmostEquals( (z:atan()       - -(-z:atan())):real(), 0,   eps )
    assertAlmostEquals( (z:atan()       - -(-z:atan())):imag(), 0,   eps )
    assertAlmostEquals( (z:atan()       - res         ):real(), 0,   eps )
    assertAlmostEquals( (z:atan()       - res         ):imag(), 0,   eps )
  end

  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    if x < pi/2 then
      local res = 1/2*1i*((1-1i*z):log()-(1+1i*z):log())
      assertAlmostEquals( (z:atan():tan() - z           ):real(), 0,   eps )
      assertAlmostEquals( (z:atan():tan() - z           ):imag(), 0, 2*eps )
      assertAlmostEquals( (z:atan()       - -(-z:atan())):real(), 0,   eps )
      assertAlmostEquals( (z:atan()       - -(-z:atan())):imag(), 0,   eps )
      assertAlmostEquals( (z:atan()       - res         ):real(), 0,   eps )
      assertAlmostEquals( (z:atan()       - res         ):imag(), 0,   eps )
    elseif x < 10 then
      assertAlmostEquals( (z:atan():tan() - z):real()           , 0, 8*eps )
      assertAlmostEquals( (z:atan():tan() - z):imag()           , 0, 8*eps )
    end
  end

  if jit.os == "OSX" then
    assertEquals( (0 + 1i):atan(), complex( pi/4, inf) ) --expected: 0 + inf*1i mac: pi/4 + infi [BUG] (mathmatica)
    assertEquals( (0 - 1i):atan(), complex( pi/4,-inf) ) --expected: 0 +-inf*1i mac: pi/4 - infi [BUG] (mathmatica)
  else
    assertEquals( (0 + 1i):atan(), complex( 0   , inf) )
    assertEquals( (0 - 1i):atan(), complex( 0   ,-inf) )
  end
  assertAlmostEquals( (  pi/2 + 0i ):atan():real() -  1.00388482185389    , 0,  13*eps )
  assertAlmostEquals( (- pi/2 + 0i ):atan():real() - -1.00388482185389    , 0,  13*eps )
  assertAlmostEquals( (  pi/2 + 0i ):atan():imag() - -1.25193300684524e-17, 0,     eps )
  assertAlmostEquals( (- pi/2 + 0i ):atan():imag() - -1.25193300684524e-17, 0,     eps )
end

function TestComplex:testAcot()
  assertNaN   ( complex( nan, nan):acot():real()             )
  assertNaN   ( complex( nan, nan):acot():imag()             )
  assertNaN   ( complex(  0 ,  0 ):acot():real()             ) --1 / complex(0, 0) = complex(nan + nani)
  assertNaN   ( complex(  0 ,  0 ):acot():imag()             ) --1 / complex(0, 0) = complex(nan + nani)
  assertEquals( complex(-inf, 0  ):acot(), complex( 0 , 0 )  )
  assertEquals( complex( inf, 0  ):acot(), complex( 0 , 0 )  )

  for _,z in ipairs(unitCircle( pi/2, values.rad)) do
    local res = 1/2*1i*((1-1i/z):log()-(1+1i/z):log())
    assertAlmostEquals( (z:acot():cot() - z           ):real(), 0, 2*eps )
    assertAlmostEquals( (z:acot():cot() - z           ):imag(), 0, 2*eps )
    assertAlmostEquals( (z:acot()       - -(-z:acot())):real(), 0,   eps )
    assertAlmostEquals( (z:acot()       - -(-z:acot())):imag(), 0,   eps )
    assertAlmostEquals( (z:acot()       - res         ):real(), 0,   eps )
    assertAlmostEquals( (z:acot()       - res         ):imag(), 0,   eps )
  end

  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    if x < pi/2 and x ~= 0 then
      local res = 1/2*1i*((1-1i/z):log()-(1+1i/z):log())
      assertAlmostEquals( (z:acot():cot() - z           ):real(), 0,   eps )
      assertAlmostEquals( (z:acot():cot() - z           ):imag(), 0,   eps )
      assertAlmostEquals( (z:acot()       - -(-z:acot())):real(), 0,   eps )
      assertAlmostEquals( (z:acot()       - -(-z:acot())):imag(), 0,   eps )
      assertAlmostEquals( (z:acot()       - res         ):real(), 0,   eps )
      assertAlmostEquals( (z:acot()       - res         ):imag(), 0,16*eps ) --Too high?
    elseif x < 10 and x ~= 0 then
      assertAlmostEquals( (z:acot():cot() - z):real()           , 0, 4*eps )
      assertAlmostEquals( (z:acot():cot() - z):imag()           , 0, 4*eps )
    end
  end

  --Below is from wolfram alpha
  assertEquals( (0 + 1i):acot(), complex( 0, -inf) )
  assertEquals( (0 - 1i):acot(), complex( 0,  inf) )
  assertAlmostEquals( (  pi/2 + 0i ):acot():real() -  0.5669115049410094    , 0,  eps )
  assertAlmostEquals( (- pi/2 + 0i ):acot():real() - -0.5669115049410094    , 0,  eps )
  assertAlmostEquals( (  pi/2 + 0i ):acot():imag()                          , 0,  eps )
  assertAlmostEquals( (- pi/2 + 0i ):acot():imag()                          , 0,  eps )
end

function TestComplex:testAsinh()
  assertAlmostEquals( ( 0 + 1i       ):asinh():real() -  0                   , 0,    eps )
  assertAlmostEquals( ( 0 - 1i       ):asinh():real() -  0                   , 0,    eps )
  assertAlmostEquals( ( 0 +(1+eps)*1i):asinh():real() -  2.10734243388799e-08, 0,    eps )
  assertAlmostEquals( ( 0 -(1+eps)*1i):asinh():real() -  2.10734243388799e-08, 0,    eps )
  assertAlmostEquals( ( 0 - 2i       ):asinh():real() -  1.31695789692482    , 0, 16*eps )
  assertAlmostEquals( ( 0 + 2i       ):asinh():real() -  1.31695789692482    , 0, 16*eps )
  assertAlmostEquals( ( 0 + 1i       ):asinh():imag() -  1.5707963267948966  , 0,    eps )
  assertAlmostEquals( ( 0 - 1i       ):asinh():imag() - -1.5707963267948966  , 0,    eps )
  assertAlmostEquals( ( 0 +(1+eps)*1i):asinh():imag() -  1.5707963267948966  , 0,    eps )
  assertAlmostEquals( ( 0 -(1+eps)*1i):asinh():imag() - -1.5707963267948966  , 0,    eps )
  assertAlmostEquals( ( 0 + 2i       ):asinh():imag() -  1.5707963267948966  , 0,    eps )
  assertAlmostEquals( ( 0 - 2i       ):asinh():imag() - -1.5707963267948966  , 0,    eps )

  for _,z in ipairs(unitCircle( pi/2, values.rad)) do
      assertAlmostEquals( (z:asinh():sinh() - z):real(), 0, 2*eps )
      assertAlmostEquals( (z:asinh():sinh() - z):imag(), 0,   eps )
  end
  for _,z in ipairs(unitCircle( pi, values.rad)) do
      assertAlmostEquals( (z:asinh():sinh() - z):real(), 0, 2*eps )
      assertAlmostEquals( (z:asinh():sinh() - z):imag(), 0, 2*eps )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    if x < pi/2 then
      assertAlmostEquals( (z:asinh():sinh() - z):real(), 0, 2*eps )
      assertAlmostEquals( (z:asinh():sinh() - z):imag(), 0,   eps )
    elseif x < 10 then
      assertAlmostEquals( (z:asinh():sinh() - z):real(), 0, 2*eps )
      assertAlmostEquals( (z:asinh():sinh() - z):imag(), 0, 2*eps )
    end
  end

  -- Check for IEEE:IEC 60559 compliance
  for _,x in ipairs(values.rad) do
    assertEquals( complex( x  , inf ):asinh(), complex( inf, pi/2) )
    assertEquals( complex( inf, x   ):asinh(), complex( inf, 0   ) )
    assertNaN   ( complex( x  , nan ):asinh():real() )
    assertNaN   ( complex( x  , nan ):asinh():imag() )
    if x > 0 then
      assertNaN ( complex( nan, x  ):asinh():real() )
      assertNaN ( complex( nan, x  ):asinh():imag() )
    end
  end
  assertEquals( complex( 0  , 0  ):asinh()       , complex( 0  , 0)    )
  assertEquals( complex( inf, inf):asinh()       , complex( inf, pi/4) )
  assertEquals( complex( inf, nan):asinh():real(), inf                 )
  assertNaN   ( complex( inf, nan):asinh():imag()                      )
  assertNaN   ( complex( nan, 0  ):asinh():real()                      )
  assertEquals( complex( nan, 0  ):asinh():imag(), 0                   )
  assertInf   ( complex( nan, inf):asinh():real(), inf                 )
  assertNaN   ( complex( nan, inf):asinh():imag()                      )
  assertNaN   ( complex( nan, nan):asinh():real()                      )
  assertNaN   ( complex( nan, nan):asinh():imag()                      )

  for _,x in ipairs(values.rad) do
    local x = x/pi
    assertAlmostEquals( (complex(0,x):asin()  - 1i * asinh(x)):real(), 0,   eps )
    assertAlmostEquals( (complex(0,x):asin()  - 1i * asinh(x)):imag(), 0,   eps )
    assertAlmostEquals( (complex(0,x):asinh() - 1i * asin (x)):real(), 0,   eps )
    assertAlmostEquals( (complex(0,x):asinh() - 1i * asin (x)):imag(), 0, 2*eps )
    for _,y in ipairs(values.rad) do
      local y = y/pi
      assertEquals( complex(x,y):asin(), -1i * (1i * complex(x,y)):asinh() )
    end
  end
end

function TestComplex:testAcosh()
  assertEquals      ( ( 1     + 0i ):acosh()                               , 0+0i        )
  assertAlmostEquals( ( 1-eps + 0i ):acosh():real() -  5.50089919428296e-32, 0   ,   eps )
  assertAlmostEquals( ( 1-eps + 0i ):acosh():imag() -  2.10734242554470e-08, 0   ,   eps )
  assertAlmostEquals( ( 1-0.1 + 0i ):acosh():real() - -1.47835141691979e-17, 0   ,   eps )
  assertAlmostEquals( ( 1-0.1 + 0i ):acosh():imag() -  4.51026811796262e-01, 0   , 2*eps )

  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (z:acosh():cosh() - z):real(), 0,  2*eps )
    assertAlmostEquals( (z:acosh():cosh() - z):imag(), 0,    eps )
  end
  for _,z in ipairs(unitCircle( 2*pi, values.rad)) do
    assertAlmostEquals( (z:acosh():cosh() - z):real(), 0, 16*eps )
    assertAlmostEquals( (z:acosh():cosh() - z):imag(), 0, 16*eps )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    if x < pi/2 then
      assertAlmostEquals( (z:acosh():cosh() - z):real(), 0,   eps )
      assertAlmostEquals( (z:acosh():cosh() - z):imag(), 0,   eps )
    elseif x < 10 then
      assertAlmostEquals( (z:acosh():cosh() - z):real(), 0, 2*eps )
      assertAlmostEquals( (z:acosh():cosh() - z):imag(), 0, 2*eps )
    end
  end

-- Check for IEEE:IEC 60559 compliance
  for _,x in ipairs(values.rad) do
    if x ~= 0 then
      assertNaN   ( complex( x  , nan ):acosh():real() )
      assertNaN   ( complex( x  , nan ):acosh():imag() )
    end
    assertNaN   ( complex( nan, x   ):acosh():real() )
    assertNaN   ( complex( nan, x   ):acosh():imag() )
    assertEquals( complex( x  , inf ):acosh(), complex( inf, pi/2) )
    assertEquals( complex(-inf, x   ):acosh(), complex( inf, pi  ) )
    assertEquals( complex( inf, x   ):acosh(), complex( inf, 0   ) )
  end
  assertEquals( complex( 0, 0    ):acosh()       , complex( 0  ,   pi/2) )
  assertEquals( complex(-0, 0    ):acosh()       , complex( 0  ,   pi/2) )
  assertEquals( complex(-inf, inf):acosh()       , complex( inf, 3*pi/4) )
  assertEquals( complex( inf, inf):acosh()       , complex( inf,   pi/4) )
  assertEquals( complex( inf, nan):acosh():real(), inf                   )
  assertNaN   ( complex( inf, nan):acosh():imag()                        )
  assertEquals( complex(-inf, nan):acosh():real(), inf                   )
  assertNaN   ( complex(-inf, nan):acosh():imag()                        )
  assertInf   ( complex( nan, inf):acosh():real(), inf                   )
  assertNaN   ( complex( nan, inf):acosh():imag()                        )
  assertNaN   ( complex( nan, nan):acosh():real()                        )
  assertNaN   ( complex( nan, nan):acosh():imag()                        )
  --Below fails on Ubuntu 22.04.1 LTS, instead nan + i pi/2 is returned, not compliant with ISO/IEC 9899:1999 (keep last so other tests run)
  assertNaN   ( complex( 0  , nan ):acosh():real() )
  assertNaN   ( complex( 0  , nan ):acosh():imag() )
end

function TestComplex:testAtanh()
  for _,z in ipairs(unitCircle( pi/2, values.rad)) do
    assertAlmostEquals( (z:atanh():tanh() - z):real(), 0, 2*eps )
    assertAlmostEquals( (z:atanh():tanh() - z):imag(), 0, 2*eps )
    if z.im ~= 0 then
      local res = 1/2*((1+z):log() - (1-z):log())
      assertAlmostEquals( (z:atanh() - res):real(), 0, 16*eps )
      assertAlmostEquals( (z:atanh() - res):imag(), 0,    eps )
    end
  end
  for _,z in ipairs(unitCircle( pi, values.rad)) do
    assertAlmostEquals( (z:atanh():tanh() - z):real(), 0, 8*eps )
    assertAlmostEquals( (z:atanh():tanh() - z):imag(), 0, 8*eps )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    local res = 1/2*((1+z):log() - (1-z):log())
    if x < pi/2 then
      assertAlmostEquals( (z:acosh():cosh() - z  ):real(), 0,   eps )
      assertAlmostEquals( (z:acosh():cosh() - z  ):imag(), 0,   eps )
      assertAlmostEquals( (z:atanh()        - res):real(), 0,   eps )
      assertAlmostEquals( (z:atanh()        - res):imag(), 0,   eps )
    elseif x < 10 then
      assertAlmostEquals( (z:acosh():cosh() - z  ):real(), 0, 2*eps )
      assertAlmostEquals( (z:acosh():cosh() - z  ):imag(), 0, 2*eps )
    end
  end
  assertEquals( ( 0 - 1i):atanh()       , 0 - pi/4*1i )
  assertEquals( (-1 + 0i):atanh():real(),-inf         )
  assertEquals( (-1 + 0i):atanh():imag(), jit.os == 'OSX' and pi/4 or 0) -- expected: 0 mac: pi/4*1i [BUG] (mathmatica)

-- Check for IEEE:IEC 60559 compliance
  for _,x in ipairs(values.rad) do
    assertEquals( complex( x, inf ):atanh(), complex( 0, pi/2) )
    assertEquals( complex( x, -x  ):atanh(), atanh(complex(x, x)):conj() ) -- first statement in G.6.2.3 The catanh functions on pg 473
    assertEquals( complex( inf, x ):atanh(), complex( 0, pi/2) )
    assertNaN   ( complex( nan, x ):atanh():real() )
    assertNaN   ( complex( nan, x ):atanh():imag() )
    if x > 0 then
      assertNaN ( complex( x, nan ):atanh():real() )
      assertNaN ( complex( x, nan ):atanh():imag() )
    end
  end
  assertNaN   ( complex( 0  , nan ):atanh():imag()                      )
  assertEquals( complex( 0  , 0   ):atanh()       , complex( 0  , 0   ) )
  assertEquals( complex( inf, inf ):atanh()       , complex( 0  , pi/2) )
  assertNaN   ( complex( nan, nan ):atanh():real()                      )
  assertNaN   ( complex( nan, nan ):atanh():imag()                      )
  assertEquals( complex( nan, inf ):atanh():imag(), pi/2                )

  if jit.os == "OSX" then
    assertEquals( complex( 1  , 0   ):atanh()       , complex( inf, pi/4) ) -- expected: inf+0i    mac: inf+pi/4*1i [BUG]
    assertNaN   ( complex( 0  , nan ):atanh():real()                      ) -- expected: 0         mac: nan         [BUG]
    assertNaN   ( complex( inf, nan ):atanh():real()                      ) -- expected: 0         mac: nan         [BUG]
    assertEquals( complex( inf, nan ):atanh():imag(), pi/2                ) -- expected: nan       mac: pi/2        [BUG]
    assertNaN   ( complex( nan, inf ):atanh():real()                      ) -- expected: 0+pi/2*1  mac: nan+pi/2*1i [BUG]
  else
    assertEquals( complex( 1  , 0   ):atanh()       , complex( inf, 0   ) )
    assertEquals( complex( 0  , nan ):atanh():real(), 0                   )
    assertEquals( complex( inf, nan ):atanh():real(), 0                   )
    assertNaN   ( complex( inf, nan ):atanh():imag()                      )
    assertEquals( complex( nan, inf ):atanh():real(), 0                   )
  end

  for _,x in ipairs(values.rad2) do
    local x = x/pi
    assertAlmostEquals( (complex( 0, x):atan()  - 1i * atanh(x)):real(), 0,   eps )
    assertAlmostEquals( (complex( 0, x):atan()  - 1i * atanh(x)):imag(), 0,   eps )
    assertAlmostEquals( (complex( 0, x):atanh() - 1i * atan (x)):real(), 0,   eps )
    assertAlmostEquals( (complex( 0, x):atanh() - 1i * atan (x)):imag(), 0, 2*eps )
    for _,y in ipairs(values.rad2) do
      local y = y/pi
      local res = (-1i) * (1i * complex(x,y)):atanh()
      assertAlmostEquals( ( complex(x,y):atan() - res):real(), 0, eps )
      assertAlmostEquals( ( complex(x,y):atan() - res):imag(), 0, eps )
    end
  end
end
function TestComplex:testSinc()
  for _,z in ipairs(unitCircle( pi/2, values.rad)) do
    if abs(z) < 1e-7 then
      assertEquals( z:sinc()    , 1 )
      assertEquals( (-z):sinc() , 1 )
    elseif abs(z) < inf then
      assertEquals( z:sinc()    , (-z):sinc()    )
      assertEquals( z:sinc()    , z:sin()    / z )
      assertEquals( (-z):sinc() , (-z):sin() /-z )
    end
  end
  for _,x in ipairs(values.num) do
    assertNaN( complex(-inf, x):sinc():real() )
    assertNaN( complex(-inf, x):sinc():imag() )
    assertNaN( complex( inf, x):sinc():real() )
    assertNaN( complex( inf, x):sinc():imag() )
    assertNaN( complex( x,-inf):sinc():real() )
    assertNaN( complex( x,-inf):sinc():imag() )
    assertNaN( complex( x, inf):sinc():real() )
    assertNaN( complex( x, inf):sinc():imag() )
  end
end

function TestComplex:testSinhc()
  for _,z in ipairs(unitCircle( pi/2, values.rad)) do
    if abs(z) < 1e-7 then
      assertEquals( z:sinhc()    , 1 )
      assertEquals( (-z):sinhc() , 1 )
    elseif abs(z) < inf then
      assertEquals( z:sinhc()    , (-z):sinhc()    )
      assertEquals( z:sinhc()    , z:sinh()    / z )
      assertEquals( (-z):sinhc() , (-z):sinh() /-z )
    end
  end
  for _,x in ipairs(values.num) do
    assertNaN( complex(-inf, x):sinhc():real() )
    assertNaN( complex(-inf, x):sinhc():imag() )
    assertNaN( complex( inf, x):sinhc():real() )
    assertNaN( complex( inf, x):sinhc():imag() )
    assertNaN( complex( x,-inf):sinhc():real() )
    assertNaN( complex( x,-inf):sinhc():imag() )
    assertNaN( complex( x, inf):sinhc():real() )
    assertNaN( complex( x, inf):sinhc():imag() )
  end
end

function TestComplex:testAsinc()
  for _,z in ipairs(unitCircle( pi/2, values.rad)) do
    if abs(z) < 1e-7 then
      assertEquals( z:asinc()    , 1 )
      assertEquals( (-z):asinc() , 1 )
    elseif abs(z) < inf then
      assertEquals( z:asinc()    , (-z):asinc()    )
      assertEquals( z:asinc()    , z:asin()    / z )
      assertEquals( (-z):asinc() , (-z):asin() /-z )
    end
  end
  for _,x in ipairs(values.num) do
    assertNaN( complex(-inf, x):asinc():real() )
    assertNaN( complex(-inf, x):asinc():imag() )
    assertNaN( complex( inf, x):asinc():real() )
    assertNaN( complex( inf, x):asinc():imag() )
    assertNaN( complex( x,-inf):asinc():real() )
    assertNaN( complex( x,-inf):asinc():imag() )
    assertNaN( complex( x, inf):asinc():real() )
    assertNaN( complex( x, inf):asinc():imag() )
  end
  assertEquals(complex(-1, 0):asinc():real(), pi/2)
  assertAlmostEquals(complex(-1, 0):asinc():imag(), 0, eps)
  assertEquals(complex( 1, 0):asinc():real(), pi/2)
  assertAlmostEquals(complex( 1, 0):asinc():imag(), 0, eps)
end

function TestComplex:testAcoth()
  for _,z in ipairs(unitCircle( pi/2, values.rad)) do
    assertAlmostEquals( (z:acoth():coth() - z):real(), 0, eps )
    assertAlmostEquals( (z:acoth():coth() - z):imag(), 0, eps )
    if z.im ~= 0 then
      local res = 1/2*((1+1/z):log() - (1-1/z):log())
      assertAlmostEquals( (z:acoth() - res):real(), 0,    eps )
      assertAlmostEquals( (z:acoth() - res):imag(), 0,    eps )
    end
  end
  for _,z in ipairs(unitCircle( pi, values.rad)) do
    assertAlmostEquals( (z:acoth():coth() - z):real(), 0, 8*eps )
    assertAlmostEquals( (z:acoth():coth() - z):imag(), 0, 8*eps )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    local res = 1/2*((1+1/z):log() - (1-1/z):log())
    if x < pi/2 and x~= 0 then
      assertAlmostEquals( (z:acosh():cosh() - z  ):real(), 0,   eps )
      assertAlmostEquals( (z:acosh():cosh() - z  ):imag(), 0,   eps )
      assertAlmostEquals( (z:acoth()        - res):real(), 0,16*eps )
      assertAlmostEquals( (z:acoth()        - res):imag(), 0,   eps )
    elseif x < 10 and x ~= 0 then
      assertAlmostEquals( (z:acosh():cosh() - z  ):real(), 0, 2*eps )
      assertAlmostEquals( (z:acosh():cosh() - z  ):imag(), 0, 2*eps )
    end
  end
  assertEquals( ( 0 - 1i):acoth()       , 0 + pi/4*1i )
  assertEquals( (-1 + 0i):acoth():real(),-inf         )
  assertEquals( (-1 + 0i):acoth():imag(), 0) -- check for mac: pi/4*1i bug

-- Check for IEEE:IEC 60559 compliance --No existing, merged division and catanh
  for _,x in ipairs(values.rad) do
    assertEquals( complex( x, inf ):acoth(), complex( 0, 0) ) --1/inf = 0
    assertEquals( complex( inf, x ):acoth(), complex( 0, 0) )
    assertNaN   ( complex( nan, x ):acoth():real() )
    assertNaN   ( complex( nan, x ):acoth():imag() )
    assertNaN   ( complex( x, nan ):acoth():real() )
    assertNaN   ( complex( x, nan ):acoth():imag() )
  end
  assertNaN   ( complex(  0 ,  0  ):acoth():real()) -- 1/(0 + 0i) = nan + nan i
  assertNaN   ( complex( inf, inf ):acoth():imag()) -- 1/(inf + inf i) = nan + nan i 
  assertNaN   ( complex( nan, nan ):acoth():real())
  assertNaN   ( complex( nan, nan ):acoth():imag())
  assertNaN   ( complex( nan, inf ):acoth():real()) -- 1/(nan + inf i) = nan + nan i
  assertNaN   ( complex( nan, inf ):acoth():imag()) -- 1/(nan + inf i) = nan + nan i
  assertNaN   ( complex( inf, nan ):acoth():real())
  assertNaN   ( complex( inf, nan ):acoth():imag())
end

function TestComplex:testInvsqrt()
  for _,z in ipairs(unitCircle( pi/2, values.rad)) do
    if abs(z) > 0 and abs(z) < inf then
      local res = z*z:invsqrt()*z:invsqrt() - complex(1,0)
      assertAlmostEquals(res:real(), 0, 2*eps )
      assertAlmostEquals(res:imag(), 0, 2*eps )
      for _, x in pairs(values.num) do
        res = z*z:invsqrt(x)*z:invsqrt() - x
        if x < 1 then --absolute error
          assertAlmostEquals(res:real()  , 0, eps )
          assertAlmostEquals(res:imag()  , 0, eps )
        elseif x < huge then --relative error
          assertAlmostEquals(res:real()/x, 0, 2*eps )
          assertAlmostEquals(res:imag()/x, 0, 2*eps )
        end
      end
    end
  end
  for _,x in ipairs(values.rad2) do
    if x > 0 then
      assertEquals( complex(inf, x):invsqrt(), complex(0, 0))
      -- assertEquals( complex( x,inf):invsqrt(), complex(0, 0)) -- returns nan + nan i?
      assertAlmostEquals( complex(-x , 0):invsqrt():imag(), 1/-sqrt(x), abs(1/-sqrt(x))*eps)
    end
    assertNaN( complex(-0, -0):invsqrt():real() )
    assertNaN( complex(-0, -0):invsqrt():imag() )
  end
end

function TestComplex:testHypot()
  for _,z1 in ipairs(unitCircle( pi/2, values.rad)) do
    for _,z2 in ipairs(unitCircle( pi/2, values.rad)) do
      -- if abs(z1) > tiny and abs(z2) > tiny then
        local res = (z1:hypot(z2) - (z1*z1 + z2*z2):sqrt())
        assertAlmostEquals(res:real(), 0, eps)
        assertAlmostEquals(res:imag(), 0, eps)
        assertEquals(hypot(z1, z2), hypot(z2, z1))
        assertEquals(hypot(z1, z2), hypot(z1,-z2))
      -- end
    end
    assertAlmostEquals(z1:hypot(0):real(), abs(z1:real()), eps)
    assertAlmostEquals(z1:hypot(0):imag(), (z1*z1):sqrt():imag(), eps) -- imaginary part depends on real and imag sign part
    assertEquals(hypot(inf, z1), inf)
    assertEquals(hypot(-inf, z1), inf)
  end
  assertEquals(hypot(inf,nan), inf)
  assertEquals(hypot(-inf,nan), inf)
end

-- --
function TestComplex:testHypot3()
  for _,z1 in ipairs(unitCircle( pi/2, values.rad)) do
    for _,z2 in ipairs(unitCircle( pi/2, values.rad)) do
      for _,z3 in ipairs(unitCircle( pi/2, values.rad)) do
        local res = z1:hypot3(z2, z3) - sqrt(z1*z1 + z2*z2 + z3*z3)
        assertEquals(res:real(), 0, eps)
        assertEquals(res:imag(), 0, eps)        
        assertEquals((z1:hypot3(z2, z3) - z2:hypot3(z1 , z3)):real(), 0)
        assertEquals((z1:hypot3(z2, z3) - z2:hypot3(z1 , z3)):imag(), 0, 2*eps)
        if abs(z1^2 + z2^2 + z3^2) > 16*eps then -- x^2 + y^2 + z^2 - (y^2 + z^2 + x^2)  = eps + eps i can result in a very large difference once square rooted
          local realRes = abs(z1:hypot3(z2, z3):real()) --To account for +/- result -> sqrt(x^2 + tiny i) = x, sqrt(x^2 - tiny i) = -x
          local imagRes = abs(z1:hypot3(z2, z3):imag())
          assertAlmostEquals(realRes - abs(z2:hypot3(z3 , z1):real()), 0, 2*eps)
          assertAlmostEquals(imagRes - abs(z2:hypot3(z3 , z1):imag()), 0, 2*eps)
          assertAlmostEquals(realRes - abs(z3:hypot3(z2 , z1):real()), 0, 2*eps)
          assertAlmostEquals(imagRes - abs(z3:hypot3(z2 , z1):imag()), 0, 2*eps)
          assertEquals((z1:hypot3(z2, z3) - z1:hypot3(-z2, z3)):real(), 0)
          assertEquals((z1:hypot3(z2, z3) - z1:hypot3(-z2, z3)):imag(), 0)
          assertEquals((z1:hypot3(z2, z3) - z1:hypot3(z2 ,-z3)):real(), 0)
          assertEquals((z1:hypot3(z2, z3) - z1:hypot3(z2 ,-z3)):imag(), 0)
        end
      end
    end
    assertAlmostEquals(z1:hypot3(0, 0):real(), abs(z1:real()), eps)
    assertAlmostEquals(z1:hypot3(0, 0):imag(), (z1*z1):sqrt():imag(), eps) -- imaginary part depends on real and imag sign part
    assertEquals(z1:hypot3(complex(inf, inf ), 0):real(), inf)
    assertEquals(z1:hypot3(complex(-inf, inf), 0):imag(), -inf)
  end
  assertEquals(complex(inf, inf ):hypot3(nan,  0):real(), inf)
  assertEquals(complex(inf, -inf):hypot3(nan, 0):imag(), -inf)
end

function TestComplex:testErf()
  local out1 = {
    1.31615128169795  + 0.190453469237835i  , 1.29544590456015  + 0.199426416663439i   ,
    1.27521687810745  + 0.207228646174191i  , 1.25547461197363  + 0.213931241738164i   ,
    1.23622714974275  + 0.219601128483860i  , 1.21748044045495  + 0.224301305672653i   ,
    1.19923858394314  + 0.228091068411634i  , 1.18150405242248  + 0.231026218433292i   ,
    1.16427789053539  + 0.233159264295395i  , 1.14755989585491  + 0.234539611373996i   ,
    1.13134878166762  + 0.235213742035883i  , 1.11564232369175  + 0.235225386384920i   ,
    1.10043749223559  + 0.234615683980555i  , 1.08573057116432  + 0.233423336926932i   ,
    1.07151726491871  + 0.231684754728300i  , 1.05779279471573  + 0.229434191301174i   ,
    1.04455198495790  + 0.226703874526571i  , 1.03178934078445  + 0.223524128716953i   ,
    1.01949911761185  + 0.219923490362611i  , 1.00767538343358  + 0.215928817511428i   ,
    0.996312074578618 + 0.211565393124530i  , 0.985403045563509 + 0.206857022738444i   ,
    0.974942113614628 + 0.201826126752244i  , 0.964923098384090 + 0.196493827645902i   ,
    0.955339857334277 + 0.190880032423859i  , 0.946186317222041 + 0.185003510565683i   ,
    0.937456502073583 + 0.178881967753786i  , 0.929144558004572 + 0.172532115636550i   ,
    0.921244775206956 + 0.165969737873882i  , 0.913751607393705 + 0.159209752701322i   ,
    0.906659688965303 + 0.152266272238305i  , 0.899963850136760 + 0.145152658756082i   ,
    0.893659130241147 + 0.137881578111230i  , 0.887740789404875 + 0.130465050541501i   ,
    0.882204318770984 + 0.122914499012116i  , 0.877045449429446 + 0.115240795292449i   ,
    0.872260160197634 + 0.107454303935323i  , 0.867844684379710 + 0.0995649243240095i  ,
    0.863795515620396 + 0.0915821309452556i , 0.860109412956494 + 0.0835150120404920i  ,
    0.856783405158297 + 0.0753723067816051i , 0.853814794442794 + 0.0671624411124064i  ,
    0.851201159631011 + 0.0588935623921217i , 0.848940358813032 + 0.0505735729728948i  ,
    0.847030531576006 + 0.0422101628394104i , 0.845470100842779 + 0.0338108414353121i  ,
    0.844257774361508 + 0.0253829687980972i , 0.843392545879830 + 0.0169337861216200i  ,
    0.842873696030564 + 0.00847044586321327i, 0.842700792949719 + 4.15107497420593e-08i,
 }
  local out2 = {
    1.31615128169795   + 0.190453469237835i, 1.32548952782484     + 0.212018027546055i,
    1.33428482104214   + 0.234840088011743i, 1.34245527464234     + 0.258926726812085i,
    1.34991660879001   + 0.284279697181013i, 1.35658249847636     + 0.310895122315399i,
    1.36236495432279   + 0.338763210550020i, 1.36717473489058     + 0.367867996208001i,
    1.37092178880195   + 0.398187109469817i, 1.37351572462604     + 0.429691578503437i,
    1.37486630613558   + 0.462345666960239i, 1.37488397020061     + 0.496106749765692i,
    1.37348036425862   + 0.530925229920841i, 1.37056889998962     + 0.566744498780978i,
    1.36606531953471   + 0.603500941992887i, 1.35988827033173     + 0.641123992953264i,
    1.35195988440471   + 0.679536235300677i, 1.34220635773976     + 0.718653555574211i,
    1.33055852521200   + 0.758385346767039i, 1.31695242639896     + 0.798634763075871i,
    1.30132985752855   + 0.839299025701730i, 1.28363890476732     + 0.880269779097804i,
    1.26383445405797   + 0.921433496591088i, 1.24187867276681     + 0.962671933830777i,
    1.21774145850191   + 1.00386262804317i , 1.19140085061215     + 1.04487944060530i ,
    1.16284340007576   + 1.08559313999289i , 1.13206449373356     + 1.12587202171816i ,
    1.09906862911558   + 1.16558256145432i , 1.06386963644769     + 1.20459009715157i ,
    1.02649084480586   + 1.24275953558972i , 0.986965189804787    + 1.27995607848852i ,
    0.945335260662995  + 1.31604596301407i , 0.901653284972644    + 1.35089721128171i ,
    0.855981050015145  + 1.38438038326611i , 0.808389759998076    + 1.41636932739099i ,
    0.758959829139324  + 1.44674192298658i , 0.707780611085187    + 1.47538080877412i ,
    0.654950065714478  + 1.50217409156528i , 0.600574364944249    + 1.52701602945017i ,
    0.544767439708640  + 1.54980768389090i , 0.487650470824213    + 1.57045753533813i ,
    0.429351326977044  + 1.58888205724283i , 0.370003953562842    + 1.60500624364461i ,
    0.309747716575809  + 1.61876408587606i , 0.248726706169561    + 1.63009899432861i ,
    0.187089004899148  + 1.63896416167383i , 0.124985925992735    + 1.64532286442085i ,
    0.0625712272906697 + 1.64914870021086i , 3.06725258552745e-07 + 1.65042575879751i ,
  }
  local z1 = linspace(1+1i, 1+10e-8*1i, 50)
  local z2 = linspace(1+1i, 10e-8+1i  , 50)
  for i=1,50 do
    local res1 = z1  [i]:erf()
    local res2 = z2  [i]:erf()
    local ref1 = out1[i]
    local ref2 = out2[i]
    assertAlmostEquals( res1.im - ref1.im, 0, 32*eps )
    assertAlmostEquals( res1.re - ref1.re, 0, 32*eps )
    assertAlmostEquals( res2.im - ref2.im, 0, 32*eps )
    assertAlmostEquals( res2.re - ref2.re, 0, 32*eps )
  end
end

function TestComplex:testErfc()
  -- erfc(z) = 1 - erf(z)
  local z1 = linspace(1+1i, 1+10e-8*1i, 50)
  local z2 = linspace(1+1i, 10e-8+1i  , 50)
  for i=1,50 do
    local res1 = z1[i]:erfc()
    local res2 = z2[i]:erfc()
    local ref1 = 1 - z1[i]:erf()
    local ref2 = 1 - z2[i]:erf()
    assertAlmostEquals( res1.im - ref1.im, 0, 4*eps )
    assertAlmostEquals( res1.re - ref1.re, 0, 4*eps )
    assertAlmostEquals( res2.im - ref2.im, 0, 4*eps )
    assertAlmostEquals( res2.re - ref2.re, 0, 4*eps )
  end
end

function TestComplex:testErfi()
  --erfi(z) = -i*erf(iz)
  local z1 = linspace(1+1i, 1+10e-8*1i, 50)
  local z2 = linspace(1+1i, 10e-8+1i  , 50)
  for i=1,50 do
    local res1 = z1[i]:erfi()
    local res2 = z2[i]:erfi()
    local ref1 = -1i * (1i*z1[i]):erf()
    local ref2 = -1i * (1i*z2[i]):erf()
    assertAlmostEquals( res1.im - ref1.im, 0, eps )
    assertAlmostEquals( res1.re - ref1.re, 0, eps )
    assertAlmostEquals( res2.im - ref2.im, 0, eps )
    assertAlmostEquals( res2.re - ref2.re, 0, eps )
  end
end

function TestComplex:testErfcx()
  --erfcx(z) = exp(z^2)*erfc(z)
  local z1 = linspace(1+1i, 1+10e-8*1i, 50)
  local z2 = linspace(1+1i, 10e-8+1i  , 50)
  for i=1,50 do
    local res1 = z1[i]:erfcx()
    local res2 = z2[i]:erfcx()
    local ref1 = (z1[i]^2):exp() * z1[i]:erfc()
    local ref2 = (z2[i]^2):exp() * z2[i]:erfc()
    assertAlmostEquals( res1.im - ref1.im, 0, eps )
    assertAlmostEquals( res1.re - ref1.re, 0, eps )
    assertAlmostEquals( res2.im - ref2.im, 0, eps )
    assertAlmostEquals( res2.re - ref2.re, 0, eps )
  end
end

function TestComplex:testWf()
  --erfw(z) = exp(-z^2)*erfc(-iz)
  local z1 = linspace(1+1i, 1+10e-8*1i, 50)
  local z2 = linspace(1+1i, 10e-8+1i  , 50)
  for i=1,50 do
    local res1 = z1[i]:wf()
    local res2 = z2[i]:wf()
    local ref1 = (-z1[i]^2):exp() * (-1i*z1[i]):erfc()
    local ref2 = (-z2[i]^2):exp() * (-1i*z2[i]):erfc()
    assertAlmostEquals( res1.im - ref1.im, 0, eps )
    assertAlmostEquals( res1.re - ref1.re, 0, eps )
    assertAlmostEquals( res2.im - ref2.im, 0, eps )
    assertAlmostEquals( res2.re - ref2.re, 0, eps )
  end
end

function TestComplex:testTgamma()
  --'NYI'
end

function TestComplex:testLgamma()
  --'NYI'
end

-- complex generic functions

function TestComplex:testCarg()
  assertEquals      ( (-0       + 0i ):carg()       , 0         )
  assertEquals      ( ( 0       + 0i ):carg()       , 0         )
  assertEquals      ( (-eps     + 0i ):carg()       , pi        )
  assertEquals      ( ( eps     + 0i ):carg()       , 0         )
  assertEquals      ( (-0       + 1i ):carg()       , pi/2      )
  assertEquals      ( ( 0       + 1i ):carg()       , pi/2      )
  assertAlmostEquals( (-eps     + 1i ):carg() - pi/2, 0   , eps )
  assertAlmostEquals( ( eps     + 1i ):carg() - pi/2, 0   , eps )
  assertEquals      ( (  pi     + 0i ):carg()       , 0         )
  assertEquals      ( (- pi     + 0i ):carg()       , pi        )
  assertEquals      ( (  pi+eps + 0i ):carg()       , 0         )
  assertEquals      ( (-(pi+eps)+ 0i ):carg()       , pi        )

  assertNaN         ( complex(  nan, nan):carg()                 )
  assertEquals      ( complex(  inf, inf):carg(), atan2(inf,inf) )

  for i,z in ipairs(unitCircle( pi, values.rad)) do
    local re, im = z:real(), z:imag()
    local rad = values.rad[i]
    assertAlmostEquals( z:carg() - atan2(im,re), 0, eps )
    assertAlmostEquals( z:carg() - rad         , 0, eps )
  end
  for i,z in ipairs(unitCircle( 2*pi, values.rad)) do
    local re, im = z:real(), z:imag()
    local rad = values.rad[i]
    assertAlmostEquals( z:carg() - atan2(im,re), 0, eps )
    assertAlmostEquals( z:carg() - rad         , 0, eps )
  end

  -- Check for IEEE:IEC 60559 compliance
  for _,x in ipairs(values.rad) do
    for _,y in ipairs(values.rad) do
      local x, y = x/pi, y/pi
      assertEquals( complex( x, y):carg(), atan2( y, x) )
    end
  end
  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      assertEquals( complex( x, y):carg(), atan2( y, x) )
    end
  end
  for i,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    local rad = values.rad[i]
    assertEquals      ( z:carg()      , atan2(im,re)     )
    assertAlmostEquals( z:carg() - rad, 0          , eps )
  end
end


function TestComplex:testConj()
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    assertEquals( z:conj()               , complex( re,-im) )
    assertEquals( complex(-re, im):conj(), complex(-re,-im) )
    assertEquals( complex( re,-im):conj(), complex( re, im) )
    assertEquals( complex(-re,-im):conj(), complex(-re, im) )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    local re, im = z:real(), z:imag()
    assertEquals( z:conj()               , complex( re,-im) )
    assertEquals( complex(-re, im):conj(), complex(-re,-im) )
    assertEquals( complex( re,-im):conj(), complex( re, im) )
    assertEquals( complex(-re,-im):conj(), complex(-re, im) )
  end
  -- Check for IEEE:IEC 60559 compliance
  for _,x in ipairs(values.rad) do
    for _,y in ipairs(values.rad) do
      local x, y = x/pi, y/pi
      assertEquals( complex(x,y):conj(): sqrt(), complex(x,y): sqrt():conj() )
      assertEquals( complex(x,y):conj():  exp(), complex(x,y):  exp():conj() )
      assertEquals( complex(x,y):conj():  log(), complex(x,y):  log():conj() )
      assertEquals( complex(x,y):conj(): sinh(), complex(x,y): sinh():conj() )
      assertEquals( complex(x,y):conj(): cosh(), complex(x,y): cosh():conj() )
      assertEquals( complex(x,y):conj(): tanh(), complex(x,y): tanh():conj() )
      assertEquals( complex(x,y):conj(): acos(), complex(x,y): acos():conj() )
      assertEquals( complex(x,y):conj():acosh(), complex(x,y):acosh():conj() )
      assertEquals( complex(x,y):conj():acosh(), complex(x,y):acosh():conj() )
      assertEquals( complex(x,y):conj():atanh(), complex(x,y):atanh():conj() )
    end
  end
end

function TestComplex:testProj()
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    assertEquals( complex( re, im):proj(), z                )
    assertEquals( complex(-re,-im):proj(), complex(-re,-im) )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    local re, im = z:real(), z:imag()
    assertEquals( complex( re, im):proj(), z                )
    assertEquals( complex(-re,-im):proj(), complex(-re,-im) )
  end
  assertEquals( complex( 1   , 2  ):proj()       , complex( 1   , 2) )
  assertEquals( complex( inf ,-1  ):proj()       , complex( inf , 0) )
  assertEquals( complex( 0   ,-inf):proj()       , complex( inf , 0) )
  assertEquals( complex( 0   , 1  ):proj()       , complex( 0   , 1) )
  assertEquals( complex( tiny, 1  ):proj()       , complex( tiny, 1) )
  assertEquals( complex( 0.1 , 1  ):proj()       , complex( 0.1 , 1) )
  assertEquals( complex( 1   , 1  ):proj()       , complex( 1   , 1) )
  assertEquals( complex( huge, 1  ):proj()       , complex( huge, 1) )
  assertEquals( complex( inf , 1  ):proj()       , complex( inf , 0) )
  assertEquals( complex(-0   , 1  ):proj()       , complex( 0   , 1) )
  assertEquals( complex(-tiny, 1  ):proj()       , complex(-tiny, 1) )
  assertEquals( complex(-0.1 , 1  ):proj()       , complex(-0.1 , 1) )
  assertEquals( complex(-1   , 1  ):proj()       , complex(-1   , 1) )
  assertEquals( complex(-huge, 1  ):proj()       , complex(-huge, 1) )
  assertEquals( complex(-inf , 1  ):proj()       , complex( inf , 0) )
  assertEquals( complex( 1   , nan):proj():real(), 1                 )
  assertNaN   ( complex( nan , nan):proj():real()                    )
  assertNaN   ( complex( 1   , nan):proj():imag()                    )
  assertNaN   ( complex( nan , nan):proj():imag()                    )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( inf , 2   ):proj(), complex( inf , 0) )
  assertEquals( complex( inf ,-2   ):proj(), complex( inf ,-0) )
  assertEquals( complex( 2   , inf ):proj(), complex( inf , 0) )
  assertEquals( complex( 2   ,-inf ):proj(), complex( inf ,-0) )
  assertEquals( complex( nan , inf ):proj(), complex( inf , 0) )
  assertEquals( complex( nan , inf ):proj(), complex( inf , 0) )
end

function TestComplex:testRect()
  assertEquals( complex( 0   , 0   ):rect()       , complex( 0   , 0) )
  assertEquals( complex( tiny, tiny):rect()       , complex( tiny, 0) )
  assertEquals( complex( tiny, 0   ):rect()       , complex( tiny, 0) )
  assertNaN   ( complex( inf , inf ):rect():real()                    )
  assertNaN   ( complex( inf , inf ):rect():imag()                    )
  assertNaN   ( complex(-inf ,-inf ):rect():real()                    )
  assertNaN   ( complex(-inf ,-inf ):rect():imag()                    )
  assertNaN   ( complex( nan , nan ):rect():real()                    )
  assertNaN   ( complex( nan , nan ):rect():imag()                    )

  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    assertEquals( z:rect(), complex( re*cos(im), re*sin(im) ) )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    local re, im = z:real(), z:imag()
    assertEquals( z:rect(), complex( re*cos(im), re*sin(im) ) )
  end
end

function TestComplex:testPolar()
  assertEquals( complex( 0   , 0   ):polar()       , complex( 0  , 0               ) )
  assertEquals( complex( tiny, 0   ):polar()       , complex( 0  , 0               ) )
  assertEquals( complex( 1   , 0   ):polar()       , complex( 1  , 0               ) )
  assertEquals( complex(-1   , 0   ):polar()       , complex( 1  , pi              ) )
  assertEquals( complex( tiny, tiny):polar()       , complex( 0  , atan2(tiny,tiny)) )
  assertEquals( complex( inf , inf ):polar()       , complex( inf, atan2( inf, inf)) )
  assertEquals( complex(-inf ,-inf ):polar()       , complex( inf, atan2(-inf,-inf)) )
  assertNaN   ( complex( nan , nan ):polar():real()                                  )
  assertNaN   ( complex( nan , nan ):polar():imag()                                  )
  assertInf   ( complex( huge, huge):polar():real()                                  )
  assertEquals( complex( huge, huge):polar():imag(), atan2( huge, huge)              )
  assertInf   ( complex(-huge,-huge):polar():real()                                  )
  assertEquals( complex(-huge,-huge):polar():imag(), atan2(-huge,-huge)              )

  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    assertAlmostEquals( (z:polar() - complex( hypot(re,im), atan2(im,re))):real(), 0, eps )
    assertAlmostEquals( (z:polar() - complex( hypot(re,im), atan2(im,re))):imag(), 0, eps )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    local re, im = z:real(), z:imag()
    if x ~= huge then
      assertAlmostEquals( (z:polar() - complex( hypot(re,im), atan2(im,re))):real(), 0, 2*eps )
      assertAlmostEquals( (z:polar() - complex( hypot(re,im), atan2(im,re))):imag(), 0,   eps )
    end
  end
end

-- complex non-generic functions

function TestComplex:testUnit()
  local z1 = unitCircle( 1, values.rad)
  for j=1,4,0.1 do
    for i,z in ipairs(unitCircle( j, values.rad)) do
      assertAlmostEquals( z:unit():real() - z1[i]:real(), 0, eps )
      assertAlmostEquals( z:unit():imag() - z1[i]:imag(), 0, eps )
    end
  end
  assertNaN   ( complex( inf , 1  ):unit():real()    )
  assertEquals( complex( inf , 1  ):unit():imag(), 0 )
  assertNaN   ( complex( inf ,-1  ):unit():real()    )
  assertEquals( complex( inf ,-1  ):unit():imag(), 0 )
  assertNaN   ( complex(-inf , 1  ):unit():real()    )
  assertEquals( complex(-inf , 1  ):unit():imag(), 0 )
  assertEquals( complex( 1   ,-inf):unit():real(), 0 )
  assertNaN   ( complex( 1   ,-inf):unit():imag()    )
  assertEquals( complex( 1   , inf):unit():real(), 0 )
  assertNaN   ( complex( 1   , inf):unit():imag()    )
  assertNaN   ( complex( nan , inf):unit():real()    )
  assertNaN   ( complex( nan , inf):unit():imag()    )
end

-- complex operators

function TestComplex:testUnm()
  assertEquals( 1/(complex( 0  , 0  ):unm()):real(),-inf                )
  assertEquals( 1/(complex( 0  , 0  ):unm()):imag(),-inf                )
  assertEquals( 1/(complex(-0  ,-0  ):unm()):real(), inf                )
  assertEquals( 1/(complex(-0  ,-0  ):unm()):imag(), inf                )
  assertEquals(    complex( inf, inf):unm()        , complex(-inf,-inf) )
  assertEquals(    complex(-inf,-inf):unm()        , complex( inf, inf) )
  assertNaN   (    complex( nan, nan):unm():real()                      )
  assertNaN   (    complex( nan, nan):unm():imag()                      )
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    assertEquals( z:unm()               , complex(-re,-im) )
    assertEquals( complex(-re, im):unm(), complex( re,-im) )
    assertEquals( complex( re,-im):unm(), complex(-re, im) )
    assertEquals( complex(-re,-im):unm(), complex( re, im) )
  end
end

function TestComplex:testAdd()
  assertEquals(  complex( 1, 1):add(complex( 0   , 0   ))        , complex( 1    , 1    ) )
  assertEquals(  complex( 1, 1):add(complex( inf , inf ))        , complex( inf  , inf  ) )
  assertEquals(  complex( 1, 1):add(complex(-inf ,-inf ))        , complex(-inf  ,-inf  ) )
  assertEquals(  complex( 1, 1):add(complex( huge, huge))        , complex( huge , huge ) )
  assertEquals(  complex( 1, 1):add(complex(-huge,-huge))        , complex(-huge ,-huge ) )
  assertEquals(  complex( 1, 1):add(complex( eps , eps ))        , complex( 1+eps, 1+eps) )
  assertEquals(  complex( 1, 1):add(complex(-eps ,-eps ))        , complex( 1-eps, 1-eps) )
  assertNaN   ( (complex( 1, 1):add(complex( nan , nan ))):real()                         )
  assertNaN   ( (complex( 1, 1):add(complex( nan , nan ))):imag()                         )

  for _,z  in ipairs(unitCircle( 1, values.rad)) do
  for _,z1 in ipairs(unitCircle( 1, values.rad)) do
    local re , im  = z :real(), z :imag()
    local re1, im1 = z1:real(), z1:imag()
    assertEquals( complex( re, im ):add(complex( re1, im1 )), complex( re+re1, im+im1 ) )
    assertEquals( complex( re, 0  ):add(complex( re1, 0   )), complex( re+re1, 0      ) )
    assertEquals( complex( 0 , im ):add(complex( 0  , im1 )), complex( 0     , im+im1 ) )
    assertEquals( complex( re, im ):add(complex( re1, 0   )), complex( re+re1, im     ) )
    assertEquals( complex( re, im ):add(complex( 0  , im1 )), complex( re    , im+im1 ) )

    assertEquals( complex(-re, im ):add(complex( re1, im1 )), complex(-re+re1, im+im1 ) )
    assertEquals( complex( re,-im ):add(complex( re1, im1 )), complex( re+re1,-im+im1 ) )
    assertEquals( complex(-re,-im ):add(complex( re1, im1 )), complex(-re+re1,-im+im1 ) )
  end end

  for _,x in ipairs(values.num) do
  for _,y in ipairs(values.num) do
    local z  = complex( x, x)
    local z1 = complex( y, y)
    local re , im  = z :real(), z:imag()
    local re1, im1 = z1:real(), z:imag()
    assertEquals( complex( re, im ):add(complex( re1, im1 )), complex( re+re1, im+im1 ) )
    assertEquals( complex(-re,-im ):add(complex( re1, im1 )), complex(-re+re1,-im+im1 ) )
  end end
end

function TestComplex:testSub()
  assertEquals(  complex( 1, 1):sub(complex( 0   , 0   ))        , complex( 1    , 1    ) )
  assertEquals(  complex( 1, 1):sub(complex( inf , inf ))        , complex(-inf  ,-inf  ) )
  assertEquals(  complex( 1, 1):sub(complex(-inf ,-inf ))        , complex( inf  , inf  ) )
  assertEquals(  complex( 1, 1):sub(complex( huge, huge))        , complex(-huge ,-huge ) )
  assertEquals(  complex( 1, 1):sub(complex(-huge,-huge))        , complex( huge , huge ) )
  assertEquals(  complex( 1, 1):sub(complex( eps , eps ))        , complex( 1-eps, 1-eps) )
  assertEquals(  complex( 1, 1):sub(complex(-eps ,-eps ))        , complex( 1+eps, 1+eps) )
  assertNaN   ( (complex( 1, 1):sub(complex( nan , nan ))):real()                         )
  assertNaN   ( (complex( 1, 1):sub(complex( nan , nan ))):imag()                         )

  for _,z  in ipairs(unitCircle( 1, values.rad)) do
  for _,z1 in ipairs(unitCircle( 1, values.rad)) do
    local re , im  = z :real(), z :imag()
    local re1, im1 = z1:real(), z1:imag()
    assertEquals( complex( re, im ):sub(complex( re1, im1 )), complex( re - re1 , im -  im1  ) )
    assertEquals( complex( re, im ):sub(complex( re1, im1 )), complex( re - re1 , im -  im1  ) )
    assertEquals( complex( re, 0  ):sub(complex( re1, 0   )), complex( re - re1 , 0          ) )
    assertEquals( complex( 0 , im ):sub(complex( 0  , im1 )), complex( 0        , im -  im1  ) )
    assertEquals( complex( re, im ):sub(complex( re1, 0   )), complex( re - re1 , im         ) )
    assertEquals( complex( re, im ):sub(complex( 0  , im1 )), complex( re       , im -  im1  ) )

    assertEquals( complex( re, im ):sub(complex(-re1, im1 )), complex( re-(-re1), im -  im1  ) )
    assertEquals( complex( re, im ):sub(complex( re1,-im1 )), complex( re-  re1 , im -(-im1 )) )
    assertEquals( complex( re, im ):sub(complex(-re1,-im1 )), complex( re-(-re1), im -(-im1 )) )
  end end
  for _,x in ipairs(values.num) do
    local z  = complex( x, x)
    local re , im  = z :real(), z :imag()
  for _,y in ipairs(values.num) do
    local z1 = complex( y, y)
    local re1, im1 = z1:real(), z1:imag()
    assertEquals( complex( re, im):sub(complex( re1, im1)), complex( re-  re1 , im-  im1 ) )
    assertEquals( complex( re, im):sub(complex(-re1,-im1)), complex( re-(-re1), im-(-im1)) )
  end end
end

function TestComplex:testMul()
  assertNaN   ( (complex( 1, 1):mul(complex( inf , inf ))):real()                     )
  assertEquals( (complex( 1, 1):mul(complex( inf , inf ))):imag(), inf                )
  assertNaN   ( (complex( 1, 1):mul(complex(-inf ,-inf ))):real()                     )
  assertEquals( (complex( 1, 1):mul(complex(-inf ,-inf ))):imag(),-inf                )
  assertNaN   ( (complex( 1, 1):mul(complex( nan , nan ))):real()                     )
  assertNaN   ( (complex( 1, 1):mul(complex( nan , nan ))):imag()                     )
  assertEquals(  complex( 1, 1):mul(complex( huge, huge))        , complex( 0, inf  ) )
  assertEquals(  complex( 1, 1):mul(complex(-huge,-huge))        , complex( 0,-inf  ) )
  assertEquals(  complex( 1, 1):mul(complex( eps , eps ))        , complex( 0, 2*eps) )
  assertEquals(  complex( 1, 1):mul(complex(-eps ,-eps ))        , complex( 0,-2*eps) )
  assertEquals(  complex( 1, 1):mul(complex( 0   , 0   ))        , complex( 0, 0    ) )

  for _,z  in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z :real(), z :imag()
      assertEquals( complex( re, im):mul(complex( 1   , 0   )), complex( re, im) )
    for _,z1 in ipairs(unitCircle( 1, values.rad)) do
      local re1, im1 = z1:real(), z1:imag()
      assertEquals( complex( re, im ):mul(complex( re1, im1 )), complex( re*re1-  im*im1 , re*im1+re1*im) )
      assertEquals( complex(-re, im ):mul(complex( re1, im1 )), complex(-re*re1-  im*im1 ,-re*im1+re1*im) )
      assertEquals( complex( re,-im ):mul(complex( re1, im1 )), complex( re*re1-(-im*im1), re*im1-re1*im) )
      assertEquals( complex(-re,-im ):mul(complex( re1, im1 )), complex(-re*re1-(-im*im1),-re*im1-re1*im) )
      assertEquals( complex( re, 0  ):mul(complex( re1, 0   )), complex( re*re1          , 0            ) )
      assertEquals( complex( 0 , im ):mul(complex( 0   , im1)), complex(-im*im1          , 0            ) )
      assertEquals( complex( re, im ):mul(complex( re1, 0   )), complex( re*re1          , re1*im       ) )
      assertEquals( complex( re, im ):mul(complex( 0   , im1)), complex(-im*im1          , re *im1      ) )
    end
  end
  for _,x in ipairs(values.num) do
    local z  = complex( x, x)
    local re, im = z :real(), z :imag()
    for _,y in ipairs(values.num) do
      local z1 = complex( y, y)
      local re1, im1 = z1:real(), z1:imag()
        assertEquals( complex( re, im ):mul(complex( 0  , im1 )), complex(-im*im1         , re*im1       ) )
      if x < huge and y < huge then
        assertEquals( complex( re, im ):mul(complex( re1, im1 )), complex( re*re1 - im*im1, re*im1+re1*im) )
      end
    end
  end
end

function TestComplex:testDiv()
  assertEquals( (complex( 0   , 0  ):div(complex( 1   , 1   )))       , complex(0,0) )
  assertInf   ( (complex( 4   , 4  ):div(complex( tiny, tiny))):real()               ) --Tiny = 2^-1022 to receive inf, we need to go above 2^1024 so 2^2 / 2^-1022 achieves inf
  assertEquals( (complex( 4   , 4  ):div(complex( tiny, tiny))):imag(), 0            ) --(1 + 1i) / (x + xi) = 1/x 
  assertEquals( (complex( 1   , 1  ):div(complex( huge, huge))):real(), 0            ) --Huge = 2^1024; 2^-1024 = 0, also 1/inf = 0
  assertEquals( (complex( 1   , 1  ):div(complex( huge, huge))):imag(), 0            )
  assertEquals( (complex( 1   , 1  ):div(complex(-huge,-huge))):real(),-0            ) --(1 + 1i) / (-x + -xi) = -1/x + comment on line 1652
  assertEquals( (complex( 1   , 1  ):div(complex(-huge,-huge))):imag(), 0            )
  assertNaN   ( (complex( 1   , 1  ):div(complex( inf , inf ))):real()               )
  assertNaN   ( (complex( 1   , 1  ):div(complex( inf , inf ))):imag()               )
  assertNaN   ( (complex( 1   , 1  ):div(complex(-inf ,-inf ))):real()               )
  assertNaN   ( (complex( 1   , 1  ):div(complex(-inf ,-inf ))):imag()               )
  assertNaN   ( (complex( 1   , 1  ):div(complex( nan , nan ))):real()               )
  assertNaN   ( (complex( 1   , 1  ):div(complex( nan , nan ))):imag()               )
  assertEquals( (complex(-inf ,-inf):div(complex( 1   , 1   ))):real(),-inf          )
  assertNaN   ( (complex(-inf ,-inf):div(complex( 1   , 1   ))):imag()               )
  assertNaN   ( (complex( nan , nan):div(complex( 1   , 1   ))):real()               )
  assertNaN   ( (complex( nan , nan):div(complex( 1   , 1   ))):imag()               )

  assertNaN   ( (complex( 1   , 0  ):div(complex( 0   , 0   ))):real()               )
  assertNaN   ( (complex( 1   , 0  ):div(complex( 0   , 0   ))):imag()               )
  assertNaN   ( (complex( 1   , 1  ):div(complex( 0   , 0   ))):real()               )
  assertNaN   ( (complex( 1   , 1  ):div(complex( 0   , 0   ))):imag()               )
  assertNaN   ( (complex( 0   , 1  ):div(complex( 0   , 0   ))):real()               )
  assertNaN   ( (complex( 0   , 1  ):div(complex( 0   , 0   ))):imag()               )
  assertEquals( (complex( 1   , 1  ):div(complex( 1   , 0   ))):real(), 1            )
  assertEquals( (complex( 1   , 1  ):div(complex( 1   , 0   ))):imag(), 1            )
  assertEquals( (complex( 1   , 1  ):div(complex( 0   , 1   ))):real(), 1            )
  assertEquals( (complex( 1   , 1  ):div(complex( 0   , 1   ))):imag(),-1            )

  for _,z  in ipairs(unitCircle( 1, values.rad)) do
  local re , im = z :real(), z :imag()
  for _,z1 in ipairs(unitCircle( 1, values.rad)) do
    local re1, im1 = z1:real(), z1:imag()
    local res1 = complex( re*re1 +  im*im1 , ( im*re1 -  re*im1)) /(im1^2 + re1^2)
    local res2 = complex(-re*re1 +  im*im1 , ( im*re1 -(-re*im1)))/(im1^2 + re1^2)
    local res3 = complex( re*re1 +(-im*im1), (-im*re1 -  re*im1)) /(im1^2 + re1^2)
    local res4 = complex(-re*re1 +(-im*im1), (-im*re1 -(-re*im1)))/(im1^2 + re1^2)
    assertTrue( (complex( re, im):div(complex( re1, im1))):eq(res1, eps) )
    assertTrue( (complex(-re, im):div(complex( re1, im1))):eq(res2, eps) )
    assertTrue( (complex( re,-im):div(complex( re1, im1))):eq(res3, eps) )
    assertTrue( (complex(-re,-im):div(complex( re1, im1))):eq(res4, eps) )
    if im1 > 0 then
        assertAlmostEquals( (complex( 0 , im):div(complex( 0  , im1)) - complex( im/im1, 0     )):imag()   , 0,   eps )
        assertAlmostEquals( (complex( 0 , im):div(complex( 0  , im1)) - complex( im/im1, 0     )):imag()   , 0,   eps )
      if(complex( im/im1, 0):real() == 0) then
        assertEquals      ( (complex( 0 , im):div(complex( 0  , im1)) - complex( im/im1, 0     )):real()   , 0        )
        assertAlmostEquals( (complex( 0 , im):div(complex( 0  , im1)) - complex( im/im1, 0     )):real()   , 0,   eps )
      else
        assertAlmostEquals( (complex( 0 , im):div(complex( 0  , im1)) / complex( im/im1, 0     )):real()- 1, 0, 2*eps )
        assertAlmostEquals( (complex( 0 , im):div(complex( 0  , im1)) / complex( im/im1, 0     )):real()- 1, 0, 2*eps )
      end
        assertAlmostEquals( (complex( re, im):div(complex( 0  , im1)) / complex( im/im1,-re/im1)):real()- 1, 0, 2*eps )
        assertAlmostEquals( (complex( re, im):div(complex( 0  , im1)) / complex( im/im1,-re/im1)):imag()   , 0,   eps )
    end
        assertAlmostEquals( (complex( re, 0 ):div(complex( re1, 0  )) / complex( re/re1, 0     )):real()- 1, 0,   eps )
        assertAlmostEquals( (complex( re, 0 ):div(complex( re1, 0  )) - complex( re/re1, 0     )):imag()   , 0,   eps )
        assertAlmostEquals( (complex( re, im):div(complex( re1, 0  )) / complex( re/re1, im/re1)):real()- 1, 0,   eps )
        assertAlmostEquals( (complex( re, im):div(complex( re1, 0  )) / complex( re/re1, im/re1)):imag()   , 0,   eps )
  end end

  for _,x in ipairs(values.num) do
    local z  = complex( x, x)
    local re , im = z :real(), z :imag()
  for _,y in ipairs(values.num) do
    if x < huge and y < huge and x > tiny and y > tiny then
      local z1 = complex( y, y)
      local re1, im1 = z1:real(), z1:imag()
      local res = complex(re*re1 + im*im1, im*re1 - re*im1)/(im1^2 + re1^2)
      if res.re ~= 0 then
        assertAlmostEquals(  complex( re, im):div(complex( re1, im1)).re/res.re, 1, eps )
      end
      if res.im ~= 0 then
        assertAlmostEquals(  complex( re, im):div(complex( re1, im1)).im/res.im, 1, eps )
      end
        assertAlmostEquals( (complex( 0 , im):div(complex( 0  , im1)) - complex( im/im1, 0)):imag()   , 0,   eps )
        assertAlmostEquals( (complex( 0 , im):div(complex( 0  , im1)) - complex( im/im1, 0)):imag()   , 0,   eps )
      if z.im == 0 then
        assertEquals      ( (complex( 0 , im):div(complex( 0  , im1)) - complex( im/im1, 0)):real()   , 0        )
        assertAlmostEquals( (complex( 0 , im):div(complex( 0  , im1)) - complex( im/im1, 0)):real()   , 0,   eps )
      else
        assertAlmostEquals( (complex( 0 , im):div(complex( 0  , im1)) / complex( im/im1, 0)):real()- 1, 0, 2*eps )
        assertAlmostEquals( (complex( 0 , im):div(complex( 0  , im1)) / complex( im/im1, 0)):real()- 1, 0, 2*eps )
      end
    end
  end end
end

function TestComplex:testInv()
  for _,z in ipairs(unitCircle( pi/2, values.rad)) do
    if abs(z) > 0 and abs(z) < inf then
      local res = z:inv() - 1/z
      assertEquals(res:real(), 0)
      assertEquals(res:imag(), 0)
      res = z*z:inv() - 1
      assertAlmostEquals(res:real(), 0, eps )
      assertAlmostEquals(res:imag(), 0, eps )
    end
  end
  for _,x in ipairs(values.rad2) do
    if x > 0 then
      assertEquals( complex(inf, x ):inv(), complex(0, 0))
      assertEquals( complex( x ,inf):inv(), complex(0, 0))
      assertEquals( complex( 0 , x ):inv(), complex(0, -1/(x)))
    end
    assertNaN( complex( 0, -0):inv():real() )
    assertNaN( complex(-0,  0):inv():imag() )
  end
end

function TestComplex:testMod()
  local a, b, d, z, z1
  local roundc = _C.round -- round imported from C

  for j,z  in ipairs(unitCircle(1, values.rad)) do
  for i,z1 in ipairs(unitCircle(1, values.rad)) do
    local d = z/z1
    local re, im = d:real(), d:imag()
    assertAlmostEquals( abs(z:mod(z1) - (z - (complex(roundc(re), roundc(im)))*z1)), 0, eps )
  end end
  for _,x in ipairs(values.rad) do
  for _,y in ipairs(values.rad) do
    if y > 0 and y < inf and x < inf then
      local a, b = x/pi, y/pi
      local z, z1 = complex(a,a), complex(b,b)
      local d = z/z1
      local re, im = d:real(), d:imag()
      assertAlmostEquals( abs(z:mod(z1) - (z - (complex(roundc(re), roundc(im)))*z1)), 0, eps )
    end
  end end
  for _,x in ipairs(values.num) do
  for _,y in ipairs(values.num) do
    if x > tiny and x < 10 and y > tiny and y < 10 then
      local a, b = complex(x,y), complex(x,y)
      assertAlmostEquals( a:mod(b):real() - (a - round(a/b)*b ):real(), 0,   eps )
      assertAlmostEquals( a:mod(b):imag() - (a - round(a/b)*b ):imag(), 0,   eps )
      a, b = complex(x,x), complex(y,y)
      assertAlmostEquals( a:mod(b):real() - (a - round(a/b)*b ):real(), 0,   eps )
      assertAlmostEquals( a:mod(b):imag() - (a - round(a/b)*b ):imag(), 0,   eps )
      a, b = complex(x,y), complex(y,x)
      assertAlmostEquals( a:mod(b):real() - (a - round(a/b)*b ):real(), 0,   eps )
      assertAlmostEquals( a:mod(b):imag() - (a - round(a/b)*b ):imag(), 0, 2*eps )
    end
  end end

  assertNaN( complex( 1  , 1   ):mod(complex( 1  ,  inf )):real() )
  assertNaN( complex( 1  , 1   ):mod(complex( 1  ,  inf )):imag() )
  assertNaN( complex( 1  , 1   ):mod(complex(-1  ,  inf )):real() )
  assertNaN( complex( 1  , 1   ):mod(complex(-1  ,  inf )):imag() )
  assertNaN( complex( 1  , 1   ):mod(complex( 1  , -inf )):real() )
  assertNaN( complex( 1  , 1   ):mod(complex( 1  , -inf )):imag() )
  assertNaN( complex( 1  , 1   ):mod(complex(-1  , -inf )):real() )
  assertNaN( complex( 1  , 1   ):mod(complex(-1  , -inf )):imag() )
  assertNaN( complex( 1  , 1   ):mod(complex( inf,  inf )):real() )
  assertNaN( complex( 1  , 1   ):mod(complex( inf,  inf )):imag() )
  assertNaN( complex( 1  , 1   ):mod(complex(-inf, -inf )):real() )
  assertNaN( complex( 1  , 1   ):mod(complex(-inf, -inf )):imag() )
  assertNaN( complex( 1  , 1   ):mod(complex( inf,  nan )):real() )
  assertNaN( complex( 1  , 1   ):mod(complex( inf,  nan )):imag() )
  assertNaN( complex( 1  , 1   ):mod(complex(-inf,  nan )):real() )
  assertNaN( complex( 1  , 1   ):mod(complex(-inf,  nan )):imag() )
  assertNaN( complex( 1  , 1   ):mod(complex( nan,  nan )):real() )
  assertNaN( complex( 1  , 1   ):mod(complex( nan,  nan )):imag() )
  assertNaN( complex( 1  , 1   ):mod(complex( 0  ,  0   )):real() )
  assertNaN( complex( 1  , 1   ):mod(complex( 0  ,  0   )):imag() )
  assertNaN( complex( 1  , 1   ):mod(complex(-0  , -0   )):real() )
  assertNaN( complex( 1  , 1   ):mod(complex(-0  , -0   )):imag() )
  assertNaN( complex( inf, nan ):mod(complex( 1  ,  1   )):real() )
  assertNaN( complex( inf, nan ):mod(complex( 1  ,  1   )):imag() )
  assertNaN( complex(-inf, nan ):mod(complex( 1  ,  1   )):real() )
  assertNaN( complex(-inf, nan ):mod(complex( 1  ,  1   )):imag() )
  assertNaN( complex( nan, nan ):mod(complex( 1  ,  1   )):real() )
  assertNaN( complex( nan, nan ):mod(complex( 1  ,  1   )):imag() )
end

function TestComplex:testPow()
  assertEquals( complex( 0  , 1 ):pow(0)          , complex( 1  , 0 ) )
  assertEquals( complex( 0  , 1 ):pow(1)          , complex( 0  , 1 ) )
  assertEquals( complex( 0  ,-1 ):pow(1)          , complex( 0  ,-1 ) )
  assertEquals( complex(-0  , 1 ):pow(1)          , complex(-0  , 1 ) )
  assertEquals( complex( 0  , 1 ):pow(1)          , complex( 0  , 1 ) )
  assertEquals( complex(-eps, 0 ):pow(1)          , complex(-eps, 0 ) )
  assertEquals( complex( eps, 0 ):pow(1)          , complex( eps, 0 ) )
  assertEquals( complex( 1  , 1 ):pow( inf):real(), inf               )
  assertNaN   ( complex( 1  , 1 ):pow( inf):imag(), nan               )
  assertEquals( complex( 1  , 1 ):pow(-inf):real(), 0                 )
  assertEquals( complex( 1  , 1 ):pow(-inf):imag(), 0                 )
  assertNaN   ( complex( 1  , 1 ):pow( nan):real()                    )
  assertNaN   ( complex( 1  , 1 ):pow( nan):imag()                    )
  assertNaN   ( complex( 1  , 1 ):pow(-nan):real()                    )
  assertNaN   ( complex( 1  , 1 ):pow(-nan):imag()                    )
  assertEquals( complex( 1  , 1 ):pow(-1)         , 0.5-0.5i          )
  assertTrue  ( (1i):pow(1i) == exp(-pi/2) )
  assertAlmostEquals( (complex(1,1):pow( 0.5) - complex(1,1):sqrt()):real(), 0, eps )
  assertAlmostEquals( (complex(1,1):pow( 0.5) - complex(1,1):sqrt()):imag(), 0, eps )

  for _,z  in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    assertEquals( complex( re, im):pow(0), complex( 1 , 0 )                  )
    assertEquals( complex( re, im):pow(1), complex( re, im)                  )
    assertEquals( complex(-re,-im):pow(1), complex(-re,-im)                  )
    assertEquals( complex( re, im):pow(2), complex( re, im)*complex( re, im) )
    assertEquals      ( complex( re, im):pow(complex( 0, 0))            , complex(1,0)      )
    assertAlmostEquals( complex( re, im):pow(complex( 1, 0)):real() - re, 0           , eps )
    assertAlmostEquals( complex( re, im):pow(complex( 1, 0)):imag() - im, 0           , eps )
  end
-- cpx ^ int
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (z:pow(2)*z:pow(3) - z:pow(2+3)       ):real(), 0,   eps )
    assertAlmostEquals( (z:pow(2)*z:pow(3) - z:pow(2+3)       ):imag(), 0,   eps )
    assertAlmostEquals( (z:pow(3)          - (3*z:log()):exp()):real(), 0, 3*eps )
    assertAlmostEquals( (z:pow(3)          - (3*z:log()):exp()):imag(), 0, 4*eps )
  end
-- cpx ^ cpx
  for _,z  in ipairs(unitCircle( 1, values.rad)) do
  for _,c  in ipairs(unitCircle( 1, values.rad)) do
    local a = complex(z:real()^2 + z:imag()^2, 0)
    assertAlmostEquals( (z:pow(c) - a:pow(c/2)*(1i*c*z:carg()):exp() ):real(), 0, 12*eps )
    assertAlmostEquals( (z:pow(c) - a:pow(c/2)*(1i*c*z:carg()):exp() ):imag(), 0, 12*eps )
  end end
end

function TestComplex:testEqual()
  local c, z
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    assertTrue ( z == complex( re, im) )
    assertTrue (-z == complex(-re,-im) )
    assertFalse( z == complex(-re, im) )
    if z.im ~= 0 then assertFalse( z == complex( re,-im) )
                 else assertTrue ( z == complex( re,-im) ) end
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    local re, im = z:real(), z:imag()
    assertTrue ( z == complex( re, im) )
    assertTrue (-z == complex(-re,-im) )
    if x > 0 then   assertFalse( z == complex(-re, im) )
             else   assertTrue ( z == complex(-re, im) ) end
    if im ~= 0 then assertFalse( z == complex( re,-im) )
               else assertTrue ( z == complex( re,-im) ) end
  end
end

function TestComplex:testTocomplex()
  option.numfmt = '%.16g'
  for _,z in ipairs(unitCircle( pi/2, values.rad)) do
    local res = tocomplex(tostring(z))
    assertAlmostEquals(res:real(), z:real(), 2*eps)
    assertAlmostEquals(res:imag(), z:imag(), 2*eps)
  end
  option.numfmt = '%.13g'
  assertEquals ( tostring(tocomplex(('0.3333333333333'))), '0.3333333333333+0i')
  option.numfmt = '%.10f'
  assertEquals ( tostring(tocomplex(('0.3333333333'))), '0.3333333333+0.0000000000i')
  assertEquals ( tostring(tocomplex('0-0.3333333333i')), '0.0000000000-0.3333333333i')
  option.numfmt = '%-2.4e'
  assertEquals ( tostring(tocomplex('-5.4054e-02+3.2432e-01i')), '-5.4054e-02+3.2432e-01i')
  assertEquals ( tostring(tocomplex('5.0000e-01-3.3333e-01i')), '5.0000e-01-3.3333e-01i')
end

-- end ------------------------------------------------------------------------o
