--[=[
 o-----------------------------------------------------------------------------o
 |
 | Complex module regression tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A.Z. Teska, aleksandra.teska at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the complex module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o
local assertEquals, assertAlmostEquals, assertTrue, assertFalse,
      assertErrorMsgContains, assertNil, assertNaN, assertIsString, assertInf
      in require 'luaunit'

local complex, _C in MAD
local infi, tiny, eps, huge, inf, nan, pi, sqrt, cos, sin, tan, cosh, sinh,
      tanh, asinh, atanh, asin, atan, atan2, exp, log, frac, trunc, round,
      hypot, floor, abs in MAD.gmath
local is_complex, is_function, is_table in MAD.typeid

-- regression test suite ------------------------------------------------------o

TestComplex = {}

local values = {
  num  = {0, tiny, 2^-64, 2^-63, 2^-53, eps, 2^-52, 2*eps, 2^-32, 2^-31, 1e-9,
          0.1-eps, 0.1, 0.1+eps, 0.5, 0.7-eps, 0.7, 0.7+eps, 1-eps, 1, 1+eps,
          1.1, 1.7, 2, 10, 1e2, 1e3, 1e6, 1e9, 2^31, 2^32, 2^52, 2^53,
          2^63, 2^64, huge},
  rad  = {0, eps, 2*eps, pi/180, pi/90, pi/36, pi/18, pi/12, pi/6, pi/4, pi/3, pi/2,
          pi-pi/3, pi-pi/4, pi-pi/6, pi-pi/12, pi},
  rad2 = {0, eps, 2*eps, pi/180, pi/90, pi/36, pi/18, pi/12, pi/6, pi/4, pi/3, pi/2},
  rad3 = {0, eps, 2*eps, pi/180, pi/90, pi/36, pi/18, pi/12, pi/6, pi/4, pi/3},
}

local function unitCircle (r, n)
  local rad
  local z = {}
  if is_table(n) then
    for i,rad in ipairs(n) do
      z[i] = complex( r*cos( rad ), r*sin( rad ) )
    end
  else
    for i = 0, 2*n do
      rad  = 2*pi*(i-1)/n
      z[i] = complex( r*cos( rad ), r*sin( rad ) )
    end
  end
  return z
end

function TestComplex:testCtorErr()
  local msg, c = {
  "cannot convert 'string' to 'complex'",
  "cannot convert 'nil' to 'complex'"   ,
  "cannot convert 'string' to 'double'" ,
  "cannot convert 'nil' to 'double'"    ,
  }
  assertErrorMsgContains( msg[1], complex, ''       )
  assertErrorMsgContains( msg[2], complex, nil      )
  assertErrorMsgContains( msg[3], complex, '' , ''  )
  assertErrorMsgContains( msg[3], complex, 1  , ''  )
  assertErrorMsgContains( msg[3], complex, '' , 1   )
  assertErrorMsgContains( msg[4], complex, nil, 1   )
  assertErrorMsgContains( msg[4], complex, 1  , nil )
end

function TestComplex:testCtor()
  assertEquals( complex(0, 1)  , 1i            )
  assertEquals( complex(0,-1)  ,-1i            )
  assertEquals( complex(0, 1)^2, complex(-1,0) )
  for _,v in ipairs(values.num) do
    assertTrue( is_complex( complex( 0, v) ) )
    assertTrue( is_complex( complex( 0,-v) ) )
    assertTrue( is_complex( complex(-v, 0) ) )
    assertTrue( is_complex( complex( v, 0) ) )
    assertTrue( is_complex( complex( v, v) ) )
    assertTrue( is_complex( complex(-v,-v) ) )
  end
  assertNaN   ( complex(nan, 1  ).re    )
  assertEquals( complex(nan, 1  ).im, 1 )
  assertEquals( complex(1  , nan).re, 1 )
  assertNaN   ( complex(1  , nan).im    )
  assertNaN   ( complex(nan, nan).re    )
  assertNaN   ( complex(nan, nan).im    )
end
function TestComplex:testCtorFields()
  assertNaN   ( complex(nan).re       )
  assertNaN   ( complex(nan, nan).re  )
  assertEquals( complex(1).re   , 1   )
  assertEquals( complex(1).im   , 0   )
  assertEquals( complex(0,1).re , 0   )
  assertEquals( complex(0,1).im , 1   )
  for _,v in ipairs(values.num) do
    assertEquals( complex( 0, v).re,  0 )
    assertEquals( complex( 0,-v).re,  0 )
    assertEquals( complex(-v, 0).re, -v )
    assertEquals( complex( v, 0).re,  v )
    assertEquals( complex( v, v).re,  v )
    assertEquals( complex(-v,-v).re, -v )
    assertEquals( complex( 0, v).im,  v )
    assertEquals( complex( 0,-v).im, -v )
    assertEquals( complex(-v, 0).im,  0 )
    assertEquals( complex( v, 0).im,  0 )
    assertEquals( complex( v, v).im,  v )
    assertEquals( complex(-v,-v).im, -v )
    if v ~= inf then
      assertEquals( ( 0+ v*1i).re,  0 )
      assertEquals( ( 0+-v*1i).re,  0 )
    end
    assertEquals( (-v+ 0*1i).re, -v )
    assertEquals( ( v+ 0*1i).re,  v )
    assertEquals( ( 0+ v*1i).im,  v )
    assertEquals( ( 0+-v*1i).im, -v )
    assertEquals( (-v+ 0*1i).im,  0 )
    assertEquals( ( v+ 0*1i).im,  0 )
  end
    assertEquals( complex( 0  , inf).re,  0   )
    assertEquals( complex( 0  ,-inf).re,  0   )
    assertEquals( complex(-inf, 0  ).re, -inf )
    assertEquals( complex( inf, 0  ).re,  inf )
    assertEquals( complex( inf, inf).re,  inf )
    assertEquals( complex(-inf,-inf).re, -inf )
    assertEquals( complex( 0  , inf).im,  inf )
    assertEquals( complex( 0  ,-inf).im, -inf )
    assertEquals( complex(-inf, 0  ).im,  0   )
    assertEquals( complex( inf, 0  ).im,  0   )
    assertEquals( complex( inf, inf).im,  inf )
    assertEquals( complex(-inf,-inf).im, -inf )
end

-- generic functions

function TestComplex:testReal()
  assertNaN   (    complex( nan, nan):real()       )
  assertEquals(    complex( inf, inf):real() , inf )
  assertEquals(    complex(-inf,-inf):real() ,-inf )
  assertEquals( 1/(complex( 0  , 0  ):real()), inf )
  assertEquals( 1/(complex(-0  ,-0  ):real()),-inf )
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertEquals( z:real()                   , z.re )
    assertEquals( complex(-z.re, z.im):real(),-z.re )
    assertEquals( complex( z.re,-z.im):real(), z.re )
    assertEquals( complex(-z.re,-z.im):real(),-z.re )
  end
end

function TestComplex:testImag()
  local c
  assertNaN   (    complex( nan, nan):imag()       )
  assertEquals(    complex( inf, inf):imag() , inf )
  assertEquals(    complex(-inf,-inf):imag() ,-inf )
  assertEquals( 1/(complex( 0  , 0  ):imag()), inf )
  assertEquals( 1/(complex(-0  ,-0  ):imag()),-inf )
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertEquals( z:imag()                   , z.im )
    assertEquals( complex(-z.re, z.im):imag(), z.im )
    assertEquals( complex( z.re,-z.im):imag(),-z.im )
    assertEquals( complex(-z.re,-z.im):imag(),-z.im )
    assertEquals( complex(z:real(), z:imag()), z    )
  end

  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      c = complex( x, y)
      assertEquals( c, complex(c:real(), c:imag()) )
    end
  end
  c = complex( inf, inf)
  assertEquals( c, complex(c:real(), c:imag()) )
end

function TestComplex:testAngle()
  for _,z  in ipairs(unitCircle( 1, values.rad)) do
  for _,z1 in ipairs(unitCircle( 1, values.rad)) do
    local re , im  = z: real(), z: imag()
    local re1, im1 = z1:real(), z1:imag()
    assertEquals( z:angle( z1 ), atan2(im1, re1) - atan2(im, re) )
    assertEquals( ( re + im*1i):angle( complex( re + im*1i) ), 0 )
    assertEquals( ( re - im*1i):angle( complex( re - im*1i) ), 0 )
    assertEquals( (-re + im*1i):angle( complex(-re + im*1i) ), 0 )
    assertEquals( (-re - im*1i):angle( complex(-re - im*1i) ), 0 )
  end end
end

function TestComplex:testCeil()
  for _,x in ipairs(values.rad) do
    for _,y in ipairs(values.rad) do
      local x, y = x/pi, y/pi
      if     x >  0 and y >  0 then assertEquals( ( x + y*1i ):ceil(), 1 + 1i )
      elseif x <= 0 and y >  0 then assertEquals( ( x + y*1i ):ceil(), 0 + 1i )
      elseif x >  0 and y <= 0 then assertEquals( ( x + y*1i ):ceil(), 1 + 0i )
      else                          assertEquals( ( x + y*1i ):ceil(), 0 + 0i ) end
    end
  end
end

function TestComplex:testFloor()
  for _,x in ipairs(values.rad) do
    for _,y in ipairs(values.rad) do
      local x, y = x/pi, y/pi
      if     x <  1 and y <  1 then assertEquals( ( x + y*1i ):floor(), 0 + 0i )
      elseif x >= 1 and y >= 1 then assertEquals( ( x + y*1i ):floor(), 1 + 1i )
      elseif x >= 1 then            assertEquals( ( x + y*1i ):floor(), 1 + 0i )
      else                          assertEquals( ( x + y*1i ):floor(), 0 + 1i ) end
    end
  end
end

function TestComplex:testFrac()
  for _,z in ipairs( unitCircle( 1, values.rad) ) do
    local re, im  = z:real(), z:imag()
    assertEquals( z:frac():real(), frac( re ) )
    assertEquals( z:frac():imag(), frac( im ) )
  end
end

function TestComplex:testTrunc()
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im  = z:real(), z:imag()
    assertEquals( z:trunc():real() - trunc( re ), 0, eps )
    assertEquals( z:trunc():imag() - trunc( im ), 0, eps )
  end
end

function TestComplex:testRound()
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im  = z:real(), z:imag()
    assertEquals( z:round():real() - round( re ), 0, eps )
    assertEquals( z:round():imag() - round( im ), 0, eps )
  end
end

function TestComplex:testAbs()
  for _,x in ipairs(values.rad) do
    for _,y in ipairs(values.rad) do
      local x, y = x/pi, y/pi
      assertAlmostEquals( (x + y*1i):abs() - hypot(x,y), 0, eps )
    end
  end
  for _,x in ipairs(values.num) do
    if x ~= huge then assertAlmostEquals( (x + x*1i):abs() - hypot(x,x), 0, 2*eps )
    else              assertInf         ( (x + x*1i):abs() )                       end
  end
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im  = z:real(), z:imag()
    assertAlmostEquals( ( re + im*1i ):abs() - 1, 0, eps )
    assertAlmostEquals( (-re + im*1i ):abs() - 1, 0, eps )
    assertAlmostEquals( ( re - im*1i ):abs() - 1, 0, eps )
    assertAlmostEquals( (-re - im*1i ):abs() - 1, 0, eps )
  end
  for _,z in ipairs(unitCircle( 10, values.rad)) do
    assertAlmostEquals( z:abs() - 10, 0, 8*eps )
  end
end

function TestComplex:testSqrt()
  local r = 1
  for i,z in ipairs(unitCircle( r, values.rad2)) do
    local rad2 = values.rad2[i]
    local c = cos(rad2/2) + sin(rad2/2)*1i
    assertAlmostEquals( z:sqrt():real() - sqrt(r)*c:real(), 0, eps )
    assertAlmostEquals( z:sqrt():imag() - sqrt(r)*c:imag(), 0, eps )
    local re, im  = z:real(), z:imag()
    assertEquals( (re + im*1i):sqrt():real(),  (re - im*1i):sqrt():real() )
    assertEquals( (re + im*1i):sqrt():imag(), -(re - im*1i):sqrt():imag() )
  end
  assertEquals      ( ( 0 + 2i ):sqrt()                                 , 1 + 1i )
  assertEquals      ( ( 1 + 0i ):sqrt()                                 , 1 + 0i )
  assertAlmostEquals( ( 0 + 1i ):sqrt():imag() - sqrt(2)/2*(1+1i):imag(), 0, eps )
  assertEquals      ( ( 0 + 1i ):sqrt():real() - sqrt(2)/2*(1+1i):real(), 0      )
  assertAlmostEquals( (-2 + 0i ):sqrt():imag() - 1.414213562373095      , 0, eps )
  assertEquals      ( (-2 + 0i ):sqrt():real()                          , 0      )

  assertEquals      ( 1/( 0 + 0i):sqrt():real()                         , inf    )
  assertEquals      ( 1/( 0 + 0i):sqrt():imag()                         , inf    )
  assertEquals      ( 1/(-0 - 0i):sqrt():real()                         , inf    )
  assertEquals      ( 1/(-0 - 0i):sqrt():imag()                         ,-inf    )
  assertEquals      ( (-eps + 0i):sqrt():real()                         , 0      )
  assertAlmostEquals( (-eps + 0i):sqrt():imag() - 1.49011611938477e-08  , 0, eps )

  local ref = {
    0 - 1i,
    1.11022302462516e-16 - 1i                  ,
    2.22044604925031e-16 - 1i                  ,
    0.00872653549837393  - 0.99996192306417131i,
    0.0174524064372835   - 0.9998476951563913i ,
    0.0436193873653360   - 0.9990482215818578i ,
    0.0871557427476582   - 0.9961946980917455i ,
    0.130526192220052    - 0.991444861373810i  ,
    0.258819045102521    - 0.965925826289068i  ,
    0.382683432365090    - 0.923879532511287i  ,
    0.500000000000000    - 0.866025403784439i  ,
    0.707106781186547    - 0.707106781186548i  ,
    0 + 1i,
    1.11022302462516e-16 + 1i                  ,
    2.22044604925031e-16 + 1i                  ,
    0.00872653549837393  + 0.99996192306417131i,
    0.0174524064372835   + 0.9998476951563913i ,
    0.0436193873653360   + 0.9990482215818578i ,
    0.0871557427476582   + 0.9961946980917455i ,
    0.130526192220052    + 0.991444861373810i  ,
    0.258819045102521    + 0.965925826289068i  ,
    0.382683432365090    + 0.923879532511287i  ,
    0.500000000000000    + 0.866025403784439i  ,
    0.707106781186547    + 0.707106781186548i  ,
  }
  for i,z in ipairs(unitCircle( r, values.rad2)) do
    local re, im  = z:real(), z:imag()
    local s = #values.rad2
    assertAlmostEquals( (-re - im*1i):sqrt():real() - ref[i]  :real(), 0, 2*eps )
    assertAlmostEquals( (-re - im*1i):sqrt():imag() - ref[i]  :imag(), 0, 2*eps )
    assertAlmostEquals( (-re + im*1i):sqrt():real() - ref[i+s]:real(), 0, 2*eps )
    assertAlmostEquals( (-re + im*1i):sqrt():imag() - ref[i+s]:imag(), 0, 2*eps )
  end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( 0, 0):sqrt(), complex( 0, 0 ) )
  for _,x in ipairs(values.rad) do
    assertNaN   ( complex( x  , nan):sqrt().re      )
    assertNaN   ( complex( x  , nan):sqrt().im      )
    assertNaN   ( complex( nan, x  ):sqrt().re      )
    assertNaN   ( complex( nan, x  ):sqrt().im      )
    assertEquals( complex( x  , inf):sqrt(), complex( inf, inf) )
    assertEquals( complex(-inf, x  ):sqrt(), complex( 0  , inf) )
    assertEquals( complex( inf, x  ):sqrt(), complex( inf, 0  ) )
  end
  assertNaN   ( complex(-inf, nan):sqrt().re      )
  assertEquals( complex(-inf, nan):sqrt().im,-inf )
  assertEquals( complex( inf, nan):sqrt().re, inf )
  assertNaN   ( complex( inf, nan):sqrt().im      )
  assertNaN   ( complex( nan, nan):sqrt().re      )
  assertNaN   ( complex( nan, nan):sqrt().im      )
end

function TestComplex:testExp()
  assertEquals      ( complex( 0, 2*pi):exp():real(), 1        )
  assertAlmostEquals( complex( 0, 2*pi):exp():imag(), 0, 2*eps )
  for _,y in ipairs(values.rad) do
    local z = complex(0,y)
    assertEquals( (sin(y) - (z:exp() - (-z):exp()) / 2i), 0 + 0i )
    assertEquals( (cos(y) - (z:exp() + (-z):exp()) / 2 ), 0 + 0i )
  end
  for _,y in ipairs(values.num) do
    local z = complex(0,y)
    assertEquals( (sin(y) - (z:exp() - (-z):exp()) / 2i), 0 + 0i )
    assertEquals( (cos(y) - (z:exp() + (-z):exp()) / 2 ), 0 + 0i )
  end
  for i,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    assertEquals( z      ,           complex( 0      , values.rad[i]):exp() )
    assertEquals( z:exp(), exp(re) * complex( cos(im),       sin(im))       )
  for i,z1 in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (z + z1):exp():real() - (z:exp()*z1:exp()):real(), 0, 12*eps )
    assertAlmostEquals( (z + z1):exp():imag() - (z:exp()*z1:exp()):imag(), 0,  8*eps )
  end end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( 0, 0):exp(), complex( 1, 0) )
  for _,x in ipairs(values.rad) do
    local x = x/pi
    assertNaN( complex( x, inf):exp():real() )
    assertNaN( complex( x, inf):exp():imag() )
    assertNaN( complex( x, nan):exp():real() )
    assertNaN( complex( x, nan):exp():imag() )
    if x > 0 then
      assertNaN   ( complex( nan, x):exp():real() )
      assertNaN   ( complex( nan, x):exp():imag() )
      assertEquals( complex(-inf, x):exp(), complex( 0  , 0  ) )
      assertEquals( complex( inf, x):exp(), complex( inf, inf) )
    end
  end
  assertEquals( complex( inf, 0  ):exp()       , complex( inf, 0) )
  assertEquals( complex(-inf, inf):exp()       , complex( 0  , 0) )
  assertEquals( complex( inf, inf):exp():real(), inf              )
  assertNaN   ( complex( inf, inf):exp():imag()                   )
  assertEquals( complex(-inf, nan):exp()       , complex( 0  , 0) )
  assertEquals( complex( inf, nan):exp():real(), inf              )
  assertNaN   ( complex( inf, nan):exp():imag()                   )
  assertNaN   ( complex( nan, 0  ):exp():real()                   )
  assertEquals( complex( nan, 0  ):exp():imag(), 0                )
  assertNaN   ( complex( nan, nan):exp():real()                   )
  assertNaN   ( complex( nan, nan):exp():imag()                   )
end

function TestComplex:testLog()
  assertEquals( (  1  + 0i):log(),  0                 + 0i      )
  assertEquals( (- 1  + 0i):log(),  0                 + pi  *1i )
  assertEquals( (  0  + 1i):log(),  0                 + pi/2*1i )
  assertEquals( (  0  - 1i):log(),  0                 - pi/2*1i )
  assertEquals( (- 0  + 1i):log(),  0                 + pi/2*1i )
  assertEquals( (  0  + 1i):log(),  0                 + pi/2*1i )
  assertEquals( (-eps + 0i):log(), -36.04365338911715 + pi  *1i )
  assertEquals( ( eps + 0i):log(), -36.04365338911715 + 0i      )

  assertAlmostEquals( complex( 0,  pi      ):log():real() -  1.1447298858494002, 0, eps )
  assertAlmostEquals( complex( 0,- pi      ):log():real() -  1.1447298858494002, 0, eps )
  assertAlmostEquals( complex( 0,  pi + 1  ):log():real() -  1.4210804127942926, 0, eps )
  assertAlmostEquals( complex( 0,-(pi + 1) ):log():real() -  1.4210804127942926, 0, eps )
  assertAlmostEquals( complex(-0,  pi      ):log():real() -  1.1447298858494002, 0, eps )
  assertAlmostEquals( complex(-0,- pi      ):log():real() -  1.1447298858494002, 0, eps )
  assertAlmostEquals( complex(-0,  pi + 1  ):log():real() -  1.4210804127942926, 0, eps )
  assertAlmostEquals( complex(-0,-(pi + 1) ):log():real() -  1.4210804127942926, 0, eps )

  assertAlmostEquals( complex( 0,  pi      ):log():imag() -  1.5707963267948966, 0, eps )
  assertAlmostEquals( complex( 0,- pi      ):log():imag() - -1.5707963267948966, 0, eps )
  assertAlmostEquals( complex( 0,  pi + 1  ):log():imag() -  1.5707963267948966, 0, eps )
  assertAlmostEquals( complex( 0,-(pi + 1) ):log():imag() - -1.5707963267948966, 0, eps )
  assertAlmostEquals( complex(-0,  pi      ):log():imag() -  1.5707963267948966, 0, eps )
  assertAlmostEquals( complex(-0,- pi      ):log():imag() - -1.5707963267948966, 0, eps )
  assertAlmostEquals( complex(-0,  pi + 1  ):log():imag() -  1.5707963267948966, 0, eps )
  assertAlmostEquals( complex(-0,-(pi + 1) ):log():imag() - -1.5707963267948966, 0, eps )

  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    assertAlmostEquals( (z:exp():log()):real() - re, 0, eps )
    assertAlmostEquals( (z:exp():log()):imag() - im, 0, eps )
    assertAlmostEquals( (z:log():exp()):real() - re, 0, eps )
    assertAlmostEquals( (z:log():exp()):imag() - im, 0, eps )

    assertAlmostEquals( (1/z):log():real() - -(z:log()):real()      , 0,   eps )
    assertEquals      ( (1/z):log():imag(),  -(z:log()):imag()                 )
    assertEquals      ( z    :log():real(),  (-z):log():real()                 )
    assertAlmostEquals( abs(z:log():imag() - (-z):log():imag()) - pi, 0, 2*eps )
  end
  for _,z in ipairs(unitCircle( pi, values.rad)) do
    local re, im = z:real(), z:imag()
    assertAlmostEquals( (z:exp():log()):real() - re, 0, 2*eps )
    assertAlmostEquals( (z:exp():log()):imag() - im, 0,   eps )
    assertAlmostEquals( (z:log():exp()):real() - re, 0, 4*eps )
    assertAlmostEquals( (z:log():exp()):imag() - im, 0, 2*eps )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    local re, im = z:real(), z:imag()
    if x < pi then
      assertAlmostEquals( (z:exp():log()):real() - re, 0,   eps )
      assertAlmostEquals( (z:exp():log()):imag() - im, 0,   eps )
      assertAlmostEquals( (z:log():exp()):real() - re, 0, 2*eps )
      assertAlmostEquals( (z:log():exp()):imag() - im, 0, 2*eps )
    end
  end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( complex(-0, 0):log(), complex(-inf, pi) ) --expected: -inf+pi*1i  jit: -inf (JIT) [BUG]
  assertEquals( complex( 0, 0):log(), complex(-inf, 0 ) )
  for _,x in ipairs(values.rad) do
    assertEquals( complex( x  , inf):log(), complex( inf, pi/2) )
    assertNaN   ( complex( x  , nan):log():real()               )
    assertNaN   ( complex( x  , nan):log():imag()               )
    assertEquals( complex(-inf, x  ):log(), complex( inf, pi  ) )
    assertEquals( complex( inf, x  ):log(), complex( inf, 0   ) )
    assertNaN   ( complex( nan, x  ):log():real()               )
    assertNaN   ( complex( nan, x  ):log():imag()               )
  end
  assertEquals( complex(-inf, inf):log()       , complex( inf, 3*pi/4) )
  assertEquals( complex( inf, inf):log()       , complex( inf,   pi/4) )
  assertEquals( complex( inf, nan):log():real(), inf                   )
  assertNaN   ( complex( inf, nan):log():imag()                        )
  assertEquals( complex( nan, inf):log():real(), inf                   )
  assertNaN   ( complex( nan, inf):log():imag()                        )
  assertNaN   ( complex( nan, nan):log():real()                        )
  assertNaN   ( complex( nan, nan):log():imag()                        )
end

function TestComplex:testLog10()
  assertEquals      ( complex( 1  , 0):log10()       ,   complex( 0, 0)                )
  assertEquals      ( complex(-1  , 0):log10():real(),   0                             )
  assertEquals      ( complex( 0  ,-1):log10():real(),   0                             )
  assertEquals      ( complex( 0  , 1):log10():real(),   0                             )
  assertEquals      ( complex(-0  , 1):log10():real(),   0                             )
  assertAlmostEquals( complex(-eps, 0):log10():real() - -15.65355977452702  , 0, 8*eps )
  assertAlmostEquals( complex( eps, 0):log10():real() - -15.65355977452702  , 0, 8*eps )

  assertAlmostEquals( complex(-1  , 0):log10():imag() -  1.364376353841841  , 0,   eps )
  assertEquals      ( complex( 0  ,-1):log10():imag(),  -0.6821881769209206            )
  assertEquals      ( complex( 0  , 1):log10():imag(),   0.6821881769209206            )
  assertEquals      ( complex(-0  , 1):log10():imag(),   0.6821881769209206            )
  assertAlmostEquals( complex(-eps, 0):log10():imag() -  1.364376353841841  , 0,   eps )
  assertEquals      ( complex( eps, 0):log10():imag(),   0                             )
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (z:log10() - z:log()/log(10)):real(), 0, eps )
    assertAlmostEquals( (z:log10() - z:log()/log(10)):imag(), 0, eps )
  end
end

function TestComplex:testSin()
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    local c = complex( sin(re)*cosh(im), cos(re)*sinh(im) )
    assertAlmostEquals( sin( z):real() - c:real(), 0, eps )
    assertAlmostEquals( sin( z):imag() - c:imag(), 0, eps )

    c = complex( sin(-re)*cosh(-im), cos(-re)*sinh(-im) )
    assertAlmostEquals( sin(-z):real() - c:real(), 0, eps )
    assertAlmostEquals( sin(-z):imag() - c:imag(), 0, eps )
    assertAlmostEquals( sin(z+2*pi):real() - sin(z):real(), 0, 3*eps)
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    local re, im = z:real(), z:imag()
    if x< 10 then
      assertAlmostEquals( (sin( z) - complex( sin( re)*cosh( im), cos( re)*sinh( im))):real(), 0, 2*eps )
      assertAlmostEquals( (sin( z) - complex( sin( re)*cosh( im), cos( re)*sinh( im))):imag(), 0, 2*eps )
      assertAlmostEquals( (sin(-z) - complex( sin(-re)*cosh(-im), cos(-re)*sinh(-im))):real(), 0, 2*eps )
      assertAlmostEquals( (sin(-z) - complex( sin(-re)*cosh(-im), cos(-re)*sinh(-im))):imag(), 0, 2*eps )
    end
  end

  assertEquals( complex( 0   , 0   ):sin(), complex( 0   , 0   ) )
  assertEquals( complex( tiny, tiny):sin(), complex( tiny, tiny) )
  assertEquals( complex( huge, huge):sin(), complex( inf ,-inf ) )
  assertEquals( complex(-huge,-huge):sin(), complex(-inf , inf ) )
  assertNaN   ( complex(-inf ,-inf ):sin():real() )
  assertNaN   ( complex( inf , inf ):sin():real() )
  assertInf   ( complex( inf , inf ):sin():imag() )
  assertNaN   ( complex( nan , nan ):sin():real() )
  assertNaN   ( complex( nan , nan ):sin():imag() )
end

function TestComplex:testCos()
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    local c = complex( cos( re)*cosh( im),-sin( re)*sinh( im) )
    assertAlmostEquals( cos( z)    :real() - c     :real(), 0,   eps )
    assertAlmostEquals( cos( z)    :imag() - c     :imag(), 0,   eps )
    c = complex( cos(-re)*cosh(-im),-sin(-re)*sinh(-im) )
    assertAlmostEquals( cos(-z)    :real() - c     :real(), 0,   eps )
    assertAlmostEquals( cos(-z)    :imag() - c     :imag(), 0,   eps )
    assertAlmostEquals( cos(z+2*pi):real() - cos(z):real(), 0, 3*eps )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    local re, im = z:real(), z:imag()
    if x< 10 then
      assertAlmostEquals( (cos( z) - complex( cos( re)*cosh( im),-sin( re)*sinh( im)) ):real(), 0,   eps )
      assertAlmostEquals( (cos( z) - complex( cos( re)*cosh( im),-sin( re)*sinh( im)) ):imag(), 0, 2*eps )
      assertAlmostEquals( (cos(-z) - complex( cos(-re)*cosh(-im),-sin(-re)*sinh(-im)) ):real(), 0,   eps )
      assertAlmostEquals( (cos(-z) - complex( cos(-re)*cosh(-im),-sin(-re)*sinh(-im)) ):imag(), 0, 2*eps )
    end
  end
  assertEquals( complex( 0   , 0   ):cos(), complex( 1  , 0  ) )
  assertEquals( complex( tiny, tiny):cos(), complex( 1  , 0  ) )
  assertEquals( complex( huge, huge):cos(), complex(-inf,-inf) )
  assertEquals( complex(-huge,-huge):cos(), complex(-inf,-inf) )
  assertNaN   ( complex(-inf ,-inf ):cos():imag() )
  assertNaN   ( complex( inf , inf ):cos():imag() )
  assertInf   ( complex( inf , inf ):cos():real() )
  assertNaN   ( complex( nan , nan ):cos():imag() )
  assertNaN   ( complex( nan , nan ):cos():real() )
end

function TestComplex:testTan()
  for _,x in ipairs(values.rad) do
    for _,y in ipairs(values.rad) do

      local x, y = x/pi, y/pi
      local z = complex(x,y)
      assertAlmostEquals( (z:tan() - z:sin() / z:cos() ):real(), 0, 3*eps )
      assertAlmostEquals( (z:tan() - z:sin() / z:cos() ):imag(), 0, 4*eps )
    end
  end
  for _,z in ipairs(unitCircle( 1, values.rad)) do
      assertAlmostEquals( (z:tan() - z:sin() / z:cos() ):real(), 0,   eps )
      assertAlmostEquals( (z:tan() - z:sin() / z:cos() ):imag(), 0,   eps )
  end
  for _,x in ipairs( values.num ) do
    local z = complex( x, x)
    if x < 10e2 then
      assertAlmostEquals( (z:tan() - z:sin() / z:cos() ):real(), 0,   eps )
      assertAlmostEquals( (z:tan() - z:sin() / z:cos() ):imag(), 0, 2*eps )
    end
  end

  assertEquals( complex( 0   , 0   ):tan(), complex( 0   , 0   ) )
  assertEquals( complex( tiny, tiny):tan(), complex( tiny, tiny) )
  assertEquals( complex( huge, huge):tan(), complex( 0   , 1   ) )
  assertEquals( complex(-huge,-huge):tan(), complex( 0   ,-1   ) )
  assertEquals( complex(-inf ,-inf ):tan(), complex( 0   ,-1   ) )
  assertEquals( complex( inf , inf ):tan(), complex( 0   , 1   ) )
  assertNaN   ( complex( nan , nan ):tan():real() )
  assertNaN   ( complex( nan , nan ):tan():imag() )
end

function TestComplex:testSinh()
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    local x = complex( sinh( re)*cos( im),cosh( re)*sin( im) )
    assertAlmostEquals( (sinh( z)        - (exp( z)-exp(-z))/2):real(), 0, eps )
    assertAlmostEquals( (sinh(-z)        - (exp(-z)-exp( z))/2):imag(), 0, eps )
    assertAlmostEquals(  sinh( z):real() - x:real()                   , 0, eps )
    assertAlmostEquals(  sinh( z):imag() - x:imag()                   , 0, eps )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    local re, im = z:real(), z:imag()
    if x< 10 then
      assertAlmostEquals( (sinh( z) - (exp( z)-exp(-z))/2)                             :real(), 0, 2*eps )
      assertAlmostEquals( (sinh(-z) - (exp(-z)-exp( z))/2)                             :imag(), 0, 2*eps )
      assertAlmostEquals( (sinh( z) - complex( sinh( re)*cos( im),cosh( re)*sin( im) )):real(), 0,   eps )
      assertAlmostEquals( (sinh( z) - complex( sinh( re)*cos( im),cosh( re)*sin( im) )):imag(), 0, 2*eps )
    end
  end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( 0, 0   ):sinh()       , complex( 0, 0) )
  assertEquals( complex( 0, inf ):sinh():real(), 0              )
  assertNaN   ( complex( 0, inf ):sinh():imag()                 )
  assertEquals( complex( 0, nan ):sinh():real(), 0              )
  assertNaN   ( complex( 0, nan ):sinh():imag()                 )
  for _,x in ipairs(values.rad) do
    local x = x/pi
    if x > 0 then
      assertNaN   ( complex( x  , inf ):sinh():real()              )
      assertNaN   ( complex( x  , inf ):sinh():imag()              )
      assertNaN   ( complex( x  , nan ):sinh():real()              )
      assertNaN   ( complex( x  , nan ):sinh():imag()              )
      assertNaN   ( complex( nan, x   ):sinh():real()              )
      assertNaN   ( complex( nan, x   ):sinh():imag()              )
      assertEquals( complex( inf, x   ):sinh(), complex( inf, inf) )
    end
  end
  assertEquals( complex( inf, 0  ):sinh()       , complex( inf, 0) )
  assertEquals( complex( inf, inf):sinh():real(), inf              )
  assertNaN   ( complex( inf, inf):sinh():imag()                   )
  assertEquals( complex( inf, nan):sinh():real(), inf              )
  assertNaN   ( complex( inf, nan):sinh():imag()                   )
  assertNaN   ( complex( nan, 0  ):sinh():real()                   )
  assertEquals( complex( nan, 0  ):sinh():imag(), 0                )
  assertNaN   ( complex( nan, nan):sinh():real()                   )
  assertNaN   ( complex( nan, nan):sinh():imag()                   )

  for _,x in ipairs(values.rad) do
    local x = x/pi
    assertAlmostEquals( (complex(0,x):sin()  - 1i * sinh(x)):real(), 0, eps )
    assertAlmostEquals( (complex(0,x):sin()  - 1i * sinh(x)):imag(), 0, eps )
    assertAlmostEquals( (complex(0,x):sinh() - 1i * sin (x)):real(), 0, eps )
    assertAlmostEquals( (complex(0,x):sinh() - 1i * sin (x)):imag(), 0, eps )
    for _,y in ipairs(values.rad) do
      local y = y/pi
      assertEquals( complex(x,y):sin(), -1i * (1i * complex(x,y)):sinh() )
    end
  end
end

function TestComplex:testCosh()
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (cosh( z)            - (exp( z)+exp(-z))/2)               :real(), 0,   eps )
    assertAlmostEquals( (cosh(-z)            - (exp(-z)+exp( z))/2)               :imag(), 0,   eps )
  for _,z1 in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (z+z1):cosh():real() - (cosh(z)*cosh(z1)+sinh(z)*sinh(z1)):real(), 0, 6*eps )
    assertAlmostEquals( (z+z1):cosh():imag() - (cosh(z)*cosh(z1)+sinh(z)*sinh(z1)):imag(), 0, 4*eps )
  end end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    if x < 10e2 then
      assertAlmostEquals( (cosh( z) - (exp( z)+exp(-z))/2):real(), 0, 2*eps )
      assertAlmostEquals( (cosh(-z) - (exp(-z)+exp( z))/2):imag(), 0, 2*eps )
    else
      assertNaN( (cosh( z) - (exp( z)+exp(-z))/2):real())
      assertNaN( (cosh(-z) - (exp(-z)+exp( z))/2):imag())
    end
  end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( 0, 0   ):cosh(), complex( 1, 0) )
  assertNaN   ( complex( 0, inf ):cosh():real()    )
  assertEquals( complex( 0, inf ):cosh():imag(), 0 )
  assertNaN   ( complex( 0, nan ):cosh():real()    )
  assertEquals( complex( 0, nan ):cosh():imag(), 0 )

  for _,x in ipairs(values.rad) do
    local x = x/pi
    if x > 0 then
      assertNaN   ( complex( x  , inf ):cosh():real() )
      assertNaN   ( complex( x  , inf ):cosh():imag() )
      assertNaN   ( complex( x  , nan ):cosh():real() )
      assertNaN   ( complex( x  , nan ):cosh():imag() )
      assertNaN   ( complex( nan, x   ):cosh():real() )
      assertNaN   ( complex( nan, x   ):cosh():imag() )
      assertEquals( complex( inf, x   ):cosh(), complex( inf, inf) )
    end
  end
  assertEquals( complex( inf, 0   ):cosh(), complex( inf, 0) )
  assertEquals( complex( inf, inf ):cosh():real(), inf )
  assertNaN   ( complex( inf, inf ):cosh():imag()      )
  assertEquals( complex( inf, nan ):cosh():real(), inf )
  assertNaN   ( complex( inf, nan ):cosh():imag()      )
  assertNaN   ( complex( nan, 0   ):cosh():real()      )
  assertEquals( complex( nan, 0   ):cosh():imag(), 0   )
  assertNaN   ( complex( nan, nan ):cosh():real()      )
  assertNaN   ( complex( nan, nan ):cosh():imag()      )

  for _,x in ipairs(values.rad) do
    local x = x/pi
    assertAlmostEquals( (complex(0,x):cos()  - cosh(x)):real(), 0, eps  )
    assertAlmostEquals( (complex(0,x):cos()  - cosh(x)):imag(), 0, eps  )
    assertEquals      ( (complex(0,x):cosh() - cos (x))       , complex(0,0) )
    for _,y in ipairs(values.rad) do
      local y = y/pi
      assertEquals( complex(x,y):cos(), (1i * complex(x,y)):cosh() )
    end
  end
end

function TestComplex:testTanh()
  for _,x in ipairs(values.rad2) do
    for _,y in ipairs(values.rad3) do
      local x = x/pi, y/pi
      local z = complex(x,y)
      assertAlmostEquals( (z:tanh() - z:sinh() / z:cosh() ):real(), 0, 4*eps ) -- mac err: 7.62939453125e-06  [TOCHECK]
      assertAlmostEquals( (z:tanh() - z:sinh() / z:cosh() ):imag(), 0, 4*eps ) -- expected: 0, mac: -2        [TOCHECK]
    end
  end
  for _,z in ipairs(unitCircle( 1, values.rad)) do
      assertAlmostEquals( (z:tanh() - z:sinh() / z:cosh() ):real(), 0, 2*eps )
      assertAlmostEquals( (z:tanh() - z:sinh() / z:cosh() ):imag(), 0,   eps )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    if x < 10e2 then
      assertAlmostEquals( (z:tanh() - z:sinh() / z:cosh() ):real(), 0, 2*eps )
      assertAlmostEquals( (z:tanh() - z:sinh() / z:cosh() ):imag(), 0, 4*eps )
    else
      assertNaN( (z:tanh() - z:sinh() / z:cosh() ):real() )
      assertNaN( (z:tanh() - z:sinh() / z:cosh() ):imag() )
    end
  end

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( 0, 0  ):tanh(), complex( 0, 0) )
  for _,x in ipairs(values.rad) do
    assertNaN( complex( x, inf ):tanh():real() )
    assertNaN( complex( x, inf ):tanh():imag() )
    assertNaN( complex( x, nan ):tanh():real() )
    assertNaN( complex( x, nan ):tanh():imag() )
    if x > 0 then
      assertNaN   ( complex( nan, x ):tanh():real() )
      assertNaN   ( complex( nan, x ):tanh():imag() )
      assertEquals( complex( inf, x ):tanh(), complex( 1, 0) )
    end
  end
  assertEquals( complex( inf, inf):tanh(), complex( 1, 0) )
  assertEquals( complex( inf, nan):tanh(), complex( 1, 0) )
  assertNaN   ( complex( nan, 0  ):tanh():real()      )
  assertEquals( complex( nan, 0  ):tanh():imag(), 0   )
  assertNaN   ( complex( nan, nan):tanh():real()      )
  assertNaN   ( complex( nan, nan):tanh():imag()      )

  for _,x in ipairs(values.rad) do
    local x = x/pi
    assertAlmostEquals( (complex(0,x):tan()  - 1i * tanh(x)):real(), 0,   eps )
    assertAlmostEquals( (complex(0,x):tan()  - 1i * tanh(x)):imag(), 0, 2*eps )
    assertAlmostEquals( (complex(0,x):tanh() - 1i * tan (x)):real(), 0,   eps )
    assertAlmostEquals( (complex(0,x):tanh() - 1i * tan (x)):imag(), 0, 2*eps )
    for _,y in ipairs(values.rad) do
      local y = y/pi
      assertEquals( complex(x,y):tan(), -1i * (1i * complex(x,y)):tanh() )
    end
  end
end

function TestComplex:testAsin()
  assertNaN   ( complex( nan, nan ):asin():real()             )
  assertNaN   ( complex( nan, nan ):asin():imag()             )
  assertEquals( complex( 0  , 0   ):asin(), complex( 0   , 0) )
  assertEquals( complex( 1  , 0   ):asin(), complex( pi/2, 0) )
  assertEquals( complex(-1  , 0   ):asin(), complex(-pi/2, 0) )
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (z:asin():sin() - z):real(), 0, eps )
    assertAlmostEquals( (z:asin():sin() - z):imag(), 0, eps )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    if x < pi/2 then
      assertAlmostEquals( (z:asin():sin() - z):real(), 0,     eps )
      assertAlmostEquals( (z:asin():sin() - z):imag(), 0,   2*eps )
    elseif x < 10 then
      assertAlmostEquals( (z:asin():sin() - z):real(), 0,   2*eps )
      assertAlmostEquals( (z:asin():sin() - z):imag(), 0,   2*eps )
    elseif x == 10  then
      assertAlmostEquals( (z:asin():sin() - z):real(), 0,  16*eps )
      assertAlmostEquals( (z:asin():sin() - z):imag(), 0,  16*eps )
    elseif x == 100 then
      assertAlmostEquals( (z:asin():sin() - z):real(), 0, 128*eps )
      assertAlmostEquals( (z:asin():sin() - z):imag(), 0, 128*eps )
    end
  end

  assertAlmostEquals( complex(  1        , 0):asin():real() -  1.5707963267948966  , 0, eps )
  assertAlmostEquals( complex(  1        , 0):asin():imag() -  0                   , 0, eps )
  assertAlmostEquals( complex(- 1        , 0):asin():real() - -1.5707963267948966  , 0, eps )
  assertAlmostEquals( complex(- 1        , 0):asin():imag() -  0                   , 0, eps )
  assertAlmostEquals( complex(  1+eps    , 0):asin():real() -  1.5707963267948966  , 0, eps )
  assertAlmostEquals( complex(  1+eps    , 0):asin():imag() -  2.10734242278576e-08, 0, eps )
  assertAlmostEquals( complex(-(1+eps)   , 0):asin():real() - -1.5707963267948966  , 0, eps )
  assertAlmostEquals( complex(-(1+eps)   , 0):asin():imag() -  2.10734242278576e-08, 0, eps )

  assertAlmostEquals( complex(  pi/2     , 0):asin():real() -  1.5707963267948966, 0,   eps )
  assertAlmostEquals( complex(- pi/2     , 0):asin():real() - -1.5707963267948966, 0,   eps )
  assertAlmostEquals( complex(  pi/2+eps , 0):asin():real() -  1.5707963267948966, 0,   eps )
  assertAlmostEquals( complex(-(pi/2+eps), 0):asin():real() - -1.5707963267948966, 0,   eps )
  assertAlmostEquals( complex(  pi/2     , 0):asin():imag() -  1.02322747854755  , 0, 3*eps )
  assertAlmostEquals( complex(- pi/2     , 0):asin():imag() -  1.02322747854755  , 0, 3*eps )
  assertAlmostEquals( complex(  pi/2+eps , 0):asin():imag() -  1.02322747854755  , 0, 3*eps )
  assertAlmostEquals( complex(-(pi/2+eps), 0):asin():imag() -  1.02322747854755  , 0, 3*eps )
end

function TestComplex:testAcos()
  assertEquals( ( 1 + 0i ):acos(), 0  + 0i )
  assertEquals( (-1 + 0i ):acos(), pi + 0i )
  for _,z in ipairs(unitCircle( 1, values.rad)) do
      assertAlmostEquals( (z:acos():cos() - z):real(), 0, 2*eps )
      assertAlmostEquals( (z:acos():cos() - z):imag(), 0,   eps )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    if x < 10 then
      assertAlmostEquals( (z:acos():cos() - z):real(), 0, 2*eps )
      assertAlmostEquals( (z:acos():cos() - z):imag(), 0, 2*eps )
    end
  end
  assertEquals      ( (  1      + 0i ):acos():real() ,  0                            )
  assertEquals      ( (  1      + 0i ):acos():imag() ,  0                            )
  assertEquals      ( (- 1      + 0i ):acos():real() ,  pi                           )
  assertEquals      ( (- 1      + 0i ):acos():imag() ,  0                            )
  assertEquals      ( (  1+eps  + 0i ):acos():real() ,  0                            )
  assertAlmostEquals( (  1+eps  + 0i ):acos():imag() - -2.10734243388799e-08, 0, eps )
  assertAlmostEquals( (-(1+eps) + 0i ):acos():real() -  pi                  , 0, eps )
  assertAlmostEquals( (-(1+eps) + 0i ):acos():imag() - -2.10734243388799e-08, 0, eps )
  assertAlmostEquals( (-(0+eps) + 0i ):acos():real() -  1.5707963267948966  , 0, eps )
  assertAlmostEquals( (-(0+eps) + 0i ):acos():imag() - -2.46519032881566e-32, 0, eps )
  assertEquals      ( (  pi     + 0i ):acos():real() ,  0                            )
  assertEquals      ( (  pi+eps + 0i ):acos():real() ,  0                            )
  assertAlmostEquals( (- 0      + 0i ):acos():real() -  1.5707963267948966  , 0, eps )
  assertAlmostEquals( (  0      + 0i ):acos():real() -  1.5707963267948966  , 0, eps )
  assertAlmostEquals( (  pi     + 0i ):acos():imag() - -1.8115262724608531  , 0, eps )
  assertAlmostEquals( (  pi+eps + 0i ):acos():imag() - -1.8115262724608531  , 0, eps )
  assertEquals      ( (- 0      + 0i ):acos():imag() ,  0                            )
  assertEquals      ( (  0      + 0i ):acos():imag() ,  0                            )

-- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( 0  , 0   ):acos()       , complex( pi/2, 0  ) )
  assertEquals( complex(-0  , 0   ):acos()       , complex( pi/2, 0  ) )
  assertEquals( complex( 0  ,-0   ):acos()       , complex( pi/2, 0  ) )
  assertEquals( complex(-0  ,-0   ):acos()       , complex( pi/2, 0  ) )
  assertEquals( complex( 0  , nan ):acos():real(), pi/2                )
  assertNaN   ( complex( 0  , nan ):acos():imag()                      )
  assertEquals( complex(-0  , nan ):acos():real(), pi/2                )
  assertNaN   ( complex(-0  , nan ):acos():imag()                      )
  assertEquals( complex( inf, inf ):acos()       , complex( pi/4,-inf) )
  for _,x in ipairs(values.rad) do
      assertEquals( complex( x, inf  ):acos(), complex( pi/2,-inf) )
    if x > 0 then
      assertNaN   ( complex( x  , nan):acos():imag()               )
      assertNaN   ( complex( x  , nan):acos():real()               )
      assertNaN   ( complex( nan, x  ):acos():imag()               )
      assertNaN   ( complex( nan, x  ):acos():real()               )
      assertEquals( complex(-inf, x  ):acos(), complex( pi  ,-inf) )
      assertEquals( complex( inf, x  ):acos(), complex( 0   ,-inf) )
    end
  end
  assertEquals( complex(-inf, inf):acos()       , complex( 3*pi/4,-inf) )
  assertEquals( complex( inf, inf):acos()       , complex(   pi/4,-inf) )
  assertNaN   ( complex( inf, nan):acos():real()                        )
  assertEquals( complex( inf, nan):acos():imag(), inf                   )
  assertNaN   ( complex(-inf, nan):acos():real()                        )
  assertEquals( complex(-inf, nan):acos():imag(), inf                   )
  assertNaN   ( complex( nan, inf):acos():real()                        )
  assertEquals( complex( nan, inf):acos():imag(),-inf                   )
  assertNaN   ( complex( nan, nan):acos():real()                        )
  assertNaN   ( complex( nan, nan):acos():imag()                        )
end

function TestComplex:testAtan()
  assertNaN   ( complex( nan, nan):atan():real()             )
  assertNaN   ( complex( nan, nan):atan():imag()             )
  assertEquals( complex( 0  , 0  ):atan(), complex( 0   , 0) )
  assertEquals( complex(-inf, 0  ):atan(), complex(-pi/2, 0) )
  assertEquals( complex( inf, 0  ):atan(), complex( pi/2, 0) )

  for _,z in ipairs(unitCircle( pi/2, values.rad)) do
    local res = 1/2*1i*((1-1i*z):log()-(1+1i*z):log())
    assertAlmostEquals( (z:atan():tan() - z           ):real(), 0, 2*eps )
    assertAlmostEquals( (z:atan():tan() - z           ):imag(), 0, 2*eps )
    assertAlmostEquals( (z:atan()       - -(-z:atan())):real(), 0,   eps )
    assertAlmostEquals( (z:atan()       - -(-z:atan())):imag(), 0,   eps )
    assertAlmostEquals( (z:atan()       - res         ):real(), 0,   eps )
    assertAlmostEquals( (z:atan()       - res         ):imag(), 0,   eps )
  end

  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    if x < pi/2 then
      local res = 1/2*1i*((1-1i*z):log()-(1+1i*z):log())
      assertAlmostEquals( (z:atan():tan() - z           ):real(), 0,   eps )
      assertAlmostEquals( (z:atan():tan() - z           ):imag(), 0, 2*eps )
      assertAlmostEquals( (z:atan()       - -(-z:atan())):real(), 0,   eps )
      assertAlmostEquals( (z:atan()       - -(-z:atan())):imag(), 0,   eps )
      assertAlmostEquals( (z:atan()       - res         ):real(), 0,   eps )
      assertAlmostEquals( (z:atan()       - res         ):imag(), 0,   eps )
    elseif x < 10 then
      assertAlmostEquals( (z:atan():tan() - z):real()           , 0, 8*eps )
      assertAlmostEquals( (z:atan():tan() - z):imag()           , 0, 8*eps )
    end
  end

  if jit.os == "OSX" then
    assertEquals( (0 + 1i):atan(), complex( pi/4, inf) ) --expected: 0 + inf*1i mac: pi/4 + infi [BUG] (mathmatica)
    assertEquals( (0 - 1i):atan(), complex( pi/4,-inf) ) --expected: 0 +-inf*1i mac: pi/4 - infi [BUG] (mathmatica)
  else
    assertEquals( (0 + 1i):atan(), complex( 0   , inf) )
    assertEquals( (0 - 1i):atan(), complex( 0   ,-inf) )
  end
  assertAlmostEquals( (  pi/2 + 0i ):atan():real() -  1.00388482185389    , 0,  13*eps )
  assertAlmostEquals( (- pi/2 + 0i ):atan():real() - -1.00388482185389    , 0,  13*eps )
  assertAlmostEquals( (  pi/2 + 0i ):atan():imag() - -1.25193300684524e-17, 0,     eps )
  assertAlmostEquals( (- pi/2 + 0i ):atan():imag() - -1.25193300684524e-17, 0,     eps )
end

function TestComplex:testAsinh()
  assertAlmostEquals( ( 0 + 1i       ):asinh():real() -  0                   , 0,    eps )
  assertAlmostEquals( ( 0 - 1i       ):asinh():real() -  0                   , 0,    eps )
  assertAlmostEquals( ( 0 +(1+eps)*1i):asinh():real() -  2.10734243388799e-08, 0,    eps )
  assertAlmostEquals( ( 0 -(1+eps)*1i):asinh():real() -  2.10734243388799e-08, 0,    eps )
  assertAlmostEquals( ( 0 - 2i       ):asinh():real() -  1.31695789692482    , 0, 16*eps )
  assertAlmostEquals( ( 0 + 2i       ):asinh():real() -  1.31695789692482    , 0, 16*eps )
  assertAlmostEquals( ( 0 + 1i       ):asinh():imag() -  1.5707963267948966  , 0,    eps )
  assertAlmostEquals( ( 0 - 1i       ):asinh():imag() - -1.5707963267948966  , 0,    eps )
  assertAlmostEquals( ( 0 +(1+eps)*1i):asinh():imag() -  1.5707963267948966  , 0,    eps )
  assertAlmostEquals( ( 0 -(1+eps)*1i):asinh():imag() - -1.5707963267948966  , 0,    eps )
  assertAlmostEquals( ( 0 + 2i       ):asinh():imag() -  1.5707963267948966  , 0,    eps )
  assertAlmostEquals( ( 0 - 2i       ):asinh():imag() - -1.5707963267948966  , 0,    eps )

  for _,z in ipairs(unitCircle( pi/2, values.rad)) do
      assertAlmostEquals( (z:asinh():sinh() - z):real(), 0, 2*eps )
      assertAlmostEquals( (z:asinh():sinh() - z):imag(), 0,   eps )
  end
  for _,z in ipairs(unitCircle( pi, values.rad)) do
      assertAlmostEquals( (z:asinh():sinh() - z):real(), 0, 2*eps )
      assertAlmostEquals( (z:asinh():sinh() - z):imag(), 0, 2*eps )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    if x < pi/2 then
      assertAlmostEquals( (z:asinh():sinh() - z):real(), 0, 2*eps )
      assertAlmostEquals( (z:asinh():sinh() - z):imag(), 0,   eps )
    elseif x < 10 then
      assertAlmostEquals( (z:asinh():sinh() - z):real(), 0, 2*eps )
      assertAlmostEquals( (z:asinh():sinh() - z):imag(), 0, 2*eps )
    end
  end

  -- Check for IEEE:IEC 60559 compliance
  for _,x in ipairs(values.rad) do
    assertEquals( complex( x  , inf ):asinh(), complex( inf, pi/2) )
    assertEquals( complex( inf, x   ):asinh(), complex( inf, 0   ) )
    assertNaN   ( complex( x  , nan ):asinh():real() )
    assertNaN   ( complex( x  , nan ):asinh():imag() )
    if x > 0 then
      assertNaN ( complex( nan, x  ):asinh():real() )
      assertNaN ( complex( nan, x  ):asinh():imag() )
    end
  end
  assertEquals( complex( 0  , 0  ):asinh()       , complex( 0  , 0)    )
  assertEquals( complex( inf, inf):asinh()       , complex( inf, pi/4) )
  assertEquals( complex( inf, nan):asinh():real(), inf                 )
  assertNaN   ( complex( inf, nan):asinh():imag()                      )
  assertNaN   ( complex( nan, 0  ):asinh():real()                      )
  assertEquals( complex( nan, 0  ):asinh():imag(), 0                   )
  assertInf   ( complex( nan, inf):asinh():real(), inf                 )
  assertNaN   ( complex( nan, inf):asinh():imag()                      )
  assertNaN   ( complex( nan, nan):asinh():real()                      )
  assertNaN   ( complex( nan, nan):asinh():imag()                      )

  for _,x in ipairs(values.rad) do
    local x = x/pi
    assertAlmostEquals( (complex(0,x):asin()  - 1i * asinh(x)):real(), 0,   eps )
    assertAlmostEquals( (complex(0,x):asin()  - 1i * asinh(x)):imag(), 0,   eps )
    assertAlmostEquals( (complex(0,x):asinh() - 1i * asin (x)):real(), 0,   eps )
    assertAlmostEquals( (complex(0,x):asinh() - 1i * asin (x)):imag(), 0, 2*eps )
    for _,y in ipairs(values.rad) do
      local y = y/pi
      assertEquals( complex(x,y):asin(), -1i * (1i * complex(x,y)):asinh() )
    end
  end
end

function TestComplex:testAcosh()
  assertEquals      ( ( 1     + 0i ):acosh()                               , 0+0i        )
  assertAlmostEquals( ( 1-eps + 0i ):acosh():real() -  5.50089919428296e-32, 0   ,   eps )
  assertAlmostEquals( ( 1-eps + 0i ):acosh():imag() -  2.10734242554470e-08, 0   ,   eps )
  assertAlmostEquals( ( 1-0.1 + 0i ):acosh():real() - -1.47835141691979e-17, 0   ,   eps )
  assertAlmostEquals( ( 1-0.1 + 0i ):acosh():imag() -  4.51026811796262e-01, 0   , 2*eps )

  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (z:acosh():cosh() - z):real(), 0,  2*eps )
    assertAlmostEquals( (z:acosh():cosh() - z):imag(), 0,    eps )
  end
  for _,z in ipairs(unitCircle( 2*pi, values.rad)) do
    assertAlmostEquals( (z:acosh():cosh() - z):real(), 0, 16*eps )
    assertAlmostEquals( (z:acosh():cosh() - z):imag(), 0, 16*eps )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    if x < pi/2 then
      assertAlmostEquals( (z:acosh():cosh() - z):real(), 0,   eps )
      assertAlmostEquals( (z:acosh():cosh() - z):imag(), 0,   eps )
    elseif x < 10 then
      assertAlmostEquals( (z:acosh():cosh() - z):real(), 0, 2*eps )
      assertAlmostEquals( (z:acosh():cosh() - z):imag(), 0, 2*eps )
    end
  end

-- Check for IEEE:IEC 60559 compliance
  for _,x in ipairs(values.rad) do
    assertNaN   ( complex( x  , nan ):acosh():real() )
    assertNaN   ( complex( x  , nan ):acosh():imag() )
    assertNaN   ( complex( nan, x   ):acosh():real() )
    assertNaN   ( complex( nan, x   ):acosh():imag() )
    assertEquals( complex( x  , inf ):acosh(), complex( inf, pi/2) )
    assertEquals( complex(-inf, x   ):acosh(), complex( inf, pi  ) )
    assertEquals( complex( inf, x   ):acosh(), complex( inf, 0   ) )
  end
  assertEquals( complex( 0, 0    ):acosh()       , complex( 0  ,   pi/2) )
  assertEquals( complex(-0, 0    ):acosh()       , complex( 0  ,   pi/2) )
  assertEquals( complex(-inf, inf):acosh()       , complex( inf, 3*pi/4) )
  assertEquals( complex( inf, inf):acosh()       , complex( inf,   pi/4) )
  assertEquals( complex( inf, nan):acosh():real(), inf                   )
  assertNaN   ( complex( inf, nan):acosh():imag()                        )
  assertEquals( complex(-inf, nan):acosh():real(), inf                   )
  assertNaN   ( complex(-inf, nan):acosh():imag()                        )
  assertInf   ( complex( nan, inf):acosh():real(), inf                   )
  assertNaN   ( complex( nan, inf):acosh():imag()                        )
  assertNaN   ( complex( nan, nan):acosh():real()                        )
  assertNaN   ( complex( nan, nan):acosh():imag()                        )
end

function TestComplex:testAtanh()
  for _,z in ipairs(unitCircle( pi/2, values.rad)) do
    assertAlmostEquals( (z:atanh():tanh() - z):real(), 0, 2*eps )
    assertAlmostEquals( (z:atanh():tanh() - z):imag(), 0, 2*eps )
    if z.im ~= 0 then
      local res = 1/2*((1+z):log() - (1-z):log())
      assertAlmostEquals( (z:atanh() - res):real(), 0, 16*eps )
      assertAlmostEquals( (z:atanh() - res):imag(), 0,    eps )
    end
  end
  for _,z in ipairs(unitCircle( pi, values.rad)) do
    assertAlmostEquals( (z:atanh():tanh() - z):real(), 0, 8*eps )
    assertAlmostEquals( (z:atanh():tanh() - z):imag(), 0, 8*eps )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    local res = 1/2*((1+z):log() - (1-z):log())
    if x < pi/2 then
      assertAlmostEquals( (z:acosh():cosh() - z  ):real(), 0,   eps )
      assertAlmostEquals( (z:acosh():cosh() - z  ):imag(), 0,   eps )
      assertAlmostEquals( (z:atanh()        - res):real(), 0,   eps )
      assertAlmostEquals( (z:atanh()        - res):imag(), 0,   eps )
    elseif x < 10 then
      assertAlmostEquals( (z:acosh():cosh() - z  ):real(), 0, 2*eps )
      assertAlmostEquals( (z:acosh():cosh() - z  ):imag(), 0, 2*eps )
    end
  end
  assertEquals( ( 0 - 1i):atanh()       , 0 - pi/4*1i )
  assertEquals( (-1 + 0i):atanh():real(),-inf         )
  assertEquals( (-1 + 0i):atanh():imag(), jit.os == 'OSX' and pi/4 or 0) -- expected: 0 mac: pi/4*1i [BUG] (mathmatica)

-- Check for IEEE:IEC 60559 compliance
  for _,x in ipairs(values.rad) do
    assertEquals( complex( x, inf ):atanh(), complex( 0, pi/2) )
    assertEquals( complex( inf, x ):atanh(), complex( 0, pi/2) )
    assertNaN   ( complex( nan, x ):atanh():real() )
    assertNaN   ( complex( nan, x ):atanh():imag() )
    if x > 0 then
      assertNaN ( complex( x, nan ):atanh():real() )
      assertNaN ( complex( x, nan ):atanh():imag() )
    end
  end
  assertNaN   ( complex( 0  , nan ):atanh():imag()                      )
  assertEquals( complex( 0  , 0   ):atanh()       , complex( 0  , 0   ) )
  assertEquals( complex( inf, inf ):atanh()       , complex( 0  , pi/2) )
  assertNaN   ( complex( nan, nan ):atanh():real()                      )
  assertNaN   ( complex( nan, nan ):atanh():imag()                      )
  assertEquals( complex( nan, inf ):atanh():imag(), pi/2                )

  if jit.os == "OSX" then
    assertEquals( complex( 1  , 0   ):atanh()       , complex( inf, pi/4) ) -- expected: inf+0i    mac: inf+0.7853981633974483i [BUG]
    assertNaN   ( complex( 0  , nan ):atanh():real()                      ) -- expected: 0         mac: nan                     [BUG]
    assertNaN   ( complex( inf, nan ):atanh():real()                      ) -- expected: 0         mac: nan                     [BUG]
    assertEquals( complex( inf, nan ):atanh():imag(), pi/2                ) -- expected: nan       mac: 1.570796326794897       [BUG]
    assertNaN   ( complex( nan, inf ):atanh():real()                      ) -- expected: 0+pi/2*1  mac: nan+1.570796326794897i  [BUG]
  else
    assertEquals( complex( 1  , 0   ):atanh()       , complex( inf, 0   ) )
    assertEquals( complex( 0  , nan ):atanh():real(), 0                   )
    assertEquals( complex( inf, nan ):atanh():real(), 0                   )
    assertNaN   ( complex( inf, nan ):atanh():imag()                      )
    assertEquals( complex( nan, inf ):atanh():real(), 0                   )
  end

  for _,x in ipairs(values.rad2) do
    local x = x/pi
    assertAlmostEquals( (complex( 0, x):atan()  - 1i * atanh(x)):real(), 0,   eps )
    assertAlmostEquals( (complex( 0, x):atan()  - 1i * atanh(x)):imag(), 0,   eps )
    assertAlmostEquals( (complex( 0, x):atanh() - 1i * atan (x)):real(), 0,   eps )
    assertAlmostEquals( (complex( 0, x):atanh() - 1i * atan (x)):imag(), 0, 2*eps )
    for _,y in ipairs(values.rad2) do
      local y = y/pi
      local res = (-1i) * (1i * complex(x,y)):atanh()
      assertAlmostEquals( ( complex(x,y):atan() - res):real(), 0, eps )
      assertAlmostEquals( ( complex(x,y):atan() - res):imag(), 0, eps )
    end
  end
end

function TestComplex:testErf()
  --'NYI'
end

function TestComplex:testTgamma()
  --'NYI'
end

function TestComplex:testLgamma()
  --'NYI'
end


-- complex generic functions

function TestComplex:testCarg()
  assertEquals      ( (-0       + 0i ):carg()       , 0         )
  assertEquals      ( ( 0       + 0i ):carg()       , 0         )
  assertEquals      ( (-eps     + 0i ):carg()       , pi        )
  assertEquals      ( ( eps     + 0i ):carg()       , 0         )
  assertEquals      ( (-0       + 1i ):carg()       , pi/2      )
  assertEquals      ( ( 0       + 1i ):carg()       , pi/2      )
  assertAlmostEquals( (-eps     + 1i ):carg() - pi/2, 0   , eps )
  assertAlmostEquals( ( eps     + 1i ):carg() - pi/2, 0   , eps )
  assertEquals      ( (  pi     + 0i ):carg()       , 0         )
  assertEquals      ( (- pi     + 0i ):carg()       , pi        )
  assertEquals      ( (  pi+eps + 0i ):carg()       , 0         )
  assertEquals      ( (-(pi+eps)+ 0i ):carg()       , pi        )

  assertNaN         ( complex(  nan, nan):carg()                 )
  assertEquals      ( complex(  inf, inf):carg(), atan2(inf,inf) )

  for i,z in ipairs(unitCircle( pi, values.rad)) do
    local re, im = z:real(), z:imag()
    local rad = values.rad[i]
    assertAlmostEquals( z:carg() - atan2(im,re), 0, eps )
    assertAlmostEquals( z:carg() - rad         , 0, eps )
  end
  for i,z in ipairs(unitCircle( 2*pi, values.rad)) do
    local re, im = z:real(), z:imag()
    local rad = values.rad[i]
    assertAlmostEquals( z:carg() - atan2(im,re), 0, eps )
    assertAlmostEquals( z:carg() - rad         , 0, eps )
  end

  -- Check for IEEE:IEC 60559 compliance
  for _,x in ipairs(values.rad) do
    for _,y in ipairs(values.rad) do
      local x, y = x/pi, y/pi
      assertEquals( complex( x, y):carg(), atan2( y, x) )
    end
  end
  for _,x in ipairs(values.num) do
    for _,y in ipairs(values.num) do
      assertEquals( complex( x, y):carg(), atan2( y, x) )
    end
  end
  for i,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    local rad = values.rad[i]
    assertEquals      ( z:carg()      , atan2(im,re)     )
    assertAlmostEquals( z:carg() - rad, 0          , eps )
  end
end


function TestComplex:testConj()
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    assertEquals( z:conj()               , complex( re,-im) )
    assertEquals( complex(-re, im):conj(), complex(-re,-im) )
    assertEquals( complex( re,-im):conj(), complex( re, im) )
    assertEquals( complex(-re,-im):conj(), complex(-re, im) )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    local re, im = z:real(), z:imag()
    assertEquals( z:conj()               , complex( re,-im) )
    assertEquals( complex(-re, im):conj(), complex(-re,-im) )
    assertEquals( complex( re,-im):conj(), complex( re, im) )
    assertEquals( complex(-re,-im):conj(), complex(-re, im) )
  end
  -- Check for IEEE:IEC 60559 compliance
  for _,x in ipairs(values.rad) do
    for _,y in ipairs(values.rad) do
      local x, y = x/pi, y/pi
      assertEquals( complex(x,y):conj(): sqrt(), complex(x,y): sqrt():conj() )
      assertEquals( complex(x,y):conj():  exp(), complex(x,y):  exp():conj() )
      assertEquals( complex(x,y):conj():  log(), complex(x,y):  log():conj() )
      assertEquals( complex(x,y):conj(): sinh(), complex(x,y): sinh():conj() )
      assertEquals( complex(x,y):conj(): cosh(), complex(x,y): cosh():conj() )
      assertEquals( complex(x,y):conj(): tanh(), complex(x,y): tanh():conj() )
      assertEquals( complex(x,y):conj(): acos(), complex(x,y): acos():conj() )
      assertEquals( complex(x,y):conj():acosh(), complex(x,y):acosh():conj() )
      assertEquals( complex(x,y):conj():acosh(), complex(x,y):acosh():conj() )
      assertEquals( complex(x,y):conj():atanh(), complex(x,y):atanh():conj() )
    end
  end
end

function TestComplex:testProj()
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    assertEquals( complex( re, im):proj(), z                )
    assertEquals( complex(-re,-im):proj(), complex(-re,-im) )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    local re, im = z:real(), z:imag()
    assertEquals( complex( re, im):proj(), z                )
    assertEquals( complex(-re,-im):proj(), complex(-re,-im) )
  end
  assertEquals( complex( 1   , 2  ):proj()       , complex( 1   , 2) )
  assertEquals( complex( inf ,-1  ):proj()       , complex( inf , 0) )
  assertEquals( complex( 0   ,-inf):proj()       , complex( inf , 0) )
  assertEquals( complex( 0   , 1  ):proj()       , complex( 0   , 1) )
  assertEquals( complex( tiny, 1  ):proj()       , complex( tiny, 1) )
  assertEquals( complex( 0.1 , 1  ):proj()       , complex( 0.1 , 1) )
  assertEquals( complex( 1   , 1  ):proj()       , complex( 1   , 1) )
  assertEquals( complex( huge, 1  ):proj()       , complex( huge, 1) )
  assertEquals( complex( inf , 1  ):proj()       , complex( inf , 0) )
  assertEquals( complex(-0   , 1  ):proj()       , complex( 0   , 1) )
  assertEquals( complex(-tiny, 1  ):proj()       , complex(-tiny, 1) )
  assertEquals( complex(-0.1 , 1  ):proj()       , complex(-0.1 , 1) )
  assertEquals( complex(-1   , 1  ):proj()       , complex(-1   , 1) )
  assertEquals( complex(-huge, 1  ):proj()       , complex(-huge, 1) )
  assertEquals( complex(-inf , 1  ):proj()       , complex( inf , 0) )
  assertEquals( complex( 1   , nan):proj():real(), 1                 )
  assertNaN   ( complex( nan , nan):proj():real()                    )
  assertNaN   ( complex( 1   , nan):proj():imag()                    )
  assertNaN   ( complex( nan , nan):proj():imag()                    )

  -- Check for IEEE:IEC 60559 compliance
  assertEquals( complex( inf , 2   ):proj(), complex( inf , 0) )
  assertEquals( complex( inf ,-2   ):proj(), complex( inf ,-0) )
  assertEquals( complex( 2   , inf ):proj(), complex( inf , 0) )
  assertEquals( complex( 2   ,-inf ):proj(), complex( inf ,-0) )
  assertEquals( complex( nan , inf ):proj(), complex( inf , 0) )
  assertEquals( complex( nan , inf ):proj(), complex( inf , 0) )
end

function TestComplex:testRect()
  assertEquals( complex( 0   , 0   ):rect()       , complex( 0   , 0) )
  assertEquals( complex( tiny, tiny):rect()       , complex( tiny, 0) )
  assertEquals( complex( tiny, 0   ):rect()       , complex( tiny, 0) )
  assertNaN   ( complex( inf , inf ):rect():real()                    )
  assertNaN   ( complex( inf , inf ):rect():imag()                    )
  assertNaN   ( complex(-inf ,-inf ):rect():real()                    )
  assertNaN   ( complex(-inf ,-inf ):rect():imag()                    )
  assertNaN   ( complex( nan , nan ):rect():real()                    )
  assertNaN   ( complex( nan , nan ):rect():imag()                    )

  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    assertEquals( z:rect(), complex( re*cos(im), re*sin(im) ) )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    local re, im = z:real(), z:imag()
    assertEquals( z:rect(), complex( re*cos(im), re*sin(im) ) )
  end
end

function TestComplex:testPolar()
  assertEquals( complex( 0   , 0   ):polar()       , complex( 0  , 0               ) )
  assertEquals( complex( tiny, 0   ):polar()       , complex( 0  , 0               ) )
  assertEquals( complex( 1   , 0   ):polar()       , complex( 1  , 0               ) )
  assertEquals( complex(-1   , 0   ):polar()       , complex( 1  , pi              ) )
  assertEquals( complex( tiny, tiny):polar()       , complex( 0  , atan2(tiny,tiny)) )
  assertEquals( complex( inf , inf ):polar()       , complex( inf, atan2( inf, inf)) )
  assertEquals( complex(-inf ,-inf ):polar()       , complex( inf, atan2(-inf,-inf)) )
  assertNaN   ( complex( nan , nan ):polar():real()                                  )
  assertNaN   ( complex( nan , nan ):polar():imag()                                  )
  assertInf   ( complex( huge, huge):polar():real()                                  )
  assertEquals( complex( huge, huge):polar():imag(), atan2( huge, huge)              )
  assertInf   ( complex(-huge,-huge):polar():real()                                  )
  assertEquals( complex(-huge,-huge):polar():imag(), atan2(-huge,-huge)              )

  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    assertAlmostEquals( (z:polar() - complex( hypot(re,im), atan2(im,re))):real(), 0, eps )
    assertAlmostEquals( (z:polar() - complex( hypot(re,im), atan2(im,re))):imag(), 0, eps )
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    local re, im = z:real(), z:imag()
    if x ~= huge then
      assertAlmostEquals( (z:polar() - complex( hypot(re,im), atan2(im,re))):real(), 0, 2*eps )
      assertAlmostEquals( (z:polar() - complex( hypot(re,im), atan2(im,re))):imag(), 0,   eps )
    end
  end
end

-- complex non-generic functions

function TestComplex:testUnit()
  local z1 = unitCircle( 1, values.rad)
  for j=1,4,0.1 do
    for i,z in ipairs(unitCircle( j, values.rad)) do
      assertAlmostEquals( z:unit():real() - z1[i]:real(), 0, eps )
      assertAlmostEquals( z:unit():imag() - z1[i]:imag(), 0, eps )
    end
  end
  assertNaN   ( complex( inf , 1  ):unit():real()    )
  assertEquals( complex( inf , 1  ):unit():imag(), 0 )
  assertNaN   ( complex( inf ,-1  ):unit():real()    )
  assertEquals( complex( inf ,-1  ):unit():imag(), 0 )
  assertNaN   ( complex(-inf , 1  ):unit():real()    )
  assertEquals( complex(-inf , 1  ):unit():imag(), 0 )
  assertEquals( complex( 1   ,-inf):unit():real(), 0 )
  assertNaN   ( complex( 1   ,-inf):unit():imag()    )
  assertEquals( complex( 1   , inf):unit():real(), 0 )
  assertNaN   ( complex( 1   , inf):unit():imag()    )
  assertNaN   ( complex( nan , inf):unit():real()    )
  assertNaN   ( complex( nan , inf):unit():imag()    )
end

-- complex operators

function TestComplex:testUnm()
  assertEquals( 1/(complex( 0  , 0  ):unm()):real(),-inf                )
  assertEquals( 1/(complex( 0  , 0  ):unm()):imag(),-inf                )
  assertEquals( 1/(complex(-0  ,-0  ):unm()):real(), inf                )
  assertEquals( 1/(complex(-0  ,-0  ):unm()):imag(), inf                )
  assertEquals(    complex( inf, inf):unm()        , complex(-inf,-inf) )
  assertEquals(    complex(-inf,-inf):unm()        , complex( inf, inf) )
  assertNaN   (    complex( nan, nan):unm():real()                      )
  assertNaN   (    complex( nan, nan):unm():imag()                      )
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    assertEquals( z:unm()               , complex(-re,-im) )
    assertEquals( complex(-re, im):unm(), complex( re,-im) )
    assertEquals( complex( re,-im):unm(), complex(-re, im) )
    assertEquals( complex(-re,-im):unm(), complex( re, im) )
  end
end

function TestComplex:testAdd()
  assertEquals(  complex( 1, 1):add(complex( 0   , 0   ))        , complex( 1    , 1    ) )
  assertEquals(  complex( 1, 1):add(complex( inf , inf ))        , complex( inf  , inf  ) )
  assertEquals(  complex( 1, 1):add(complex(-inf ,-inf ))        , complex(-inf  ,-inf  ) )
  assertEquals(  complex( 1, 1):add(complex( huge, huge))        , complex( huge , huge ) )
  assertEquals(  complex( 1, 1):add(complex(-huge,-huge))        , complex(-huge ,-huge ) )
  assertEquals(  complex( 1, 1):add(complex( eps , eps ))        , complex( 1+eps, 1+eps) )
  assertEquals(  complex( 1, 1):add(complex(-eps ,-eps ))        , complex( 1-eps, 1-eps) )
  assertNaN   ( (complex( 1, 1):add(complex( nan , nan ))):real()                         )
  assertNaN   ( (complex( 1, 1):add(complex( nan , nan ))):imag()                         )

  for _,z  in ipairs(unitCircle( 1, values.rad)) do
  for _,z1 in ipairs(unitCircle( 1, values.rad)) do
    local re , im  = z :real(), z :imag()
    local re1, im1 = z1:real(), z1:imag()
    assertEquals( complex( re, im ):add(complex( re1, im1 )), complex( re+re1, im+im1 ) )
    assertEquals( complex( re, 0  ):add(complex( re1, 0   )), complex( re+re1, 0      ) )
    assertEquals( complex( 0 , im ):add(complex( 0  , im1 )), complex( 0     , im+im1 ) )
    assertEquals( complex( re, im ):add(complex( re1, 0   )), complex( re+re1, im     ) )
    assertEquals( complex( re, im ):add(complex( 0  , im1 )), complex( re    , im+im1 ) )

    assertEquals( complex(-re, im ):add(complex( re1, im1 )), complex(-re+re1, im+im1 ) )
    assertEquals( complex( re,-im ):add(complex( re1, im1 )), complex( re+re1,-im+im1 ) )
    assertEquals( complex(-re,-im ):add(complex( re1, im1 )), complex(-re+re1,-im+im1 ) )
  end end

  for _,x in ipairs(values.num) do
  for _,y in ipairs(values.num) do
    local z  = complex( x, x)
    local z1 = complex( y, y)
    local re , im  = z :real(), z:imag()
    local re1, im1 = z1:real(), z:imag()
    assertEquals( complex( re, im ):add(complex( re1, im1 )), complex( re+re1, im+im1 ) )
    assertEquals( complex(-re,-im ):add(complex( re1, im1 )), complex(-re+re1,-im+im1 ) )
  end end
end

function TestComplex:testSub()
  assertEquals(  complex( 1, 1):sub(complex( 0   , 0   ))        , complex( 1    , 1    ) )
  assertEquals(  complex( 1, 1):sub(complex( inf , inf ))        , complex(-inf  ,-inf  ) )
  assertEquals(  complex( 1, 1):sub(complex(-inf ,-inf ))        , complex( inf  , inf  ) )
  assertEquals(  complex( 1, 1):sub(complex( huge, huge))        , complex(-huge ,-huge ) )
  assertEquals(  complex( 1, 1):sub(complex(-huge,-huge))        , complex( huge , huge ) )
  assertEquals(  complex( 1, 1):sub(complex( eps , eps ))        , complex( 1-eps, 1-eps) )
  assertEquals(  complex( 1, 1):sub(complex(-eps ,-eps ))        , complex( 1+eps, 1+eps) )
  assertNaN   ( (complex( 1, 1):sub(complex( nan , nan ))):real()                         )
  assertNaN   ( (complex( 1, 1):sub(complex( nan , nan ))):imag()                         )

  for _,z  in ipairs(unitCircle( 1, values.rad)) do
  for _,z1 in ipairs(unitCircle( 1, values.rad)) do
    local re , im  = z :real(), z :imag()
    local re1, im1 = z1:real(), z1:imag()
    assertEquals( complex( re, im ):sub(complex( re1, im1 )), complex( re - re1 , im -  im1  ) )
    assertEquals( complex( re, im ):sub(complex( re1, im1 )), complex( re - re1 , im -  im1  ) )
    assertEquals( complex( re, 0  ):sub(complex( re1, 0   )), complex( re - re1 , 0          ) )
    assertEquals( complex( 0 , im ):sub(complex( 0  , im1 )), complex( 0        , im -  im1  ) )
    assertEquals( complex( re, im ):sub(complex( re1, 0   )), complex( re - re1 , im         ) )
    assertEquals( complex( re, im ):sub(complex( 0  , im1 )), complex( re       , im -  im1  ) )

    assertEquals( complex( re, im ):sub(complex(-re1, im1 )), complex( re-(-re1), im -  im1  ) )
    assertEquals( complex( re, im ):sub(complex( re1,-im1 )), complex( re-  re1 , im -(-im1 )) )
    assertEquals( complex( re, im ):sub(complex(-re1,-im1 )), complex( re-(-re1), im -(-im1 )) )
  end end
  for _,x in ipairs(values.num) do
    local z  = complex( x, x)
    local re , im  = z :real(), z :imag()
  for _,y in ipairs(values.num) do
    local z1 = complex( y, y)
    local re1, im1 = z1:real(), z1:imag()
    assertEquals( complex( re, im):sub(complex( re1, im1)), complex( re-  re1 , im-  im1 ) )
    assertEquals( complex( re, im):sub(complex(-re1,-im1)), complex( re-(-re1), im-(-im1)) )
  end end
end

function TestComplex:testMul()
  assertNaN   ( (complex( 1, 1):mul(complex( inf , inf ))):real()                     )
  assertEquals( (complex( 1, 1):mul(complex( inf , inf ))):imag(), inf                )
  assertNaN   ( (complex( 1, 1):mul(complex(-inf ,-inf ))):real()                     )
  assertEquals( (complex( 1, 1):mul(complex(-inf ,-inf ))):imag(),-inf                )
  assertNaN   ( (complex( 1, 1):mul(complex( nan , nan ))):real()                     )
  assertNaN   ( (complex( 1, 1):mul(complex( nan , nan ))):imag()                     )
  assertEquals(  complex( 1, 1):mul(complex( huge, huge))        , complex( 0, inf  ) )
  assertEquals(  complex( 1, 1):mul(complex(-huge,-huge))        , complex( 0,-inf  ) )
  assertEquals(  complex( 1, 1):mul(complex( eps , eps ))        , complex( 0, 2*eps) )
  assertEquals(  complex( 1, 1):mul(complex(-eps ,-eps ))        , complex( 0,-2*eps) )
  assertEquals(  complex( 1, 1):mul(complex( 0   , 0   ))        , complex( 0, 0    ) )

  for _,z  in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z :real(), z :imag()
      assertEquals( complex( re, im):mul(complex( 1   , 0   )), complex( re, im) )
    for _,z1 in ipairs(unitCircle( 1, values.rad)) do
      local re1, im1 = z1:real(), z1:imag()
      assertEquals( complex( re, im ):mul(complex( re1, im1 )), complex( re*re1-  im*im1 , re*im1+re1*im) )
      assertEquals( complex(-re, im ):mul(complex( re1, im1 )), complex(-re*re1-  im*im1 ,-re*im1+re1*im) )
      assertEquals( complex( re,-im ):mul(complex( re1, im1 )), complex( re*re1-(-im*im1), re*im1-re1*im) )
      assertEquals( complex(-re,-im ):mul(complex( re1, im1 )), complex(-re*re1-(-im*im1),-re*im1-re1*im) )
      assertEquals( complex( re, 0  ):mul(complex( re1, 0   )), complex( re*re1          , 0            ) )
      assertEquals( complex( 0 , im ):mul(complex( 0   , im1)), complex(-im*im1          , 0            ) )
      assertEquals( complex( re, im ):mul(complex( re1, 0   )), complex( re*re1          , re1*im       ) )
      assertEquals( complex( re, im ):mul(complex( 0   , im1)), complex(-im*im1          , re *im1      ) )
    end
  end
  for _,x in ipairs(values.num) do
    local z  = complex( x, x)
    local re, im = z :real(), z :imag()
    for _,y in ipairs(values.num) do
      local z1 = complex( y, y)
      local re1, im1 = z1:real(), z1:imag()
        assertEquals( complex( re, im ):mul(complex( 0  , im1 )), complex(-im*im1         , re*im1       ) )
      if x < huge and y < huge then
        assertEquals( complex( re, im ):mul(complex( re1, im1 )), complex( re*re1 - im*im1, re*im1+re1*im) )
      end
    end
  end
end

function TestComplex:testDiv()
  assertEquals( (complex( 0   , 0  ):div(complex( 1   , 1   )))       , complex(0,0) )
  assertInf   ( (complex( 1   , 1  ):div(complex( tiny, tiny))):real()               )
  assertNaN   ( (complex( 1   , 1  ):div(complex( tiny, tiny))):imag()               )
  assertNaN   ( (complex( 1   , 1  ):div(complex( huge, huge))):real()               )
  assertEquals( (complex( 1   , 1  ):div(complex( huge, huge))):imag(), 0            )
  assertNaN   ( (complex( 1   , 1  ):div(complex(-huge,-huge))):real()               )
  assertEquals( (complex( 1   , 1  ):div(complex(-huge,-huge))):imag(), 0            )
  assertNaN   ( (complex( 1   , 1  ):div(complex( inf , inf ))):real()               )
  assertNaN   ( (complex( 1   , 1  ):div(complex( inf , inf ))):imag()               )
  assertNaN   ( (complex( 1   , 1  ):div(complex(-inf ,-inf ))):real()               )
  assertNaN   ( (complex( 1   , 1  ):div(complex(-inf ,-inf ))):imag()               )
  assertNaN   ( (complex( 1   , 1  ):div(complex( nan , nan ))):real()               )
  assertNaN   ( (complex( 1   , 1  ):div(complex( nan , nan ))):imag()               )
  assertEquals( (complex(-inf ,-inf):div(complex( 1   , 1   ))):real(),-inf          )
  assertNaN   ( (complex(-inf ,-inf):div(complex( 1   , 1   ))):imag()               )
  assertNaN   ( (complex( nan , nan):div(complex( 1   , 1   ))):real()               )
  assertNaN   ( (complex( nan , nan):div(complex( 1   , 1   ))):imag()               )

  assertNaN   ( (complex( 1   , 0  ):div(complex( 0   , 0   ))):real()               )
  assertNaN   ( (complex( 1   , 0  ):div(complex( 0   , 0   ))):imag()               )
  assertNaN   ( (complex( 1   , 1  ):div(complex( 0   , 0   ))):real()               )
  assertNaN   ( (complex( 1   , 1  ):div(complex( 0   , 0   ))):imag()               )
  assertNaN   ( (complex( 0   , 1  ):div(complex( 0   , 0   ))):real()               )
  assertNaN   ( (complex( 0   , 1  ):div(complex( 0   , 0   ))):imag()               )
  assertEquals( (complex( 1   , 1  ):div(complex( 1   , 0   ))):real(), 1            )
  assertEquals( (complex( 1   , 1  ):div(complex( 1   , 0   ))):imag(), 1            )
  assertEquals( (complex( 1   , 1  ):div(complex( 0   , 1   ))):real(), 1            )
  assertEquals( (complex( 1   , 1  ):div(complex( 0   , 1   ))):imag(),-1            )

  for _,z  in ipairs(unitCircle( 1, values.rad)) do
  local re , im = z :real(), z :imag()
  for _,z1 in ipairs(unitCircle( 1, values.rad)) do
    local re1, im1 = z1:real(), z1:imag()
    local res1 = complex( re*re1 +  im*im1 , ( im*re1 -  re*im1)) /(im1^2 + re1^2)
    local res2 = complex(-re*re1 +  im*im1 , ( im*re1 -(-re*im1)))/(im1^2 + re1^2)
    local res3 = complex( re*re1 +(-im*im1), (-im*re1 -  re*im1)) /(im1^2 + re1^2)
    local res4 = complex(-re*re1 +(-im*im1), (-im*re1 -(-re*im1)))/(im1^2 + re1^2)
    assertEquals( complex( re, im):div(complex( re1, im1)), res1 )
    assertEquals( complex(-re, im):div(complex( re1, im1)), res2 )
    assertEquals( complex( re,-im):div(complex( re1, im1)), res3 )
    assertEquals( complex(-re,-im):div(complex( re1, im1)), res4 )
    if im1 > 0 then
        assertAlmostEquals( (complex( 0 , im):div(complex( 0  , im1)) - complex( im/im1, 0     )):imag()   , 0,   eps )
        assertAlmostEquals( (complex( 0 , im):div(complex( 0  , im1)) - complex( im/im1, 0     )):imag()   , 0,   eps )
      if(complex( im/im1, 0):real() == 0) then
        assertEquals      ( (complex( 0 , im):div(complex( 0  , im1)) - complex( im/im1, 0     )):real()   , 0        )
        assertAlmostEquals( (complex( 0 , im):div(complex( 0  , im1)) - complex( im/im1, 0     )):real()   , 0,   eps )
      else
        assertAlmostEquals( (complex( 0 , im):div(complex( 0  , im1)) / complex( im/im1, 0     )):real()- 1, 0, 2*eps )
        assertAlmostEquals( (complex( 0 , im):div(complex( 0  , im1)) / complex( im/im1, 0     )):real()- 1, 0, 2*eps )
      end
        assertAlmostEquals( (complex( re, im):div(complex( 0  , im1)) / complex( im/im1,-re/im1)):real()- 1, 0, 2*eps )
        assertAlmostEquals( (complex( re, im):div(complex( 0  , im1)) / complex( im/im1,-re/im1)):imag()   , 0,   eps )
    end
        assertAlmostEquals( (complex( re, 0 ):div(complex( re1, 0  )) / complex( re/re1, 0     )):real()- 1, 0,   eps )
        assertAlmostEquals( (complex( re, 0 ):div(complex( re1, 0  )) - complex( re/re1, 0     )):imag()   , 0,   eps )
        assertAlmostEquals( (complex( re, im):div(complex( re1, 0  )) / complex( re/re1, im/re1)):real()- 1, 0,   eps )
        assertAlmostEquals( (complex( re, im):div(complex( re1, 0  )) / complex( re/re1, im/re1)):imag()   , 0,   eps )
  end end

  for _,x in ipairs(values.num) do
    local z  = complex( x, x)
    local re , im = z :real(), z :imag()
  for _,y in ipairs(values.num) do
    if x < huge and y < huge and x > tiny and y > tiny then
      local z1 = complex( y, y)
      local re1, im1 = z1:real(), z1:imag()
      local res = complex( re*re1 +  im*im1 , ( im*re1 -  re*im1)) /(im1^2 + re1^2)
        assertEquals      (  complex( re, im):div(complex( re1, im1)), res )
        assertAlmostEquals( (complex( 0 , im):div(complex( 0  , im1)) - complex( im/im1, 0)):imag()   , 0,   eps )
        assertAlmostEquals( (complex( 0 , im):div(complex( 0  , im1)) - complex( im/im1, 0)):imag()   , 0,   eps )
      if(complex( z.im/z1.im, 0).re == 0) then
        assertEquals      ( (complex( 0 , im):div(complex( 0  , im1)) - complex( im/im1, 0)):real()   , 0        )
        assertAlmostEquals( (complex( 0 , im):div(complex( 0  , im1)) - complex( im/im1, 0)):real()   , 0,   eps )
      else
        assertAlmostEquals( (complex( 0 , im):div(complex( 0  , im1)) / complex( im/im1, 0)):real()- 1, 0, 2*eps )
        assertAlmostEquals( (complex( 0 , im):div(complex( 0  , im1)) / complex( im/im1, 0)):real()- 1, 0, 2*eps )
      end
    end
  end end
end

function TestComplex:testMod()
  local a, b, d, z, z1
  local roundc = _C.round -- round imported from C

  for j,z  in ipairs(unitCircle( 1, values.rad)) do
  for i,z1 in ipairs(unitCircle( 1, values.rad)) do
    local d = z/z1
    local re, im = d:real(), d:imag()
    assertEquals( z:mod(z1), (z - (complex(roundc(re), roundc(im)))*z1) )
  end end
  for _,x in ipairs(values.rad) do
  for _,y in ipairs(values.rad) do
    if y > 0 and y < inf and x < inf then
      local a, b = x/pi, y/pi
      local z, z1 = complex(a,a), complex(b,b)
      local d = z/z1
      local re, im = d:real(), d:imag()
      assertEquals( z:mod(z1), (z - (complex(roundc(re), roundc(im)))*z1) )
    end
  end end
  for _,x in ipairs(values.num) do
  for _,y in ipairs(values.num) do
    if x > tiny and x < 10 and y > tiny and y < 10 then
      local a, b = complex(x,y), complex(x,y)
      assertAlmostEquals( a:mod(b):real() - (a - round(a/b)*b ):real(), 0,   eps )
      assertAlmostEquals( a:mod(b):imag() - (a - round(a/b)*b ):imag(), 0,   eps )
      a, b = complex(x,x), complex(y,y)
      assertAlmostEquals( a:mod(b):real() - (a - round(a/b)*b ):real(), 0,   eps )
      assertAlmostEquals( a:mod(b):imag() - (a - round(a/b)*b ):imag(), 0,   eps )
      a, b = complex(x,y), complex(y,x)
      assertAlmostEquals( a:mod(b):real() - (a - round(a/b)*b ):real(), 0,   eps )
      assertAlmostEquals( a:mod(b):imag() - (a - round(a/b)*b ):imag(), 0, 2*eps )
    end
  end end

  assertNaN( complex( 1  , 1   ):mod(complex( 1  ,  inf )):real() )
  assertNaN( complex( 1  , 1   ):mod(complex( 1  ,  inf )):imag() )
  assertNaN( complex( 1  , 1   ):mod(complex(-1  ,  inf )):real() )
  assertNaN( complex( 1  , 1   ):mod(complex(-1  ,  inf )):imag() )
  assertNaN( complex( 1  , 1   ):mod(complex( 1  , -inf )):real() )
  assertNaN( complex( 1  , 1   ):mod(complex( 1  , -inf )):imag() )
  assertNaN( complex( 1  , 1   ):mod(complex(-1  , -inf )):real() )
  assertNaN( complex( 1  , 1   ):mod(complex(-1  , -inf )):imag() )
  assertNaN( complex( 1  , 1   ):mod(complex( inf,  inf )):real() )
  assertNaN( complex( 1  , 1   ):mod(complex( inf,  inf )):imag() )
  assertNaN( complex( 1  , 1   ):mod(complex(-inf, -inf )):real() )
  assertNaN( complex( 1  , 1   ):mod(complex(-inf, -inf )):imag() )
  assertNaN( complex( 1  , 1   ):mod(complex( inf,  nan )):real() )
  assertNaN( complex( 1  , 1   ):mod(complex( inf,  nan )):imag() )
  assertNaN( complex( 1  , 1   ):mod(complex(-inf,  nan )):real() )
  assertNaN( complex( 1  , 1   ):mod(complex(-inf,  nan )):imag() )
  assertNaN( complex( 1  , 1   ):mod(complex( nan,  nan )):real() )
  assertNaN( complex( 1  , 1   ):mod(complex( nan,  nan )):imag() )
  assertNaN( complex( 1  , 1   ):mod(complex( 0  ,  0   )):real() )
  assertNaN( complex( 1  , 1   ):mod(complex( 0  ,  0   )):imag() )
  assertNaN( complex( 1  , 1   ):mod(complex(-0  , -0   )):real() )
  assertNaN( complex( 1  , 1   ):mod(complex(-0  , -0   )):imag() )
  assertNaN( complex( inf, nan ):mod(complex( 1  ,  1   )):real() )
  assertNaN( complex( inf, nan ):mod(complex( 1  ,  1   )):imag() )
  assertNaN( complex(-inf, nan ):mod(complex( 1  ,  1   )):real() )
  assertNaN( complex(-inf, nan ):mod(complex( 1  ,  1   )):imag() )
  assertNaN( complex( nan, nan ):mod(complex( 1  ,  1   )):real() )
  assertNaN( complex( nan, nan ):mod(complex( 1  ,  1   )):imag() )
end

function TestComplex:testPow()
  assertEquals( complex( 0  , 1 ):pow(0)          , complex( 1  , 0 ) )
  assertEquals( complex( 0  , 1 ):pow(1)          , complex( 0  , 1 ) )
  assertEquals( complex( 0  ,-1 ):pow(1)          , complex( 0  ,-1 ) )
  assertEquals( complex(-0  , 1 ):pow(1)          , complex(-0  , 1 ) )
  assertEquals( complex( 0  , 1 ):pow(1)          , complex( 0  , 1 ) )
  assertEquals( complex(-eps, 0 ):pow(1)          , complex(-eps, 0 ) )
  assertEquals( complex( eps, 0 ):pow(1)          , complex( eps, 0 ) )
  assertEquals( complex( 1  , 1 ):pow( inf):real(), inf               )
  assertNaN   ( complex( 1  , 1 ):pow( inf):imag(), nan               )
  assertEquals( complex( 1  , 1 ):pow(-inf):real(), 0                 )
  assertEquals( complex( 1  , 1 ):pow(-inf):imag(), 0                 )
  assertNaN   ( complex( 1  , 1 ):pow( nan):real()                    )
  assertNaN   ( complex( 1  , 1 ):pow( nan):imag()                    )
  assertNaN   ( complex( 1  , 1 ):pow(-nan):real()                    )
  assertNaN   ( complex( 1  , 1 ):pow(-nan):imag()                    )
  assertEquals( complex( 1  , 1 ):pow(-1)         , 0.5-0.5i          )
  assertTrue  ( (1i):pow(1i) == exp(-pi/2) )
  assertAlmostEquals( (complex(1,1):pow( 0.5) - complex(1,1):sqrt()):real(), 0, eps )
  assertAlmostEquals( (complex(1,1):pow( 0.5) - complex(1,1):sqrt()):imag(), 0, eps )

  for _,z  in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    assertEquals( complex( re, im):pow(0), complex( 1 , 0 )                  )
    assertEquals( complex( re, im):pow(1), complex( re, im)                  )
    assertEquals( complex(-re,-im):pow(1), complex(-re,-im)                  )
    assertEquals( complex( re, im):pow(2), complex( re, im)*complex( re, im) )
    assertEquals      ( complex( re, im):pow(complex( 0, 0))            , complex(1,0)      )
    assertAlmostEquals( complex( re, im):pow(complex( 1, 0)):real() - re, 0           , eps )
    assertAlmostEquals( complex( re, im):pow(complex( 1, 0)):imag() - im, 0           , eps )
  end
-- cpx ^ int
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    assertAlmostEquals( (z:pow(2)*z:pow(3) - z:pow(2+3)       ):real(), 0,   eps )
    assertAlmostEquals( (z:pow(2)*z:pow(3) - z:pow(2+3)       ):imag(), 0,   eps )
    assertAlmostEquals( (z:pow(3)          - (3*z:log()):exp()):real(), 0, 3*eps )
    assertAlmostEquals( (z:pow(3)          - (3*z:log()):exp()):imag(), 0, 4*eps )
  end
-- cpx ^ cpx
  for _,z  in ipairs(unitCircle( 1, values.rad)) do
  for _,c  in ipairs(unitCircle( 1, values.rad)) do
    local a = complex(z:real()^2 + z:imag()^2, 0)
    assertAlmostEquals( (z:pow(c) - a:pow(c/2)*(1i*c*z:carg()):exp() ):real(), 0, 12*eps )
    assertAlmostEquals( (z:pow(c) - a:pow(c/2)*(1i*c*z:carg()):exp() ):imag(), 0, 12*eps )
  end end
end

function TestComplex:testEqual()
  local c, z
  for _,z in ipairs(unitCircle( 1, values.rad)) do
    local re, im = z:real(), z:imag()
    assertTrue ( z == complex( re, im) )
    assertTrue (-z == complex(-re,-im) )
    assertFalse( z == complex(-re, im) )
    if z.im ~= 0 then assertFalse( z == complex( re,-im) )
                 else assertTrue ( z == complex( re,-im) ) end
  end
  for _,x in ipairs(values.num) do
    local z = complex( x, x)
    local re, im = z:real(), z:imag()
    assertTrue ( z == complex( re, im) )
    assertTrue (-z == complex(-re,-im) )
    if x > 0 then   assertFalse( z == complex(-re, im) )
             else   assertTrue ( z == complex(-re, im) ) end
    if im ~= 0 then assertFalse( z == complex( re,-im) )
               else assertTrue ( z == complex( re,-im) ) end
  end
end

-- end ------------------------------------------------------------------------o